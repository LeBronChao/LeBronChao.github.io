<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeBronChao&#39;s Blog</title>
  
  
  <link href="https://lebronchao.com/atom.xml" rel="self"/>
  
  <link href="https://lebronchao.com/"/>
  <updated>2022-10-12T15:59:18.000Z</updated>
  <id>https://lebronchao.com/</id>
  
  <author>
    <name>LeBronChao-</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript设计模式-发布订阅模式</title>
    <link href="https://lebronchao.com/2022/10/12/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lebronchao.com/2022/10/12/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-10-12T15:59:18.000Z</published>
    <updated>2022-10-12T15:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是发布 — 订阅模式</h1><p>发布 — 订阅模式，它定义程序对象之间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知并执行相应操作。在日常生活中，常见的发布订阅模式有：订阅号，用户关注订阅号，内容创作者在平台发布内容后，平台遍历粉丝列表进行内容推送；销售中介，客户给销售人员留下了客户信息及联系方式，在新产品推出时，挨个给客户打电话进行推销，等等… 而发布订阅模式，一般由三类对象组成：</p><ul><li>发布者 Publisher<ul><li>事件发布者，将需要发布的事件传递给信道中介</li></ul></li><li>信道中介 Event Channel<ul><li>作为发布订阅的中介，需要缓存相应事件的订阅者列表，在发布者发布时遍历订阅者列表并通知它们</li></ul></li><li>订阅者 Subscriber<ul><li>订阅事件，并定义事件发布后的操作，向信道中介发起订阅</li></ul></li></ul><h1>发布 — 订阅模式的应用</h1><p>在上面也介绍到了发布订阅模式在日常生活中以及前端开发工作中的使用场景，例如原生 DOM 事件，暴露了订阅接口后，开发者不需要反复查询该事件是否完成；异步编程的请求中，开发者无需轮询 HTTP 请求的状态，可以通过订阅请求的 success、error、update 等事件。在编程风格上，发布订阅模式让两个对象在松耦合的情况下建立联系，不再需要显式的将接口调用硬编码耦合进另一个对象，发布者和订阅者发生各自代码的变更都不会影响到对方，下面来看看前端开发最常见的发布订阅模式应用： DOM 事件和自定义事件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/006APoFYly8gx7yenv02qg30b90b9qhj.gif" alt="猫咪拍了拍你"></p><h2 id="DOM-事件">DOM 事件</h2><blockquote><p>由简入繁， DOM 事件是前端开发中最常见、简单的发布订阅模式应用</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加订阅者前者也不受影响</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.click(); <span class="comment">// 模拟用户点击</span></span><br></pre></td></tr></table></figure><h2 id="自定义事件">自定义事件</h2><blockquote><p>由上述订阅号为例子实现一个简易的自定义事件，进阶发布订阅模式应用</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subscription = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者列表</span></span><br><span class="line">subscription.subscriber = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅函数</span></span><br><span class="line">subscription.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subscriber.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布函数</span></span><br><span class="line">subscription.publish = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subscriber.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">    fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 粉丝 1 订阅</span></span><br><span class="line">subscription.subscribe(<span class="function">(<span class="params">article</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`fans1 receive <span class="subst">$&#123;article&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 粉丝 2 订阅</span></span><br><span class="line">subscription.subscribe(<span class="function">(<span class="params">article</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`fans2 receive <span class="subst">$&#123;article&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅号发布</span></span><br><span class="line"><span class="keyword">const</span> article = <span class="string">&#x27;article&#x27;</span>;</span><br><span class="line">subscription.publish(article);</span><br><span class="line"><span class="comment">// fans1 receive article</span></span><br><span class="line"><span class="comment">// fans2 receive article</span></span><br></pre></td></tr></table></figure><h2 id="通用发布-订阅模式">通用发布 - 订阅模式</h2><blockquote><p>上面自定义事件的例子，仅能局限在单个订阅号场景</p><p>下面通过 key 将事件的发布和订阅进行隔离，实现通用的发布订阅模式</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/0065btHFly1gvzh4jb626g306o06otzd.gif" alt="元气满满!开干吧! - kitty酱表情包_卡通_卡通表情"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用发布订阅模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 订阅者列表</span></span><br><span class="line">  subscriber = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  <span class="function"><span class="title">subscribe</span>(<span class="params">key, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>.subscriber[key])) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subscriber[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.subscriber[key].push(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消单个订阅</span></span><br><span class="line">  <span class="function"><span class="title">unsubscribe</span>(<span class="params">key, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> subscribers = <span class="built_in">this</span>.subscriber[key] || [];</span><br><span class="line">    <span class="built_in">this</span>.subscriber[key] = subscribers.filter(<span class="function">(<span class="params">_fn</span>) =&gt;</span> _fn !== fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消所有订阅</span></span><br><span class="line">  <span class="function"><span class="title">unsubscribeAll</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscriber[key] = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  <span class="function"><span class="title">publish</span>(<span class="params">key, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> subscribers = <span class="built_in">this</span>.subscriber[key] || [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subscribers.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;has&#x27;t subscriber&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subscribers.forEach(<span class="function">(<span class="params">subscriber</span>) =&gt;</span> &#123;</span><br><span class="line">      subscriber.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发布订阅信道中介</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="keyword">const</span> publisher = &#123;</span><br><span class="line">  article1: <span class="string">&#x27;article1&#x27;</span>,</span><br><span class="line">  article2: <span class="string">&#x27;article2&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">const</span> subscriber1 = <span class="function">(<span class="params">article</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`fans1 receive <span class="subst">$&#123;article&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> subscriber2 = <span class="function">(<span class="params">article</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`fans2 receive <span class="subst">$&#123;article&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅操作</span></span><br><span class="line">e.subscribe(<span class="string">&#x27;event1&#x27;</span>, subscriber1);</span><br><span class="line">e.subscribe(<span class="string">&#x27;event1&#x27;</span>, subscriber2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布操作</span></span><br><span class="line">e.publish(<span class="string">&#x27;event1&#x27;</span>, publisher.article1);</span><br><span class="line"><span class="comment">// fans1 receive article1</span></span><br><span class="line"><span class="comment">// fans2 receive article1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多事件发布订阅</span></span><br><span class="line">e.subscribe(<span class="string">&#x27;event2&#x27;</span>, subscriber1);</span><br><span class="line">e.publish(<span class="string">&#x27;event2&#x27;</span>, publisher.article1);</span><br><span class="line"><span class="comment">// fans1 receive article1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消单个订阅</span></span><br><span class="line">e.unsubscribe(<span class="string">&#x27;event1&#x27;</span>, subscriber1);</span><br><span class="line">e.publish(<span class="string">&#x27;event1&#x27;</span>, publisher.article2);</span><br><span class="line"><span class="comment">// fans2 receive article2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消所有订阅</span></span><br><span class="line">e.unsubscribeAll(<span class="string">&#x27;event1&#x27;</span>);</span><br><span class="line">e.publish(<span class="string">&#x27;event1&#x27;</span>);</span><br><span class="line"><span class="comment">// has&#x27;t subscriber</span></span><br></pre></td></tr></table></figure><h2 id="模块间通信">模块间通信</h2><p>模拟如下场景，在一个中台型平台上可以接入多款应用，切换不同的应用时需要：</p><ul><li>拉取新的应用信息</li><li>拉取新的应用设置</li><li>拉取用户对新应用的权限信息</li><li>重置系列缓存数据</li></ul><p>而这些业务逻辑和操作又封装在各自的 store 或者组件里，如果没有应用发布订阅模式，可能代码是下面这种情况；如果有新增一个切换应用的入口，又需要 CV 一遍同样的代码；</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/ceeb653ely8h4lawhh9scg206o06o4kv.gif" alt="菜狗吃菜动图表情包_菜狗_菜动表情-发表情"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制台页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  userStore.getPermission();</span><br><span class="line">  appStore.getAppInfo();</span><br><span class="line">  settingStore.getAppSetting();</span><br><span class="line">  dataStore.resetDataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果应用了发布订阅模式，只需在各自的模块内执行订阅和发布操作即可，降低模块间的耦合度</p><p>如果新增切换应用的入口，也只需要新增一行“发布”操作的代码</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/ceeb653ely8h4hf7rdpltj206c06cq2v.jpg" alt="可以啊小伙儿_小伙儿_可以表情-发表情"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event.js</span></span><br><span class="line"><span class="comment">// 创建全局发布订阅信道</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="comment">// 集中维护事件名称  避免命名冲突</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EVENT_TYPE = &#123;</span><br><span class="line">  OPEN_APP: <span class="string">&#x27;OPEN_APP&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user.js</span></span><br><span class="line">event.subscribe(EVENT_TYPE.OPEN_APP, getPermission);</span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line">event.subscribe(EVENT_TYPE.OPEN_APP, getAppInfo);</span><br><span class="line"><span class="comment">// setting.js</span></span><br><span class="line">event.subscribe(EVENT_TYPE.OPEN_APP, getAppSetting);</span><br><span class="line"><span class="comment">// data.js</span></span><br><span class="line">event.subscribe(EVENT_TYPE.OPEN_APP, resetDataCache);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  event.publish(EVENT_TYPE.OPEN_APP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>观察者模式和发布 — 订阅模式</h1><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20221010192001316.png" alt="image-20221010192001316"></p><p>观察者模式和发布 — 订阅模式最大的区别在于：</p><ul><li>观察者模式由具体目标（被观察对象）调度</li><li>发布 — 订阅模式由调度中心（信道中介）统一调度</li><li>发布 — 订阅模式比观察者模式多一个调度中心（信道中介）</li></ul><blockquote><p>也可以理解为发布 — 订阅模式是基于观察者模式进行通用化设计，松散耦合，灵活度更高</p><p>观察者模式和发布 — 订阅模式的前端实践分别有 Vue 的数据双向绑定和事件总线 EventBus</p></blockquote><p>对 Vue 相关实现感兴趣可以看看以下几篇文章</p><ul><li><a href="https://juejin.cn/post/6945634348464865317">Vue 的前世今生</a></li><li><a href="https://juejin.cn/post/6944887985531781133">Vue 进阶 Diff 算法详解</a></li><li><a href="https://juejin.cn/post/6982004709145968677">[建议收藏] 你想知道的 Vue3 核心源码这里都有</a></li><li><a href="https://juejin.cn/post/7004635792446324749">[源码解读]一文读懂 Vuex4 源码</a></li></ul><h1>小结</h1><p>阅读完本文，我们对发布 — 订阅模式有了一个大致的了解。它的优点非常明显，时机和对象上的解耦，广泛应用于异步编程，同时帮助我们完成松耦合的代码编写。但也不是没有缺点，对象与对象之间的必要联系将被深埋在背后，可能会导致程序难以跟踪维护和理解。创建订阅者对象和存储列表需要消耗一定的时间和内存，而且存在很多订阅者订阅了一个事件之后，这个事件没有触发，而这块内存却一直被占用。优缺点都有，不要为了用而用，适合场景和业务的才是最好的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/008h4Hg2gy1h2j4m3yf3vg306o06ozz5.gif" alt="点赞 - 可达鸭表情包-发表情"></p><h1>设计模式系列文章推荐</h1><ul><li><a href="https://www.lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 单例模式</a></li><li><a href="https://www.lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 策略模式</a></li><li><a href="https://www.lebronchao.com/2022/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 代理模式</a></li><li><a href="https://www.lebronchao.com/2022/10/12/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 发布订阅模式</a></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;什么是发布 — 订阅模式&lt;/h1&gt;
&lt;p&gt;发布 — 订阅模式，它定义程序对象之间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知并执行相应操作。在日常生活中，常见的发布订阅模式有：订阅号，用户关注订阅号，内容创作者在平台发布内容后，平台遍历粉</summary>
      
    
    
    
    <category term="设计模式" scheme="https://lebronchao.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="JavaScript" scheme="https://lebronchao.com/tags/JavaScript/"/>
    
    <category term="设计模式" scheme="https://lebronchao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="发布订阅模式" scheme="https://lebronchao.com/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式-代理模式</title>
    <link href="https://lebronchao.com/2022/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lebronchao.com/2022/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-10-09T16:24:29.000Z</published>
    <updated>2022-10-09T16:24:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见，怎么这么久没更新了呢？</p><p>Emm…最近绩效评估季，绩效总结、360 评估，要写的东西比较多嚯，耽搁了一段时间</p><p>废话不多说，迎来 JavaScript 设计模式第三篇：代理模式 ~</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/bef3df8agy1fcnwggurzej208c08c74y.jpg" alt="美好的一天从学习开始 - 做个爱学习的 doge_学习_doge_装逼_萌萌哒表情"></p><h1>代理模式概念</h1><p>代理模式给某一个对象提供一个代理对象或者占位符，并由代理对象控制原对象的引用，也可以理解为对外暴露的接口并不是原对象。通俗地讲，生活中也有比较常见的代理模式：中介、寄卖、经纪人等等。而这种模式存在的意义在于当访问者与被访问者不方便直接访问/接触的情况下，提供一个替身来处理事务流程，实际访问的是替身，替身将事务做了一些处理/过滤之后，再转交给本体对象以减轻本体对象的负担。</p><h1>最简代理模式实现</h1><blockquote><p>由简入繁</p></blockquote><p>上面了解了代理模式的相关概念，接下来我们用一个最简代理模式的例子实现一下代理模式，从代码中感受代理模式的流程</p><blockquote><p>Talk is Cheap. Show me the code!</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20220919195415997.png" alt="image-20220919195415997"></p><ul><li>client 向服务端发送一个请求</li><li>proxy 代理请求转发给服务端</li><li>服务端处理请求</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Request = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = &#123;</span><br><span class="line">  requestTo: <span class="function">(<span class="params">server</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> req = <span class="keyword">new</span> Request();</span><br><span class="line">    server.receiveRequest(req);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = &#123;</span><br><span class="line">  handleRequest: <span class="function">(<span class="params">request</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;receive request: &#x27;</span>, request);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = &#123;</span><br><span class="line">  receiveRequest: <span class="function">(<span class="params">request</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;proxy request: &#x27;</span>, request);</span><br><span class="line">    server.handleRequest(request);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.requestTo(proxy);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * proxy request:  Request &#123;&#125;</span></span><br><span class="line"><span class="comment"> * receive request:  Request &#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1>保护代理</h1><blockquote><p>保护代理，顾名思义是为了保护本体</p><p>基于权限控制对资源的访问</p></blockquote><p>下面用一个场景和例子来实际感受一下，基于上面最简代理模式进行扩展，我们可以使用保护代理实现，过滤未通过身份校验的请求、监听服务端 ready 才发送请求等操作，保护实体服务端不被非法请求攻击和降低服务端负担。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = &#123;</span><br><span class="line">  receiveRequest: <span class="function">(<span class="params">request</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 校验身份</span></span><br><span class="line">    <span class="keyword">const</span> pass = validatePassport(request);</span><br><span class="line">    <span class="keyword">if</span> (pass) &#123;</span><br><span class="line">      <span class="comment">// 监听服务端 ready 后代理请求</span></span><br><span class="line">      server.listenReady(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;proxy request: &#x27;</span>, request);</span><br><span class="line">        server.handleRequest(request);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>虚拟代理</h1><blockquote><p>虚拟代理作为创建开销大的对象的代表，协助控制创建开销大的资源，直到真正需要一个对象的时候再去创建它，由虚拟代理来扮演对象的替身，对象创建后，再将资源直接委托给实体对象</p></blockquote><p>下面将会实现一个虚拟代理实现图片预加载的例子，从代码和实际场景中感受虚拟代理的作用。</p><ul><li>实体图片对象挂载在 body 中</li><li>由于加载图片耗时较高，开销较大，加载图片资源时<ul><li>将实体图片对象设置为 loading 状态</li><li>使用替身对象执行图片资源加载</li><li>监听替身对象资源加载完成，将资源替换给实体对象</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> img = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(img);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function">(<span class="params">src</span>) =&gt;</span> &#123;</span><br><span class="line">      imgNode.src = src;</span><br><span class="line">    &#125;,</span><br><span class="line">    setLoading: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      imgNode.src = <span class="string">&#x27;loading.gif&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyImg = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 替身图片对象</span></span><br><span class="line">  <span class="keyword">const</span> tempImg = <span class="keyword">new</span> Image();</span><br><span class="line">  <span class="comment">// 监听资源加载完成，将资源替换给实体图片对象</span></span><br><span class="line">  tempImg.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    img.setSrc(<span class="built_in">this</span>.src);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 代理开始将实体对象设置为loading状态，使用替身对象开始加载图片资源</span></span><br><span class="line">    setSrc: <span class="function">(<span class="params">src</span>) =&gt;</span> &#123;</span><br><span class="line">      img.setLoading();</span><br><span class="line">      tempImg.src = src;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyImg.setSrc(<span class="string">&#x27;file.jpg&#x27;</span>);</span><br></pre></td></tr></table></figure><h1>代理模式的应用</h1><blockquote><p>看完保护代理和虚拟代理之后，下面来看看代理模式在前端中的一些具体应用</p></blockquote><h2 id="请求优化（埋点、错误聚合上报）">请求优化（埋点、错误聚合上报）</h2><p>前段时间有幸受邀参加了 ByteTech 字节青训营的评委，主要参加评审的是前端监控系统主题项目。前端监控就会涉及一些错误等信息的上报，部分项目只实现了最简的 HTTP 请求上报。</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/008h4Hg2gy1h243zghtz6j30u00u078d.jpg" alt="不请自来你们真能卷龙卷风都被你们卷来了"></p><p>而有部分项目对这块内容做了以下优化，是一个比较贴切的代理模式实践场景：</p><ul><li>Navigator.sendBeacon<ul><li>使用户代理在有机会时异步地向服务器发送数据（ HTTP POST ），不影响交互性能</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon">https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon</a></li></ul></li><li>数据聚合上报（未使用代理模式优化版本为，每次 report 都使用请求上报）<ul><li>降低请求次数，聚合多事件/信息进行上报<ul><li>定时</li><li>定量分组</li></ul></li></ul></li></ul><blockquote><p>下面简单实现一下两种上报的示意代码</p></blockquote><ul><li>定时</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> events = [];</span><br><span class="line"><span class="keyword">const</span> TIMER = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化时启动定时器</span></span><br><span class="line">  timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 定时使用 sendBeacon 上报</span></span><br><span class="line">    <span class="keyword">const</span> evts = events.splice(<span class="number">0</span>, events.length);</span><br><span class="line">    navigator.sendBeacon(<span class="string">&#x27;/path&#x27;</span>, &#123; <span class="attr">events</span>: evts &#125;);</span><br><span class="line">  &#125;, TIMER);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> destroyed = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 销毁时清除定时器</span></span><br><span class="line">  <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> report = <span class="function">(<span class="params">eventName, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// sdk 上报工具函数，聚合事件</span></span><br><span class="line">  events.push(&#123;</span><br><span class="line">    eventName,</span><br><span class="line">    data,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>定量分组</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> events = [];</span><br><span class="line"><span class="keyword">const</span> LIMIT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reportRequest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 定量分组使用 sendBeacon 上报</span></span><br><span class="line">  <span class="keyword">const</span> evts = events.splice(<span class="number">0</span>, LIMIT);</span><br><span class="line">  navigator.sendBeacon(<span class="string">&#x27;/path&#x27;</span>, &#123; <span class="attr">events</span>: evts &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> report = <span class="function">(<span class="params">eventName, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// sdk 上报工具函数，聚合事件</span></span><br><span class="line">  events.push(&#123;</span><br><span class="line">    eventName,</span><br><span class="line">    data,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (events.length &gt;= LIMIT) &#123;</span><br><span class="line">    reportRequest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数据缓存代理">数据缓存代理</h2><ul><li><p>之前看到过一道面试题：前端怎么实现缓存到期自动删除缓存？</p><ul><li><p>如果正向地去思考，缓存到期了，程序都关闭了，怎么删？</p></li><li><p>换个角度：不在过期时立即 set ，get 时才需要判断缓存是否过期</p><p>在 get 时判断下是否过期，过期了再删除不就得了 ~</p></li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/b64da6adly1h4voq4w7nlj20j60iv0tg.jpg" alt="小猫咪觉得很赞(猫猫点赞表情包)_点赞_很赞_小猫咪表情"></p><ul><li>通过 ProxyStorage 代理缓存中间件，实现支持设置缓存过期时间</li><li>代理一层，便于切换缓存中间件，增加可维护性</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Storage = &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">key, value, maxAge</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(</span><br><span class="line">      key,</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        maxAge,</span><br><span class="line">        value,</span><br><span class="line">        time: <span class="built_in">Date</span>.now(),</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> v = <span class="built_in">localStorage</span>.getItem(key);</span><br><span class="line">    <span class="keyword">if</span> (!v) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; maxAge, value, time &#125; = <span class="built_in">JSON</span>.parse(v);</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now &lt; time + maxAge * <span class="number">1000</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">localStorage</span>.removeItem(key);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> v = <span class="built_in">localStorage</span>.getItem(key);</span><br><span class="line">    <span class="keyword">if</span> (!v) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; maxAge, time &#125; = <span class="built_in">JSON</span>.parse(v);</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now &lt; time + maxAge * <span class="number">1000</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">localStorage</span>.removeItem(key);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="请求函数的封装">请求函数的封装</h2><p>通过代理模式封装请求函数，可以实现以下功能：</p><ul><li>植入通用参数、通用请求头</li><li>全局请求埋点上报</li><li>全局异常状态码处理器</li><li>全局请求错误、异常上报和处理</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/006APoFYly8h58u4ejh44g3050050my0-20220919200313364.gif" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SUCCESS_STATUS_CODE = <span class="number">200</span>,</span><br><span class="line">  FAIL_STATUS_CODE = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">const</span> isValidHttpStatus = <span class="function">(<span class="params">statusCode</span>) =&gt;</span></span><br><span class="line">  statusCode &gt;= SUCCESS_STATUS_CODE &amp;&amp; statusCode &lt; FAIL_STATUS_CODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ErrorCode = &#123;</span><br><span class="line">  NotLogin: <span class="number">2022</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ErrorHandler = &#123;</span><br><span class="line">  [ErrorCode.NotLogin]: redirectToLoginPage,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = <span class="keyword">async</span> (reqParams) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; headers, method, data, params, url &#125; = reqParams;</span><br><span class="line">  <span class="comment">// 封装请求参数，植入通用参数、通用请求头</span></span><br><span class="line">  <span class="keyword">const</span> requestObj = &#123;</span><br><span class="line">    url: url + <span class="string">`?<span class="subst">$&#123;qs.stringify(&#123; ...commonParams, ...params &#125;)&#125;</span>`</span>,</span><br><span class="line">    headers: &#123; ...commonHeaders, ...headers &#125;,</span><br><span class="line">    data,</span><br><span class="line">    method,</span><br><span class="line">    start: <span class="built_in">Date</span>.now(),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 上报请求开始埋点</span></span><br><span class="line">    reportEvent(AJAX_START, requestObj);</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> ajax(requestObj);</span><br><span class="line">    requestObj.end = <span class="built_in">Date</span>.now();</span><br><span class="line">    requestObj.response = res;</span><br><span class="line">    <span class="comment">// 上报请求结束埋点</span></span><br><span class="line">    reportEvent(AJAX_END, requestObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; statusCode, <span class="attr">data</span>: resData &#125; = res;</span><br><span class="line">    <span class="keyword">const</span> &#123; errorCode &#125; = resData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isValidHttpStatus(statusCode)) &#123;</span><br><span class="line">      <span class="comment">// 异常状态码埋点上报</span></span><br><span class="line">      reportEvent(AJAX_ERROR, requestObj);</span><br><span class="line">      <span class="keyword">throw</span> resData;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errorCode) &#123;</span><br><span class="line">      <span class="comment">// 错误码全局处理器定义，未定义则把错误抛出给上层业务处理</span></span><br><span class="line">      reportEvent(AJAX_WARNING, requestObj);</span><br><span class="line">      <span class="keyword">if</span> (ErrorHandler(errorCode)) &#123;</span><br><span class="line">        ErrorHandler(errorCode)();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> resData;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 正常返回请求数据</span></span><br><span class="line">      <span class="keyword">return</span> resData;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 捕获错误并进行埋点上报，抛给上层业务处理</span></span><br><span class="line">    requestObj.error = error;</span><br><span class="line">    reportEvent(AJAX_ERROR, requestObj);</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Vue-中的代理模式">Vue 中的代理模式</h2><blockquote><p>将数据、方法、计算属性等代理到组件实例上</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">    vue: <span class="string">&#x27;vue&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">helloVue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.msg + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.vue;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.helloVue);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Koa-中的代理模式">Koa 中的代理模式</h2><blockquote><p>context 上下文代理封装在 request 和 response 里的属性</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(context.request.url);</span><br><span class="line">  <span class="built_in">console</span>.log(context.url);</span><br><span class="line">  <span class="built_in">console</span>.log(context.response.body);</span><br><span class="line">  <span class="built_in">console</span>.log(context.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1>其他代理模式</h1><blockquote><p>除了本文提到的代理模式应用，还有其他非常多的变体和应用</p><p>这里简要列举和介绍一下，就不一一详细展开说明了</p></blockquote><ul><li>防火墙代理：控制网络资源访问，保护主体不让”坏人“接近</li><li>远程代理（科学上网）：为一个对象在不同的地址空间提供局部代表，比如大家的”科学上网“</li><li>保护代理：用于对象应该有不同的访问权限的情况</li><li>智能引用代理：取代了简单的指针，它在访问对象时执行一些附加的操作，比如计算一个对象被引用的次数（可能用于 GC 的引用计数</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/006APoFYly8h2r81r46eag306o06oq35.gif" alt="拿捏了_拿捏表情"></p><h1>小结</h1><p>代理模式有着许多的小分类，前端开发工作中常用的有虚拟代理、保护代理和缓存代理等。其实读到这里，大家也能感受到，日常开发工作中常做的一个动作 —— ”封装“ ，其实就是代理模式的运用 ~</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/bef3df8agy1fcnwgf3012j208c08c0tb.jpg" alt="刻苦学习了一天，好充实、好幸福 - 做个爱学习的 doge_学习_doge_装逼_萌萌哒表情"></p><h1>设计模式系列文章推荐</h1><ul><li><a href="https://www.lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 单例模式</a></li><li><a href="https://www.lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 策略模式</a></li><li><a href="https://www.lebronchao.com/2022/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 代理模式</a></li><li><a href="https://www.lebronchao.com/2022/10/12/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 发布订阅模式</a></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久不见，怎么这么久没更新了呢？&lt;/p&gt;
&lt;p&gt;Emm…最近绩效评估季，绩效总结、360 评估，要写的东西比较多嚯，耽搁了一段时间&lt;/p&gt;
&lt;p&gt;废话不多说，迎来 JavaScript 设计模式第三篇：代理模式 ~&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loadin</summary>
      
    
    
    
    <category term="设计模式" scheme="https://lebronchao.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="JavaScript" scheme="https://lebronchao.com/tags/JavaScript/"/>
    
    <category term="设计模式" scheme="https://lebronchao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="代理模式" scheme="https://lebronchao.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 设计模式 —— 策略模式</title>
    <link href="https://lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-21T13:11:23.000Z</published>
    <updated>2022-08-21T13:11:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>很快，迎来了 JavaScript 设计模式系列的第二篇 —— 策略模式 …</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/eeef21c8afaf4d89857f31ba2644ad36~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1>什么是策略模式</h1><blockquote><p>策略模式定义：</p><p>定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换</p></blockquote><p>策略模式一般由两部分组成：</p><ol><li><p>封装不同策略的策略组（使得代码复用性、可扩展、可维护性提高，避免大量 CV 代码的情况）</p></li><li><p>Context（委托算法，执行策略）</p></li></ol><h1>什么时候使用策略模式 ？</h1><blockquote><p>策略模式广泛应用于程序研发中，当出现需要根据不同的前置条件执行不同的算法得到结果时，使用策略模式可以让你的代码更加优雅</p></blockquote><p>怎么？不信？ 那就上点代码让你感受一下 💩 山的力量！</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/5cab40c1005d40c6a578a60fb43e836a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>假设一个函数负责 Consul （服务发现）和 LB （负载均衡）</p><p>这里 Consul 函数就是 Context，各种 LB 算法就是策略组</p><p>传入服务唯一标识和负载均衡算法</p><p>返回服务器实例 IP 地址</p><p>如想了解 LB 相关知识，可以看看这篇文章 <a href="https://juejin.cn/post/6987196608161005581">[深入浅出 LB]手把手带你实现一个负载均衡器</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consul</span>(<span class="params">serviceId, algorithm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (algorithm === <span class="string">&#x27;random&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// random flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;weightedRoundRobin&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// weightedRoundRobin flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;ipHash&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ipHash flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;urlHash&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// urlHash flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;leastConnection&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// leastConnection flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;fair&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// fair flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这段代码存在着一些明显的问题</p><ol><li><p>Consul 函数过于庞大，不符合单一职责原则，难维护</p></li><li><p>堆砌了过多的 IF-ELSE 语句，代码看起来比较冗余</p></li><li><p>负载均衡算法复用性较差，如果其他地方需要用到…（你不会直接 CV 吧 🤓</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/6167b9b2dc57444cbbbbd660b86ae406~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>针对以上问题，我们可以利用策略模式加以优化</p></blockquote><ol><li><p>首先将各 LB 算法封装成独立的函数，提高复用性</p></li><li><p>建立算法名称 -&gt; 算法执行函数映射，干掉冗余的 IF-ELSE（简直就是 IF-ELSE 的救世主</p></li><li><p>简化 Consul 函数，具体算法对于 Consul 来说是“隐形”的，单一职责</p></li><li><p>可拓展性提高，如需拓展更多算法，仅需引入算法和添加 Map 中的配置</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// random flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">weightedRoundRobin</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// weightedRoundRobin flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipHash</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// IPHash flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlHash</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// URL Hash flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leastConnection</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// leaseConnection flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fair</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// fair flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALGORITHM = &#123;</span><br><span class="line">  RANDOM: <span class="string">&#x27;random&#x27;</span>,</span><br><span class="line">  WEIGHTED_ROUND_ROBIN: <span class="string">&#x27;weightedRoundRobin&#x27;</span>,</span><br><span class="line">  IP_HASH: <span class="string">&#x27;ipHash&#x27;</span>,</span><br><span class="line">  URL_HASH: <span class="string">&#x27;urlHash&#x27;</span>,</span><br><span class="line">  LEAST_CONNECTION: <span class="string">&#x27;leastConnection&#x27;</span>,</span><br><span class="line">  FAIR: <span class="string">&#x27;fair&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALGORITHM_MAP = &#123;</span><br><span class="line">  [ALGORITHM.RANDOM]: random,</span><br><span class="line">  [ALGORITHM.WEIGHTED_ROUND_ROBIN]: weightedRoundRobin,</span><br><span class="line">  [ALGORITHM.IP_HASH]: ipHash,</span><br><span class="line">  [ALGORITHM.URL_HASH]: urlHash,</span><br><span class="line">  [ALGORITHM.LEAST_CONNECTION]: leastConnection,</span><br><span class="line">  [ALGORITHM.FAIR]: fair,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consul</span>(<span class="params">serviceId, algorithm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ALGORITHM_MAP[algorithm](serviceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>策略模式应用场景之表单校验</h1><h2 id="粗糙的表单校验">粗糙的表单校验</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 粗糙的表单校验</span></span><br><span class="line"><span class="keyword">let</span> loginFrom = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;loginFrom&#x27;</span>);</span><br><span class="line">loginFrom.onsubmit = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> username = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> pwd = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;pwd&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> mobile = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;mobile&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (username === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;用户名不可为空&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pwd.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;密码长度不能少于6位&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="regexp">/^1(3\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|8\d|9[0-35-9])\d&#123;8&#125;$/</span>.test(mobile)</span><br><span class="line">  ) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;手机号码格式不正确&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用策略模式优化后的表单校验">使用策略模式优化后的表单校验</h2><blockquote><p>Context：validate</p><p>策略组：strategy</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用策略模式优化</span></span><br><span class="line"><span class="keyword">const</span> strategy = &#123;</span><br><span class="line">  isEmpty: <span class="function"><span class="keyword">function</span> (<span class="params">&#123; value &#125;, errMsg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isMobile: <span class="function"><span class="keyword">function</span> (<span class="params">&#123; value &#125;, errMsg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !<span class="regexp">/^1(3\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|8\d|9[0-35-9])\d&#123;8&#125;$/</span>.test(value)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isLongerThanMinLength: <span class="function"><span class="keyword">function</span> (<span class="params">&#123; value, len &#125;, errMsg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; len) &#123;</span><br><span class="line">      <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.validateItems = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">params, strategyKey, errMsg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.validateItems.push(&#123; params, strategyKey, errMsg &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>.validateItems) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; params, strategyKey, errMsg &#125; = item;</span><br><span class="line">      <span class="keyword">const</span> msg = strategy[strategyKey](params, errMsg);</span><br><span class="line">      <span class="keyword">if</span> (msg) &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> username = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> pwd = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;pwd&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> mobile = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;mobile&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> validator = <span class="keyword">new</span> Validator();</span><br><span class="line">  validator.add(&#123; <span class="attr">value</span>: username &#125;, <span class="string">&#x27;isEmpty&#x27;</span>, <span class="string">&#x27;用户名不可为空&#x27;</span>);</span><br><span class="line">  validator.add(</span><br><span class="line">    &#123; <span class="attr">value</span>: pwd, <span class="attr">len</span>: <span class="number">6</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;isLongerThanMinLength&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;密码长度不能少于6位&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  validator.add(&#123; <span class="attr">value</span>: mobile &#125;, <span class="string">&#x27;isMobile&#x27;</span>, <span class="string">&#x27;手机号码格式不正确&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> errMsg = validator.start();</span><br><span class="line">  <span class="keyword">if</span> (errMsg) &#123;</span><br><span class="line">    alert(errMsg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;校验通过&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validate();</span><br></pre></td></tr></table></figure><h1>策略模式和多态的区别</h1><ul><li><p>策略模式定义了算法组，分别封装，它们之间可以相互替换，此模式的变化独立于使用算法的客户</p></li><li><p>多态常用继承、方法重写、父类引用指向子类对象等方法实现</p></li></ul><blockquote><p>策略模式强调的是做同一件事的不同且不重复的方法</p><p>多态是一种语言机制，有的不支持多态的语言也一样要实现策略模式</p><p>策略处于程序设计层次，多态处于语言语法层次</p></blockquote><h1>总结</h1><h2 id="策略模式的优点">策略模式的优点</h2><ul><li><p>策略模式利用组合、委托和多态等技术和思想，可以有效避免多重且冗余的 IF-ELSE</p></li><li><p>策略模式提供了对开放——封闭原则的完美支持，将算法封装在独立的策略中。可以在不修改原代码的情况下，灵活增加新算法。提高了它们的复用性、和可拓展性，也更容易切换和理解。</p></li><li><p>策略模式中的算法也可以复用在工程的其他地方，避免大量重复的 CV 工作</p></li><li><p>在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案</p></li></ul><h2 id="策略模式的缺点">策略模式的缺点</h2><ul><li><p>策略模式会在程序中增加许多策略函数、类、对象，但实际上比把它们堆砌在 Context 中要更好</p></li><li><p>使用策略模式必须了解所有的策略，必须了解它们的细节比较它们之间的不同点，才能选择一个合适的策略。此时需要向用户暴露它的所有实现，违反最少知识原则。</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/a16be28e58b54115b4bc17ebc45b7cd0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1>设计模式系列文章推荐</h1><ul><li><a href="https://www.lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 单例模式</a></li><li><a href="https://www.lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 策略模式</a></li><li><a href="https://www.lebronchao.com/2022/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 代理模式</a></li><li><a href="https://www.lebronchao.com/2022/10/12/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 发布订阅模式</a></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;很快，迎来了 JavaScript 设计模式系列的第二篇 —— 策略模式 …&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https://lebronchao-1</summary>
      
    
    
    
    <category term="设计模式" scheme="https://lebronchao.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="JavaScript" scheme="https://lebronchao.com/tags/JavaScript/"/>
    
    <category term="设计模式" scheme="https://lebronchao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="策略模式" scheme="https://lebronchao.com/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 设计模式 —— 单例模式</title>
    <link href="https://lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-08-21T13:11:14.000Z</published>
    <updated>2022-08-21T13:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案 —— 设计模式</p><p>设计模式原则：“找出程序中变化的地方，并将变化封装起来”</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/e424e745d4e545a8bb75e14a563dbe70~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><h1>为什么要学习设计模式?</h1><p>从事开发岗位也有一年多的时间了，见识过陈年老项目，也从零到一搭建过一个项目。随着项目和业务的不断扩张，写下的代码如果没有进行设计，就渐渐变成了 emm … x 山，怎么写都不对劲，过段时间就想着重构。</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/bf5f5a7bb5c440db89c525db7044a7ba~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>人之所以可以走到食物链的顶端，是因为会学习、总结，会使用“名字”和“工具”。而设计模式并不是凭空发明出来的，是经过了大量的项目实践总结出来的对某种业务场景下的程序编写最佳实践，总结出来的解决方案，并给它取了个名字，就变成了一个设计模式。就好比篮球场上的战术，组织后卫常喊出打几号战术，而不是一个人一个人地指挥，简洁的代号往往比冗杂的描述更优雅。有可能你经常写程序的一种方式，可以描述出来，但不知道它叫什么名字，有可能就是一种设计模式。所以我们在学习的过程中，经常会有这种感受： ooooo ！！这玩意儿我经常用，经常这么写，原来这个是 xx 模式！</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/eac8ed0ef6544b3489bff9d17ee7870b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>最后，为什么要学设计模式呢？虽然有时候设计模式会使代码复杂度升高，增加开发的成本，但极大地降低了维护成本。就好比图书馆中的书如果无序地散落在各个角落，找起来如同大海捞针；而如果标号且归类、有序地放在指定书架上，找起来就容易了许多。想象一个场景，某天，你指着一段代码开始骂，这谁写的 x 山！鼠标移了上去， git 修改记录显示，哦！我写的，那没事了。赶紧设计模式学起来，优雅地编写简洁、可复用、易维护的程序 ~</p><h1>单例模式</h1><blockquote><p>1、保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p>2、主要解决一个全局使用的类频繁地创建和销毁，占用内存</p></blockquote><h2 id="实现单例模式">实现单例模式</h2><blockquote><p>实现一个简洁的单例模式并不复杂，无非就是将实例对象保存起来，下一次获取/创建对象的时候，直接返回之前创建的实例</p></blockquote><h3 id="最简单例模式">最简单例模式</h3><blockquote><ul><li><p>闭包实现</p></li><li><p>ES6 实现</p></li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用闭包实现</span></span><br><span class="line"><span class="keyword">var</span> Singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Instance</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Instance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> single1 = Singleton();</span><br><span class="line"><span class="keyword">var</span> single2 = Singleton();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(single1 === single2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Singleton.instance) &#123;</span><br><span class="line">      Singleton.instance = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Singleton.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> single1 = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="keyword">const</span> single2 = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(single1 === single2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="惰性单例">惰性单例</h3><blockquote><p>惰性单例：初始化时不进行实例创建，到获取实例时才进行实例创建，类似前端的资源懒加载思想</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非惰性单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (!SingleTon.instance) &#123;</span><br><span class="line">      SingleTon.instance = <span class="keyword">new</span> Tool(args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 惰性单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.instance) &#123;</span><br><span class="line">      <span class="built_in">this</span>.instance = <span class="keyword">new</span> Tool(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透明单例和代理单例">透明单例和代理单例</h3><blockquote><ul><li><p>透明单例</p><ul><li>将实例的创建和方法的执行封装到了一个类中</li><li>不太符合“单一职责原则”，代码不易读、不易改</li></ul></li><li><p>代理单例</p><ul><li>代理模式：将实例创建和方法分离，委托出去</li><li>Person 作为普通类，可以创建对象实例</li><li>createPerson 作为单例创建代理，可以创建一个单例</li><li>符合“单一职责原则”，代码易读、易改</li></ul></li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 透明 单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createPerson</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (createPerson.instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> createPerson.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">    <span class="keyword">return</span> (createPerson.instance = <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;lebron&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;james&#x27;</span>);</span><br><span class="line">p1.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line">p2.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createPerson</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!createPerson.instance) &#123;</span><br><span class="line">      createPerson.instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createPerson.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;lebron&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;james&#x27;</span>);</span><br><span class="line">p1.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line">p2.init(); <span class="comment">// My name is  lebron</span></span><br></pre></td></tr></table></figure><h3 id="最终版本">最终版本</h3><blockquote><p>每次实现一个类的单例模式都去 CV 重复的模板代码，不太符合预期。</p><p>于是，我们可以根据设计模式的原则“找出程序变化的地方，并将变化封装起来”</p><p>可以做如下改造</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> singleInstance;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">singleConstructor</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 第一次实例化</span></span><br><span class="line">      <span class="keyword">if</span> (!singleInstance) &#123;</span><br><span class="line">        singleInstance = <span class="keyword">new</span> fn(...args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 多次实例化直接返回</span></span><br><span class="line">      <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    singleConstructor.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">return</span> singleConstructor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createPerson = <span class="keyword">new</span> SingleTon(Person);</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;lebron&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;james&#x27;</span>);</span><br><span class="line">p1.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line">p2.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">number</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.number = number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;This is tool &#x27;</span>, <span class="built_in">this</span>.number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createTool = <span class="keyword">new</span> SingleTon(Tool);</span><br><span class="line"><span class="keyword">const</span> t1 = <span class="keyword">new</span> createTool(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> t2 = <span class="keyword">new</span> createTool(<span class="number">2</span>);</span><br><span class="line">t1.init(); <span class="comment">// This is tool  1</span></span><br><span class="line">t2.init(); <span class="comment">// This is tool  1</span></span><br><span class="line"><span class="built_in">console</span>.log(t1 === t2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="单例模式的应用场景">单例模式的应用场景</h2><h3 id="登录窗口">登录窗口</h3><blockquote><p>登录窗口在我们的软件中很常见，也很适合使用单例模式创建（全局唯一、频繁使用）</p><p>使用单例模式创建可以避免多次节点创建和销毁</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.element.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">           用户名 &lt;input name=&quot;username&quot;/&gt;</span></span><br><span class="line"><span class="string">           密码 &lt;input name=&quot;password&quot;/&gt;</span></span><br><span class="line"><span class="string">           &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;</span></span><br><span class="line"><span class="string">          `</span>;</span><br><span class="line">    <span class="built_in">this</span>.element.style.cssText = <span class="string">`width:100px;height:100px;position:absolute;left:50%;top:50%;margin-top:-50px;margin-left:-50px;display:none`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="built_in">this</span>.element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;show&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hide&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用上文最终版本创建单例代码</span></span><br><span class="line"><span class="keyword">const</span> createLogin = <span class="keyword">new</span> SingleTon(Login);</span><br><span class="line"><span class="keyword">const</span> loginInstance = createLogin();</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;show-btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  loginInstance.show();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;hide-btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  loginInstance.hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Store">Store</h3><blockquote><p>全局状态管理，全局唯一实例，例如 Vuex / Redux / Mobx</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已省略一些无关代码</span></span><br><span class="line"><span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  install(<span class="built_in">window</span>.Vue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Vue = _Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jquery">Jquery</h3><blockquote><p>Jquery 也是应用的单例模式，虽然它已经渐渐淡出了我们的视野 😂</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.jQuery != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.jQuery;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//init~~~~~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><h3 id="使用场景">使用场景</h3><ul><li>保证一个类仅有一个实例，并提供一个访问它的全局访问点</li></ul><h3 id="优点">优点</h3><ul><li><p>在内存里只有一个实例，减少了内存的开销，尤其是频繁地创建和销毁实例</p></li><li><p>避免对资源的多重占用</p></li></ul><h1>闲谈</h1><blockquote><p>上半年一直在忙毕业的事情，然后也休息了一段时间，已经大半年没写技术文章了。</p><p>近期正式入职了，开始逐步调整到一个比较好的学习和工作状态。制定一些学习计划，恢复更新文章（很久没写还是有点不太习惯哈哈</p><p>第一个系列《设计模式》第一篇墨迹了半天，但也终于产出了。后续会持续更新，更新频率和进度看空闲时间情况了哈哈，欢迎关注~</p><p>一个还在努力的前端开发工程师，继续加油！</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/cce8553a6ec8415690f43252e508eb09~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1>设计模式系列文章推荐</h1><ul><li><a href="https://www.lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 单例模式</a></li><li><a href="https://www.lebronchao.com/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 策略模式</a></li><li><a href="https://www.lebronchao.com/2022/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 代理模式</a></li><li><a href="https://www.lebronchao.com/2022/10/12/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">JavaScript 设计模式 —— 发布订阅模式</a></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案 —— 设计模式&lt;/p&gt;
&lt;p&gt;设计模式原则：“找出程序中变化的地方，并将变化封装起来”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; </summary>
      
    
    
    
    <category term="设计模式" scheme="https://lebronchao.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="JavaScript" scheme="https://lebronchao.com/tags/JavaScript/"/>
    
    <category term="设计模式" scheme="https://lebronchao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="单例模式" scheme="https://lebronchao.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>摄影 | 梧桐山</title>
    <link href="https://lebronchao.com/2022/02/20/%E6%91%84%E5%BD%B1-%E6%A2%A7%E6%A1%90%E5%B1%B1/"/>
    <id>https://lebronchao.com/2022/02/20/%E6%91%84%E5%BD%B1-%E6%A2%A7%E6%A1%90%E5%B1%B1/</id>
    <published>2022-02-19T16:24:49.000Z</published>
    <updated>2022-02-19T16:24:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 24-70GM<br>出镜：无<br>地点：梧桐山</p></blockquote><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00244.JPG" alt="DSC00244"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00248.JPG" alt="DSC00248"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00249.JPG" alt="DSC00249"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00250.JPG" alt="DSC00250"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00251.JPG" alt="DSC00251"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00253.JPG" alt="DSC00253"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00260.JPG" alt="DSC00260"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00287.JPG" alt="DSC00287"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00302.JPG" alt="DSC00302"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00271.JPG" alt="DSC00271"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00278.JPG" alt="DSC00278"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_0086.JPG" alt="IMG_0086"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00266.JPG" alt="DSC00266"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00237.JPG" alt="DSC00237"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00242.JPG" alt="DSC00242"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00232.JPG" alt="DSC00232"></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机身：SONY A7M2&lt;br&gt;
镜头：SONY 24-70GM&lt;br&gt;
出镜：无&lt;br&gt;
地点：梧桐山&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;justified-gallery&quot;&gt;&lt;p&gt;&lt;img src= &quot;/img/loa</summary>
      
    
    
    
    <category term="摄影" scheme="https://lebronchao.com/categories/%E6%91%84%E5%BD%B1/"/>
    
    
    <category term="人文" scheme="https://lebronchao.com/tags/%E4%BA%BA%E6%96%87/"/>
    
    <category term="摄影" scheme="https://lebronchao.com/tags/%E6%91%84%E5%BD%B1/"/>
    
    <category term="风光" scheme="https://lebronchao.com/tags/%E9%A3%8E%E5%85%89/"/>
    
  </entry>
  
  <entry>
    <title>摄影 | 南山夜景</title>
    <link href="https://lebronchao.com/2022/02/07/%E6%91%84%E5%BD%B1-%E5%8D%97%E5%B1%B1%E5%A4%9C%E6%99%AF/"/>
    <id>https://lebronchao.com/2022/02/07/%E6%91%84%E5%BD%B1-%E5%8D%97%E5%B1%B1%E5%A4%9C%E6%99%AF/</id>
    <published>2022-02-06T16:16:47.000Z</published>
    <updated>2022-02-06T16:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机身： SONY A7M2<br>镜头： SONY 24-70 GM<br>出镜： 无<br>地点： 深圳大南山公园</p></blockquote><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00174.JPG" alt="DSC00174"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00175.JPG" alt="DSC00175"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00229.JPG" alt="DSC00229"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00230.JPG" alt="DSC00230"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00167.JPG" alt="DSC00167"></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机身： SONY A7M2&lt;br&gt;
镜头： SONY 24-70 GM&lt;br&gt;
出镜： 无&lt;br&gt;
地点： 深圳大南山公园&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;justified-gallery&quot;&gt;&lt;p&gt;&lt;img src= </summary>
      
    
    
    
    <category term="摄影" scheme="https://lebronchao.com/categories/%E6%91%84%E5%BD%B1/"/>
    
    
    <category term="摄影" scheme="https://lebronchao.com/tags/%E6%91%84%E5%BD%B1/"/>
    
    <category term="风光" scheme="https://lebronchao.com/tags/%E9%A3%8E%E5%85%89/"/>
    
    <category term="城市夜景" scheme="https://lebronchao.com/tags/%E5%9F%8E%E5%B8%82%E5%A4%9C%E6%99%AF/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS加解密之Crypto</title>
    <link href="https://lebronchao.com/2021/12/22/NodeJS%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BCrypto/"/>
    <id>https://lebronchao.com/2021/12/22/NodeJS%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BCrypto/</id>
    <published>2021-12-22T15:50:51.000Z</published>
    <updated>2021-12-22T15:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>互联网时代，网络上的数据量每天都在以惊人的速度增长。同时，各类网络安全问题层出不穷。在信息安全重要性日益凸显的今天，作为一名开发者，需要加强对安全的认识，并通过技术手段增强服务的安全性。crypto 模块的目的是为了提供通用的加密和哈希算法。用纯 JavaScript 代码实现这些功能不是不可能，但速度会非常慢。Nodejs 用 C/C++实现这些算法后，通过 cypto 这个模块暴露为 JavaScript 接口，这样用起来方便，运行速度也快。</p></blockquote><h1>编码方式</h1><blockquote><p>为什么信息传输需要编码？</p><p>在开发加密解密数据的时候碰到需要把加密好的字节数组转换成 String 对象用于网络传输的需求，如果把字节数组直接转换成 UTF-8 等编码方式的话肯定会存在某些编码没有对应的字符(8bit 只能表示 128 个字符)，在编码和解析过程中会出错，不能正确地表达信息。这时就可以通过常用的二进制数据编码方式 Base64 编码或者 Hex 编码来实现。</p></blockquote><h2 id="hex-编码"><strong>hex 编码</strong></h2><ul><li>编码原理</li></ul><p>将一个 8 位的字节数据用两个 16 进制数表示出来</p><ol><li>将 8 位二进制码重新分组成两个 4 位的字节</li><li>其中一个字节的低 4 位是原字节的高 4 位，另一个字节的低 4 位是原数据的低 4 位</li><li>高 4 位都补 0，然后输出这两个字节对应的十六进制数字作为编码</li></ol><ul><li>例子</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ASCII码：A(<span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">二进制码:<span class="number">0100</span> <span class="number">0001</span></span><br><span class="line"></span><br><span class="line">重新分组: <span class="number">00000100</span>  <span class="number">00000001</span></span><br><span class="line"></span><br><span class="line">十六进制: <span class="number">4</span>         <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Hex编码：<span class="number">41</span></span><br></pre></td></tr></table></figure><p>就算原文件是纯英文内容，编码后内容也和原文完全不一样，普通人难以阅读但由于只有 16 个字符，听说一些程序员大牛能够记下他们的映射关系，从而达到读 hex 编码和读原文一样的效果。另外，数据在经过 hex 编码后，空间占用变成了原来的 2 倍。</p><h2 id="base64-编码"><strong>base64 编码</strong></h2><ul><li>编码原理</li></ul><p>Base64 编码是通过 64 个字符来表示二进制数据，64 个字符表示二进制数据只能表示 6 位，所以它可以通过 4 个 Base64 字符来表示 3 个字节，如下是 Base64 的字符编码表</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202230237552.(null)" alt="img"></p><ul><li>举个 Base64 编码的例子，图就很浅显易懂了</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202230244003.(null)" alt="img"></p><ul><li>字符串长度不是 3 的倍数时补 0，也就是“=”</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202230248378.(null)" alt="img"></p><p>由 64 个字符组成，比 hex 编码更难阅读，但由于每 3 个字节会被编码为 4 个字符。</p><p>所以，空间占用会是原来的 4/3，比 hex 要节省空间。另外要注意的是，虽然 Base64 编码后的数据难以阅读，但不能将其作为加密算法使用，因为它解码都不需要你提供密钥啊</p><h2 id="urlencode-编码"><strong>urlencode 编码</strong></h2><ul><li>编码原理</li></ul><p>urlencode 编码，看名字就就知道是设计给 url 编码的对于<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，<code>.</code>，<code>-</code>和<code>_</code> ，urlencode 都不会做任何处理原样输出，而其它字节会被编码为<code>%xx</code>(16 进制)的形式，其中<code>xx</code>就是这个字节对应的 hex 编码。 由于英文字符原样保留，对于以英文为主的内容，可读性最好，空间占用几乎不变，而对于非英文内容，每个字节会被编码为%xx 的 3 个字符，空间占用是原来的 3 倍，所以 urlencode 是一个对英文友好的编码方案。</p><h1><strong>Hash</strong></h1><blockquote><p>摘要：将不固定长度的消息作为输入 Hash 函数，生成固定长度的输出，这段输出称之为摘要</p><p>适用场景：敏感信息的校验和存储、验证消息完整 &amp; 未被篡改</p></blockquote><h2 id="特点"><strong>特点</strong></h2><ol><li>输出长度固定：输入长度不固定，输出长度固定（因算法而异，常见的有 MD5、SHA 系列）。</li><li>运算不可逆：已知运算结果的情况下，无法通过通过逆运算得到原始字符串。</li><li>高度离散：输入的微小变化，可导致运算结果差异巨大。</li><li>弱碰撞性：不同输入的散列值可能相同。</li></ol><h2 id="以-MD5-为例">以 MD5 为例</h2><blockquote><p>MD5（Message-Digest Algorithm）是计算机安全领域广泛使用的散列函数（又称哈希算法、摘要算法），主要用来确保消息的完整和一致性。</p><p>常见的应用场景：密码保护、下载文件校验等。</p></blockquote><h2 id="应用场景"><strong>应用场景</strong></h2><ol><li>文件完整性校验：比如从网上下载一个软件，一般网站都会将软件的 md5 值附在网页上，用户下载完软件后，可对下载到本地的软件进行 md5 运算，然后跟网站上的 md5 值进行对比，确保软件的完整性</li><li>密码保护：将 md5 后的密码保存到数据库，而不是保存明文密码，避免拖库等事件发生后，明文密码泄漏。</li><li>防篡改：比如数字证书的防篡改，就用到了摘要算法。（当然还要结合数字签名等手段）</li></ol><h2 id="简单的-md5-运算">简单的 md5 运算</h2><ul><li>hash.digest([encoding])</li></ul><p>计算摘要。encoding 可以是<code>hex</code>、<code>base64</code>或其他。如果声明了 encoding，那么返回字符串。否则，返回 Buffer 实例。注意，调用 hash.digest()后，hash 对象就作废了，再次调用就会报错。</p><ul><li>hash.update(data[, input_encoding])</li></ul><p>input_encoding 可以是<code>utf8</code>、<code>ascii</code>或者其他。如果 data 是字符串，且没有指定 input_encoding，则默认是<code>utf8</code>。注意，hash.update()方法可以调用多次。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FILE_PATH = <span class="string">&#x27;./index.txt&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ENCODING = <span class="string">&#x27;hex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(FILE_PATH);</span><br><span class="line"><span class="keyword">const</span> result = md5.update(content).digest(ENCODING);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// f62091d58876a322864f5a522eb05052</span></span><br></pre></td></tr></table></figure><h2 id="密码保护">密码保护</h2><blockquote><p>前面提到，将明文密码保存到数据库是很不安全的</p><p>最不济也要进行 md5 后进行保存</p><p>比如用户密码是<code>123456</code>，md5 运行后，得到<code>输出：e10adc3949ba59abbe56e057f20f883e</code></p></blockquote><p>这样至少有两个好处：</p><ol><li>防内部攻击：网站开发者也不知道用户的明文密码，避免开发者拿着用户明文密码干坏事，以这种形式来保护用户的隐私</li><li>防外部攻击：如网站被黑客入侵，黑客也只能拿到 md5 后的密码，而不是用户的明文密码，保证了密码的安全性</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cryptPwd = <span class="function">(<span class="params">password</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> md5.update(password).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> cryptPassword = cryptPwd(password);</span><br><span class="line"><span class="built_in">console</span>.log(cryptPassword);</span><br><span class="line"></span><br><span class="line"><span class="comment">// e10adc3949ba59abbe56e057f20f883e</span></span><br></pre></td></tr></table></figure><ul><li>前面提到，通过对用户密码进行 md5 运算来提高安全性。<ul><li>但实际上，这样的安全性是很差的，为什么呢？</li><li>稍微修改下上面的例子，可能你就明白了。相同的明文密码，md5 值也是相同的。</li></ul></li><li>也就是说当攻击者知道算法是 md5，且数据库里存储的密码值为<code>e10adc3949ba59abbe56e057f20f883e</code>时，理论上可以可以猜到，用户的明文密码就是<code>123456</code>。</li><li>事实上，彩虹表就是这么进行暴力破解的：事先将常见明文密码的 md5 值运算好存起来，然后跟网站数据库里存储的密码进行匹配，就能够快速找到用户的明文密码。</li></ul><blockquote><p>那么有什么办法可以进一步提升安全性呢？</p><p>答案是：密码加盐。</p></blockquote><h2 id="密码加盐"><strong>密码加盐</strong></h2><blockquote><p>“加盐”这个词看上去很玄乎，其实原理很简单</p><p>就是在密码特定位置插入特定字符串后，再对修改后的字符串进行 md5 运算。</p></blockquote><p>同样的密码，当“盐”值不一样时，md5 值的差异非常大</p><p>通过密码加盐，可以防止最初级的暴力破解，如果攻击者事先不知道”盐“值，破解的难度就会非常大</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cryptPwd = <span class="function">(<span class="params">password, salt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> saltPassword = <span class="string">`<span class="subst">$&#123;password&#125;</span>:<span class="subst">$&#123;salt&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`原始密码：<span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码：<span class="subst">$&#123;saltPassword&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = md5.update(password).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码的MD5值：<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> salt = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">cryptPwd(password, salt);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始密码：123456</span></span><br><span class="line"><span class="comment">加盐密码：123456:abc</span></span><br><span class="line"><span class="comment">加盐密码的MD5值：e10adc3949ba59abbe56e057f20f883e</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="密码加盐：随机盐值"><strong>密码加盐：随机盐值</strong></h2><blockquote><p>通过密码加盐，密码的安全性已经提高了不少</p><p>但其实上面的例子存在不少问题</p></blockquote><ul><li>假设字符串拼接算法、盐值已外泄，上面的代码至少存在下面问题：</li></ul><ol><li>短盐值：需要穷举的可能性较少，容易暴力破解，一般采用长盐值来解决。</li><li>盐值固定：类似的，攻击者只需要把常用密码+盐值的 hash 值表算出来。</li></ol><ul><li>短盐值自不必说，应该避免<ul><li>对于为什么不应该使用固定盐值，这里需要多解释一下。很多时候，我们的盐值是硬编码到我们的代码里的（比如配置文件），一旦攻击者通过某种手段获知了盐值，那么，只需要针对这串固定的盐值进行暴力穷举就行了</li></ul></li><li>比如上面的代码，当你知道盐值是<code>abc</code>时，立刻就能猜到<code>51011af1892f59e74baf61f3d4389092</code>对应的明文密码是<code>123456</code>。</li></ul><blockquote><p>那么，该怎么优化呢？答案是：随机盐值。</p></blockquote><p>可以看到，密码同样是 123456，由于采用了随机盐值，前后运算得出的结果是不同的</p><p>这样带来的好处是，多个用户，同样的密码，攻击者需要进行多次运算才能够完全破解</p><p>同样是纯数字 3 位短盐值，随机盐值破解所需的运算量 &gt;&gt; 固定盐值</p><blockquote><p>示例代码如下</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getRandomSalt = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random().toString().slice(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cryptPwd = <span class="function">(<span class="params">password, salt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> saltPassword = <span class="string">`<span class="subst">$&#123;password&#125;</span>:<span class="subst">$&#123;salt&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`原始密码：<span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码：<span class="subst">$&#123;saltPassword&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = md5.update(saltPassword).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码的MD5值：<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cryptPwd(password, getRandomSalt());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始密码：123456</span></span><br><span class="line"><span class="comment">加盐密码：123456:126</span></span><br><span class="line"><span class="comment">加盐密码的MD5值：3aeb1848ff63aa32b262bc3f8dd5bd82</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">cryptPwd(password, getRandomSalt());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始密码：123456</span></span><br><span class="line"><span class="comment">加盐密码：123456:232</span></span><br><span class="line"><span class="comment">加盐密码的MD5值：21a427268a5094322146e18e47b135fb</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="HMAC-功能"><strong>HMAC 功能</strong></h2><blockquote><p>HMAC 的全称是 Hash-based Message Authentication Code，也即在 hash 的加盐运算。</p><p>具体到使用的话，跟 hash 模块差不多，选定 hash 算法，指定“盐”即可。</p><p>和上面的例子的区别是一个是手动拼盐值，一个是利用 HMAC 模块</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FILE_PATH = <span class="string">&quot;./index.txt&quot;</span></span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">&#x27;secret&#x27;</span></span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(FILE_PATH,&#123;<span class="attr">encoding</span>:<span class="string">&#x27;utf8&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> hmac = crypto.createHmac(<span class="string">&#x27;sha256&#x27;</span>, SECRET);</span><br><span class="line"></span><br><span class="line">hmac.update(content)</span><br><span class="line"><span class="keyword">const</span> output = hmac.digest(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hmac: <span class="subst">$&#123;output&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hmac: 6f438ef66d3806ae14d6692d9610e55c41ebb4eb3ee73911a4d512bd1cade976</span></span><br></pre></td></tr></table></figure><blockquote><p>注：大文件可流式处理</p></blockquote><h1>加密 / 解密</h1><blockquote><p>加解密主要用到下面两组方法：</p></blockquote><ul><li><p>加密：</p><ul><li>crypto.createCipher(algorithm, password)</li></ul></li><li><p>crypto.createCipheriv(algorithm, key, iv)</p></li><li><p>解密：</p><ul><li>crypto.createDecipher(algorithm, password)</li></ul></li><li><p>crypto.createDecipheriv(algorithm, key, iv)</p></li></ul><h2 id="crypto-createCipher-crypto-createDecipher"><strong>crypto.createCipher / crypto.createDecipher</strong></h2><blockquote><p>先来看下 crypto.createCipher(algorithm, password)，两个参数分别是加密算法、密码</p></blockquote><ul><li><p>algorithm：加密算法，比如<code>aes192</code></p><ul><li>具体有哪些可选的算法，依赖于本地<code>openssl</code>的版本</li></ul></li><li><p>可以通过<code>openssl list-cipher-algorithms</code>命令查看支持哪些算法</p></li><li><p>password：用来生成密钥(key)、初始化向量(IV)</p></li></ul><blockquote><p>crypto.createDecipher(algorithm, password)可以看作 crypto.createCipher(algorithm, password) 逆向操作</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">&#x27;secret&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ALGORITHM = <span class="string">&#x27;aes192&#x27;</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;Hello Node.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">const</span> cipher = crypto.createCipher(ALGORITHM, SECRET)</span><br><span class="line">cipher.update(content)</span><br><span class="line"><span class="keyword">const</span> output = cipher.final(encoding)</span><br><span class="line"><span class="built_in">console</span>.log(output)</span><br><span class="line"><span class="comment">// 944e6e3c21d6eb8568bd6a9716631e、e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">const</span> decipher = crypto.createDecipher(ALGORITHM, SECRET)</span><br><span class="line">decipher.update(output, encoding)</span><br><span class="line"><span class="keyword">const</span> input = decipher.final(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(input)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello Node.js</span></span><br></pre></td></tr></table></figure><h2 id="crypto-createCipheriv-crypto-createDecipheriv"><strong>crypto.createCipheriv / crypto.createDecipheriv</strong></h2><blockquote><p>相对于 crypto.createCipher() 来说，crypto.createCipheriv() 需要提供<code>key</code>和<code>iv</code>，而 crypto.createCipher() 是根据用户提供的 password 算出来的</p><p>key、iv 可以是 Buffer，也可以是 utf8 编码的字符串，这里需要关注的是它们的长度：</p></blockquote><ul><li><p>key：根据选择的算法有关</p><ul><li>比如 aes128、aes192、aes256，长度分别是 128、192、256 位（16、24、32 字节）</li></ul></li><li><p>iv：初始化向量，都是 128 位（16 字节），也可以理解为密码盐的一种</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> key = crypto.randomBytes(<span class="number">192</span> / <span class="number">8</span>)</span><br><span class="line"><span class="keyword">const</span> iv = crypto.randomBytes(<span class="number">128</span> / <span class="number">8</span>)</span><br><span class="line"><span class="keyword">const</span> algorithm = <span class="string">&#x27;aes192&#x27;</span></span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encrypt = <span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cipher = crypto.createCipheriv(algorithm, key, iv)</span><br><span class="line">    cipher.update(text)</span><br><span class="line">    <span class="keyword">return</span> cipher.final(encoding)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrypt = <span class="function">(<span class="params">encrypted</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.createDecipheriv(algorithm, key, iv)</span><br><span class="line">    decipher.update(encrypted, encoding)</span><br><span class="line">    <span class="keyword">return</span> decipher.final(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;Hello Node.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> crypted = encrypt(content)</span><br><span class="line"><span class="built_in">console</span>.log(crypted)</span><br><span class="line"></span><br><span class="line"><span class="comment">// db75f3e9e78fba0401ca82527a0bbd62</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrypted = decrypt(crypted)</span><br><span class="line"><span class="built_in">console</span>.log(decrypted)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello Node.js</span></span><br></pre></td></tr></table></figure><h2 id="数字签名-签名校验"><strong>数字签名</strong> <strong>/ 签名校验</strong></h2><ul><li>假设：<ul><li>服务端原始信息为 M，摘要算法为 Hash，Hash(M)得出的摘要是 H</li><li>公钥为 Pub，私钥为 Piv，非对称加密算法为 Encrypt，非对称解密算法为 Decrypt</li><li>Encrypt(H)得到的结果是 S</li><li>客户端拿到的信息为 M1，利用 Hash(M1)得出的结果是 H1</li></ul></li><li>数字签名的产生、校验步骤分别如下：<ul><li>数字签名的产生步骤：<ul><li>利用摘要算法 Hash 算出 M 的摘要，即 Hash(M) == H</li><li>利用非对称加密算法对摘要进行加密 Encrypt( H, Piv )，得到数字签名 S</li></ul></li><li>数字签名的校验步骤：<ul><li>利用解密算法 D 对数字签名进行解密，即 Decrypt(S) == H</li><li>计算 M1 的摘要 Hash(M1) == H1，对比 H、H1，如果两者相同，则通过校验</li></ul></li></ul></li></ul><p>私钥如何生成不是这里的重点，这里采用网上的服务来生成。</p><p>了解了数字签名产生、校验的原理后，相信下面的代码很容易理解：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> privateKey = fs.readFileSync(<span class="string">&#x27;./private-key.pem&#x27;</span>);  <span class="comment">// 私钥</span></span><br><span class="line"><span class="keyword">const</span> publicKey = fs.readFileSync(<span class="string">&#x27;./public-key.pem&#x27;</span>);  <span class="comment">// 公钥</span></span><br><span class="line"><span class="keyword">const</span> algorithm = <span class="string">&#x27;RSA-SHA256&#x27;</span>;  <span class="comment">// 加密算法 vs 摘要算法</span></span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字签名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sign</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sign = crypto.createSign(algorithm);</span><br><span class="line">    sign.update(text);</span><br><span class="line">    <span class="keyword">return</span> sign.sign(privateKey, encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验签名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">oriContent, signature</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> verifier = crypto.createVerify(algorithm);</span><br><span class="line">    verifier.update(oriContent);</span><br><span class="line">    <span class="keyword">return</span> verifier.verify(publicKey, signature, encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对内容进行签名</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> signature = sign(content);</span><br><span class="line"><span class="built_in">console</span>.log(signature);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验签名，如果通过，返回true</span></span><br><span class="line"><span class="keyword">const</span> verified = verify(content, signature);</span><br><span class="line"><span class="built_in">console</span>.log(verified);</span><br></pre></td></tr></table></figure><h2 id="DH-DiffieHellman">DH(DiffieHellman)</h2><blockquote><p>DiffieHellman：Diffie–Hellman key exchange，缩写为 D-H，是一种安全协议，常用于密钥交换，让通信双方在预先没有对方信息的情况下，通过不安全通信信道，创建一个密钥。这个密钥可以在后续的通信中，作为对称加密的密钥加密传递的信息。</p></blockquote><ul><li>原理解析</li></ul><p>假设客户端、服务端挑选两个素数 a、p（都公开），然后</p><ul><li><p>客户端：选择自然数 Xa，Ya = a^Xa mod p，并将 Ya 发送给服务端；</p></li><li><p>服务端：选择自然数 Xb，Yb = a^Xb mod p，并将 Yb 发送给客户端；</p></li><li><p>客户端：计算 Ka = Yb^Xa mod p</p></li><li><p>服务端：计算 Kb = Ya^Xb mod p</p></li></ul><blockquote><p>Ka = Yb^Xa mod p</p><p>= (a^Xb mod p)^Xa mod p</p><p>= a^(Xb * Xa) mod p</p><p>= (a^Xa mod p)^Xb mod p</p><p>= Ya^Xb mod p</p><p>= Kb</p><p>可以看到，尽管客户端、服务端彼此不知道对方的 Xa、Xb，但算出了相等的 secret</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> primeLength = <span class="number">1024</span>;  <span class="comment">// 素数p的长度</span></span><br><span class="line"><span class="keyword">const</span> generator = <span class="number">5</span>;  <span class="comment">// 素数a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建客户端的DH实例</span></span><br><span class="line"><span class="keyword">const</span> client = crypto.createDiffieHellman(primeLength, generator);</span><br><span class="line"><span class="comment">// 产生公、私钥对，Ya = a^Xa mod p</span></span><br><span class="line"><span class="keyword">const</span> clientKey = client.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务端的DH实例，采用跟客户端相同的素数a、p</span></span><br><span class="line"><span class="keyword">const</span> server = crypto.createDiffieHellman(client.getPrime(), client.getGenerator());</span><br><span class="line"><span class="comment">// 产生公、私钥对，Yb = a^Xb mod p</span></span><br><span class="line"><span class="keyword">const</span> serverKey = server.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 Ka = Yb^Xa mod p</span></span><br><span class="line"><span class="keyword">const</span> clientSecret = client.computeSecret(server.getPublicKey());</span><br><span class="line"><span class="comment">// 计算 Kb = Ya^Xb mod p</span></span><br><span class="line"><span class="keyword">const</span> serverSecret = server.computeSecret(client.getPublicKey());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于素数p是动态生成的，所以每次打印都不一样</span></span><br><span class="line"><span class="comment">// 但是 clientSecret === serverSecret</span></span><br><span class="line"><span class="built_in">console</span>.log(clientSecret.toString(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(serverSecret.toString(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="comment">// 39edfedad4f1be731977436936ca844e50ebc90953ad208c71d7f2dc1772409962ec3eb90eaf99db5948f089e1d4951f148bd7ff76c18b53ff6be32f267fc54535928ce4acf15d923cfd0caec45db95b206e7636128210ea6813a20fb09cbfb06214b2f488716fea32788023d98cb4cb7fe39b68bd3563b3b34257e37f6b7fb7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 39edfedad4f1be731977436936ca844e50ebc90953ad208c71d7f2dc1772409962ec3eb90eaf99db5948f089e1d4951f148bd7ff76c18b53ff6be32f267fc54535928ce4acf15d923cfd0caec45db95b206e7636128210ea6813a20fb09cbfb06214b2f488716fea32788023d98cb4cb7fe39b68bd3563b3b34257e37f6b7fb7</span></span><br></pre></td></tr></table></figure><h2 id="ECDH-Elliptic-Curve-Diffie-Hellma">ECDH(Elliptic Curve Diffie-Hellma)</h2><blockquote><p>ECDH 和 DH 原理类似，都是安全密钥协商协议。</p><p>相对于 DH 协议，结合椭圆曲线密码学 ECC 加速，运算更节省 CPU 资源</p></blockquote><ul><li>ECDH（<strong>Elliptic Curve Diffie-Hellman</strong> ）原理如下</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202230722255.(null)" alt="img"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> G = <span class="string">&#x27;secp521r1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = crypto.createECDH(G);</span><br><span class="line"><span class="keyword">const</span> serverKey = server.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = crypto.createECDH(G);</span><br><span class="line"><span class="keyword">const</span> clientKey = client.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serverSecret = server.computeSecret(clientKey);</span><br><span class="line"><span class="keyword">const</span> clientSecret = client.computeSecret(serverKey);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(serverSecret.toString(encoding));</span><br><span class="line"><span class="built_in">console</span>.log(clientSecret.toString(encoding));</span><br><span class="line"><span class="comment">// 01c418be1b479f936397d4c1653ad77fa28fade67ff058dc18264a72bd1fc208ea6cac4dad996fda55bf271e84f0faef085173257b67bf21f95b09acee4d0a204517</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 01c418be1b479f936397d4c1653ad77fa28fade67ff058dc18264a72bd1fc208ea6cac4dad996fda55bf271e84f0faef085173257b67bf21f95b09acee4d0a204517</span></span><br></pre></td></tr></table></figure><h2 id="ECDHE-Elliptic-Curve-Diffie-Hellma-Ephemeral">ECDHE(Elliptic Curve Diffie-Hellma Ephemeral)</h2><blockquote><p>普通的 ECDH 算法也存在一定缺陷，比如密钥协商的时候有一方的私钥总是一样的，一般都是 Server 方固定，Client 方私钥随机生成。随着时间的延长，黑客可以截获到海量的密钥协商过程（有些数据是公开的），黑客就可以依据这些数据暴力破解出 Server 的私钥，然后就可以计算出会话密钥了，加密的数据也会随之被破解。固定一方的私钥会有被破解的风险，那么就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个算法就是 ECDH 的增强版：ECDHE， E 全称是 Ephemeral（临时性的）。</p></blockquote><h1>扩展</h1><blockquote><p>学习这块儿知识的同时也学习了很多密码学相关知识，发现越挖越深快陷进去了 😂，感兴趣的同学可以继续展开看看相关加密算法和他们之间的区别以及应用场景，例如：</p></blockquote><ul><li>非对称加密 DSA、RSA、DH、DHE、ECDHE</li><li>对称加密 AES、DES</li></ul><blockquote><p><a href="https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg">RSA 算法原理（二） - 阮一峰的网络日志</a></p><p><a href="https://www.cnblogs.com/xiaolincoding/p/14318338.html">图解 ECDHE 密钥交换算法 - 小林 coding</a></p><p>资料加密标准(DES) - 维基百科](<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96">https://zh.wikipedia.org/wiki/資料加密標準</a>)</p><p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">高级加密标准(AES) - 维基百科</a></p></blockquote><h1><strong>相关术语</strong></h1><p>SPKAC：Signed Public Key and Challenge</p><p>MD5：Message-Digest Algorithm 5，信息-摘要算法。</p><p>SHA：Secure Hash Algorithm，安全散列算法。</p><p>HMAC：Hash-based Message Authentication Code，密钥相关的哈希运算消息认证码。</p><p>对称加密：比如 AES、DES</p><p>非对称加密：比如 RSA、DSA</p><p>AES：Advanced Encryption Standard（高级加密标准），密钥长度可以是 128、192 和 256 位。</p><p>DES：Data Encryption Standard，数据加密标准，对称密钥加密算法（现在认为不安全）。</p><p>DiffieHellman：Diffie–Hellman key exchange，缩写为 D-H，是一种安全协议，让通信双方在预先没有对方信息的情况下，通过不安全通信信道，创建一个密钥。这个密钥可以在后续的通信中，作为对称加密的密钥加密传递的信息。（备注，是使用协议的发明者命名）</p><p><strong>密钥交换算法</strong></p><p>常见的密钥交换算法有 RSA，ECDHE，DH，DHE 等算法。它们的特性如下：</p><ul><li><p>RSA：算法实现简单，诞生于 1977 年，历史悠久，经过了长时间的破解测试，安全性高。缺点就是需要比较大的素数（目前常用的是 2048 位）来保证安全强度，很消耗 CPU 运算资源。RSA 是目前唯一一个既能用于密钥交换又能用于证书签名的算法。</p></li><li><p>DH：diffie-hellman 密钥交换算法，诞生时间比较早（1977 年），但是 1999 年才公开。缺点是比较消耗 CPU 性能。</p></li><li><p>ECDHE：使用椭圆曲线（ECC）的 DH 算法，优点是能用较小的素数（256 位）实现 RSA 相同的安全等级。缺点是算法实现复杂，用于密钥交换的历史不长，没有经过长时间的安全攻击测试。</p></li><li><p>ECDH：不支持 PFS，安全性低，同时无法实现 false start。</p></li><li><p>DHE：不支持 ECC。非常消耗 CPU 资源 。</p></li></ul><p>建议优先支持 RSA 和 ECDH_RSA 密钥交换算法。原因是：</p><ul><li><p>ECDHE 支持 ECC 加速，计算速度更快。支持 PFS，更加安全。支持 false start，用户访问速度更快。</p></li><li><p>目前还有至少 20% 以上的客户端不支持 ECDHE，我们推荐使用 RSA 而不是 DH 或者 DHE，因为 DH 系列算法非常消耗 CPU（相当于要做两次 RSA 计算）。</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;互联网时代，网络上的数据量每天都在以惊人的速度增长。同时，各类网络安全问题层出不穷。在信息安全重要性日益凸显的今天，作为一名开发者，需要加强对安全的认识，并通过技术手段增强服务的安全性。crypto 模块的目的是为了提供通用的加密和哈希算法。用纯 </summary>
      
    
    
    
    <category term="Back End" scheme="https://lebronchao.com/categories/Back-End/"/>
    
    
    <category term="JavaScript" scheme="https://lebronchao.com/tags/JavaScript/"/>
    
    <category term="Node" scheme="https://lebronchao.com/tags/Node/"/>
    
    <category term="服务端" scheme="https://lebronchao.com/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>摄影 | 广州行</title>
    <link href="https://lebronchao.com/2021/12/11/%E6%91%84%E5%BD%B1-%E5%B9%BF%E5%B7%9E%E8%A1%8C/"/>
    <id>https://lebronchao.com/2021/12/11/%E6%91%84%E5%BD%B1-%E5%B9%BF%E5%B7%9E%E8%A1%8C/</id>
    <published>2021-12-11T07:51:35.000Z</published>
    <updated>2021-12-11T07:51:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机身：IPhone 13 Pro Max<br>镜头：IPhone 13 Pro Max<br>出镜：无<br>地点：广州</p></blockquote><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9240.JPG" alt="IMG_9240"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9244.JPG" alt="IMG_9244"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9246.JPG" alt="IMG_9246"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9257.JPG" alt="IMG_9257"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9265.JPG" alt="IMG_9265"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9271.JPG" alt="IMG_9271"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9290.JPG" alt="IMG_9290"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9296.JPG" alt="IMG_9296"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9306.JPG" alt="IMG_9306"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9300.JPG" alt="IMG_9300"></p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9305.JPG" alt="IMG_9305"></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机身：IPhone 13 Pro Max&lt;br&gt;
镜头：IPhone 13 Pro Max&lt;br&gt;
出镜：无&lt;br&gt;
地点：广州&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;justified-gallery&quot;&gt;&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="摄影" scheme="https://lebronchao.com/categories/%E6%91%84%E5%BD%B1/"/>
    
    
    <category term="摄影" scheme="https://lebronchao.com/tags/%E6%91%84%E5%BD%B1/"/>
    
    <category term="风光" scheme="https://lebronchao.com/tags/%E9%A3%8E%E5%85%89/"/>
    
    <category term="广州" scheme="https://lebronchao.com/tags/%E5%B9%BF%E5%B7%9E/"/>
    
  </entry>
  
  <entry>
    <title>带你重新认识Node</title>
    <link href="https://lebronchao.com/2021/12/11/%E5%B8%A6%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Node/"/>
    <id>https://lebronchao.com/2021/12/11/%E5%B8%A6%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Node/</id>
    <published>2021-12-11T07:38:45.000Z</published>
    <updated>2021-12-11T07:38:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1>最初做 Node 的目的是什么？</h1><blockquote><p>Node 作者 Ryan Dahl：</p><p>基于 V8 创建一个轻量级的高性能 Web 服务器并提供一套库</p></blockquote><h1>为什么是 JavaScript？</h1><blockquote><p>Ryan Dahl 是一名资深的 C/C++程序员，创造出 Node 之前主要工作是围绕 Web 高性能服务器进行的</p><p>他发现 Web 高性能服务器的两个要点：</p></blockquote><ul><li>事件驱动</li><li>非阻塞 I / O</li></ul><p>Ryan Dahl 也曾评估过使用 C、Lua、Haskell、Ruby 等语言作为备选实现，得出以下结论：</p><ul><li>C 的开发门槛高，可以预见不会有太多的开发者能将它用于业务开发</li><li>Ryan Dahl 觉得自己还不足够玩转 Haskell，所以舍弃它</li><li>Lua 自身已经含有很多阻塞 I / O 库，为其构建非阻塞 I / O 库不能改变开发者使用习惯</li><li>Ruby 的虚拟机性能不佳</li></ul><p>JavaScript 的优势：</p><ul><li>开发门槛低</li><li>在后端领域没有历史包袱</li><li>第二次浏览器大战渐渐分出高下，Chrome 浏览器的 JavaScript 引擎 V8 摘得性能第一的桂冠</li></ul><h1>Node 给 JavaScript 带来的意义</h1><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225039105.(null)" alt="img"></p><blockquote><p>除了 HTML、Webkit 和显卡这些 UI 相关技术没有支持外，Node 的结构与 Chrome 十分相似。他们都是基于事件驱动的异步架构：</p></blockquote><ul><li>浏览器通过事件驱动来服务界面上的交互</li><li>Node 通过事件驱动来服务 I / O</li></ul><blockquote><p>在 Node 中，JavaScript 还被赋予了新的能力：</p></blockquote><ul><li>随心所欲地访问本地文件</li><li>搭建 WebSocket 服务端</li><li>连接数据库，进行业务研发</li><li>像 Web Worker 一样玩转多进程</li></ul><blockquote><p>Node 使 JavaScript 可以运行在不同的地方，不再限制在浏览器中、DOM 树打交道。如果 HTTP 协议是水平面，Node 就是浏览器在协议栈另一边的倒影。</p><p>Node 不处理 UI，但用与浏览器相同的机制和原理运行，打破了 JavaScript 只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低前后端转换所需要的上下文代价。</p></blockquote><h1>Node 的特点</h1><h2 id="异步-I-O">异步 I / O</h2><ul><li>以读取文件为例</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225046783.(null)" alt="img"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;/path&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件完成&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;发起读取文件&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>熟悉的用户必知道，“读取文件完成”是在“发起读取文件”之后输出的</p><p>fs.readFile 后的代码是被立即执行的，而“读取文件完成”的执行时间是不被预期的</p><p>只知道它将在这个异步操作后执行，但并不知道具体的时间点</p><p>异步调用中对于结果值的捕获是符合“Don’t call me, I will call you”原则的</p><p>这也是注重结果，不关心过程的一种表现</p></blockquote><p>Node 中，绝大多数操作都以异步的方式进行调用，Ryan Dahl 排除万难，在底层构建了很多异步 I / O 的 API，从文件读取到网络请求等。使开发者很已从语言层面很自然地进行并行 I / O 操作，在每个调用之间无需等待之前的 I / O 调用结束，在编程模型上可以极大提升效率</p><blockquote><p><strong>注：异步 I / O 机制将在下文中详细阐述</strong></p></blockquote><h2 id="事件与回调函数">事件与回调函数</h2><p><strong>事件</strong></p><p>随着 Web2.0 的到来，JavaScript 在前端担任了更多的职责，时间也得到了广泛的应用。将前端浏览器中广泛应用且成熟的事件与回到函数引入后端，配合异步 I / O ，可以很好地将事件发生的时间点暴露给业务逻辑。</p><ul><li>服务端例子</li></ul><blockquote><p>对于服务器绑定了 request 事件</p></blockquote><blockquote><p>对于请求对象，绑定了 data 和 end 事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 侦听服务器的request事件</span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> req.setEncoding(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"> <span class="comment">// 侦听请求的data事件</span></span><br><span class="line"> req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>) </span>&#123;</span><br><span class="line"> postData += trunk;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 侦听请求的end事件</span></span><br><span class="line"> req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> res.end(postData);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动完成&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>前端例子</li></ul><blockquote><p>发出请求后，只需关心请求成功时执行相应的业务逻辑即可</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line"> url: <span class="string">&#x27;/url&#x27;</span>,</span><br><span class="line"> method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line"> data: &#123;&#125;,</span><br><span class="line"> success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// success事件</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是一个问题，后续也出现了一系列异步编程解决方案:</p></blockquote><ul><li>事件发布/订阅模式</li><li>Promise、async / await</li><li>流程控制库</li></ul><p><strong>回调函数</strong></p><ul><li>Node 除了异步和事件外，回调函数也是一大特色</li><li>纵观下来，回调函数也是最好的接收异步调用返回数据的方式<ul><li>但是这种编程方式对于很多习惯同步思路编程的人来说，也许是十分不习惯的</li><li>代码的编写顺序与执行顺序并无关系，这对他们可能造成阅读上的障碍</li></ul></li><li>在流程控制方面，因为穿插了异步方法和回调函数，与常规的同步方式相比变得不那么一目了然了<ul><li>转变为异步编程思维后，通过对业务的划分和对事件的提炼，在流程控制方面处理业务的复杂度是与同步方式实际上是一致的</li></ul></li></ul><h2 id="单线程">单线程</h2><blockquote><p>Node 保持了 JavaScript 在浏览器中单线程的特点</p><p>JavaScript 与其他线程是无法共享任何状态的，最大的好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销</p></blockquote><ul><li>单线程的缺点<ul><li>无法利用多核 CPU</li><li>错误会引起整个应用退出，健壮性较差</li><li>大量计算占用 CPU 导致无法继续调用异步 I / O</li></ul></li><li>后续也推出了 child_process 和 cluster 模块较好地缓解了以上缺点</li></ul><h2 id="跨平台">跨平台</h2><blockquote><p>起初 Node 只能在 Linux 平台上运行，如果想在 Windows 平台上学习和使用 Node，则必须通过 Cygwin / MinGW，后微软投入通过基于 libuv 实现跨平台架构</p></blockquote><ul><li>libuv</li></ul><blockquote><p>在操作系统与 Node 上层模块系统之间构建了一层平台架构</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225633500.(null)" alt="img"></p><blockquote><p>通过良好的架构，Node 的第三方 C++模块也可以借助 libuv 实现跨平台</p></blockquote><h1>Node 模块机制 - CommonJS</h1><blockquote><p>背景：</p><p>在其他高级语言中，Java 有类文件，Python 有 import 机制，Ruby 有 require，PHP 有 include 和 require。而 JavaScript 通过 script 标签引入代码的方式显得杂乱无章，。人们不得不用命名空间等方式人为地约束代码，以达到安全和易用的目的。</p><p>直到后来出现了 CommonJS…</p></blockquote><h2 id="愿景">愿景</h2><blockquote><p>希望 JavaScript 能欧在任何地方运行</p></blockquote><h2 id="出发点">出发点</h2><p>对于 JavaScript 自身而言，它的规范依然是薄弱的，还有以下缺陷：</p><ul><li>没有模块系统</li><li>标准库较少<ul><li>ECMAScript 仅定义了部分核心库</li><li>对于文件系统 I / O 流等常见需求没有标准 API</li></ul></li><li>没有标准接口<ul><li>在 JavaScript 中，几乎没有定义过如 Web 服务器或者数据库之类的标准统一接口</li></ul></li><li>缺乏包管理系统<ul><li>导致 JavaScript 应用中基本没有自动加载和安装以来的能力</li></ul></li></ul><p>CommonJS 的提出，主要是为了弥补当前 JavaScript 没有标准的缺陷，以达到像 Python、Ruby 和 Java 具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段，希望可以利用 JavaScript 开发：</p><ul><li>服务端 JavaScript 程序</li><li>命令行工具</li><li>桌面图形界面应用程序</li><li>混合应用</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225637966.(null)" alt="img"></p><p>CommonJS 规范涵盖了：</p><ul><li>模块</li><li>二进制</li><li>Buffer</li><li>字符集编码</li><li>I / O 流</li><li>进程环境</li><li>文件系统</li><li>套接字</li><li>单元测试</li><li>Web 服务器网关接口</li><li>包管理</li></ul><blockquote><p>Node 与浏览器以及 W3C 组织、CommonJS 组织、ECMAScript 之间的关系，共同构成了一个繁荣的生态系统</p></blockquote><h2 id="模块规范">模块规范</h2><ul><li>模块定义</li></ul><blockquote><p>上下文提供了 exports 对象用于导出当前模块的方法或者变量，并且它是导出的唯一出口</p><p>在模块中，还存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性</p><p>在 Node 中，一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="built_in">exports</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模块引用</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = math.add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><p>在 CommonJS 规范中，存在 require 方法，这个方法接受模块标识，以此引入一个模块的 API 到当前上下文中</p></blockquote><ul><li>模块标识</li></ul><p>模块标识就是传递给 require 方法的参数，可以是：</p><ul><li>如何小驼峰命名的字符串</li><li>以./ 、…/ 开头的相对路径 or 绝对路径</li><li>可以没有文件名后缀.js</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225641404.(null)" alt="img"></p><blockquote><p>模块的定义十分简单，接口也十分简洁</p></blockquote><blockquote><p>每个模块具有独立的空间，它们互不干扰，在引用时也显得干净利落</p></blockquote><ul><li>意义：</li></ul><blockquote><p>将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖</p></blockquote><h2 id="模块实现">模块实现</h2><blockquote><p>在 Node 引入模块，需要经历以下三个步骤</p></blockquote><ul><li>路径分析</li><li>文件定位</li><li>编译执行</li></ul><p>Node 中模块分为两类：</p><ul><li>核心模块</li></ul><blockquote><p>编译过程中，编译进了二进制执行文件</p><p>在 Node 进程启动时，部分核心模块就直接被加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略，并且在路径分析中优先判断，所以它的加载速度是最快的。</p></blockquote><ul><li>用户编写的文件模块</li></ul><blockquote><p>运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢</p></blockquote><h3 id="优先从缓存加载">优先从缓存加载</h3><blockquote><p>与浏览器会缓存静态脚本文件以提高性能一样，Node 对引入过的模块都会进行二次缓存，以减少二次引入时的开销。不同点在于:</p></blockquote><ul><li>浏览器仅缓存文件</li><li>Node 缓存的是编译和执行之后的对象</li></ul><blockquote><p>无论核心模块还是文件模块，require 方法对相同模块的二次加载都一律采用缓存优先的方式</p></blockquote><h3 id="路径分析和文件定位">路径分析和文件定位</h3><p><strong>标识符分析（路径）</strong></p><p>前面说到过，require 方法接受一个参数作为标识符，分为以下几类：</p><ul><li>核心模块</li></ul><blockquote><p>优先级仅次于缓存加载，在 Node 的源代码编译过程中已编译为二进制代码，加载过程最快</p><p><strong>注：加载一个与核心模块标识符相同的自定义模块是不会成功的，只能通过选择不同的标识符 / 换用路径的方式实现</strong></p></blockquote><ul><li>路径形式的文件模块</li></ul><blockquote><p>以 ./ 、…/ 开头的标识符都被当做文件模块处理</p><p>require 方法会将路径转为真实路径，并以真实路径为索引，将编译执行后的结果存放到缓存中，以使二次加载更快</p><p>文件模块给 Node 指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度仅慢于核心模块</p></blockquote><ul><li>自定义模块</li></ul><blockquote><p>是一种特殊的文件模块，是一个文件或者包的形式</p><p>这类模块的查找是最费时的，也是最慢的一种</p></blockquote><p>先介绍一下模块路径这个概念，也是定位文件模块时制定的查找策略，具体表现为一个路径组成的数组</p><ul><li><code>console.log(module.path)</code></li><li>你可以得到一个路径数组</li></ul><p>[‘/home/bytedance/reasearch/node_modules’,</p><p>‘/home/bytedance/node_modules’,</p><p>‘home/node_module’, /node_modules’]</p><p>可以看出规则如下：</p><ul><li>当前文件目录下的 node_modules 目录</li><li>父目录下的 node_modules 目录</li><li>父目录的父目录下的 node_modules 目录</li><li>沿路径向上逐级递归，直到根目录下的 node_modules 目录</li></ul><blockquote><p>它的生成方式与 JavaScript 原型链 / 作用域链的查找方式十分类似</p><p>在加载过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件</p><p>文件路径越深，模块查找耗时会越多，这是自定义模块的加载速度最慢的原因</p></blockquote><p><strong>文件定位</strong></p><ul><li>文件扩展名分析</li></ul><blockquote><p>require 分析标识符会出现不包含文件扩展名的情况</p><p>会按.js、.json、.node 的次序补足扩展名，一次尝试</p><p>过程中，需调用 fs 模块同步阻塞地判断文件是否存在，Node 单线程因此会引起性能问题</p><p>如果是.node / .json 文件带上扩展名能加快点速度，配合缓存机制，可大幅缓解 Node 单线程阻塞调用的缺陷</p></blockquote><ul><li>目录分析和包</li></ul><blockquote><p>分析标识符的过程中可能没有找到文件，却得到一个目录，则会将目录当做一个包来处理</p><p>通过解析 package.json 文件对应该包的 main 属性指定的文件名</p><p>如果 main 相应文件解析错误 / 没有 package.json 文件，node 会将 index 作为文件名</p><p>一次查找 index.js index.json index.node</p><p>该目录没有定位成功则进行下一个模块路径进行查找</p><p>直到模块路径数组都被遍历完依然没有查找到目标文件则抛出异常</p></blockquote><h3 id="模块编译">模块编译</h3><blockquote><p>在 Node 中，每个文件模块都是一个对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.id = id;</span><br><span class="line"> <span class="built_in">this</span>.exports = &#123;&#125;;</span><br><span class="line"> <span class="built_in">this</span>.parent = parent;</span><br><span class="line"> <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">     parent.children.push(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">this</span>.filename = <span class="literal">null</span>;</span><br><span class="line"> <span class="built_in">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line"> <span class="built_in">this</span>.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>js 文件<ul><li>通过 fs 模块同步读取文件后编译执行</li></ul></li><li>node 文件<ul><li>这是用 C/C++编写的扩展文件，通过 dlopen 方法加在最后编译生成的文件</li></ul></li><li>json 文件<ul><li>通过 fs 模块同步读取文件后，JSON.parse 解析返回的结果</li></ul></li><li>其他<ul><li>都被当作 js 文件载入</li></ul></li></ul><blockquote><p>每一个编译成功的模块都会将其文件路径作为索引存在 Module.cache 对象上，以提高二次引入的性能</p></blockquote><h1>包与 NPM</h1><blockquote><p>Node 组织了自身核心模块，也使得第三方文件模块可以有序地编写和使用</p><p>但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用</p><p>而在模块之外，包和 NPM 则是将模块联系起来的一种机制</p><p>一定程度上解决了变量依赖、依赖关系等代码组织性问题</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225646448.(null)" alt="img"></p><h2 id="包结构">包结构</h2><blockquote><p>包实际上是一个存档文件，即一个目录直接打包为一个.zip/tar.gz 格式的文件，安装后解压还原为目录</p></blockquote><ul><li>符合 CommonJS 规范的包目录应该包含如下文件<ul><li>package.json 包描述文件</li><li>bin 用于存放可执行二进制文件</li><li>lib 用于存放 JavaScript 代码的目录</li><li>doc 用于存放文档的目录</li><li>test 用于存放单元测试用例的代码</li></ul></li></ul><h2 id="包描述文件">包描述文件</h2><blockquote><p>package.json</p></blockquote><p>CommonJS 为 package.json 定义了如下一些必须的字段</p><ul><li>name 包名</li><li>description 包简介</li><li>version 版本号</li><li>keywords 关键词数组，用于做 npm 搜索</li><li>maintainers 包维护者列表</li><li>contributors 贡献者列表</li><li>bugs 一个可以反馈 bug 的网页地址 / 邮件地址</li><li>licenses 许可证列表</li><li>repositories 托管源代码的位置列表</li><li>dependencies 使用当前包所需要依赖的包</li><li>homepage 当前包的网站地址</li><li>os 操作系统支持列表<ul><li>aix、freebsd、linux、macos、solaris、vxworks、windows</li></ul></li><li>cpu CPU 架构的支持列表<ul><li>arm、mips、ppc、sparc、x86、x86_64</li></ul></li><li>builtin 标志当前包是否是内建在底层系统的标准组件</li><li>implements 实现规范的列表</li><li>scripts 脚本说明对象</li></ul><blockquote><p>包规范的定义可以帮助 Node 解决依赖包安装的问题，而 NPM 正是基于该规范进行了实现</p></blockquote><h2 id="NPM-常用功能">NPM 常用功能</h2><blockquote><p>CommonJS 包规范是理论，NPM 是其中一种实践</p><p>NPM 于 Node，相当于 gem 于 Ruby，pear 于 PHP</p><p>帮助完成了第三方模块的发布、安装和依赖等</p></blockquote><ol><li>查看帮助</li></ol><ul><li>查看版本 <code>npm -v</code></li><li>查看命令 <code>npm</code></li></ul><ol start="2"><li>安装依赖包</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &#123;packageName&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行该命令后，NPM 会在当前目录下创建 node_modules 目录下创建包目录，接着将相应的包解压到这个目录下</p></blockquote><ul><li>全局安装模式</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &#123;packageName&#125; -g</span><br></pre></td></tr></table></figure><blockquote><p>全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任何地方 reuqire 它</p><p>全局模式这个成为并不精确，-g 实际上是将一个包安装为全局可用的执行命令</p><p>它根据包描述文件中的 bin 字段配置，将实际脚本链接到与 Node 可执行文件相同的路径下</p></blockquote><ul><li>从本地安装</li></ul><blockquote><p>对于一些没有发布到 NPM 上的包，或者因为网络原因无法直接安装的包</p><p>可以通过将包下按在到本地，然后本地安装</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &lt;tarball file&gt;</span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install folder&gt;</span><br></pre></td></tr></table></figure><ul><li>从非官方源安装</li></ul><blockquote><p>如果不能通过官方源安装，可以通过镜像源安装</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --registry=&#123;urlResource&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果使用过程中几乎全使用镜像源，可以指定默认源</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry &#123;urlResource&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>NPM 钩子命令</li></ol><blockquote><p>package.json 中 scripts 字段的提出就是让包在安装或者卸载等过程中提供钩子机制</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;preinstall&quot;</span>: <span class="string">&quot;preinstall.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;install&quot;</span>: <span class="string">&quot;install.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uninstall&quot;</span>: <span class="string">&quot;uninstall.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;test.js&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Install<ul><li>在以上字段执行<code>npm install &lt;package&gt;</code>时，preinstall 指向的脚本会被加载执行，然后 install 指向的脚本会被执行</li></ul></li><li>Uninstall<ul><li>执行<code>npm uninstall &lt;package&gt;</code>时，uninstall 指向的脚本也许会做一些清理工作</li></ul></li><li>Test<ul><li>执行<code>npm test</code>将会运行 test 指向的脚本，一个优秀的包应当包含测试用例，并在 package.json 文件正配置好运行测试的命令，方便用户运行测试用例，以便检验包是否稳定可靠</li></ul></li></ul><h2 id="局域-NPM">局域 NPM</h2><ul><li>背景</li></ul><p>企业的限制在于，一方面需要享受到模块开发带来的低耦合和项目组织上的好处，另一方面却要考虑模块保密性的问题。所以，通过 NPM 共享和发布存在潜在的风险。</p><ul><li>解决方案</li></ul><p>为了同时能够享受到 NPM 上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是企业搭建自己的 NPM 仓库，NPM 无论是它的服务端和客户端都是开源的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225651308.(null)" alt="img"></p><blockquote><p>局域 NPM 仓库的搭建方法与搭建镜像站的方式几乎一样，与镜像仓库不同的地方在于可以选择不同步官方源仓库中的包</p></blockquote><ul><li>作用<ul><li>私有的可重用模块可以打包到局域 NPM 仓库中，这样可以保持更新的中心化，不至于让各个小项目维护相同功能的模块</li><li>杜绝通过复制粘贴实现代码共享的行为</li></ul></li></ul><h1>异步 I / O</h1><h2 id="为什么需要异步-I-O-？">为什么需要异步 I / O ？</h2><ul><li>用户体验</li></ul><blockquote><p>浏览器中 JavaScript 在单线程上执行，还和 UI 渲染共用一个线程</p><p>《高性能 JavaScript》曾总结过，如果脚本执行的时间超过 100ms 用户就会感到页面卡顿</p><p>如果网页临时需要获取一个网络资源，通过同步的方式获取，JS 需要等资源完全从服务器获取后才能继续执行，这期间 UI 将停顿，不响应用户的交互行为。可以想象，这样的用户体验将会多差。</p><p>而采用异步请求，JavaScript 和 UI 的执行都不会处于等待状态，给用户一个鲜活的页面</p><p>I / O 是昂贵的，分布式 I / O 是更昂贵的</p><p>只有后端能够快速响应资源，才能让前端体验变好</p></blockquote><ul><li>资源分配</li></ul><blockquote><p>计算机在发展过程中将组件进行了抽象，分为了 I / O 设备和计算设备</p><p>假设业务场景有一组互不相关的任务需要完成，主流方法有两种：</p></blockquote><ol><li>多线程并行完成</li></ol><p>多线程的代价在于创建线程和执行线程上下文切换的开销较大。</p><p>在复杂的业务中经常面临锁、状态同步等问题。但是多线程在多核 CPU 上能够有效提升 CPU 利用率</p><ol start="2"><li>单线程串行依次执行</li></ol><p>单线程顺序执行任务比较符合编程人员按顺序思考的思维方式，依然是主流的编程方式</p><p>串行执行的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞</p><p>在计算机资源中，通常 I / O 与 CPU 计算是可以并行的，同步编程模型导致的问题是，I / O 的进行会让后续任务等待，这造成资源不能更好地被利用</p><ol start="3"><li>Node 在两者之间给出了它的答案</li></ol><blockquote><p>利用单线程，远离多线程死锁、状态同步等问题；</p><p>利用异步 I / O，让单线程可以远离阻塞，更好地使用 CPU</p><p>为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效地利用 CPU 和 I / O</p><p>异步 I / O 的提出是期望 I / O 的调用不再阻塞后续运算，将原有等待 I / O 完成的这段时间分配给其余需要的业务去执行</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225655015.(null)" alt="img"></p><h2 id="异步-I-O-现状">异步 I / O 现状</h2><h3 id="异步-I-O-与非阻塞-I-O">异步 I / O 与非阻塞 I / O</h3><blockquote><p>操作系统内核对于 I / O 方式只有两种：阻塞与非阻塞</p><p>在调用阻塞 I / O 时，应用程序需要等待 I / O 完成才返回结果</p><p>特点：调用之后一定要等到系统内核层面完成所有操作后调用才结束</p><p>例子：系统内核在完成磁盘寻道、读取数据、复制数据到内幕才能中之后，这个调用才结束》</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202224957133.(null)" alt="img"></p><blockquote><p>非阻塞 I / O 与阻塞 I / O 的差别为调用之后会立即返回</p><p>非阻塞 I / O 返回之后，CPU 的时间片可以用来处理其他事务，此时的性能提升是明显的</p><p>存在的问题：</p></blockquote><ul><li>由于完整的 I / O 没有完成，立即返回的并不是业务层期望的数据而仅仅是当前调用的状态</li><li>为了获取完整的数据，应用程序需要重复调用 I / O 操作来确认是否完成，称之为“轮询”。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225703091.(null)" alt="img"></p><h3 id="主要的轮询技术">主要的轮询技术</h3><ul><li>read</li></ul><blockquote><p>它是最原始、性能最低的一种，通过重复调用检查 I / O 的状态来完成数据的完整读取</p><p>在得到最终数据前，CPU 一直耗用在等待上</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225706724.(null)" alt="img"></p><ul><li>select</li></ul><blockquote><p>它是在 read 的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断</p><p>限制：它采用一个 1024 长度的数组来存储状态，最多可以同时检查 1024 个文件描述符</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225711576.(null)" alt="img"></p><ul><li>poll</li></ul><blockquote><p>较 select 有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查</p><p>文件描述符较多时，它的性能还是十分低下的</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225714602.(null)" alt="img"></p><ul><li>epoll</li></ul><blockquote><p>该方案是 Linux 下效率最高的 I / O 事件通知机制，在进入轮询的时候如果没有检查到 I / O 事件，将会进行休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费 CPU，执行效率较高</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225718042.(null)" alt="img"></p><h3 id="理想的非阻塞异步-I-O">理想的非阻塞异步 I / O</h3><blockquote><p>尽管 epoll 已经利用了时间来降低 CPU 的耗用，但是休眠期间 CPU 几乎是限制的，对于当前线程而言利用率不够</p></blockquote><p>完美的异步 I / O 应该是应用程序发起非阻塞调用，无需通过遍历或者时间唤醒等方式轮询</p><p>可以直接处理下一个任务，只需在 I / O 完成后通过信号或回调将数据传递给应用程序即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225721234.(null)" alt="img"></p><p>Linux 下存在原生提供的一种异步 I / O 方式（AIO）就是通过信号或者回调来传递数据的</p><p>缺点：</p><ul><li>仅 Linux 下有</li><li>仅支持 I / O 中的 O_DIRECT 方式读取，导致无法利用系统缓存</li></ul><blockquote><p>注：<a href="https://blog.csdn.net/AXW2013/article/details/70242228">关于 O_DIRECT</a></p></blockquote><h3 id="现实的异步-I-O">现实的异步 I / O</h3><blockquote><p>通过让部分线程进行阻塞 I / O 或者非阻塞 I / O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I / O 得到的数据进行传递，这就轻松实现了异步 I / O（尽管它是模拟的</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225724648.(null)" alt="img"></p><ul><li>libeio 实质上是采用线程池与阻塞 I / O 模拟异步 I / O</li><li>Node 最初在*nix 平台下采用 libeio 配合 libev 实现异步 I / O，后通过自行实现线程池完成</li><li>Windows 下的 IOCP<ul><li>调用异步方法，等待 I / O 完成之后的通知，执行回调，用户无需考虑轮询</li><li>内部其实仍是线程池的原理，不同之处在于这些线程池由系统内核接手管理</li><li>与 Node 异步调用模型十分近似</li></ul></li><li>由于 Windows 平台和*nix 平台的差异，Node 提供了 libuv 作为抽象封装层，做兼容性判断<ul><li>保证上层 Node 与下层的自定义线程池和 IOCP 各自独立</li></ul></li><li>我们时常提到 Node 是单线程的<ul><li>这里的单线程仅仅只是 JavaScript 执行在单线程中罢了</li><li>无论是*nix 还是 Windows 平台，内部完成 I / O 任务的另有线程池</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225728300.(null)" alt="img"></p><h2 id="Node-的异步-I-O">Node 的异步 I / O</h2><blockquote><p>Node 完成整个异步 I / O 环节的有事件循环、观察者和请求对象等</p></blockquote><h3 id="事件循环">事件循环</h3><blockquote><p>着重强调一下 Node 自身的执行模型——事件循环</p></blockquote><p>Node 进程启动时，会创建一个类似 while(true)的循环</p><p>每次循环体的过程称之为 Tick，每个 Tick 的过程就是查看是否有事件待处理</p><p>如果有就取出事件及其相关的回调函数，并执行它们</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225732500.(null)" alt="img"></p><h3 id="观察者">观察者</h3><blockquote><p>每个事件循环中有一个或多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件</p></blockquote><ul><li>浏览器采用了类似的机制<ul><li>事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者</li></ul></li><li>Node 中事件主要来源于网络请求、文件 I / O 等<ul><li>这些时间对应的观察者有文件 I / O 观察者、网络 I / O 观察者等，将事件进行了分类</li></ul></li><li>事件循环是一个典型的生产者 / 消费者模型<ul><li>异步 I / O、网络请求等则是事件的生产者</li><li>这些事件被传递到对应的观察者，事件循环则从观察者那取出事件并处理</li></ul></li></ul><h3 id="小结">小结</h3><blockquote><p>事件循环、观察者、请求对象、I / O 线程池这四者共同构成了 NOde 异步 I / O 模型的基本要素</p></blockquote><p>由于我们知道 JavaScipt 是单线程的，所以按尝试很容易理解它不能充分利用多核 CPU</p><p>事实上在 Node 中，除了 JavaScript 是单线程外，Node 自身其实是多喜爱昵称的，只是 I / O 线程使用的 CPU 较少</p><p>另一个需要注意的点是，除了用户代码无法并行执行以外，所有的 I / O 是可以并行执行的</p><blockquote><p>注：图为 Node 整个异步 I / O 过程</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202225736774.(null)" alt="img"></p><h1>事件驱动与高性能服务器</h1><blockquote><p>前面对异步的讲解，也基本勾勒出了事件驱动的实质，即通过主循环加事件触发的方式来运行程序</p></blockquote><p>下面为几种经典的服务器模型：</p><ul><li>同步式<ul><li>一次只能处理一个请求，并且其余请求都处于等待状态</li></ul></li><li>进程 / 请求<ul><li>这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多</li></ul></li><li>线程 / 请求<ul><li>尽管线程比进程要清凉，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢</li><li>比进程 / 请求要好，但对于大型站点而言依然不够</li></ul></li><li>总结<ul><li>线程 / 请求的方式目前还被 Apache 所采用</li><li>Node 通过事件驱动的方式处理请求，无需为每一个请求创建额外的线程，可以省掉创建线程和销毁线程的开销</li><li>同时操作系统在调度任务时因为线程较少，上下文的代价很低<ul><li>这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受上下文切换开销的影响，这也是 Node 高性能的一个原因</li></ul></li></ul></li></ul><blockquote><p>事件驱动带来的高效已经渐渐开始为业界所重视</p><p>知名服务器 Nginx 也摒弃了多线程的方式，采用和 Node 相同的事件驱动</p><p>不同之处在于 Nginx 采用纯 C 写成，性能较高，但是它仅适合于做 Web 服务器，用于反向代理或者负载均衡服务，在业务处理方面较为欠缺</p><p>Node 则是一套高性能平台，可以利用它构建与 Nginx 相同的功能，也可以处理各种具体业务</p><p>Node 没有 Nginx 在 Web 服务器方面那么专业，但场景更大，自身性能也不错</p><p>在实际项目中可以结合它们各自的优点以达到应用的最优性能</p><p>JavaScript 在服务器端近乎空白，使得 Node 没有任何历史包袱，而 Node 在性能优化上的表现使得它一下子就在社区中流行了起来~</p></blockquote><h1>写在最后</h1><p>本文介绍了 Node 被创造的目的、语言选型、特点、模块机制、包管理机制以及异步 I / O 等相关知识，希望能让你对 Node 有一个新的认识。最近一直也在计划学习 Node 和服务端相关知识，感兴趣的同学可以一起学习和交流~</p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;最初做 Node 的目的是什么？&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Node 作者 Ryan Dahl：&lt;/p&gt;
&lt;p&gt;基于 V8 创建一个轻量级的高性能 Web 服务器并提供一套库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;为什么是 JavaScript？&lt;/</summary>
      
    
    
    
    <category term="Back End" scheme="https://lebronchao.com/categories/Back-End/"/>
    
    
    <category term="JavaScript" scheme="https://lebronchao.com/tags/JavaScript/"/>
    
    <category term="Node" scheme="https://lebronchao.com/tags/Node/"/>
    
    <category term="服务端" scheme="https://lebronchao.com/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[面经分享] 收获多家大厂offer | 分享我的2022秋招经历</title>
    <link href="https://lebronchao.com/2021/11/02/%E7%A7%8B%E6%8B%9B%E5%88%86%E4%BA%AB/"/>
    <id>https://lebronchao.com/2021/11/02/%E7%A7%8B%E6%8B%9B%E5%88%86%E4%BA%AB/</id>
    <published>2021-11-02T15:06:11.000Z</published>
    <updated>2021-11-02T15:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>好久不见，我是 LeBron，有段时间没写博客了。最近几个月的大部分精力都放在秋招上了，边实习边秋招还是挺吃力的，总算结果还是不错。</p><p>先介绍一下个人情况：2022 届双非本科应届生，项目经验和经历还算丰富，在字节实习至今也快 8 个月了，详细情况可以来我的博客看看哈 : <a href="https://www.lebronchao.com/about/">LeBronChao’s Blog</a></p><p>秋招从 7.19 ~ 10.24 历时三个多月，腾讯、阿里、字节、百度、大疆、华为、Shopee、滴滴、美团、拼多多 10 家公司，将近 40 场笔试 / 面试（自我介绍都快念麻了)，基本全部通过收到 offer，借此机会做个总结和大家分享一下面经。</p><h1>面试前的准备</h1><h2 id="简历">简历</h2><blockquote><p>可以参考<a href="https://juejin.cn/post/6952679000422498318">前端 Offer 提速：如何写出有亮点的简历</a></p><p>这个其实不用讲太多了，尽量地写出亮点，比如</p></blockquote><ul><li>开源项目经验</li><li>实习经历 &amp; 重点产出</li><li>技术深度展现 / 知名开源框架 PR</li><li>技术热情 / 影响力</li><li>知识产权 / 论文</li><li>校园项目经验 / 亮点经历</li><li>等等…</li><li>重点：Word 格式容易出问题 尽量用 PDF 格式</li></ul><h2 id="相应岗位知识">相应岗位知识</h2><blockquote><p>这个其实靠平时积累会比较多一点，面试前可以通过面经做个自测，我面试的大部分是前端岗位主要分为以下几个方面</p></blockquote><ul><li><p>计算机网络</p><ul><li>TCP / UDP</li><li>HTTP / HTTPS / WebSocket</li><li>LB / CDN / DNS / IP</li><li>网络安全</li><li>…</li></ul></li><li><p>操作系统</p></li><li><p>开发技能 &amp; 原理</p><ul><li>HTML / CSS(LESS) / JS / TS</li><li>Vue、React、Node、Webpack 等</li><li>浏览器 / 小程序 / 跨端</li><li>性能优化 / 安全策略</li><li>这个根据自己的实际情况来定，<strong>不熟悉的不要写到简历里</strong></li></ul></li><li><p>算法题 / 智力题</p><ul><li><p>系统学习数据结构和算法</p></li><li><p>然后就是刷题了，Hot100 和常见题刷起来吧，主要刷 easy 和 middle，hard 没必要</p></li><li><p>培养举一反三的能力</p></li><li><p>题库</p><ul><li><a href="https://leetcode-cn.com/">力扣</a></li><li><a href="https://codetop.cc/home">CodeTop 企业题库</a></li></ul></li></ul></li><li><p>相应的技术广度扩展和深度探索</p></li><li><p>新的技术动态关注程度，比如</p><ul><li>ES 新特性</li><li>Vue3 的更新和对比</li><li>字节的 Modern.js</li><li>阿里的 Kraken</li><li>…</li></ul></li><li><p>提前想好常见问题的答案和对面试的公司做初步的了解，比如</p><ul><li>你的项目有什么亮点和难点</li><li>你会从哪些角度去考虑选择毕业后的第一家公司</li><li>你觉得 XXX 是一家怎么样的公司</li><li>你有什么优点和缺点</li><li>为什么想做全栈工程师</li><li>你的职业规划是怎么样的</li><li>…</li></ul></li></ul><blockquote><p>感兴趣的话可以看看这篇文章：<a href="https://juejin.cn/post/6953116014678638629">[建议收藏] 初中级前端应该掌握的基础知识</a></p><p>我的公众号、博客里也有挺多相关知识的讲解，感兴趣可以看看：<a href="">前端 LeBron</a></p><p>欢迎关注我的微信公众号：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62cfe8552fa3405b9370000ec256ef8a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p></blockquote><h2 id="自我介绍">自我介绍</h2><p>你和面试官一般都是初次见面，他只能通过你的简历和自我介绍来了解你。<strong>所以说不是特别熟悉的东西不要写到简历里，自我介绍也不要说</strong>。面试官一般也基本不会逐字逐句地看你的简历，可能没法发现你的亮点，自我介绍这不是把机会给你了吗（开始装逼哈哈哈。自我介绍可以由你的基本信息、项目经验、技术亮点和解决哪些比较复杂的问题、个人经历的亮点和未来的规划简述组成。也可以尝试引导面试官问你问题，一般面试官都会从简历 / 自我介绍中开始发问。自我介绍要简明干练，一般 1min 左右就好了。</p><h1>总结</h1><p>三个多月的秋招生活告一段落，最终选择了留在字节工作。新时期的工作带来了新的挑战，没有躺赢的命那就站起来奔跑吧！努力是会有结果的！</p><p>我是一个即将毕业的 22 届双非本科应届生，在字节游戏中台做前端开发工作。希望我的秋招面试经验可以给予正在找工作的你一点帮助，特别是正在奋战秋招/实习的同学、学弟和学妹们。字节游戏中台前端部门求贤若渴，持续招人中。感兴趣的同学可以通过内推链接投递，有问题也可以加微信沟通。Vx:LeBronChao-</p><p>游戏中台内推：</p><ul><li><p>深圳</p><ul><li>社招：<a href="https://job.toutiao.com/s/R6gm31s">前端开发（高级）工程师-游戏中台</a></li><li>校招 &amp; 实习：<a href="https://job.toutiao.com/s/R6gBGHA">前端开发实习生 — 有转正机会</a></li></ul></li><li><p>上海</p><ul><li>社招：<a href="https://job.toutiao.com/s/R6gVo9r">前端开发（高级）工程师-游戏中台</a></li><li>校招 &amp; 实习：<a href="https://job.toutiao.com/s/R6gmupU">前端开发实习生-独立闭环业务（可转正）</a></li></ul></li><li><p>【社招总内推链接】</p><ul><li><a href="https://job.toutiao.com/s/R6qQccL">https://job.toutiao.com/s/R6qQccL</a></li></ul></li><li><p>【内推码】</p><ul><li>4FCV6BV</li></ul></li><li><p>【我的邮箱】</p><ul><li><a href="mailto:chaoweiwen@bytedance.com">chaoweiwen@bytedance.com</a></li></ul></li></ul><h1>废话不多说，直接上面经 ↓</h1><h1>字节</h1><h2 id="10-9-实习转正答辩-通过">10.9 实习转正答辩 通过</h2><h1>腾讯</h1><h2 id="8-17-WXG-游戏一面-60min-通过">8.17 WXG 游戏一面 60min 通过</h2><ol start="0"><li>实习工作主要负责什么</li><li>小程序开发中遇到过什么问题？怎么解决的</li><li>实习项目的难点、亮点</li><li>字节小程序和微信小程序有什么区别</li><li>Uni-app 框架做了什么工作、处理？</li><li>用 Uni-app 开发的过程中遇到过什么问题？怎么解决的？</li><li>从输入网址到整个渲染过程描述</li><li>除了 HTTP 缓存还有什么缓存方式？</li><li>HTTP 缓存、localstorge、sessionstorge、cookie、indexDB 这些方式实现缓存有什么区别、特点</li><li>做过 CDN 相关的工作吗？</li><li>CDN 有什么好处呢？</li><li>聊参与的开源项目技术栈、云开发</li><li>进程和线程的区别？</li><li>进程间通信方式有哪些？</li><li>有用过 Mysql？讲解一下什么是事务？</li><li>二叉树有哪些遍历方式？哪些属于 DFS?</li><li>有用过预处理器吗？有什么特点？</li><li>有考虑过多主题样式吗？怎么实现？</li><li>Node 用过吗？用过哪些相关框架？做过哪些东西？</li><li>手撕 jsonStringfy</li><li>实现 JSON.parse 的思路？除了 eval 和 new Function（AST、编译原理）</li><li>跨端方式有哪几种解决方案？</li></ol><h2 id="8-18-WXG-游戏二面-40min-通过">8.18 WXG 游戏二面 40min 通过</h2><ol start="0"><li>为什么选择做前端？</li><li>前端和其他方向相比，比如机器学习，有什么区别和特点</li><li>怎么样才算前端做得比较好？</li><li>有做过性能优化吗？怎么做得？</li><li>小程序是怎么跑在客户端的?</li><li>双线程架构有什么好处呢？</li><li>如果不使用双线程架构会怎么样？在技术指标上会有什么变化?</li><li>体验卡顿问题？一帧大概多少毫秒？</li><li>JS 和渲染，你觉得一帧各占多少毫秒比较合适？</li><li>说一说各种跨端的方式？JSB 是怎么进行桥接的？</li><li>除了 JSB 还有什么连接方式吗？</li><li>做过性能优化，有哪些操作？首屏渲染优化了多少秒？达到目标了吗？达到你自己的目标了吗？</li><li>各个操作分别优化了多少毫秒？</li><li>CDN 的原理？为什么资源加载快？</li><li>如果你是一个 CDN 服务商，你会怎么设计你的 CDN 来吸引开发者。</li><li>什么情况下会存在跨域问题？</li><li>你在字节感受怎么样？为什么会选择来微信？</li><li>你觉得首屏渲染多少秒是一个合格的标准？</li><li>之前有投递过腾讯吗？为什么没有来？</li><li>后面可以过来实习吗？实习多久？后续在哪个城市发展？</li><li>反问环节、业务介绍</li></ol><h2 id="8-30-WXG-游戏三面-30min-通过">8.30 WXG 游戏三面 30min 通过</h2><ol start="0"><li>实习多久了？为什么投递腾讯？</li><li>聊实习业务、技术难点、亮点，实习对个人的提升</li><li>小程序怎么调用客户端能力？JSBridge 初始化需要多少时间？</li><li>Faas 和普通的后端工程服务有什么区别和特点？</li><li>原子服务之间的调用会有什么问题吗？</li><li>你自己起一个 Node 后端项目？需要做什么操作能让它更好更稳定地运行呢？</li><li>算法题 LeetCode middle 122 买卖股票的最佳时机 II</li><li>反问环节、新人培养、业务了解</li></ol><h2 id="9-7-WXG-游戏-hc-不足流程结束">9.7 WXG 游戏 hc 不足流程结束</h2><h2 id="9-14-TEG-腾讯大数据（数平）一面-40min">9.14 TEG 腾讯大数据（数平）一面 40min</h2><ol start="0"><li>字节实习项目介绍、难点、亮点、挑战</li><li>企业项目性能如何？FCP、FMP 如何?是否进行了分包加载？包体积大小如何？</li><li>Vue 路由模式有几种？有什么区别？</li><li>Vue 最大的优点和缺点是什么？</li><li>有实战过 React 吗？和 Vue 对比有什么区别和优缺点？</li><li>Class 组件和函数组件有什么区别？</li><li>React 组件间数据传递方式</li><li>用过打包工具吗？介绍一下 Webpack</li><li>用过哪些 Loader 和 Plugin？</li><li>Plugin 的原理和编写思路是怎么样的？</li><li>前端异常和性能监控怎么做？让你设计一个异常和性能监控平台你会怎么设计？</li><li>LocalStorge 和 cookie 有什么区别？</li><li>ES6 实现排序有哪几种方式？</li><li>了解 Set 吗？介绍一下</li><li>解决跨域的方式有哪几种？分别是什么原理和实现形式？</li><li>有用过代理工具/抓包吗？</li><li>个人职业规划</li><li>用过 Node 吗？有哪些应用场景？</li><li>字节转正了吗？会因为什么选择一家公司？考虑哪些因素？</li><li>反问环节、业务介绍</li></ol><h2 id="9-15-TEG-腾讯大数据（数平）二面-60min-通过">9.15 TEG 腾讯大数据（数平）二面 60min 通过</h2><ol start="0"><li><p>物联网工程和计算机是什么关系？</p></li><li><p>大学学习了哪些课程？计算机系列课程学过吗？</p></li><li><p>简历上各个项目挨个聊</p></li><li><p>数组和链表有什么区别和特点</p></li><li><p>链表有多少种类型？</p></li><li><p>双向链表的应用场景有哪些?</p></li><li><p>一道贪心算法题</p><p>有 1、5、10、50、100 面值硬币，输入一个长度为 5 的数组，表示有多少枚对应面值的硬币，再输入一个需要凑齐的数值，输出最少需要多少枚</p></li><li><p>常见的排序算法有哪些？</p></li><li><p>快排的实现思路是？时间复杂度是？冒泡呢？</p></li><li><p>有用过哪些设计模式？介绍一下</p></li><li><p>常用 Vue 的哪个版本？nextTick 是怎么实现的？什么原理？知道 process.nextTick 吗？</p></li><li><p>Vue 异步更新介绍一下</p></li><li><p>聊浏览器执行机制、事件循环、多线程架构</p></li><li><p>Vue 怎么实现数据双向绑定和视图更新</p></li><li><p>有用过 ts 吗？有什么好处和特点？</p></li><li><p>聊字节实习项目</p></li><li><p>聊小程序 WebView 预加载、热更新机制</p></li><li><p>反问环节、业务介绍</p></li></ol><h2 id="9-23-TEG-腾讯大数据（数平）GM-三面-20min-通过">9.23 TEG 腾讯大数据（数平）GM 三面 20min 通过</h2><ol start="0"><li>本科期间产出了很多论文和知识产权？是很早就开始做了吗？</li><li>你是一个学霸吗？还是实践能力比较强？</li><li>聊字节实习项目和工作</li><li>聊职业规划、个人发展</li><li>为什么想转全栈？</li><li>去字节实习的目的是什么？</li><li>字节如何评估你的实习工作？</li><li>你如何做你的述职答辩？</li><li>你如何考虑你的校招去向，会因为哪些因素选择一家公司？目前更倾向哪家公司？说说你的想法</li><li>你觉得腾讯和字节有什么不同？</li><li>反问环节</li></ol><h2 id="9-26-TEG-腾讯大数据（数平）-HR-面-20min-通过">9.26 TEG 腾讯大数据（数平） HR 面 20min 通过</h2><ol start="0"><li>为什么不考虑考研？</li><li>介绍一下获得国一等奖的项目和发明专利</li><li>介绍一下开源项目</li><li>你觉得字节是一家什么样的公司？</li><li>你觉得腾讯是一家什么样的公司？</li><li>你觉得 TEG（技术工程事业群）的价值怎么体现？</li><li>你觉得加入腾讯 TEG 工作有什么挑战</li><li>为什么想转全栈？</li><li>手里还有其他 offer 吗？怎么考虑和选择</li><li>哪里人？后续在哪个城市发展？</li><li>有无亲属在腾讯</li><li>反问环节</li></ol><h1>阿里</h1><h2 id="8-13-淘系一面-60min-通过">8.13 淘系一面 60min 通过</h2><blockquote><p>一面老板直接上了我是没想到的</p></blockquote><ol start="0"><li><p>为什么想来阿里？</p></li><li><p>聊一下你觉得做得比较好的项目，有什么难点和亮点？</p></li><li><p>聊负载均衡器项目</p><ol start="0"><li>Node 进程间通信方式是怎么实现的?</li><li>Node 多进程架构是怎么样的？怎么监听同一个端口</li><li>一致性哈希算法的实现原理是？</li><li>最小连接数算法的实现方式是？</li><li>介绍一下 ARP 协议的作用</li><li>你的负载均衡器有用到 ARP 应用吗？怎么应用？</li></ol></li><li><p>聊企业项目亮点</p></li><li><p>讲讲 Faas 的理解，优缺点</p></li><li><p>小程序的技术架构原理是怎么样的？</p></li><li><p>小程序为什么要使用双线程+JSB 的架构？</p></li><li><p>Vue3 的 hooks 原理？</p></li><li><p>Vue3 有哪些 hooks API？</p></li><li><p>讲一讲 Webpack 的原理</p></li><li><p>反问环节</p></li></ol><h2 id="9-7-淘系-拖了一个月告知-hc-不足…">9.7 淘系 拖了一个月告知 hc 不足…</h2><h1>华为</h1><h2 id="10-16-一面-60min-通过">10.16 一面 60min 通过</h2><ol start="0"><li><p>算法题</p><p>碰撞检测算法，给定一个数组表示一系列行星。对于数组的每一个元素，其绝对值表示行星的大小，正负表示行星移动的方向（正表示向右移动，负表示向左移动）找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星永远不会发生碰撞</p><p>用例：</p><p>[5, 10, -5] =&gt; [5,10]</p><p>[8, -8] =&gt; []</p><p>[10, 2, -5] =&gt; [10]</p><p>[-2, -1, 1, 2] =&gt; [-2, -1, 1, 2]</p></li><li><p>Vue 声明周期有哪些</p></li><li><p>讲一讲什么是 MVC</p></li><li><p>Vue 和 React 有什么区别</p></li><li><p>Vuex 有哪些使用场景？为什么使用？Vuex 的实现原理是？</p></li><li><p>Vue 的路由模式有哪些？区别和实现原理是？</p></li><li><p>物联网场景 Web 和常规 Web 场景有什么区别？</p></li><li><p>HTTPS 加密原理是？</p></li><li><p>讲讲你做的负载均衡器</p></li><li><p>小程序和 h5 有啥区别？</p></li><li><p>Uni-app 的转译原理介绍一下</p></li><li><p>反问环节、业务介绍</p></li></ol><h2 id="10-16-二面-45min-通过">10.16 二面 45min 通过</h2><ol start="0"><li><p>算法题</p><p>给定一个数组，里面有 6 个整数，求这个数组能够表示的最大 24 进制的时间是多少，输出这个时间，无法表示输出 invalid。</p><p>输入描述:</p><p>输入为一个整数数组，数组内有六个整数。输入数组长度为 6，不需要考虑其它长度，元素值为 0 或者正整数，6 个数字每个数字只能使用一次。</p><p>输出描述:</p><p>输出为一个 24 进制格式的时间，或者字符串&quot;invalid&quot;。</p><p>备注:输出时间格式为 xx:xx:xx 格式。</p><p>示例 1 输入[0,2,3,0,5,6]</p><p>输出 23:56:00</p><p>示例 2 输入[9,9,9,9,9,9]</p><p>输出 invalid</p></li><li><p>介绍知识产权（发明专利、实用新型专利、软件著作权），如何产出，团队构成和个人角色。</p></li><li><p>介绍个人国奖项目</p></li><li><p>大学四年的规划、经历和职业规划</p></li><li><p>实习过程中遇到的技术难点、亮点</p></li><li><p>反问环节、业务介绍</p></li></ol><h2 id="10-24-三面-40min-通过">10.24 三面 40min 通过</h2><ol start="0"><li>考虑留在字节吗？从哪些方面考虑选择一家公司？</li><li>讲一讲你是怎么学习前端开发的？遇到过哪些难点？怎么解决？学习周期多久？</li><li>聊字节实习项目、工作、产出</li><li>实习工作合作过程中有遇到什么问题吗？怎么解决这些问题？</li><li>合作过程中的沟通时间占比多少？</li><li>实习和学业怎么平衡的？</li><li>职业规划是怎么样的？</li><li>意向城市</li><li>反问环节</li></ol><h1>大疆</h1><h2 id="8-1-笔试-90min（60min-完成）通过">8.1 笔试 90min（60min 完成）通过</h2><p>3 单选</p><ol><li>以下判断单链表有环方法错误的是 暴力穷举、找相同尾结点、哈希缓存、快慢指针找交点</li><li>根据前序和中序选后续遍历的结果</li><li>JavaScript 解释器运行到什么阶段可以判断出不需要运行 func2 语法解析、词法解析、语义分析、生成字节码</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;已知</span><br><span class="line">&#x2F;&#x2F;b.js包含如下代码</span><br><span class="line">import &#123; func1 &#125; from &#39;.&#x2F;a&#39;</span><br><span class="line">&#x2F;&#x2F;a.js包含如下代码</span><br><span class="line">export function func1()&#123;&#125;</span><br><span class="line">export function func2()&#123;&#125;</span><br></pre></td></tr></table></figure><p>6 多选</p><ol><li><p>空间复杂度为 O（1）的算法有 归并排序、堆排序、冒泡排序、快速排序</p></li><li><p>关于 HTTP 1.0/1.1/2.0 说法正确的事</p><ol><li>HTTP1.0 每次请求需要建立一个 TCP 连接</li><li>HTTP/1.1 支持多路复用</li><li>HTTP/2.0 支持二进制解析</li><li>HTTP/2.0 支持服务端推送</li></ol></li><li><p>Chrome 采用了多进程架构，创建少量 tab 时会启动独立的工作进程，以下关于线程、进程对比描述正确的是</p><ol><li>进程安全性更高，tab 崩溃不会互相影响</li><li>进程启动成本更低，可以快速创建 tab</li><li>进程间通信效率更高，更容易支持插件化</li><li>进程管理更容易，tab 独立渲染更快。</li></ol></li><li><p>对于 JS 原型链描述正确的是</p><ol><li>任何一个函数都有 prototype 属性</li><li>任何一个非 null 对象都有****proto****属性，等同于 prototype</li><li>原型链属性查找优先级为：实例****proto___ &gt; 实例本身</li><li>严格模式中，全局作用域 this 为 undefined</li></ol></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 2;</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a &#x3D; 1;</span><br><span class="line">  return (b) &#x3D;&gt; &#123;</span><br><span class="line">    return (c) &#x3D;&gt; &#123;</span><br><span class="line">      const ret &#x3D; a + b + c;</span><br><span class="line">      a *&#x3D; 2;</span><br><span class="line">      return ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">let f1 &#x3D; func();</span><br><span class="line">let f2 &#x3D; func();</span><br><span class="line"></span><br><span class="line">console.log(func()(1)(2), func()(1)(2)); &#x2F;&#x2F; 4 4</span><br><span class="line"></span><br><span class="line">console.log(f1(1)(2), f2(1)(2)); &#x2F;&#x2F; 4 4</span><br><span class="line"></span><br><span class="line">console.log(f1(1)(2),f1(1)(2)); &#x2F;&#x2F; 4 4</span><br><span class="line"></span><br><span class="line">console.log(func()(1)(2), func()(1)(2)); &#x2F;&#x2F; 4 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>对于 Promise、async、await 描述正确的是</p><ol><li>Promise 用于解决回调嵌套过深的问题</li><li>await 可以以”同步“的方式实现异步的逻辑</li><li>Promise rejected 状态可以变为 pending 状态</li><li>Promise 执行过程中可以取消</li></ol></li></ol><p>5 问答</p><ol><li>EventLoop 看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br><span class="line">console.log(4);</span><br><span class="line">​</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(5);</span><br><span class="line">&#125;, 0);</span><br><span class="line">​</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(6);</span><br><span class="line">&#125;, 1);</span><br></pre></td></tr></table></figure><ol start="2"><li>简述浏览器的垃圾回收机制</li><li>介绍 Vue 的双向绑定实现原理及流程</li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum WidgetType &#123;</span><br><span class="line">  Button,</span><br><span class="line">  Text,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class Widget &#123;</span><br><span class="line">  draw() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class WButton extends Widget &#123;</span><br><span class="line">  type: WidgetType &#x3D; WidgetType.Button;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    console.log(&quot;draw Button&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class WText extends Widget &#123;</span><br><span class="line">  type: WidgetType &#x3D; WidgetType.Text;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    console.log(&quot;draw Text&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class WButtonText&#123;</span><br><span class="line">  button: WButton</span><br><span class="line">  text: WText</span><br><span class="line">  constructor(button: WButton, text: WText) &#123;</span><br><span class="line">    this.button &#x3D; button;</span><br><span class="line">    this.text &#x3D; text;</span><br><span class="line">  &#125;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    this.button.draw();</span><br><span class="line">    this.text.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">function render() &#123;</span><br><span class="line">  let btext &#x3D; new WButtonText(new WButton(), new WText());</span><br><span class="line">  btext.draw();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">&#x2F;*</span><br><span class="line">请尝试使用设计模式改写代码，使得render中可以用如下方式调用，得到相同的输出</span><br><span class="line">*&#x2F;</span><br><span class="line">​</span><br><span class="line">function render() &#123;</span><br><span class="line">  let btext &#x3D; new WText(new WButton());</span><br><span class="line">  btext.draw();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br></pre></td></tr></table></figure><ol start="2"><li>实现一个搜索器，输入一个二叉树的根节点，调用搜索器的 next()方法，将返回二叉树中下一个最小的数；调用搜索器的 hasNext 方法，将返回是否存在下一个数。二叉树节点是无需整数</li></ol><p>附加题：</p><blockquote><p>能不能给非可视化方向的同学一点机会…</p></blockquote><ol><li>（可视化方向附加题）简述 WebGL 渲染管线</li><li>（可视化方向附加题）简述你了解的 3D 场景管理数据结构及其实现原理</li><li>（可视化方向附加题）在 WebGL 3D 场景中，要实现物体阴影效果，请简述实现原理。假设场景区域很大，要如何优化阴影效果。</li></ol><h2 id="8-19-一面-60min-通过">8.19 一面 60min 通过</h2><ol><li>为什么选择来大疆？不留在字节吗？</li><li>你会因为什么因素选择一家公司？</li><li>有其他公司的 offer 吗？</li><li>介绍一下 V8 垃圾回收机制？</li><li>知道 V8 垃圾回收机制对比编码有什么好处？</li><li>什么情况会出现内存泄漏？</li><li>你编码有出现过内存泄漏或者有排查过吗？</li><li>怎么防止内存泄漏？排查解决治标不治本</li><li>用的什么技术栈？有用过 TS 吗？</li><li>介绍一下你的实习项目业务</li><li>项目有什么难点？亮点？</li><li>多主题的实现你有调研过其他的解决方案吗？这个需求的背景是什么？为什么不调研别的方案？为什么不和组内同时讨论？为什么没去看 antd 的源码实现？</li><li>你的项目里面有涉及到权限等级系统的设计吗？</li><li>让你设计一个省市区的级联选择器你会考虑哪些点？</li><li>说说你的开源项目？</li><li>有用过哪些 ES6 新特性，都说一说</li><li>箭头函数 this 指向哪里？在不同的地方执行 this 执行会指向不同吗？</li><li>const 和 let 带来了什好处？</li><li>除了块级作用域还有什么作用域？</li><li>过渡使用闭包会出现什么问题？</li><li>promise 出现以前是怎么处理异步编程的？promise 有什么好处？编程思路发生了什么转变？会出现什么问题？</li><li>从哪里看到的大疆招聘信息？了解大疆是怎么样的一个企业？</li><li>你觉得来大疆做前端你会做哪些工作？</li><li>↑ 你觉得你的描述能够吸引人吗？</li><li>业务介绍、反问环节</li></ol><h2 id="8-26-二面-30min-通过">8.26 二面 30min 通过</h2><ol><li>讲一讲你觉得最能体现你技术水平的项目</li><li>聊字节实习工作、项目、负载均衡器项目</li><li>通过这些项目 / 字节实习，你学到了什么？</li><li>个人的职业规划是怎么样的？</li><li>场景设计，单人 / 多人了解，如何做加解密可以做到服务器被攻陷也不会泄漏聊天记录，加解密的流程是怎么样的？</li><li>为什么想来大疆？有用过大疆的产品吗？</li><li>你能总结一下你个人的优缺点吗？</li><li>你的缺点有给你带来困扰和影响吗？</li><li>你实习的同事对你评价怎么样？</li><li>不考虑在字节留用吗？</li><li>你的产品思维怎么样？通过什么事情能够体现？</li><li>你平时有什么爱好？水平如何？</li><li>反问环节、业务介绍</li></ol><h2 id="8-29-三面-50min-通过">8.29 三面 50min 通过</h2><ol><li>了解企业实习工作和业务</li><li>最近国家约谈互联网大厂和做出整改你怎么看？动机是什么？面对整改你们做了什么工作?</li><li>为什么是国家整改而不是企业主动去做？</li><li>你对未来的职业规划包括选择是怎么样的？</li><li>你会因为什么去选择一家公司？为什么选择大疆？</li><li>你自己做的最满意的一个项目是什么？有什么特点和难点？</li><li>自己做的项目和企业项目的区别是什么？实习有什么收获？</li><li>你怎么看待大疆？和互联网企业不太一样，有什么特别的想法吗？</li><li>你也有提到有用过大疆的产品，感觉体验怎么样？有什么功能建议点？…讨论大疆产品和爱好</li><li>如果发了 offer 让你来？你觉得你需要提前做什么准备？</li><li>你有遇到过比较大的挫折和困难吗，是怎么面对的？</li><li>你的人生目标是什么？最大的优缺点是什么?</li><li>有过让自己后悔的决策吗?</li><li>字节和大疆都给你 offer 了你会怎么选择呢？</li><li>反问环节、企业文化价值观交流</li></ol><h1>Shopee</h1><h2 id="7-19-提前批笔试-120min-通过">7.19 提前批笔试 120min 通过</h2><ol start="0"><li><p>Symbol 相关</p></li><li><p>Proxy 相关</p></li><li><p>instance of 相关</p></li><li><p>%、rem、vh、px 相关</p></li><li><p>liunx 建立新进程的命令</p></li><li><p>状态码 504 的含义</p></li><li><p>前端安全，SQL 注入、XSS 攻击、CSRF 攻击、HTTPS、CA 相关</p></li><li><p>IP、子网掩码算广播地址</p></li><li><p>正则相关，选一个正则不能进行的操作</p></li><li><p>选一个会触发重绘、回流的情景</p></li><li><p>不给 cookie 设置有效时间，它的生命周期是？</p></li><li><p>visualbility：hidden、display：none 是否触发重绘回流</p></li><li><p>使用虚拟 DOM 的好处</p></li><li><p>CSRF 防御方案</p></li><li><p>可能被 XSS 注入的标签</p></li><li><p>position 定位类型</p></li><li><p>CORS 解决跨域请求头设置 带 cookie</p></li><li><p>算法：</p><ol start="0"><li>找出最后一个只出现一个的字符</li><li>ACM 的一道题 仓库拣货，二维数组标记几个点为货物，经过货物四周即为拣货成功。从入口开始，需要转向几次才能拣完所有的货。</li><li>相交数组，找出两个数组重复的项</li></ol></li></ol><h2 id="7-25-提前批一面-50min-通过">7.25 提前批一面 50min 通过</h2><ol start="0"><li>重绘重排及优化点</li><li>CSS 定位方式有哪几种 分别有什么区别</li><li>虚拟 DOM 的优缺点</li><li>TCP 连接可靠性</li><li>TCP 是否有数据校验</li><li>TCP 流量控制、拥塞控制</li><li>Vue data 为什么是个函数</li><li>深拷贝、浅拷贝 为什么会有这种概念</li><li>JS 基本类型、引用类型</li><li>V8 垃圾回收描述</li><li>事件委托、事件代理</li><li>算法：括号匹配、二叉树后续遍历</li><li>反问环节</li></ol><h2 id="8-1-提前批二面-54min-通过">8.1 提前批二面 54min 通过</h2><ol start="0"><li>EventLoop，写输出和思路</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;start&quot;);</span><br><span class="line">​</span><br><span class="line">  Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;Promise1&quot;);</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;setTimeout2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">​</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;setTimeout1&quot;);</span><br><span class="line">    Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;promise2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">​</span><br><span class="line">console.log(&quot;end&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li>闭包、块级作用域，写输出和思路</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result &#x3D; [],</span><br><span class="line">  a &#x3D; 3;</span><br><span class="line">var total &#x3D; 0;</span><br><span class="line">function foo(a) &#123;</span><br><span class="line">  var i &#x3D; 0;</span><br><span class="line">  for (; i &lt; 3; i++) &#123;</span><br><span class="line">    result[i] &#x3D; function () &#123;</span><br><span class="line">      total +&#x3D; i * a;</span><br><span class="line">      console.log(total);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">foo(1);</span><br><span class="line">result[0]();</span><br><span class="line">result[1]();</span><br><span class="line">result[2]();</span><br></pre></td></tr></table></figure><ol start="3"><li>手撕防抖，支持立即执行</li><li>前端性能优化，聊了静态资源上 cdn，HTTP 缓存，接口聚合，骨架屏/loading，DNS 预解析，preload，prefetch，webpack 优化：Compress、Tenser、HMR、多线程打包、开启缓存、DLL</li><li>实现一个组件，无限滚动，要求刷新性能尽可能地好，聊了虚拟列表固定大小和不固定大小分别怎么实现</li><li>聊实习项目、亮点、遇到问题、怎么解决</li><li>ES6 - 最新版本有什么新特性</li><li>Vite 了解吗，聊一聊，和 webpack 有什么区别，为什么比 webpack 快</li><li>反问环节</li></ol><h2 id="8-4-提前批-HR-面-20min-通过">8.4 提前批 HR 面 20min 通过</h2><ol start="0"><li>自我介绍</li><li>字节实习工作内容</li><li>做项目遇到什么问题，怎么解决的？</li><li>会因为什么选择一个公司？业务？薪酬？大厂背景？</li><li>对什么业务比较感兴趣呢？</li><li>用三个词形容自己</li><li>职业规划，有考虑考研吗？</li><li>自身有什么优缺点？</li><li>手头还有什么 offer？</li><li>有什么兴趣、爱好？</li></ol><h1>百度</h1><h2 id="8-19-提前批一面-80min-通过">8.19 提前批一面 80min 通过</h2><ol><li><p>介绍企业实习项目</p></li><li><p>项目并发量级这么大，是怎么承受高并发的？怎么更新版本？</p></li><li><p>前端层面怎么设计可以减轻服务端压力，承受高并发？</p></li><li><p>介绍一下 HTTP 缓存</p></li><li><p>CDN 有什么好处？原理呢？</p></li><li><p>离线包有了解过吗？</p></li><li><p>你的 safeRouter 是怎么封装的？怎么做的？</p></li><li><p>VueRouter 的原理是什么？</p></li><li><p>个人项目的权限系统是怎么设计的？如果更复杂的权限系统你会怎么设计？</p></li><li><p>封装一个通用的根据权限渲染不同内容的组件你会怎么设计？</p></li><li><p>浏览器的时间循环机制描述一下？</p></li><li><p>Node 事件循环和浏览器有什么区别？</p></li><li><p>遍历一个对象有什么形式？</p></li><li><p>for in 有什么缺陷？怎么避免？</p></li><li><p>for of 可以遍历对象吗？怎么让它能遍历</p></li><li><p>v-model 的原理</p></li><li><p>怎么实现多个位置绑定同一个 v-model？</p></li><li><p>vue 组件传值有哪些方式？尽可能多地说</p></li><li><p>工程化了解过吗？Webpack 的 Loader 和 Plugin 有什么区别？</p></li><li><p>Plugin 可以实现 Loader 的功能吗？</p></li><li><p>拆包有了解过吗？路由懒加载有了解过吗？讲一讲</p></li><li><p>讲一讲你了解的数据结构</p></li><li><p>链表的头插法、查询、有序插入时间复杂度是多少？</p></li><li><p>二叉树的查询复杂度是多少？</p></li><li><p>快排的时间复杂度是多少？</p></li><li><p>算法</p><ol><li><p>数组去重</p><ol><li>set</li><li>手动</li></ol></li><li><p>爬楼梯</p><ol><li>迭代</li><li>递归</li><li>缓存 + 递归</li></ol></li></ol></li><li><p>反问环节、业务介绍</p></li></ol><h2 id="8-21-提前批二面-80min-通过">8.21 提前批二面 80min 通过</h2><ol><li><p>聊开源项目</p></li><li><p>聊企业实习项目</p></li><li><p>项目有什么难点？亮点？</p></li><li><p>实习有什么收获？</p></li><li><p>实现一个 repeat 函数，第一个参数是字符串，第二个参数是字符串重复多少次后返回，例如 repeat(‘str’,2)返回 strstr</p><ol><li>实现这个函数你要考虑什么问题？</li><li>一个字符串的最大长度是多少？</li><li>除了问人，可以查文档等各种方式去查、写代码去验证，你会怎么做？（第二个问题）</li><li>MDN 文档中文版和英文版有什么不一样吗？可以看一看</li><li>你现在写的是迭代的方式，你可以改成递归的方式吗？</li><li>你一般怎么对代码进行 debug？</li><li>你现在的时间复杂度是多少？可以优化吗？</li><li>ok，优化到 logn 了，logn 的迭代形式要怎么改呢？</li></ol></li><li><p>反问环节、业务了解</p></li></ol><h2 id="8-24-提前批三面-30min-通过">8.24 提前批三面 30min 通过</h2><ol><li><p>在字节转正了吗？</p></li><li><p>后续职业规划是怎么样的？考虑考研吗？</p></li><li><p>聊字节实习项目</p></li><li><p>实习有哪些成长？</p></li><li><p>我看你学的是物联网，还获得了不少奖项和知识产权，为什么选择做前端呢？</p></li><li><p>你会因为哪些因素选择一家公司？</p></li><li><p>后续考虑在深圳发展吗？</p></li><li><p>算法设计</p><p>1000 支疫苗，有一支变质了，可以通过试纸检测，反应时间需要一小时，如何在一小时用尽可能少的试纸找到变质的疫苗。一张试纸可以滴多支疫苗，一支疫苗也可以滴在多张试纸。</p><ol><li>将疫苗变成 m _ n 矩阵，m _ n = 1000， m + n 尽量小，需 m + n 张（mn 对应行列）</li><li>将疫苗进行二进制编号，使用 10 张试纸，对应位为 1 则滴，不为 1 则不滴，通过变红的试纸反推编号。</li></ol></li><li><p>反问环节</p></li></ol><h1>滴滴</h1><h2 id="7-31-提前批一面-70min-通过">7.31 提前批一面 70min 通过</h2><ol><li>聊负载均衡器 实现、算法（个人项目）</li><li>Node 进程间通信实现，其他进程间通信方式</li><li>实习项目介绍，业务理解，亮点</li><li>Express 和 Koa 的区别，中间件的实现方式 compose</li><li>实现一个 compose</li><li>compose 函数看代码写输出 带 try catch 和抛错</li><li>讲讲对 webpack 的理解</li><li>vue2 和 vue3 的区别</li><li>vue 组件传值$attr</li><li>Vue 的插槽有哪几种类型，分别有什么区别</li><li>手撕最长公共子串 LeetCode 1143 middle</li><li>手撕深拷贝</li><li>判断数据类型的方法</li><li>手撕发布订阅模式</li><li>反问环节</li></ol><h2 id="7-31-提前批二面-70min-通过">7.31 提前批二面 70min 通过</h2><ol><li>尽可能多的写出 div 中 img 垂直水平居中的方法。要求至少有一种方法是使用 flex 布局。其中 div 宽高 300px，img 宽高 100px</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;img &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>画一条 0.5px 的线</li><li>宏任务、微任务、EventLoop</li><li>看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(100)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(200)</span><br><span class="line">Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(300)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>尽可能多的写出数组去重的方法</li><li>写一个每隔一秒输出 0、1、2、3、4、5 的方法</li><li><strong>var const let</strong> 块级作用域</li><li>写出 console 的结果</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f &#x3D; (function() &#123;</span><br><span class="line">  var c &#x3D; &quot;c&quot;;</span><br><span class="line">  return &#123;</span><br><span class="line">    a: function() &#123;</span><br><span class="line">      return c;</span><br><span class="line">    &#125;,</span><br><span class="line">    b: function(d) &#123;</span><br><span class="line">      c &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">console.warn(f.a())</span><br><span class="line">console.warn(f.c)</span><br><span class="line">console.warn(f.b(&quot;d&quot;))</span><br><span class="line">console.warn(f.a())</span><br></pre></td></tr></table></figure><ol start="7"><li>闭包</li><li>任选一种排序方法进行实现</li><li>浏览器 url 从输入到显示出页面的流程（带缓存）</li><li>强缓存、协商缓存</li><li>link 标签引入 css 会阻塞 dom 渲染嘛</li><li>async 和 defer 的区别</li><li>node EventLoop 和浏览器有什么区别</li><li>进程间通信 domain socket 具体实现流程</li><li>箭头函数和普通函数有什么区别</li><li>小程序的运行机制（双线程、JSB 相关）</li><li>redis 怎么实现分布式锁</li><li>你认为自己的定位是怎么样的 有什么优缺点</li><li>你认为别人眼中的你是怎么样的</li><li>反问环节</li></ol><h2 id="7-31-提前批三面-70min-通过">7.31 提前批三面 70min 通过</h2><ol><li>自我介绍爱好、特长、特点、亮点、个人定位</li><li>大学中的成长历程、怎么接触技术、学习和发展历程</li><li>实习项目和做的事情</li><li>未来个人职业规划</li><li>聊负载均衡器项目（个人项目）</li><li>为什么会去做技术分享、目的、怎么选题（字节部门技术分享）</li><li>再让你做技术分享你会选什么题目</li><li>大学里最有成就感的事情，为什么？</li><li>简历上六个项目挨个聊</li><li>物联网工程专业和计算机的关系和区别</li><li>除了前端还有没有学过别的方向的技术</li><li>最擅长的专业课是什么</li><li>你怎么给一个非专业的人介绍计算机网络</li><li>计算机网络为什么要分层</li><li>你的数据结构和算法怎么样 有没有刷题</li><li>dp 了解吗 讲一讲</li><li>写道题吧 对象的 key 全部驼峰转下划线 要求递归 可限制深度 dfs 和 bfs 分别怎么实现</li><li>反问环节</li></ol><h1>美团</h1><h2 id="8-16-一面-70min-通过">8.16 一面 70min 通过</h2><ol><li>看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;windowsName&quot;;</span><br><span class="line">var a &#x3D; &#123;</span><br><span class="line">  name:&quot;Cherry&quot;,</span><br><span class="line">  </span><br><span class="line">  func1:function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func2:function()&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      this.func1();</span><br><span class="line">    &#125;, 100)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.func2();</span><br></pre></td></tr></table></figure><ol start="2"><li>说说对闭包的理解，有哪些应用场景</li><li>实现一个方法</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(a) -&gt; [a]</span><br><span class="line">f(b) -&gt; [a, b]</span><br><span class="line">f(c) -&gt; [a, b, c]</span><br></pre></td></tr></table></figure><ol start="4"><li>看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const list &#x3D; [1, 2, 3];</span><br><span class="line">const square &#x3D; num &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(num * num);</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">function test()&#123;</span><br><span class="line">  list.forEach(async x&#x3D;&gt;&#123;</span><br><span class="line">    const res &#x3D; await square(x);</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><ol start="5"><li>new 的过程中发生了什么</li><li>说一下 Promise 的应用</li><li>async await 是什么的语法糖</li><li>Promise 有哪些状态，可逆吗？</li><li>讲讲 Vue 的双向绑定原理</li><li>数组的双向绑定相关，Vue2 直接更新数组某项会进行视图更新吗？</li><li>了解跨域吗？讲一讲有哪几种方式</li><li>TCP 三次握手四次挥手，为什么三次和四次，如何保障可靠性</li><li>手写快排</li><li>跨端方式交流</li><li>反问环节</li></ol><h2 id="8-24-二面-45min-通过">8.24 二面 45min 通过</h2><ol><li><p>可以提前过来实习吗？</p></li><li><p>字节留用情况？</p></li><li><p>更看重公司的哪些因素？</p></li><li><p>有考虑考研吗？</p></li><li><p>聊字节实习项目</p></li><li><p>介绍一下你的 HTTP 缓存文章写了哪些内容</p></li><li><p>ETag 是什么？常见的算法有哪些？</p></li><li><p>负载均衡器项目是怎么实现的？</p></li><li><p>一致性哈希算法原理是？</p></li><li><p>最有成就感的项目是哪一个？</p></li><li><p>介绍一下虚拟 DOM，有什么优缺点？</p></li><li><p>虚拟 DOM 的底层 patch、diff 有了解过吗？</p></li><li><p>Vue 的 diff 算法，Vue2 和 Vue3 分别是怎么样的？有什么区别？</p></li><li><p>Vue 的双向绑定原理是怎么实现的？</p></li><li><p>算法</p><ol><li>计算一个数组最长连续自然数个数，要求值连续，位置没有要求</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入 &#123;100,4,200,1,3,2&#125;</span><br><span class="line">输出 4</span><br><span class="line">示例2 输入 &#123;200,201,202,100,4,200,1,3,2,204,203&#125;</span><br><span class="line">输出 5</span><br></pre></td></tr></table></figure><ol start="2"><li>看代码说输出，会报错吗</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let A &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  this.a &#x3D; 100;</span><br><span class="line">  return &#123;a: 200&#125;</span><br><span class="line">&#125;</span><br><span class="line">A.a &#x3D; 300</span><br><span class="line">A.__proto__.a &#x3D; 500</span><br><span class="line">A.prototype &#x3D; &#123; a: 600 &#125;</span><br><span class="line">a &#x3D; new A()</span><br><span class="line">console.log(a.a)</span><br></pre></td></tr></table></figure></li><li><p>箭头函数和普通函数有什么区别？</p></li><li><p>prototype 和*<strong>*proto**</strong> 有什么区别？</p></li><li><p>能说一下 HTTPS 握手、加解密流程吗？</p></li><li><p>让你最有收获的专业课是什么？</p></li><li><p>你觉得自己有什么优点和缺点？</p></li><li><p>除了前端还学习过什么别的技术吗？</p></li><li><p>你的知识产权（发明专利、实用新型专利、软件著作权）是怎么产生的？</p></li><li><p>反问环节</p></li></ol><h2 id="9-1-HR-面-20min-通过">9.1 HR 面 20min 通过</h2><ol><li>你的专利和软件著作权是通过什么机会去产出的？第几作者呢？</li><li>看你项目经验很丰富</li><li>你在字节的工作感受如何？压力大吗？</li><li>字节是否会给你留用 offer？</li><li>你还有投递其他那些公司？</li><li>你会因为什么选择一家公司？</li><li>你觉得你做的最有成就感的项目是哪个？</li><li>你觉得你做的最难的项目是哪一个？难点在哪里？</li><li>你的职业规划是怎么样的？</li><li>你有哪些优点和优势？</li><li>反问环节</li></ol><h1>拼多多</h1><h2 id="7-25-提前批笔试-90min（30min-完成）-通过">7.25 提前批笔试 90min（30min 完成） 通过</h2><ol start="0"><li>递归实现和非递归实现哪个更快</li><li>TCP 和 UDP 的区别是</li><li>实操 HTML CSS</li><li>实现一个异步加载 js 函数返回一个 promise，成功 resolve，失败/5s 超时 reject</li><li>手写 Promise.resolve 和 Promise.reject</li></ol><h2 id="8-3-提前批一面-55min-通过">8.3 提前批一面 55min 通过</h2><ol start="0"><li><p>手撕括号匹配</p></li><li><p>实现一个 promiseTimeout 方法，接收两个参数，第一个参数为 promise，第二个参数为 number 类型；该方法的作用为</p><ol start="0"><li>若 promise 在第二个参数给定的时间内处于 pending 状态，则返回一个 rejected 的 promise，其 reason 为 new Error（‘promise timeout’）</li><li>若 promise 在第二个参数给定的时间内处于非 pending 状态，则返回该 promise</li></ol></li><li><p>浏览器任务循环，看代码写输出</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">​</span><br><span class="line">async1();</span><br><span class="line">​</span><br><span class="line">new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;promise1&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;promise2&quot;);</span><br><span class="line">    return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((result) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;promise3&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">​</span><br><span class="line">console.log(&quot;script end&quot;);</span><br></pre></td></tr></table></figure><ol start="4"><li>看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">console.log(&#39;a finish&#39;);</span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">console.log(&#39;b finish&#39;);</span><br><span class="line">​</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;a.js&quot; defer&#x3D;&quot;defer&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;b.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      console.log(&quot;event begin&quot;);</span><br><span class="line">      document.addEventListener(&quot;DOMContentLoaded&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;DOMContentLoaded finish&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      window.addEventListener(&quot;load&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;load finish&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;main&quot; class&#x3D;&quot;bg&quot;&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">        let i &#x3D; 0;</span><br><span class="line">        while (i &lt; 1000000) &#123;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;compute finished&quot;);</span><br><span class="line">      &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><ol start="5"><li>Vue 双向绑定实现原理</li><li>Vue.$nextTick 实现原理，是宏任务还是微任务</li><li>Vue scoped 实现原理</li><li>跨域的实现方式</li><li>简单请求复杂请求 Option 预请求</li><li>从 url 到页面渲染间发生了什么</li><li>重绘、回流，优化方式</li><li>HTTP 缓存 强缓存、协商缓存</li><li>手写 Reac Hookst 计数器（自增），闭包陷阱</li><li>无限滚动场景，虚拟列表设计</li><li>单点登录</li><li>前端安全 CSRF</li></ol><h2 id="8-7-提前批二面-50min-通过">8.7 提前批二面 50min 通过</h2><ol start="0"><li>你觉得 Vue 是个怎么样的框架</li><li>Vue DSL 是个什么样的模式</li><li>什么是 MVVM？</li><li>MVVM 三层分别做了什么事情</li><li>Vue 中组件是什么概念？什么场景你会去封装一个组件</li><li>Vue 组件数据通信有什么方式？分别有什么区别</li><li>Vuex 异步和同步操作分别用什么，区别在哪里？</li><li>算法题：给出一个数组中有多个对象，对象的属性有用户的 id 和操作的时间，给出了时间的起止，输出一个数组，数组中的对象为操作次数和相同操作次数的用户数，按操作次数从大到小排列</li><li>for in 和 for of 的区别</li><li>const、let 和 var 的区别</li><li>什么是块级作用域</li><li>垃圾回收做了什么事情</li><li>如何让函数作用域外的访问函数内的变量</li><li>什么是闭包，手写个闭包</li><li>this 在 JS 中是什么</li><li>箭头函数和普通函数有什么区别</li><li>怎么改变函数的 this 指向</li><li>说一下 flex 布局，有哪些常见属性，分别用来干吗</li><li>简单写个 flex 布局</li><li>CSS 有哪些单位 有什么区别</li><li>rem 有什么使用场景</li><li>浏览器拿到 document 后浏览器的渲染流程</li><li>什么情况会阻塞渲染，怎么优化</li><li>async 和 defer 有什么区别</li><li>怎么手动测量渲染时间</li></ol><h2 id="8-16-提前批三面-70min-通过">8.16 提前批三面 70min 通过</h2><ol start="0"><li>算法</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">请将第二排天上数组，使得第二排每一位数字是对应的第一排数字的次数</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">- - - - - - - - - -</span><br><span class="line">​</span><br><span class="line">例如</span><br><span class="line">0 1 2 3</span><br><span class="line">1 2 1 0</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现一个 HardMan</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HardMan(&quot;jack&quot;)输出</span><br><span class="line">i am jack</span><br><span class="line">HardMan(&quot;jack&quot;).learn(&quot;computer&quot;)输出：</span><br><span class="line">i am jack</span><br><span class="line">Learning computer</span><br><span class="line">HardMan(&quot;jack&quot;).rest(10).learn(&quot;computer&quot;)输出</span><br><span class="line">i am jack 等待10s</span><br><span class="line">Start learning after 10 seconds</span><br><span class="line">Learning computer</span><br><span class="line">HardMan(&quot;jack&quot;).restFirst(5).learn(&quot;computer&quot;)输出</span><br><span class="line">等待5s</span><br><span class="line">Start learning after 5 seconds</span><br><span class="line">i am jack</span><br><span class="line">Learning chinese</span><br></pre></td></tr></table></figure><ol start="3"><li>介绍项目，难点、亮点、问题、怎么解决</li><li>HTTP 强缓存、协商缓存</li><li>localstorge 和 HTTP 缓存有啥区别，你会怎么选择缓存方案</li><li>缓存位置在哪儿？策略？</li><li>反问环节</li></ol><h2 id="8-23-HR-面-20min-通过">8.23 HR 面 20min 通过</h2><ol start="0"><li>自我介绍</li><li>职业规划</li><li>后续在哪个城市发展</li><li>爸妈同意吗？有没有女朋友</li><li>会因为什么因素选择一家公司</li><li>有什么感兴趣的业务方向</li><li>期望薪资是什么水平？</li><li>为什么选择做前端开发？</li><li>可以过来实习嘛？</li><li>工作强度是否了解过？是否能接受？</li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;好久不见，我是 LeBron，有段时间没写博客了。最近几个月的大部分精力都放在秋招上了，边实习边秋招还是挺吃力的，总算结果还是不错。&lt;/p&gt;
&lt;p&gt;先介绍一下个人情况：2022 届双非本科应届生，项目经验和经历还算丰富，在字节实习至今也快 8 个月了</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="面经" scheme="https://lebronchao.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="秋招" scheme="https://lebronchao.com/tags/%E7%A7%8B%E6%8B%9B/"/>
    
    <category term="应届生" scheme="https://lebronchao.com/tags/%E5%BA%94%E5%B1%8A%E7%94%9F/"/>
    
    <category term="面试" scheme="https://lebronchao.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>[源码解读]一文读懂Vuex4源码</title>
    <link href="https://lebronchao.com/2021/09/05/Vuex4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://lebronchao.com/2021/09/05/Vuex4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2021-09-05T02:25:04.000Z</published>
    <updated>2021-09-05T02:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex4 源码解析</p><blockquote><p>Vuex 是在 Vue 中常用的状态管理库，在 Vue3 发布后，这个状态管理库也随之发出了适配 Vue3 的 Vuex4</p></blockquote><h1>快速过 Vuex3.x 原理</h1><ul><li>为什么每个组件都可以通过<code>this.$store</code>访问到 store 数据？<ul><li>在 beforeCreate 时，通过 mixin 的方式注入了 store</li></ul></li><li>为什么 Vuex 中的数据都是响应式的<ul><li>创建 store 的时候调用的是<code>new Vue</code>,创建了一个 Vue 实例，相当于借用了 Vue 的响应式。</li></ul></li><li>mapXxxx 是怎么获取到 store 中的数据和方法的<ul><li>mapXxxx 只是一个语法糖，底层实现也是从$store 中获取然后返回到 computed / methods 中。</li></ul></li></ul><h1>Vuex4 使用</h1><h2 id="Vue-useStore">Vue.useStore</h2><ul><li>在 Vue3 Composition API 中使用 Vuex</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = useStore();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>Vuex4 原理探究</h1><blockquote><p>去除冗余代码看本质</p></blockquote><h2 id="Vuex4-是怎么注入-Vue-的">Vuex4 是怎么注入 Vue 的</h2><h3 id="install">install</h3><ul><li>Vuex 是以插件的形式在 Vue 中使用的，在 createApp 时调用 install 安装<ul><li>也就是我们常用的 Vue.use 函数<ul><li>插件列表中加入 plugin</li><li>执行 plugin 的安装函数</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3源码 app.use</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>&lt;<span class="title">HostElement</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  render: RootRenderFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate?: RootHydrateFunction</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CreateAppFunction</span>&lt;<span class="title">HostElement</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码....</span></span><br><span class="line">    <span class="keyword">const</span> app: App = (context.app = &#123;</span><br><span class="line">      _uid: uid++,</span><br><span class="line">      _component: rootComponent <span class="keyword">as</span> ConcreteComponent,</span><br><span class="line">      _props: rootProps,</span><br><span class="line">      _container: <span class="literal">null</span>,</span><br><span class="line">      _context: context,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略部分代码....</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">use</span>(<span class="params">plugin: Plugin, ...options: <span class="built_in">any</span>[]</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (installedPlugins.has(plugin)) &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warn(<span class="string">`Plugin has already been applied to target app.`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plugin &amp;&amp; isFunction(plugin.install)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin.install(app, ...options)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(plugin)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin(app, ...options)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`A plugin must either be a function or an object with an &quot;install&quot; `</span> +</span><br><span class="line">              <span class="string">`function.`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 省略部分代码 ....</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Store 类的 install，两种实现分别为挂载到全局和组件内访问<ul><li>实现通过 inject 获取<ul><li>详情见下文 app.provide 讲解</li></ul></li><li>实现 this.$store 获取<ul><li>将 store 挂载到全局 properties</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex4实现插件install</span></span><br><span class="line">install (app, injectKey) &#123;</span><br><span class="line">  <span class="comment">// 实现通过inject获取</span></span><br><span class="line">  app.provide(injectKey || storeKey, <span class="built_in">this</span>)</span><br><span class="line">  <span class="comment">// 实现this.$store获取</span></span><br><span class="line">  app.config.globalProperties.$store = <span class="built_in">this</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Provide / Inject 架构示意图</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)" alt="img"></p><blockquote><p>下面接着看 provide 实现</p></blockquote><h3 id="app-provide-实现">app.provide 实现</h3><ul><li>每个 Vue 组件都有一个 context 上下文对象</li><li>对 context 上下文中的 provides 对象进行赋值</li><li>createAppContext 是一个创建 App 上下文函数<ul><li>返回体中是一个具有一些常见的 Option（mixins、components 等）</li><li>Vue 的插件实现最主要的为其中一项 provides，具体实现方式为：<ul><li>将插件通过 key / value 的形式挂载到 app 上下文的 provides 对象上</li><li>inject 时，通过存入的 key 进行取出</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3 app.provide实现</span></span><br><span class="line"><span class="function"><span class="title">provide</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 已存在则警告</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; (key <span class="keyword">as</span> <span class="built_in">string</span> | symbol) <span class="keyword">in</span> context.provides) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`App already provides property with key &quot;<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>&quot;. `</span> +</span><br><span class="line">        <span class="string">`It will be overwritten with the new value.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将store放入context的provide中</span></span><br><span class="line">  context.provides[key <span class="keyword">as</span> <span class="built_in">string</span>] = value</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// context相关   context为上下文对象</span></span><br><span class="line"><span class="keyword">const</span> context = createAppContext()</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppContext</span>(<span class="params"></span>): <span class="title">AppContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app: <span class="literal">null</span> <span class="keyword">as</span> <span class="built_in">any</span>,</span><br><span class="line">    config: &#123;</span><br><span class="line">      isNativeTag: NO,</span><br><span class="line">      performance: <span class="literal">false</span>,</span><br><span class="line">      globalProperties: &#123;&#125;,</span><br><span class="line">      optionMergeStrategies: &#123;&#125;,</span><br><span class="line">      errorHandler: <span class="literal">undefined</span>,</span><br><span class="line">      warnHandler: <span class="literal">undefined</span>,</span><br><span class="line">      compilerOptions: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mixins: [],</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    directives: &#123;&#125;,</span><br><span class="line">    provides: <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useStore-的实现">useStore 的实现</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useStore</span>(<span class="params">key = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> inject(key !== <span class="literal">null</span> ? key : storeKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-provide">Vue.provide</h3><ul><li>Vue 的 provide API 也比较简单，相当于直接通过 key/value 赋值</li><li>当前实例 provides 和父级实例 provides 相同时，通过原型链建立连接</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3 provide实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">provide</span>&lt;<span class="title">T</span>&gt;(<span class="params">key: InjectionKey&lt;T&gt; | <span class="built_in">string</span> | <span class="built_in">number</span>, value: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!currentInstance) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      warn(<span class="string">`provide() can only be used inside setup().`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> provides = currentInstance.provides;</span><br><span class="line">    <span class="keyword">const</span> parentProvides =</span><br><span class="line">      currentInstance.parent &amp;&amp; currentInstance.parent.provides;</span><br><span class="line">    <span class="keyword">if</span> (parentProvides === provides) &#123;</span><br><span class="line">      provides = currentInstance.provides = <span class="built_in">Object</span>.create(parentProvides);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TS doesn&#x27;t allow symbol as index type</span></span><br><span class="line">    provides[key <span class="keyword">as</span> <span class="built_in">string</span>] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-inject">Vue.inject</h3><ul><li>通过 provide 时存入的 key 取出 store</li><li>有父级实例则取父级实例的 provides，没有则取根实例的 provides</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3 inject实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inject</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key: InjectionKey&lt;<span class="built_in">any</span>&gt; | <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  treatDefaultAsFactory = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = currentInstance || currentRenderingInstance;</span><br><span class="line">  <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">    <span class="comment">// 有父级实例则取父级实例的provides，没有则取根实例的provides</span></span><br><span class="line">    <span class="keyword">const</span> provides =</span><br><span class="line">      instance.parent == <span class="literal">null</span></span><br><span class="line">        ? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides</span><br><span class="line">        : instance.parent.provides;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过provide时存入的key取出store</span></span><br><span class="line">    <span class="keyword">if</span> (provides &amp;&amp; (key <span class="keyword">as</span> <span class="built_in">string</span> | symbol) <span class="keyword">in</span> provides) &#123;</span><br><span class="line">      <span class="keyword">return</span> provides[key <span class="keyword">as</span> <span class="built_in">string</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略一部分代码......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注入">注入</h3><ul><li>为什么每个组件实例都有 Store 对象了?<ul><li>在创建组件实例的时候注入了 provides<ul><li>优先注入父级 provides</li><li>兜底为注入 app 上下文的 provides</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponentInstance</span>(<span class="params">vnode, parent, suspense</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">type</span> = vnode.type;</span><br><span class="line">  <span class="keyword">const</span> appContext =</span><br><span class="line">    (parent ? parent.appContext : vnode.appContext) || emptyAppContext;</span><br><span class="line">  <span class="keyword">const</span> instance = &#123;</span><br><span class="line">    parent,</span><br><span class="line">    appContext,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    provides: parent ? parent.provides : <span class="built_in">Object</span>.create(appContext.provides),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可从 vue 中引入 provide、inject、getCurrentInstance 等 API 进行库开发 / 高阶用法，这里不过多赘述。</p></blockquote><h2 id="Vuex4-执行机制">Vuex4 执行机制</h2><h3 id="createStore">createStore</h3><ul><li>从 createStore 开始看起<ul><li>可以发现 Vuex4 中的 state 是通过 reactive API 去创建的响应式数据，Vuex3 中是通过 new Vue 实例</li><li>dispatch、commit 的实现基本是封装了一层执行，底层也是通过 store 去执行，不用过于关心</li><li>而 Vuex4 的响应式实现，同样是借用了 Vue3 的响应式 API reactive</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex4源码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Store(options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">    <span class="built_in">this</span>._committing = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>._actionSubscribers = [];</span><br><span class="line">    <span class="built_in">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options);</span><br><span class="line">    <span class="built_in">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>._subscribers = [];</span><br><span class="line">    <span class="built_in">this</span>._makeLocalGettersCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind commit and dispatch to self</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span>(<span class="params"><span class="keyword">type</span>, payload</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dispatch.call(store, <span class="keyword">type</span>, payload);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span>(<span class="params"><span class="keyword">type</span>, payload, options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> commit.call(store, <span class="keyword">type</span>, payload, options);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> state = <span class="built_in">this</span>._modules.root.state;</span><br><span class="line">    installModule(<span class="built_in">this</span>, state, [], <span class="built_in">this</span>._modules.root);</span><br><span class="line">    resetStoreState(<span class="built_in">this</span>, state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreState</span>(<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略若干代码...</span></span><br><span class="line">  store._state = reactive(&#123;</span><br><span class="line">    data: state,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 省略若干代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="installModule">installModule</h3><blockquote><p>installModule 主要为按序初始化各模块，主要功能代码已高亮</p></blockquote><ol><li><blockquote><p>Mutation</p></blockquote></li><li><blockquote><p>Action</p></blockquote></li><li><blockquote><p>Getter</p></blockquote></li><li><blockquote><p>Child（install）</p></blockquote></li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span>(<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">namespace</span> = store._modules.getNamespace(path);</span><br><span class="line"></span><br><span class="line">  // register in <span class="keyword">namespace</span> map</span><br><span class="line">  if (module.namespaced) &#123;</span><br><span class="line">    <span class="keyword">if</span> (store._modulesNamespaceMap[<span class="keyword">namespace</span>] &amp;&amp; __DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">`[vuex] duplicate namespace <span class="subst">$&#123;<span class="keyword">namespace</span>&#125;</span> for the namespaced module <span class="subst">$&#123;path.join(</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="string">&#x27;/&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    store._modulesNamespaceMap[<span class="keyword">namespace</span>] = module;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set state</span><br><span class="line">  if (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>];</span><br><span class="line">    store._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="keyword">if</span> (moduleName <span class="keyword">in</span> parentState) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(</span><br><span class="line">            <span class="string">`[vuex] state field &quot;<span class="subst">$&#123;moduleName&#125;</span>&quot; was overridden by a module with the same name at &quot;<span class="subst">$&#123;path.join(</span></span></span><br><span class="line"><span class="string"><span class="subst">              <span class="string">&#x27;.&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">            )&#125;</span>&quot;`</span></span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      parentState[moduleName] = <span class="built_in">module</span>.state;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = (<span class="built_in">module</span>.context = makeLocalContext(store, <span class="keyword">namespace</span>, path));</span><br><span class="line"></span><br><span class="line">  module.forEachMutation((mutation, key) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = <span class="keyword">namespace</span> + key;</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  module.forEachAction((action, key) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">type</span> = action.root ? key : <span class="keyword">namespace</span> + key;</span><br><span class="line">    const handler = action.handler || action;</span><br><span class="line">    registerAction(store, type, handler, local);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  module.forEachGetter((getter, key) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = <span class="keyword">namespace</span> + key;</span><br><span class="line">    registerGetter(store, namespacedType, getter, local);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  module.forEachChild((child, key) =&gt; &#123;</span><br><span class="line">    installModule(store, rootState, path.concat(key), child, hot);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="订阅机制">订阅机制</h3><blockquote><p>看完了 Vuex4 是如何安装和注入的，最后来看看 Vuex 的订阅机制是如何实现的</p></blockquote><ul><li>和订阅机制有关的方法主要有<ul><li>订阅：subscribe、subscribeAction，分别用于订阅 Mutation 和 Action</li><li>执行：commit、dispatch，分别用于执行</li></ul></li><li>数据项有：_actionSubscribers、_subscribers</li></ul><h4 id="subscribe">subscribe</h4><blockquote><p>订阅 store 的 mutation。<code>handler</code> 会在每个 mutation 完成后调用，接收 mutation 和经过 mutation 后的状态作为参数</p></blockquote><blockquote><p>所有的订阅 callback 都会被放入<code>this._subscribers</code>，可通过 prepend 选项选择放入队头 / 队尾。</p></blockquote><ol><li>将 callback 推入订阅数组</li><li>返回一个取消订阅的函数</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法   该方法会返回一个取消订阅的函数</span></span><br><span class="line">store.subscribe(<span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(action.type)</span><br><span class="line">    <span class="built_in">console</span>.log(action.payload)</span><br><span class="line">&#125;, &#123; <span class="attr">prepend</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe  Vuex4源码实现</span></span><br><span class="line">subscribe (fn, options) &#123;</span><br><span class="line">    <span class="keyword">return</span> genericSubscribe(fn, <span class="built_in">this</span>._subscribers, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genericSubscribe</span> (<span class="params">fn, subs, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subs.indexOf(fn) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        options &amp;&amp; options.prepend</span><br><span class="line">            ? subs.unshift(fn)</span><br><span class="line">            : subs.push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> i = subs.indexOf(fn)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            subs.splice(i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接着看看 commit 执行时如何触发这些订阅的 callback</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210905101036157.png" alt="image-20210905101036157"></p><ol><li>执行需 commit 的函数</li><li>依次执行<code>this._subscribers</code>中的订阅 callback</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commit实现</span></span><br><span class="line">commit (_type, _payload, _options) &#123;</span><br><span class="line">    <span class="comment">// check object-style commit</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        payload,</span><br><span class="line">        options</span><br><span class="line">    &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> mutation = &#123; <span class="keyword">type</span>, payload &#125;</span><br><span class="line">    <span class="keyword">const</span> entry = <span class="built_in">this</span>._mutations[<span class="keyword">type</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行需commit的函数</span></span><br><span class="line">    <span class="built_in">this</span>._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">            handler(payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)x</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行订阅函数</span></span><br><span class="line">    <span class="built_in">this</span>._subscribers</span><br><span class="line">        .slice() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">        .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(mutation, <span class="built_in">this</span>.state))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="subscribeAction">subscribeAction</h4><blockquote><p>订阅 store 的 action。<code>handler</code> 会在每个 action 分发的时候调用并接收 action 描述和当前的 store 的 state 这两个参数</p></blockquote><blockquote><p>可订阅：执行前、执行后和错误</p></blockquote><ol><li>将订阅对象推入<code>this._actionSubscribers</code></li><li>返回一个取消订阅函数</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line">store.subscribeAction(&#123;</span><br><span class="line">    before: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`before action <span class="subst">$&#123;action.<span class="keyword">type</span>&#125;</span>`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    after: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`after action <span class="subst">$&#123;action.<span class="keyword">type</span>&#125;</span>`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">action, state, error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`error action <span class="subst">$&#123;action.<span class="keyword">type</span>&#125;</span>`</span>)</span><br><span class="line">        <span class="built_in">console</span>.error(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">prepend</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vuex4源码实现</span></span><br><span class="line">subscribeAction (fn, options) &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> ? &#123; <span class="attr">before</span>: fn &#125; : fn</span><br><span class="line">    <span class="keyword">return</span> genericSubscribe(subs, <span class="built_in">this</span>._actionSubscribers, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genericSubscribe</span> (<span class="params">fn, subs, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subs.indexOf(fn) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        options &amp;&amp; options.prepend</span><br><span class="line">            ? subs.unshift(fn)</span><br><span class="line">            : subs.push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> i = subs.indexOf(fn)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            subs.splice(i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>dispatch 执行时如何触发这些订阅函数？</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210905101145134.png" alt="image-20210905101145134"></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex4源码实现</span></span><br><span class="line">dispatch (_type, _payload) &#123;</span><br><span class="line">  <span class="comment">// check object-style dispatch</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    payload</span><br><span class="line">  &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = &#123; <span class="keyword">type</span>, payload &#125;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="built_in">this</span>._actions[<span class="keyword">type</span>]</span><br><span class="line">  <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown action type: <span class="subst">$&#123;<span class="keyword">type</span>&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// before订阅执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._actionSubscribers</span><br><span class="line">      .slice() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">      .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.before)</span><br><span class="line">      .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.before(action, <span class="built_in">this</span>.state))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in before action subscribers: `</span>)</span><br><span class="line">      <span class="built_in">console</span>.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// action执行</span></span><br><span class="line">  <span class="keyword">const</span> result = entry.length &gt; <span class="number">1</span></span><br><span class="line">    ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload)))</span><br><span class="line">    : entry[<span class="number">0</span>](payload)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// after订阅执行</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._actionSubscribers</span><br><span class="line">          .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after)</span><br><span class="line">          .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after(action, <span class="built_in">this</span>.state))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in after action subscribers: `</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// error订阅执行</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._actionSubscribers</span><br><span class="line">          .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.error)</span><br><span class="line">          .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.error(action, <span class="built_in">this</span>.state, error))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in error action subscribers: `</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>一句话总结</h1><blockquote><p>Vuex3 -&gt; Vuex4，主要实现方式将 mixin 注入改为了 provides / inject 的方式注入。</p></blockquote><blockquote><p>Provide / Inject 不仅用于 Vuex 实现，同样可以用于深层组件的数据传递</p></blockquote><blockquote><p>提示：<code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p></blockquote><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vuex4 源码解析&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vuex 是在 Vue 中常用的状态管理库，在 Vue3 发布后，这个状态管理库也随之发出了适配 Vue3 的 Vuex4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;快速过 Vuex3.x 原理&lt;/h1&gt;
&lt;u</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="Vue" scheme="https://lebronchao.com/tags/Vue/"/>
    
    <category term="SPA" scheme="https://lebronchao.com/tags/SPA/"/>
    
    <category term="源码分析" scheme="https://lebronchao.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅地操作数据库？ORM了解一下</title>
    <link href="https://lebronchao.com/2021/09/05/ORM/"/>
    <id>https://lebronchao.com/2021/09/05/ORM/</id>
    <published>2021-09-05T02:24:50.000Z</published>
    <updated>2021-09-05T02:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是 ORM</h1><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/orm.jpg" alt="img"></p><p>对象关系映射（Object Relational Mapping，简称 ORM），是一种程序技术，实现面向对象编程语言中的内存对象与关系型数据库中的业务实体之间的关系映射。这样在我们操作数据库的时候，不再需要和复杂的 SQL 语句打交道，只需要简单地操作对象的属性和方法就可以直接实现对数据库中对应实体表的 CRUD（增删改查）的操作。常见的 ORM 框架有 Node.js 的 TypeOrm、Sequlize，Java 的 Hibernate、Mybatis 和 Go 的 Gorm、GoRose 等。</p><ul><li>ORM 的方法论基于三个核心原则<ul><li>简单：以最基本的形式建模数据</li><li>传达性：数据库结构被任何人都能理解的语言文档化</li><li>精确性：基于数据模型创建正确、标准化的结构</li></ul></li></ul><h1>为什么会出现 ORM</h1><blockquote><p>面向对象编程语言和关系型数据库都是目前最流行的技术，但他们的模型是不一样的。</p></blockquote><ul><li>几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。</li><li>以 MVC 分层模式为例。Model 作为数据承载实体，在用户界面和业务逻辑层之间，数据以面向对象的形式传递；而当我们需要通过 Controller 分发请求把数据持久化的时候，我们就遇到了内存中的对象如何持久化成关系数据库中存储的一条实际数据记录的问题。</li><li>面向对象是从软件工程的基本原则，即封装，继承，多态的基础上发展起来的；而关系型数据库则是从数学理论的基础上发展起来的，两者之间是不匹配的。所有就出现了 ORM 以项目中间件的形式实现数据在不同场景下的数据关系映射。。而对象关系映射就是这样一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。在其基础上诞生很多对象和关系之间的映射框架，也即 ORM 技术。</li></ul><h1>ORM 的使用 以 Sequelize 为例</h1><blockquote><p>仅示例，更多操作可参考</p></blockquote><ul><li><a href="https://www.sequelize.com.cn/">Sequelize 中文文档</a></li><li><a href="https://github.com/RobinBuschmann/sequelize-typescript">RobinBuschmann/sequelize-typescript</a></li></ul><p>Sequelize 是一个基于 Promise 的 Node.js <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a>, 目前支持 <a href="https://en.wikipedia.org/wiki/PostgreSQL">Postgres</a>, <a href="https://en.wikipedia.org/wiki/MySQL">MySQL</a>, <a href="https://en.wikipedia.org/wiki/MariaDB">MariaDB</a>, <a href="https://en.wikipedia.org/wiki/SQLite">SQLite</a> 以及 <a href="https://en.wikipedia.org/wiki/Microsoft_SQL_Server">Microsoft SQL Server</a>. 它具有强大的事务支持, 关联关系, 预读和延迟加载,读取复制等功能。</p><p>Sequelize 遵从 <a href="http://semver.org/">语义版本控制</a>。 支持 Node v10 及更高版本以便使用 ES6 功能。</p><h2 id="连接数据库">连接数据库</h2><ul><li>设置使用 sequlize 插件，并配置要连接的数据库</li></ul><h2 id="定义-Model">定义 Model</h2><blockquote><p>通过面向对象 Class 和 关系型数据库的表建立连接</p><p>@Column 表示数据库的一列</p><p>@PrimaryKey 表示主键</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">tsimport &#123;</span><br><span class="line">  Column,</span><br><span class="line">  Model,</span><br><span class="line">  PrimaryKey,</span><br><span class="line">  Table,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@gulu/sequelize/typescript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> GameType &#123;</span><br><span class="line">  micro_game = <span class="string">&#x27;micro_game&#x27;</span>,</span><br><span class="line">  mobile_game = <span class="string">&#x27;mobile_game&#x27;</span>,</span><br><span class="line">  micro_app = <span class="string">&#x27;micro_app&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Table</span>(&#123; <span class="attr">modelName</span>: <span class="string">&#x27;game&#x27;</span>, <span class="attr">timestamps</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">GameModel</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="meta">@PrimaryKey</span></span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  gameId!: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  name!: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  description?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  <span class="keyword">type</span>!: GameType;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  icon?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  isDelete!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作数据库">操作数据库</h2><blockquote><p>通过 Model 的方法操作数据库</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> GameModel <span class="keyword">from</span> <span class="string">&#x27;../model/game&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏列表查询服务</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">query</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> GameModel.findAll(&#123;</span><br><span class="line">    <span class="comment">// 去除软删除字段</span></span><br><span class="line">    attributes: &#123;</span><br><span class="line">      exclude: [<span class="string">&#x27;isDelete&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 查询未被软删除的游戏</span></span><br><span class="line">    where: &#123;</span><br><span class="line">      isDelete: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相当于以下 SQL 语句</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> gameId, name, description, type, icon <span class="keyword">from</span> game <span class="keyword">where</span> isDelete <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>当然 Sequlize 也支持 SQL 语句查询</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> GameModel <span class="keyword">from</span> <span class="string">&#x27;../model/game&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏列表查询服务</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">query</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> GameModel.sequelize.query(</span><br><span class="line">      <span class="string">&#x27;select gameId, name, description, type, icon from game where isDelete = 0&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>ORM 的优缺点</h1><blockquote><p>优点</p></blockquote><ol><li>隐藏了数据访问的细节，“封闭”的通用数据库交互是 ORM 的核心。他使得我们的通用数据库交互变得简单易行，并且完全不用考虑 SQL 语句。</li><li>开发效率更高，ORM 使我们构造固化数据变得简单易行，在 ORM 诞生前，我们需要见过我们的对象模型转化为一条一条的 SQL 语句，通过直连或者是 DB helper 在关系数据库构造我们的数据库体系。而现在，基本上所有的 ORM 框架都提供了通过对象模型构造关系数据库结构的功能。</li><li>数据访问更抽象、轻便，支持面向对象封装。数据模型都在一个地方定义，更容易更新和维护，也利于重用代码</li><li>ORM 有现成的工具，很多功能都可以自动完成，比如数据消毒、预处理、事务等等。</li><li>它迫使你使用 MVC 架构，ORM 就是天然的 Model，最终使代码更清晰。</li><li>基于 ORM 的业务代码比较简单，代码量少，语义性好，容易理解。</li><li>防范 SQL 注入攻击</li><li>不必编写性能不佳的 SQL。</li></ol><blockquote><p>缺点</p></blockquote><ol><li>无可避免的，自动化意味着映射和关联管理，代价是牺牲性能。现在的各种 ORM 框架都在尝试使用各种方法来减轻性能上的损失，如懒加载技术、缓存技术等。</li><li>面向对象的查询语言作为一种数据库与对象之间的过渡，虽然隐藏了数据层面的业务抽象，但并不能完全屏蔽数据库层的设计。ORM 库也不是轻量级的工具，需要花很多精力学习和设置，无疑将增加学习成本。</li><li>ORM 难以实现过于复杂的查询。虽然可以实现，但是需要花费很大的代价（性能不如原生 SQL）。</li><li>持久化层缺乏弹性，一旦出现业务需求变更，就必须修改持久化层的接口</li><li>持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化层相关程序代码，增加了软件的维护难度。</li></ol><blockquote><p>什么是“持久化” 层</p></blockquote><ul><li><p>持久（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML 数据文件中等等。</p></li><li><p>总结：当下 ORM 的开发模式是主流，提高了代码的封装性和可读性，同时防范了 SQL 注入攻击。以较小量级的性能损失换来了明显的开发效率提升，明显的性能损失往往存在于复杂的查询，这种情况可以选择使用 ORM 提供的 SQL 语句接口进行查询以优化性能。</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;什么是 ORM&lt;/h1&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/orm.jp</summary>
      
    
    
    
    <category term="Back End" scheme="https://lebronchao.com/categories/Back-End/"/>
    
    
    <category term="数据库" scheme="https://lebronchao.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="TypeScript" scheme="https://lebronchao.com/tags/TypeScript/"/>
    
    <category term="Node" scheme="https://lebronchao.com/tags/Node/"/>
    
    <category term="ORM" scheme="https://lebronchao.com/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>[深入浅出LB]手把手带你实现一个负载均衡器</title>
    <link href="https://lebronchao.com/2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://lebronchao.com/2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2021-08-01T16:11:46.000Z</published>
    <updated>2021-08-01T16:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Load Balance 负载均衡 🌡</h1><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20210622002849831.(null)" alt="img"></p><blockquote><p>简介</p></blockquote><p>负载均衡，含义就是根据一定算法将负载（工作任务）进行平衡，分摊到多个操作单元上运行、执行，常见的为 Web 服务器、企业核心应用服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡在原有的网络结构上提供了一种透明且有效的的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性，同时承受住更大的并发量级。</p><blockquote><p>简单来说就是将大量的并发请求处理转发给多个后端节点处理，减少工作响应时间。</p></blockquote><ul><li><p>避免资源浪费</p></li><li><p>避免服务不可用</p></li></ul><h1>一、分类</h1><h2 id="四层（传输层）">四层（传输层）</h2><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622002908874.png" alt="image-20210622002908874"></p><p>四层即 OSI 七层模型中的传输层，有 TCP、UDP 协议，这两种协议中包含源 IP、目标 IP 以外，还包含源端口号及目标端口号。四层负载均衡在接收到客户端请求后，通过修改报文的地址信息（IP + PORT）将流量转发到应用服务器。</p><h2 id="七层（应用层）">七层（应用层）</h2><blockquote><p>代理负载均衡</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622002927473.png" alt="image-20210622002927473"></p><p>七层即 OSI 七层模型中的应用层，应用层协议较多，常用的为 HTTP/HTTPS。七层负载均衡可以给予这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个 Web 服务器的负载均衡，除了根据 IP + PORT 进行负载均衡，还可以根据七层的 URL、Cookie、浏览器类别、语言、请求类型来决定。</p><blockquote><p>四层负载均衡的本质是转发，七层负载均衡的本质是内容交换和代理。</p></blockquote><table><thead><tr><th></th><th><strong>四层负载均衡</strong></th><th><strong>七层负载均衡</strong></th></tr></thead><tbody><tr><td><strong>基于</strong></td><td>IP + PORT</td><td>URL 或 主机 IP</td></tr><tr><td><strong>类似</strong></td><td>路由器</td><td>代理服务器</td></tr><tr><td><strong>复杂度</strong></td><td>低</td><td>高</td></tr><tr><td><strong>性能</strong></td><td>高，无需解析内容</td><td>中，需算法识别 URL Header、Cookie 等</td></tr><tr><td><strong>安全性</strong></td><td>低，无法识别 DDoS 攻击</td><td>高，可防御 SYN Flood 攻击</td></tr><tr><td><strong>扩展功能</strong></td><td>无</td><td>内容缓存、图片防盗链等</td></tr></tbody></table><h1>二、常见算法</h1><blockquote><p>前置数据结构</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> urlObj&#123;</span><br><span class="line">  url:<span class="built_in">string</span>,</span><br><span class="line">  weight:<span class="built_in">number</span> <span class="comment">// 仅在权重轮询时生效</span></span><br><span class="line">&#125;</span><br><span class="line">urlDesc: urlObj[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> urlCollectObj&#123;</span><br><span class="line">  count: <span class="built_in">number</span>, <span class="comment">// 连接数</span></span><br><span class="line">  costTime: <span class="built_in">number</span>, <span class="comment">// 响应时间</span></span><br><span class="line">  connection: <span class="built_in">number</span>, <span class="comment">// 实时连接数</span></span><br><span class="line">&#125;</span><br><span class="line">urlCollect: urlCollectObj[]</span><br></pre></td></tr></table></figure><h2 id="Random">Random</h2><blockquote><p>随机</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622002949591.png" alt="image-20210622002949591"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Random = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  收集url</span></span><br><span class="line">  urlDesc.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    urlCollect.push(val.url);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  生成随机数下标返回相应URL</span></span><br><span class="line">    <span class="keyword">const</span> pos = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * urlCollect.length);</span><br><span class="line">    <span class="keyword">return</span> urlCollect[pos];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Random;</span><br></pre></td></tr></table></figure><h2 id="Weighted-Round-Robin">Weighted Round Robin</h2><blockquote><p>权重轮询算法</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622003000250.png" alt="image-20210622003000250"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WeiRoundRobin = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span>,</span><br><span class="line">    urlCollect = [],</span><br><span class="line">    copyUrlDesc = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(urlDesc));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据权重收集url</span></span><br><span class="line">  <span class="keyword">while</span> (copyUrlDesc.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copyUrlDesc.length; i++) &#123;</span><br><span class="line">      urlCollect.push(copyUrlDesc[i].url);</span><br><span class="line">      copyUrlDesc[i].weight--;</span><br><span class="line">      <span class="keyword">if</span> (copyUrlDesc[i].weight === <span class="number">0</span>) &#123;</span><br><span class="line">        copyUrlDesc.splice(i, <span class="number">1</span>);</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 轮询获取URL函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = urlCollect[pos++];</span><br><span class="line">    <span class="keyword">if</span> (pos === urlCollect.length) &#123;</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WeiRoundRobin;</span><br></pre></td></tr></table></figure><h2 id="IP-Hash-URL-Hash">IP Hash &amp; URL Hash</h2><blockquote><p>源 IP / URL Hash</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622003030857.png" alt="image-20210622003030857"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Hash &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../util&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IpHash = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlDesc) &#123;</span><br><span class="line">    <span class="comment">// 收集url</span></span><br><span class="line">    urlCollect.push(urlDesc[key].url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">sourceInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 生成Hash十进制数值</span></span><br><span class="line">    <span class="keyword">const</span> hashInfo = Hash(sourceInfo);</span><br><span class="line">    <span class="comment">// 取余为下标</span></span><br><span class="line">    <span class="keyword">const</span> urlPos = <span class="built_in">Math</span>.abs(hashInfo) % urlCollect.length;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> urlCollect[urlPos];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = IpHash;</span><br></pre></td></tr></table></figure><h2 id="Consistent-Hash">Consistent Hash</h2><blockquote><p>一致性 Hash</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622003051914.png" alt="image-20210622003051914"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Hash &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../util&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ConsistentHash = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlHashMap = &#123;&#125;,</span><br><span class="line">    hashCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlDesc) &#123;</span><br><span class="line">    <span class="comment">// 收集urlHash进数组和生成HashMap</span></span><br><span class="line">    <span class="keyword">const</span> &#123; url &#125; = urlDesc[key];</span><br><span class="line">    <span class="keyword">const</span> hash = Hash(url);</span><br><span class="line">    urlHashMap[hash] = url;</span><br><span class="line">    hashCollect.push(hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将hash数组从小到大排序</span></span><br><span class="line">  hashCollect = hashCollect.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">sourceInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 生成Hash十进制数值</span></span><br><span class="line">    <span class="keyword">const</span> hashInfo = Hash(sourceInfo);</span><br><span class="line">    <span class="comment">// 遍历hash数组找到第一个比源信息hash值大的，并通过hashMap返回url</span></span><br><span class="line">    hashCollect.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &gt;= hashInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> urlHashMap[val];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 没找大则返回最大的</span></span><br><span class="line">    <span class="keyword">return</span> urlHashMap[hashCollect[hashCollect.length - <span class="number">1</span>]];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ConsistentHash;</span><br></pre></td></tr></table></figure><h2 id="Least-Connections">Least Connections</h2><blockquote><p>最小连接数</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622003136462.png" alt="image-20210622003136462"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> leastConnections = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">urlCollect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.POSITIVE_INFINITY,</span><br><span class="line">      url = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历对象找到最少连接数的地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> urlCollect) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = urlCollect[key].connection;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; min) &#123;</span><br><span class="line">        min = val;</span><br><span class="line">        url = key;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = leastConnections;</span><br></pre></td></tr></table></figure><blockquote><p>注：urlCollect 为负载均属数据统计对象，有以下属性</p></blockquote><ul><li><p>connection 实时连接数</p></li><li><p>count 处理请求次数</p></li><li><p>costTime 响应时间。</p></li></ul><h2 id="FAIR">FAIR</h2><blockquote><p>最小响应时间</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622003155965.png" alt="image-20210622003155965"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Fair = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">urlCollect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.POSITIVE_INFINITY,</span><br><span class="line">      url = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到耗时最少的url</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlCollect) &#123;</span><br><span class="line">      <span class="keyword">const</span> urlObj = urlCollect[key];</span><br><span class="line">      <span class="keyword">if</span> (urlObj.costTime &lt; min) &#123;</span><br><span class="line">        min = urlObj.costTime;</span><br><span class="line">        url = key;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Fair;</span><br></pre></td></tr></table></figure><blockquote><p>看到这里是不是感觉算法都挺简单的 🥱</p></blockquote><blockquote><p>期待一下模块四的实现吧 😏</p></blockquote><h1>三、健康监测</h1><blockquote><p>健康监测即对应用服务器的健康监测，为防止把请求转发到异常的应用服务器上，应使用健康监测策略。应对不同的业务敏感程度，可相应调整策略和频率。</p></blockquote><h2 id="HTTP-HTTPS-健康监测步骤（七层）">HTTP / HTTPS 健康监测步骤（七层）</h2><ol><li>负载均衡节点向应用服务器发送 HEAD 请求。</li><li>应用服务器接收到 HEAD 请求后根据情况返回相应状态码。</li><li>若在超时时间内未收到返回的状态码，则判断为超时，健康检查失败。</li><li>若在超时时间内收到返回的状态码，负载均衡节点进行比对，判断健康检查是否成功。</li></ol><h2 id="TCP-健康检查步骤（四层）">TCP 健康检查步骤（四层）</h2><ol><li>负载均衡节点向内网应用服务器 IP + PORT 发 TCP SYN 请求数据包。</li><li>内网应用服务器收到请求后，若在正常监听，则返回 SYN + ACK 数据包。</li><li>若在超时时间内未收到返回的数据包，则判断服务无响应、健康检查失败，并向内网应用服务器发送 RST 数据包中断 TCP 连接。</li><li>若在超时时间内收到返回的数据包，则判定服务健康运行，发起 RST 数据包中断 TCP 连接。</li></ol><h2 id="UDP-健康检查步骤（四层）">UDP 健康检查步骤（四层）</h2><ol><li>负载均衡节点向内网应用服务器 IP + PORT 发送 UDP 报文。</li><li>若内网应用服务器未正常监听，则返回<code>PORT XX unreachable</code>的 ICMP 报错信息，反之为正常。</li><li>若在超时时间内收到了报错信息，则判断服务异常，健康检查失败。</li><li>若在超时时间内未收到报错信息，则判断服务健康运行。</li></ol><h1>四、VIP 技术</h1><blockquote><p>Vrtual IP</p></blockquote><h2 id="虚拟-IP">虚拟 IP</h2><ul><li>在 TCP / IP 架构下，所有想上网的电脑，不论以何种形式连上网络，都不需要有一个唯一的 IP 地址。事实上 IP 地址是主机硬件物理地址的一种抽象。</li><li>简单来说地址分为两种<ul><li>MAC 物理地址</li><li>IP 逻辑地址</li></ul></li><li>虚拟 IP 是一个未分配给真实主机的 IP，也就是说对外提供的服务器的主机除了有一个真实 IP 还有一个虚 IP，这两个 IP 中的任意一个都可以连接到这台主机。<ul><li>通过虚拟 IP 对应真实主机的 MAC 地址实现</li></ul></li><li>虚拟 IP 一般用作达到高可用的目的，比如让所有项目中的数据库链接配置都是这个虚拟 IP，当主服务器发生故障无法对外提供服务时，动态将这个虚 IP 切换到备用服务器。</li></ul><h2 id="虚拟-IP-原理">虚拟 IP 原理</h2><ol><li>ARP 是地址解析协议，作用为将一个 IP 地址转换为 MAC 地址。</li><li>每台主机都有 ARP 高速缓存，存储同一个网络内 IP 地址与 MAC 地址的映射关系，主机发送数据会先从这个缓存中查询目标 IP 对应 MAC 地址，向这个 MAC 地址发送数据。操作系统自动维护这个缓存。</li><li>Linux 下可用 ARP 命令操作 ARP 高速缓存</li></ol><ul><li><p>比如存在主机 A（192.168.1.6）和主机 B（192.168.1.8）。A 作为对外服务的主服务器，B 作为备份机器，两台服务器之间通过 HeartBeat 通信。</p></li><li><p>即主服务器会定时给备份服务器发送数据包，告知主服务器正常，当备份服务器在规定时间内没有收到主服务器的 HeartBeat，会认为主服务器宕机。</p></li><li><p>此时备份服务器就升级为主服务器。</p><ul><li>服务器 B 将自己的 ARP 缓存发送出去，告知路由器修改路由表，告知虚拟 IP 地址应该指向 192.168.1.8.</li><li>这时外接再次访问虚拟 IP 的时候，机器 B 就会变成主服务器，而 A 降级为备份服务器。</li><li>这样就完成了主从机器的切换，这一切对外都是无感知、透明的。</li></ul></li></ul><h1>五、基于 nodejs 实现一个简单的负载均衡</h1><h2 id="预期效果">预期效果</h2><blockquote><p>编辑 config.js 后<code>npm run start</code>即可启动均衡器和后端服务节点</p></blockquote><ul><li><p>urlDesc：后端服务节点配置对象，weight 仅在 WeightRoundRobin 算法时起作用</p></li><li><p>port：均衡器监听端口</p></li><li><p>algorithm：算法名称（模块二中的算法均已实现）</p></li><li><p>workerNum：后端服务端口开启进程数，提供并发能力。</p></li><li><p>balancerNum：均衡器端口开启进程数，提供并发能力。</p></li><li><p>workerFilePath：后端服务节点执行文件，推荐使用绝对路径。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ALGORITHM, BASE_URL&#125; = <span class="built_in">require</span>(<span class="string">&quot;./constant&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    urlDesc: [</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16666</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">6</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16667</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16668</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16669</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16670</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16671</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16672</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    algorithm: ALGORITHM.RANDOM,</span><br><span class="line">    workerNum: <span class="number">5</span>，</span><br><span class="line">    balancerNum: <span class="number">5</span>，</span><br><span class="line">    workerFilePath:path.resolve(__dirname, <span class="string">&quot;./worker.js&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="架构设计图">架构设计图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622003323078.png" alt="image-20210622003323078"></p><h2 id="先来看看主流程-main-js">先来看看主流程 main.js</h2><ol><li><p>初始化负载均衡统计对象 balanceDataBase</p><ul><li>balanceDataBase 是一个 DataBase 类实例，用于统计负载均衡数据（后续会讲到）.</li></ul></li><li><p>运行均衡器</p><ul><li>多进程模型，提供并发能力。</li></ul></li><li><p>运行后端服务节点</p><ul><li>多线程+多进程模型，运行多个服务节点并提供并发能力。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; urlDesc, balancerNum &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> &#123; DataBase &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./util&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; Worker &#125; = <span class="built_in">require</span>(<span class="string">&#x27;worker_threads&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runWorker = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 防止监听端口数 &gt; CPU核数</span></span><br><span class="line">  <span class="keyword">const</span> urlObjArr = urlDesc.slice(<span class="number">0</span>, cpusLen);</span><br><span class="line">  <span class="comment">// 初始化创建子线程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; urlObjArr.length; i++) &#123;</span><br><span class="line">    createWorkerThread(urlObjArr[i].url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runBalancer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置子进程执行文件</span></span><br><span class="line">  cluster.setupMaster(&#123; <span class="attr">exec</span>: path.resolve(__dirname, <span class="string">&#x27;./balancer.js&#x27;</span>) &#125;);</span><br><span class="line">  <span class="comment">// 初始化创建子进程</span></span><br><span class="line">  <span class="keyword">let</span> max;</span><br><span class="line">  <span class="keyword">if</span> (balancerNum) &#123;</span><br><span class="line">    max = balancerNum &gt; cpusLen ? cpusLen : balancerNum;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    createBalancer();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化负载均衡数据统计对象</span></span><br><span class="line"><span class="keyword">const</span> balanceDataBase = <span class="keyword">new</span> DataBase(urlDesc);</span><br><span class="line"><span class="comment">// 运行均衡器</span></span><br><span class="line">runBalancer();</span><br><span class="line"><span class="comment">// 运行后端服务节点</span></span><br><span class="line">runWorker();</span><br></pre></td></tr></table></figure><h3 id="创建均衡器（createBalancer-函数）">创建均衡器（createBalancer 函数）</h3><ol><li>创建进程</li><li>监听进程通信消息<ul><li>监听更新响应时间事件并执行更新函数<ul><li>用于 FAIR 算法（最小响应时间）。</li></ul></li><li>监听获取统计对象事件并返回</li></ul></li><li>监听异常退出并重新创建，进程守护。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createBalancer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建进程</span></span><br><span class="line">  <span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">  worker.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 监听更新响应时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (msg.type === <span class="string">&#x27;updateCostTime&#x27;</span>) &#123;</span><br><span class="line">      balanceDataBase.updateCostTime(msg.URL, msg.costTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听获取url统计对象事件并返回</span></span><br><span class="line">    <span class="keyword">if</span> (msg.type === <span class="string">&#x27;getUrlCollect&#x27;</span>) &#123;</span><br><span class="line">      worker.send(&#123;</span><br><span class="line">        type: <span class="string">&#x27;getUrlCollect&#x27;</span>,</span><br><span class="line">        urlCollect: balanceDataBase.urlCollect,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 监听异常退出事件并重新创建进程</span></span><br><span class="line">  worker.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    createBalancer();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="创建后端服务节点（createWorkerThread-函数）">创建后端服务节点（createWorkerThread 函数）</h3><ol><li><p>创建线程</p></li><li><p>解析需要监听的端口</p></li><li><p>向子线程通信，发送需要监听的端口</p></li><li><p>通过线程通信，监听子线程事件</p><ul><li><p>监听连接事件，并触发处理函数。</p></li><li><p>监听断开连接事件并触发处理函数。</p></li><li><p>用于统计负载均衡分布和实时连接数。</p></li></ul></li><li><p>监听异常退出并重新创建，线程守护。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createWorkerThread = <span class="function">(<span class="params">listenUrl</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 创建线程</span></span><br><span class="line">  <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(path.resolve(__dirname, <span class="string">&#x27;./workerThread.js&#x27;</span>));</span><br><span class="line">  <span class="comment">// 获取监听端口</span></span><br><span class="line">  <span class="keyword">const</span> listenPort = listenUrl.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// 向子线程发送要监听的端口号</span></span><br><span class="line">  worker.postMessage(&#123; <span class="attr">type</span>: <span class="string">&#x27;port&#x27;</span>, <span class="attr">port</span>: listenPort &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收子线程消息统计进程被访问次数</span></span><br><span class="line">  worker.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 监听连接事件并触发计数事件</span></span><br><span class="line">    <span class="keyword">if</span> (msg.type === <span class="string">&#x27;connect&#x27;</span>) &#123;</span><br><span class="line">      balanceDataBase.add(msg.port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听断开连接事件并触发计数事件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (msg.type === <span class="string">&#x27;disconnect&#x27;</span>) &#123;</span><br><span class="line">      balanceDataBase.sub(msg.port);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 监听异常退出事件并重新创建进程</span></span><br><span class="line">  worker.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    createWorkerThread(listenUrl);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="再来看看均衡器工作流程-balancer-js">再来看看均衡器工作流程 balancer.js</h2><ol><li>获取 getURL 工具函数</li><li>监听请求并代理<ol><li>获取需要传入 getURL 工具函数的参数。</li><li>通过 getURL 工具函数获取均衡代理目的地址 URL</li><li>记录请求开始时间</li><li>处理跨域</li><li>返回响应</li><li>通过进程通信，触发响应时间更新事件。</li></ol></li></ol><blockquote><p>注 1：LoadBalance 函数即通过算法名称返回不同的 getURL 工具函数，各算法实现见模块二：常见算法</p></blockquote><blockquote><p>注 2：getSource 函数即处理参数并返回，getURL 为上面讲到的获取 URL 工具函数。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> LoadBalance = <span class="built_in">require</span>(<span class="string">&#x27;./algorithm&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> &#123; urlFormat, ipFormat &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./util&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ALGORITHM, BASE_URL &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./constant&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; urlDesc, algorithm, port &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取转发URL工具函数</span></span><br><span class="line">  <span class="keyword">const</span> getURL = LoadBalance(urlDesc.slice(<span class="number">0</span>, cpusLen), algorithm);</span><br><span class="line">  <span class="comment">// 监听请求并均衡代理</span></span><br><span class="line">  app.get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取需要传入的参数</span></span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">await</span> getSource(req);</span><br><span class="line">    <span class="comment">// 获取URL</span></span><br><span class="line">    <span class="keyword">const</span> URL = getURL(source);</span><br><span class="line">    <span class="comment">// res.redirect(301, URL) 重定向负载均衡</span></span><br><span class="line">    <span class="comment">// 记录请求开始时间</span></span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="comment">// 代理请求</span></span><br><span class="line">    axios.get(URL).then(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 获取负载均衡统计对象并返回</span></span><br><span class="line">      <span class="keyword">const</span> urlCollect = <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">      <span class="comment">// 处理跨域</span></span><br><span class="line">      res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">      response.data.urlCollect = urlCollect;</span><br><span class="line">      <span class="comment">// 返回数据</span></span><br><span class="line">      res.send(response.data);</span><br><span class="line">      <span class="comment">// 记录相应时间并更新</span></span><br><span class="line">      <span class="keyword">const</span> costTime = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">      process.send(&#123; <span class="attr">type</span>: <span class="string">&#x27;updateCostTime&#x27;</span>, costTime, URL &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 负载均衡服务器开始监听请求</span></span><br><span class="line">  app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Load Balance Server Running at <span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getSource = <span class="keyword">async</span> (req) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (algorithm) &#123;</span><br><span class="line">    <span class="keyword">case</span> ALGORITHM.IP_HASH:</span><br><span class="line">      <span class="keyword">return</span> ipFormat(req);</span><br><span class="line">    <span class="keyword">case</span> ALGORITHM.URL_HASH:</span><br><span class="line">      <span class="keyword">return</span> urlFormat(req);</span><br><span class="line">    <span class="keyword">case</span> ALGORITHM.CONSISTENT_HASH:</span><br><span class="line">      <span class="keyword">return</span> urlFormat(req);</span><br><span class="line">    <span class="keyword">case</span> ALGORITHM.LEAST_CONNECTIONS:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">    <span class="keyword">case</span> ALGORITHM.FAIR:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="如何在均衡器中获取负载均衡统计对象-getUrlCollect">如何在均衡器中获取负载均衡统计对象 getUrlCollect</h3><ol><li>通过进程通信，向父进程发送获取消息。</li><li>同时开始监听父进程通信消息，接收后使用 Promise resovle 返回。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取负载均衡统计对象</span></span><br><span class="line"><span class="keyword">const</span> getUrlCollect = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      process.send(&#123; <span class="attr">type</span>: <span class="string">&#x27;getUrlCollect&#x27;</span> &#125;);</span><br><span class="line">      process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&#x27;getUrlCollect&#x27;</span>) &#123;</span><br><span class="line">          resolve(msg.urlCollect);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="如何实现服务节点并发-workerThread-js">如何实现服务节点并发 workerThread.js</h2><blockquote><p>使用多线程+多进程模型，为每个服务节点提供并发能力。</p></blockquote><h3 id="主进程流程">主进程流程</h3><ol><li>根据配置文件，创建相应数量服务节点。<ol><li>创建进程</li><li>监听父线程消息（服务节点监听端口），并转发给子进程。</li><li>监听子进程消息，并转发给父线程（建立连接、断开连接事件）。</li><li>监听异常退出并重新建立。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> &#123; parentPort &#125; = <span class="built_in">require</span>(<span class="string">&#x27;worker_threads&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; workerNum, workerFilePath &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="comment">// 创建工作进程函数</span></span><br><span class="line">  <span class="keyword">const</span> createWorker = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">    <span class="comment">// 监听父线程消息，并转发给子进程。</span></span><br><span class="line">    parentPort.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.type === <span class="string">&#x27;port&#x27;</span>) &#123;</span><br><span class="line">        worker.send(&#123; <span class="attr">type</span>: <span class="string">&#x27;port&#x27;</span>, <span class="attr">port</span>: msg.port &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 监听子进程消息并转发给父线程</span></span><br><span class="line">    worker.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">      parentPort.postMessage(msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 监听进程异常退出并重新创建</span></span><br><span class="line">    worker.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      createWorker();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 按配置创建进程，但不可大于CPU核数</span></span><br><span class="line">  <span class="keyword">let</span> max;</span><br><span class="line">  <span class="keyword">if</span> (workerNum) &#123;</span><br><span class="line">    max = workerNum &gt; cpusLen ? cpusLen : workerNum;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    createWorker();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 后端服务执行文件</span></span><br><span class="line">  <span class="built_in">require</span>(workerFilePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子进程流程-worker-js（config-workerFilePath）">子进程流程 worker.js（config.workerFilePath）</h3><ol><li>通过进程间通信，向父进程发送消息，触发建立连接事件。</li><li>返回相应。</li><li>通过进程间通信，向父进程发送消息，触发断开连接事件。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">let</span> port = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 触发连接事件</span></span><br><span class="line">  process.send(&#123; <span class="attr">type</span>: <span class="string">&#x27;connect&#x27;</span>, port &#125;);</span><br><span class="line">  <span class="comment">// 打印信息</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;HTTP Version: &#x27;</span> + req.httpVersion);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Connection PORT Is &#x27;</span> + port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">&#x27;Hello My PORT is &#x27;</span> + port;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回响应</span></span><br><span class="line">  res.send(&#123; msg &#125;);</span><br><span class="line">  <span class="comment">// 触发断开连接事件</span></span><br><span class="line">  process.send(&#123; <span class="attr">type</span>: <span class="string">&#x27;disconnect&#x27;</span>, port &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收主进通信消息中的端口口并监听</span></span><br><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.type === <span class="string">&#x27;port&#x27;</span>) &#123;</span><br><span class="line">    port = msg.port;</span><br><span class="line">    app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Worker Listening &#x27;</span> + port);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="最后来看看-DataBase-类">最后来看看 DataBase 类</h2><ul><li>成员：</li></ul><ol><li>status：任务队列状态</li><li>urlCollect：数据统计对象（提供给各算法使用 / 展示数据）<ol><li>count：处理请求数</li><li>costTime：响应时间</li><li>connection：实时连接数</li></ol></li><li>add 方法<ol><li>增加连接数和实时连接数</li></ol></li><li>sub 方法<ol><li>减少实时连接数</li></ol></li><li>updateCostTime 方法<ol><li>更新响应时间</li></ol></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBase</span> </span>&#123;</span><br><span class="line">  urlCollect = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">urlObj</span>)</span> &#123;</span><br><span class="line">    urlObj.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.urlCollect[val.url] = &#123;</span><br><span class="line">        count: <span class="number">0</span>,</span><br><span class="line">        costTime: <span class="number">0</span>,</span><br><span class="line">        connection: <span class="number">0</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//增加连接数和实时连接数</span></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">port</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">this</span>.urlCollect[url].count++;</span><br><span class="line">    <span class="built_in">this</span>.urlCollect[url].connection++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 减少实时连接数</span></span><br><span class="line">  <span class="function"><span class="title">sub</span>(<span class="params">port</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">this</span>.urlCollect[url].connection--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新响应时间</span></span><br><span class="line">  <span class="function"><span class="title">updateCostTime</span>(<span class="params">url, time</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.urlCollect[url].costTime = time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><blockquote><p>做了个可视化图表来看均衡效果(Random)✔️</p></blockquote><blockquote><p>看起来均衡效果还不错 🧐</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20210622003557369.(null)" alt="img"></p><h1>小作业</h1><blockquote><p>想手动实现一下负载均衡器 / 看看源码的同学都可以看看 👉🏻 <a href="https://github.com/LeBronChao/LoadBalancer">代码仓库</a></p></blockquote><h1>六、知识扩展</h1><h2 id="cluster-多进程为什么可以监听一个端口">cluster 多进程为什么可以监听一个端口?</h2><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20210622003752283.png" alt="image-20210622003752283"></p><ol><li>通过 cluster.isMaster 判断是否为主进程，主进程不负责任务处理，只负责管理和调度工作子进程。</li><li>master 主进程启动了一个 TCP 服务器，真正监听端口的只有这个 TCP 服务器。请求触发了这个 TCP 服务器的<code>connection</code>事件后，通过句柄转发（IPC）给工作进程处理。<ol><li>句柄转发可转发 TCP 服务器、TCP 套接字、UDP 套接字、IPC 管道</li><li>IPC 只支持传输字符串，不支持传输对象（可序列化）。</li><li>转发流程：父进程发送 -&gt; stringfy &amp;&amp; send(fd) -&gt; IPC -&gt; get(fd) &amp;&amp; parse -&gt; 子进程接收</li><li>fd 为句柄文件描述符。</li></ol></li><li>如何选择工作进程?<ol><li>cluster 模块内置了 RoundRobin 算法，轮询选择工作进程。</li></ol></li><li>为什么不直接用 cluster 进行负载均衡?<ol><li>手动实现可根据不同场景选择不同的负载均衡算法。</li></ol></li></ol><h2 id="Node-怎么实现进程间通信的？">Node 怎么实现进程间通信的？</h2><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20210622003758932.(null)" alt="img"></p><ol><li>常见的进程间通信方式<ol><li>管道通信<ol><li>匿名管道</li><li>命名管道</li></ol></li><li>信号量</li><li>共享内存</li><li>Socket</li><li>消息队列</li></ol></li><li>Node 中实现 IPC 通道是依赖于 libuv。Windows 下由命名管道实现，*nix 系统则采用 Domain Socket 实现。</li><li>表现在应用层上的进程间通信只有简单的 message 事件和 send()方法，接口十分简洁和消息化。</li><li>IPC 管道是如何建立的？<ol><li>父进程先通过环境变量告知子进程管道的文件描述符</li><li>父进程创建子进程</li><li>子进程启动，通过文件描述符连接已存在的 IPC 管道，与父进程建立连接。</li></ol></li></ol><h2 id="多进程-VS-多线程">多进程 VS 多线程</h2><h3 id="多进程">多进程</h3><ol><li>数据共享复杂，需要 IPC。数据是分开的，同步简单。</li><li>占用内存多，CPU 利用率低。</li><li>创建销毁复杂，速度慢</li><li>进程独立运行，不会相互影响</li><li>可用于多机多核分布式，易于扩展</li></ol><h3 id="多线程">多线程</h3><ol><li>共享进程数据，数据共享简单，同步复杂。</li><li>占用内存少，CPU 利用率高。</li><li>创建销毁简单，速度快。</li><li>线程同呼吸共命运。</li><li>只能用于多核分布式。</li></ol><h1>七、由本次分享产生的一些想法</h1><blockquote><p>欢迎留言讨论</p></blockquote><ol><li>Node.js 非阻塞异步 I/O 速度快，前端扩展服务端业务？</li><li>企业实践，说明 Node 还是可靠的？<ol><li>阿里 Node 中台架构</li><li>腾讯 CloudBase 云开发 Node</li><li>大量 Node.js 全栈工程师岗位</li></ol></li><li>Node 计算密集型不友好？<ol><li>Serverless 盛行，计算密集型用 C++/Go/Java 编写，以 Faas 的方式调用。</li></ol></li><li>Node 生态不如其他成熟的语言<ol><li>阿里输出了 Java 生态</li><li>是不是可以看准趋势，打造 Node 生态以增强团队影响力。</li></ol></li><li>未雨绸缪，将 Node &amp; 服务端业务知识加入学习计划 / 规划专题分享？</li><li>讨论</li></ol><ul><li><a href="https://www.zhihu.com/question/357717742/answer/926367671"> Node.js 做 Web 后端优势为什么这么大？ - 知乎 (zhihu.com)</a></li></ul><h1>八、参考资料</h1><ol><li><a href="https://help.aliyun.com/document_detail/85958.html">健康检查概述 - 负载均衡</a></li><li>《深入浅出 Node.js》</li><li><a href="http://nodejs.cn/">Node.js (nodejs.cn)</a></li><li><a href="https://juejin.cn/post/6844903908385488903#heading-17">深入理解 Node.js 中的进程与线程 </a></li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Load Balance 负载均衡 🌡&lt;/h1&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://lebronchao.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://lebronchao.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="负载均衡" scheme="https://lebronchao.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="Node" scheme="https://lebronchao.com/tags/Node/"/>
    
    <category term="进程" scheme="https://lebronchao.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="https://lebronchao.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="进程间通信" scheme="https://lebronchao.com/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>[建议收藏]你想知道的Vue3核心源码这里都有</title>
    <link href="https://lebronchao.com/2021/07/07/Vue3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/"/>
    <id>https://lebronchao.com/2021/07/07/Vue3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/</id>
    <published>2021-07-06T17:09:08.000Z</published>
    <updated>2021-07-06T17:09:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Effect 和 Reactive</h1><blockquote><p>effect 作为 Vue 响应式原理中的核心，在 Computed、Watch、Reactive 中都有出现</p><p>主要和 Reactive(Proxy)、track、trigger 等函数配合实现收集依赖，触发依赖更新</p></blockquote><ul><li>Effect<ul><li>副作用依赖函数</li></ul></li><li>Track<ul><li>依赖收集</li></ul></li><li>Trigger<ul><li>依赖触发</li></ul></li></ul><h2 id="Effect">Effect</h2><blockquote><p>effect 可以被理解为一个副作用函数，被当做依赖收集，在响应式数据更新后被触发。</p><p>Vue 的响应式 API 例如 Computed、Watch 都有用到 effect 来实现</p></blockquote><ul><li>先来看看入口函数<ul><li>入口函数主要是一些逻辑处理，核心逻辑位于 createReactiveEffect</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions = EMPTY_OBJ</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 如果已经是effect，则重置</span></span><br><span class="line">  <span class="keyword">if</span> (isEffect(fn)) &#123;</span><br><span class="line">    fn = fn.raw;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建effect</span></span><br><span class="line">  <span class="keyword">const</span> effect = createReactiveEffect(fn, options);</span><br><span class="line">  <span class="comment">// 如果不是惰性执行，先执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    effect();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createReactiveEffect</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> effectStack: ReactiveEffect[] = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveEffect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params"></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有激活，说明调用了effect stop函数</span></span><br><span class="line">    <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">      <span class="comment">// 无调度者则直接返回，否则执行fn</span></span><br><span class="line">      <span class="keyword">return</span> options.scheduler ? <span class="literal">undefined</span> : fn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断EffectStack中有没有effect，有则不处理</span></span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(effect)) &#123;</span><br><span class="line">      <span class="comment">// 清除effect</span></span><br><span class="line">      cleanup(effect);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 开始重新收集依赖</span></span><br><span class="line"><span class="comment">         * 压入stack</span></span><br><span class="line"><span class="comment">         * 将effect设置为activeEffect</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        enableTracking();</span><br><span class="line">        effectStack.push(effect);</span><br><span class="line">        activeEffect = effect;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 完成后将effect弹出</span></span><br><span class="line"><span class="comment">         * 重置依赖</span></span><br><span class="line"><span class="comment">         * 重置activeEffect</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        effectStack.pop();</span><br><span class="line">        resetTracking();</span><br><span class="line">        activeEffect = effectStack[effectStack.length - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> ReactiveEffect;</span><br><span class="line">  effect.id = uid++; <span class="comment">// 自增id，effect唯一标识</span></span><br><span class="line">  effect.allowRecurse = !!options.allowRecurse;</span><br><span class="line">  effect._isEffect = <span class="literal">true</span>; <span class="comment">// 是否是effect</span></span><br><span class="line">  effect.active = <span class="literal">true</span>; <span class="comment">// 是否激活</span></span><br><span class="line">  effect.raw = fn; <span class="comment">// 挂载原始对象</span></span><br><span class="line">  effect.deps = []; <span class="comment">// 当前effect的dep数组</span></span><br><span class="line">  effect.options = options; <span class="comment">// 传入的options</span></span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次effect运行都会重新收集依赖，deps是effect的依赖数组，需要全部清空</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params">effect: ReactiveEffect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deps &#125; = effect;</span><br><span class="line">  <span class="keyword">if</span> (deps.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">      deps[i].delete(effect);</span><br><span class="line">    &#125;</span><br><span class="line">    deps.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Track">Track</h2><blockquote><p>Track 这个函数常出现在 reactive 的 getter 函数中，用于依赖收集</p><p>源码详解见注释</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target: <span class="built_in">object</span>, <span class="keyword">type</span>: TrackOpTypes, key: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// activeEffect为空表示没有依赖</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// targetMap依赖管理Map，用于收集依赖</span></span><br><span class="line">  <span class="comment">// 检查targetMap中有没有target，没有则新建</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dep用来收集依赖函数，当监听的key值发生变化，触发dep中的依赖函数更新</span></span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key);</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect);</span><br><span class="line">    activeEffect.deps.push(dep);</span><br><span class="line">    <span class="comment">// 开发环境会触发onTrack，仅用于调试</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        effect: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        key,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trigger">Trigger</h2><blockquote><p>Trigger 常出现在 reactive 中的 setter 函数中，用于触发依赖更新</p><p>源码详解见注释</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  newValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;unknown, unknown&gt; | <span class="built_in">Set</span>&lt;unknown&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取依赖Map，如果没有则不需要触发</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// never been tracked</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用Set保存需要触发的effect，避免重复</span></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;ReactiveEffect&gt;();</span><br><span class="line">  <span class="comment">// 定义依赖添加函数</span></span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd: <span class="built_in">Set</span>&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.forEach(<span class="function">(<span class="params">effect</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect || effect.allowRecurse) &#123;</span><br><span class="line">          effects.add(effect);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将depsMap中的依赖添加到effects中</span></span><br><span class="line">  <span class="comment">// 只为了理解和原理的话   各个分支不用细看</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    depsMap.forEach(add);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    depsMap.forEach(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;</span><br><span class="line">        add(dep);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      add(depsMap.get(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.ADD:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          add(depsMap.get(ITERATE_KEY));</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            add(depsMap.get(MAP_KEY_ITERATE_KEY));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isIntegerKey(key)) &#123;</span><br><span class="line">          <span class="comment">// new index added to array -&gt; length changes</span></span><br><span class="line">          add(depsMap.get(<span class="string">&#x27;length&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.DELETE:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          add(depsMap.get(ITERATE_KEY));</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            add(depsMap.get(MAP_KEY_ITERATE_KEY));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.SET:</span><br><span class="line">        <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">          add(depsMap.get(ITERATE_KEY));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装effects执行函数</span></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect: ReactiveEffect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.options.onTrigger) &#123;</span><br><span class="line">      effect.options.onTrigger(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在scheduler则调用</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发effects中的所有依赖函数</span></span><br><span class="line">  effects.forEach(run);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactive">Reactive</h2><blockquote><p>了解了 Track 用于依赖收集，Trigger 用于依赖触发，那么他们的调用时机是什么时候呢?来看看 Reactive 的源码就清楚了，源码详解见注释。</p><p>注：源码结构较为复杂（封装），为便于理解原理，以下为简化源码。</p></blockquote><ul><li>总结来说<ul><li>在 getter 时进行依赖收集</li><li>在 setter 时触发依赖更新</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target:<span class="built_in">object</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | symbol, receiver: <span class="built_in">object</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">            track(target, TrackOpTypes.GET, key)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span> | symbol, value: unknown, receiver: <span class="built_in">object</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key]</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">            <span class="comment">// trigger(target, TriggerOpTypes.ADD, key, value)</span></span><br><span class="line">            trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Computed</h1><blockquote><p>Computed 是 Vue 中常用且好用的一个属性，这个属性的值在依赖改变后同步进行改变，在依赖未改变时使用缓存的值。</p></blockquote><ul><li>Vue2<ul><li>在 Vue2 中 Computed 的实现通过嵌套 watcher，实现响应式数据的依赖收集，间接链式触发依赖更新。</li></ul></li><li>Vue3 中出现了 effect，重新实现了 Computed 属性<ul><li>effect 可以被理解为副作用函数，被当做依赖收集，在响应式数据更新后被触发。</li></ul></li></ul><blockquote><p>Show me the Code</p></blockquote><ul><li>读完这段 computed 函数会发现，这里只是做了简要的 getter 和 setter 的赋值处理<ul><li>computed 支持两种写法<ul><li>函数</li><li>getter、setter</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computed</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> getter: ComputedGetter&lt;T&gt;;</span><br><span class="line">  <span class="keyword">let</span> setter: ComputedSetter&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOptions)) &#123;</span><br><span class="line">    getter = getterOrOptions;</span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">&#x27;Write operation failed: computed value is readonly&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.get;</span><br><span class="line">    setter = getterOrOptions.set;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ComputedRefImpl(</span><br><span class="line">    getter,</span><br><span class="line">    setter,</span><br><span class="line">    isFunction(getterOrOptions) || !getterOrOptions.set</span><br><span class="line">  ) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心逻辑都在 ComputedRefImpl 中，我们接着往下看<ul><li>通过 dirty 变量标记数据是否为旧数据</li><li>在响应式数据更新后将 dirty 赋值为 true</li><li>在下一次 get 时，dirty 为 true 时进行重新计算，并将 dirty 赋值为 false</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputedRefImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _value!: T;</span><br><span class="line">  <span class="keyword">private</span> _dirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> effect: ReactiveEffect&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> [ReactiveFlags.IS_READONLY]: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    getter: ComputedGetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> _setter: ComputedSetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    isReadonly: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">      lazy: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 响应式数据更新后将dirty赋值为true</span></span><br><span class="line">      <span class="comment">// 下次执行getter判断dirty为true即重新计算computed值</span></span><br><span class="line">      scheduler: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">          <span class="built_in">this</span>._dirty = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 派发所有引用当前计算属性的副作用函数effect</span></span><br><span class="line">          trigger(toRaw(<span class="built_in">this</span>), TriggerOpTypes.SET, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>[ReactiveFlags.IS_READONLY] = isReadonly;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span></span><br><span class="line">    <span class="keyword">const</span> self = toRaw(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 当响应式数据更新后dirty为true</span></span><br><span class="line">    <span class="comment">// 重新计算数据后，将dirty赋值为false</span></span><br><span class="line">    <span class="keyword">if</span> (self._dirty) &#123;</span><br><span class="line">      self._value = <span class="built_in">this</span>.effect();</span><br><span class="line">      self._dirty = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    track(self, TrackOpTypes.GET, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计算后的值</span></span><br><span class="line">    <span class="keyword">return</span> self._value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._setter(newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Watch</h1><blockquote><p>Watch 主要用于对某个变量的监听，并做相应的处理</p><p>Vue3 中不仅重构了 watch，还多了一个 WatchEffect API</p></blockquote><ul><li>Watch</li></ul><blockquote><p>用于对某个变量的监听，同时可以通过 callBack 拿到新值和旧值</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">watch(state, <span class="function">(<span class="params">state, prevState</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>WatchEffect</li></ul><blockquote><p>每次更新都会执行，自动收集使用到的依赖</p></blockquote><blockquote><p>无法获取到新值和旧值，可手动停止监听</p></blockquote><blockquote><p><code>onInvalidate(fn)</code>传入的回调会在 <code>watchEffect</code> 重新运行或者 <code>watchEffect</code> 停止的时候执行</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watchEffect(<span class="function">(<span class="params">onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 手动停止监听</span></span><br><span class="line">stop();</span><br></pre></td></tr></table></figure><h2 id="watch-和-watchEffect-的不同点">watch 和 watchEffect 的不同点</h2><ul><li>watch 惰性执行，watchEffect 每次代码加载都会执行</li><li>watch 可指定监听变量，watchEffect 自动依赖收集</li><li>watch 可获取新旧值，watchEffect 不行</li><li>watchEffect 有 onInvalidate 功能，watch 没有</li><li>watch 只可监听 ref、reactive 等对象，watchEffect 只可监听具体属性</li></ul><h2 id="Source-Code">Source Code</h2><blockquote><p>Show me the Code</p></blockquote><ul><li>这里可以看到 watch 和 watchEffet 的核心逻辑都封装到了 doWatch 中</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watch</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span>&lt;<span class="title">T</span> = <span class="title">any</span>, <span class="title">Immediate</span> <span class="title">extends</span> <span class="title">Readonly</span>&lt;<span class="title">boolean</span>&gt; = <span class="title">false</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: T | WatchSource&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptions&lt;Immediate&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !isFunction(cb)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`\`watch(fn, options?)\` signature has been moved to a separate API. `</span> +</span><br><span class="line">        <span class="string">`Use \`watchEffect(fn, options?)\` instead. \`watch\` now only `</span> +</span><br><span class="line">        <span class="string">`supports \`watch(source, cb, options?) signature.`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doWatch(source <span class="keyword">as</span> <span class="built_in">any</span>, cb, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptionsBase</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(effect, <span class="literal">null</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doWatch</li></ul><blockquote><p>以下为删减版源码，理解核心原理即可</p><p>详情见注释</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: WatchSource | WatchSource[] | WatchEffect | object,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: WatchCallback | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123; immediate, deep, flush, onTrack, onTrigger &#125;: WatchOptions = EMPTY_OBJ,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance = currentInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> getter: <span class="function">() =&gt;</span> any</span><br><span class="line">  <span class="keyword">let</span> forceTrigger = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> isMultiSource = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对不同的情况做getter赋值</span></span><br><span class="line">  <span class="keyword">if</span> (isRef(source)) &#123;</span><br><span class="line">    <span class="comment">// ref通过.value获取</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> (source <span class="keyword">as</span> Ref).value</span><br><span class="line">    forceTrigger = !!(source <span class="keyword">as</span> Ref)._shallow</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(source)) &#123;</span><br><span class="line">    <span class="comment">// reactive直接获取</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> source</span><br><span class="line">    deep = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(source)) &#123;</span><br><span class="line">    <span class="comment">// 如果是数组，做遍历处理</span></span><br><span class="line">    isMultiSource = <span class="literal">true</span></span><br><span class="line">    forceTrigger = source.some(isReactive)</span><br><span class="line">    getter = <span class="function">() =&gt;</span></span><br><span class="line">      source.map(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRef(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> s.value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> traverse(s)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER, [</span><br><span class="line">            instance &amp;&amp; (instance.proxy <span class="keyword">as</span> any)</span><br><span class="line">          ])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warnInvalidSource(s)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(source)) &#123;</span><br><span class="line">    <span class="comment">// 如果是函数的情况</span></span><br><span class="line">    <span class="comment">// 有cb则为watch，没有则为watchEffect</span></span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// getter with cb</span></span><br><span class="line">      getter = <span class="function">() =&gt;</span></span><br><span class="line">        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER, [</span><br><span class="line">          instance &amp;&amp; (instance.proxy <span class="keyword">as</span> any)</span><br><span class="line">        ])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// no cb -&gt; simple effect</span></span><br><span class="line">      getter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance &amp;&amp; instance.isUnmounted) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> callWithAsyncErrorHandling(</span><br><span class="line">          source,</span><br><span class="line">          instance,</span><br><span class="line">          ErrorCodes.WATCH_CALLBACK,</span><br><span class="line">          [onInvalidate]</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常情况</span></span><br><span class="line">    getter = NOOP</span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    __DEV__ &amp;&amp; warnInvalidSource(source)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 深度监听逻辑处理</span></span><br><span class="line">  <span class="keyword">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class="line">    <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">    getter = <span class="function">() =&gt;</span> traverse(baseGetter())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cleanup: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">let</span> onInvalidate: InvalidateCbRegistrator = <span class="function">(<span class="params">fn: () =&gt; <span class="keyword">void</span></span>) =&gt;</span> &#123;</span><br><span class="line">    cleanup = runner.options.onStop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录oldValue，并通过runner获取newValue</span></span><br><span class="line">  <span class="comment">// callback的封装处理为job</span></span><br><span class="line">  <span class="keyword">let</span> oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE</span><br><span class="line">  <span class="keyword">const</span> job: SchedulerJob = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!runner.active) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// watch(source, cb)</span></span><br><span class="line">      <span class="keyword">const</span> newValue = runner()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        deep ||</span><br><span class="line">        forceTrigger ||</span><br><span class="line">        (isMultiSource</span><br><span class="line">          ? (newValue <span class="keyword">as</span> any[]).some(<span class="function">(<span class="params">v, i</span>) =&gt;</span></span><br><span class="line">              hasChanged(v, (oldValue <span class="keyword">as</span> any[])[i])</span><br><span class="line">            )</span><br><span class="line">          : hasChanged(newValue, oldValue)) ||</span><br><span class="line">        (__COMPAT__ &amp;&amp;</span><br><span class="line">          isArray(newValue) &amp;&amp;</span><br><span class="line">          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// cleanup before running cb again</span></span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [</span><br><span class="line">          newValue,</span><br><span class="line">          <span class="comment">// pass undefined as the old value when it&#x27;s changed for the first time</span></span><br><span class="line">          oldValue === INITIAL_WATCHER_VALUE ? <span class="literal">undefined</span> : oldValue,</span><br><span class="line">          onInvalidate</span><br><span class="line">        ])</span><br><span class="line">        oldValue = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// watchEffect</span></span><br><span class="line">      runner()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// important: mark the job as a watcher callback so that scheduler knows</span></span><br><span class="line">  <span class="comment">// it is allowed to self-trigger (#1727)</span></span><br><span class="line">  job.allowRecurse = !!cb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过读取配置，处理job的触发时机</span></span><br><span class="line">  <span class="comment">// 并再次将job的执行封装到scheduler中</span></span><br><span class="line">  <span class="keyword">let</span> scheduler: ReactiveEffectOptions[<span class="string">&#x27;scheduler&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123; <span class="comment">// 同步执行</span></span><br><span class="line">    scheduler = job</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123; <span class="comment">// 更新后执行</span></span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">    <span class="comment">// 更新前执行</span></span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance || instance.isMounted) &#123;</span><br><span class="line">        queuePreFlushCb(job)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// with &#x27;pre&#x27; option, the first call must happen before</span></span><br><span class="line">        <span class="comment">// the component is mounted so it is called synchronously.</span></span><br><span class="line">        job()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用effect副作用处理依赖收集，在依赖更新后调用scheduler（其中封装了callback的执行）</span></span><br><span class="line">  <span class="keyword">const</span> runner = effect(getter, &#123;</span><br><span class="line">    lazy: <span class="literal">true</span>,</span><br><span class="line">    onTrack,</span><br><span class="line">    onTrigger,</span><br><span class="line">    scheduler</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收集依赖</span></span><br><span class="line">  recordInstanceBoundEffect(runner, instance)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取配置，进行watch初始化</span></span><br><span class="line">  <span class="comment">// 是否有cb</span></span><br><span class="line">  <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">    <span class="comment">// 是否立刻执行</span></span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      job()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      oldValue = runner()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是否更新后执行</span></span><br><span class="line">    queuePostRenderEffect(runner, instance &amp;&amp; instance.suspense)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    runner()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回手动停止函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    stop(runner)</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      remove(instance.effects!, runner)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Mixin</h1><blockquote><p>Mixin 意为混合，是公共逻辑封装利器。</p><p>原理比较简单，那就是合并。</p></blockquote><ul><li>合并分为对象的合并和生命周期的合并<ul><li>对象，mergeOption<ul><li>类型 Object.assign 的合并，会出现覆盖现象</li></ul></li><li>生命周期，mergeHook<ul><li>合并会将两个生命周期放入一个队列，依次调用</li></ul></li></ul></li><li>mergeOptions</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  to: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">from</span>: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance?: ComponentInternalInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  strats = instance &amp;&amp; instance.appContext.config.optionMergeStrategies</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__COMPAT__ &amp;&amp; isFunction(<span class="keyword">from</span>)) &#123;</span><br><span class="line">    <span class="keyword">from</span> = <span class="keyword">from</span>.options;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; mixins, <span class="attr">extends</span>: extendsOptions &#125; = <span class="keyword">from</span>;</span><br><span class="line"></span><br><span class="line">  extendsOptions &amp;&amp; mergeOptions(to, extendsOptions, instance, strats);</span><br><span class="line">  mixins &amp;&amp;</span><br><span class="line">    mixins.forEach(<span class="function">(<span class="params">m: ComponentOptionsMixin</span>) =&gt;</span></span><br><span class="line">      mergeOptions(to, m, instance, strats)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对mixin中的对象进行遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果存在则进行覆盖处理</span></span><br><span class="line">    <span class="keyword">if</span> (strats &amp;&amp; hasOwn(strats, key)) &#123;</span><br><span class="line">      to[key] = strats[key](</span><br><span class="line">        to[key],</span><br><span class="line">        <span class="keyword">from</span>[key],</span><br><span class="line">        instance &amp;&amp; instance.proxy,</span><br><span class="line">        key</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不存在则直接赋值</span></span><br><span class="line">      to[key] = <span class="keyword">from</span>[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mergeHook</li></ul><blockquote><p>简单粗暴放进 Set，调用时依次调用</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  to: <span class="built_in">Function</span>[] | <span class="built_in">Function</span> | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">from</span>: <span class="built_in">Function</span> | <span class="built_in">Function</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([...toArray(to), ...toArray(<span class="keyword">from</span>)]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Diff 算法优化</h1><blockquote><p>了解 Vue3 的 Diff 算法优化前，可以先了解一下<a href="https://juejin.cn/post/6944887985531781133">Vue2 的 Diff 算法</a></p><p>本部分注重把算法讲清楚，将不进行逐行源码分析</p></blockquote><ul><li>Vue3 中的主要优化点为<ul><li>在 updateChildren 时双端比较 -&gt; 最长递增子序列</li><li>全量 Diff -&gt; 静态标记 + 非全量 Diff</li><li>静态提升</li></ul></li></ul><h2 id="updateChildren">updateChildren</h2><ul><li>Vue2<ul><li>头 - 头比较</li><li>尾 - 尾比较</li><li>头 - 尾比较</li><li>尾 - 头比较</li></ul></li><li>Vue3<ul><li>头 - 头比较</li><li>尾 - 尾比较</li><li>基于最长递增子序列进行移动 / 删除 / 新增</li></ul></li></ul><h3 id="举个-🌰">举个 🌰</h3><ul><li>oldChild [a,b,c,d,e,f,g]</li><li>newChild [a,b,f,c,d,e,h,g]</li></ul><ol><li>首先进行头 - 头比较,比较到不一样的节点时跳出循环<ul><li>得到[a,b]</li></ul></li><li>然后进行尾 - 尾比较，比较到不一样的节点时跳出循环<ul><li>得到[g]</li></ul></li><li>剩余[f,c,d,e,h]<ul><li>通过 newIndexToOldIndexMap 生成数组[5, 2, 3, 4, -1]</li><li>得出最长递增子序列[2, 3, 4]对应节点为[c, d, e]</li><li>剩余的节点基于[c, d, e]进行移动 / 新增 / 删除</li></ul></li></ol><blockquote><p><strong>最长递增子序列</strong> 减少 Dom 元素的移动，达到最少的 dom 操作以减小开销。</p><p>关于最长递增子序列算法可以看看<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md">最长递增子序列</a></p></blockquote><h2 id="静态标记">静态标记</h2><blockquote><p>Vue2 中对 vdom 进行全量 Diff，Vue3 中增加了静态标记进行非全量 Diff</p><p>对 vnode 打了像以下枚举内的静态标记</p></blockquote><ul><li>patchFlag</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="built_in">enum</span> PatchFlags &#123;</span><br><span class="line">  TEXT = <span class="number">1</span>, <span class="comment">//动态文本节点</span></span><br><span class="line">  CLASS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">//2   动态class</span></span><br><span class="line">  STYLE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">//4   动态style</span></span><br><span class="line">  PROPS = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">//8                动态属性，但不包含类名和样式</span></span><br><span class="line">  FULL_PROPS = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">//16   具有动态key属性，当key改变时，需进行完整的diff比较</span></span><br><span class="line">  HYDRATE_EVENTS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">//32  带有监听事件的节点</span></span><br><span class="line">  STABLE_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">//64  一个不会改变子节点顺序的fragment</span></span><br><span class="line">  KEYED_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">//128 带有key属性的fragment或部分子节点有key</span></span><br><span class="line">  UNKEYEN_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">//256  子节点没有key的fragment</span></span><br><span class="line">  NEED_PATCH = <span class="number">1</span> &lt;&lt; <span class="number">9</span>, <span class="comment">//512   一个节点只会进行非props比较</span></span><br><span class="line">  DYNAMIC_SLOTS = <span class="number">1</span> &lt;&lt; <span class="number">10</span>, <span class="comment">//1024   动态slot</span></span><br><span class="line">  HOISTED = -<span class="number">1</span>, <span class="comment">//静态节点</span></span><br><span class="line">  <span class="comment">//指示在diff过程中要退出优化模式</span></span><br><span class="line">  BAIL = -<span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个-🌰-2">举个 🌰</h3><ul><li>模板长这样</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>生成 vdom 源码</li></ul><blockquote><p>对 msg 变量进行了标记</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createVNode <span class="keyword">as</span> _createVNode,</span><br><span class="line">  toDisplayString <span class="keyword">as</span> _toDisplayString,</span><br><span class="line">  openBlock <span class="keyword">as</span> _openBlock,</span><br><span class="line">  createBlock <span class="keyword">as</span> _createBlock,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    _openBlock(),</span><br><span class="line">    _createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">      _createVNode(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello World&#x27;</span>),</span><br><span class="line">      _createVNode(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.msg), <span class="number">1</span> <span class="comment">/* TEXT */</span>),</span><br><span class="line">    ])</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><ul><li>对 vnode 进行标记，将需要动态更新和不需要动态更新的节点进行分类</li><li>静态节点仅需创建一次，渲染直接复用，不参与 diff 算法流程。</li></ul><h2 id="静态提升">静态提升</h2><ul><li><p>Vue2 中无论是元素是否参与更新，每次都会重新创建</p></li><li><p>Vue3 中对于不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停地复用</p></li><li><p>以后每次进行 render 的时候，就不会重复创建这些静态的内容，而是直接从一开始就创建好的常量中取就行了。</p></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createVNode <span class="keyword">as</span> _createVNode,</span><br><span class="line">  toDisplayString <span class="keyword">as</span> _toDisplayString,</span><br><span class="line">  openBlock <span class="keyword">as</span> _openBlock,</span><br><span class="line">  createBlock <span class="keyword">as</span> _createBlock,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态提升前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    _openBlock(),</span><br><span class="line">    _createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">      _createVNode(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Xmo&#x27;</span>),</span><br><span class="line">      _createVNode(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Xmo&#x27;</span>),</span><br><span class="line">      _createVNode(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Xmo&#x27;</span>),</span><br><span class="line">      _createVNode(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.msg), <span class="number">1</span> <span class="comment">/* TEXT */</span>),</span><br><span class="line">    ])</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 静态提升后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span> _createVNode(</span><br><span class="line">  <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&#x27;Xmo&#x27;</span>,</span><br><span class="line">  -<span class="number">1</span> <span class="comment">/* HOISTED */</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span> _createVNode(</span><br><span class="line">  <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&#x27;Xmo&#x27;</span>,</span><br><span class="line">  -<span class="number">1</span> <span class="comment">/* HOISTED */</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span> _createVNode(</span><br><span class="line">  <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&#x27;Xmo&#x27;</span>,</span><br><span class="line">  -<span class="number">1</span> <span class="comment">/* HOISTED */</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    _openBlock(),</span><br><span class="line">    _createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">      _hoisted_1,</span><br><span class="line">      _hoisted_2,</span><br><span class="line">      _hoisted_3,</span><br><span class="line">      _createVNode(<span class="string">&#x27;p&#x27;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.msg), <span class="number">1</span> <span class="comment">/* TEXT */</span>),</span><br><span class="line">    ])</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><h1>cacheHandlers 事件侦听器缓存</h1><ul><li><p>默认情况下 onClick 会被视为动态绑定，所以每次都会去追踪它的变化</p></li><li><p>但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。</p></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">&quot;onClick&quot;</span>&gt;btn&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用缓存前</span></span><br><span class="line"><span class="comment">// 这里我们还没有开启事件监听缓存，熟悉的静态标记 8 /* PROPS */ 出现了，</span></span><br><span class="line"><span class="comment">// 它将标签的 Props （属性） 标记动态属性。</span></span><br><span class="line"><span class="comment">// 如果我们存在属性不会改变，不希望这个属性被标记为动态，那么就需要 cacheHandler 的出场了。</span></span><br><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">onClick</span>: _ctx.onClick &#125;, <span class="string">&quot;btn&quot;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">&quot;onClick&quot;</span>])</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用缓存后</span></span><br><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      onClick: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.onClick(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;btn&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>它的意思很明显，onClick 方法被存入 cache。</p><p>在使用的时候，如果能在缓存中找到这个方法，那么它将直接被使用。</p><p>如果找不到，那么将这个方法注入缓存。</p><p>总之，就是把方法给缓存了。</p></blockquote><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Effect 和 Reactive&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;effect 作为 Vue 响应式原理中的核心，在 Computed、Watch、Reactive 中都有出现&lt;/p&gt;
&lt;p&gt;主要和 Reactive(Proxy)、track、trigger </summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="Vue" scheme="https://lebronchao.com/tags/Vue/"/>
    
    <category term="SPA" scheme="https://lebronchao.com/tags/SPA/"/>
    
    <category term="源码分析" scheme="https://lebronchao.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>[深入浅出]JavaScript GC 垃圾回收机制</title>
    <link href="https://lebronchao.com/2021/06/22/JavaScipt-GC/"/>
    <id>https://lebronchao.com/2021/06/22/JavaScipt-GC/</id>
    <published>2021-06-22T15:32:35.000Z</published>
    <updated>2021-06-22T15:32:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1>[科普]JavaScript GC</h1><h1>为什么需要垃圾回收</h1><ul><li>在 C / C++中，跟踪内存的使用和管理内存对开发者来说是很大的负担<ul><li>JavaScript 是使用垃圾回收机制的语言，也就是说执行环境负责在代码执行时管理内存，帮开发者卸下了这个负担</li><li>通过自动内存管理实现内存的分配和资源的回收</li><li>基本思路很简单，确定哪个变量不会再被使用了，把它的内存空间释放</li><li>这个过程是周期性的，意思是这个垃圾回收程序每隔一段时间就会运行一次</li></ul></li><li>像 JS 中的对象、字符串、对象的内存是不固定的，只有真正用到的时候才会动态分配内存<ul><li>这些内存需在不使用后进行释放以便再次使用，否则在计算机可用内存耗尽后造成崩溃</li></ul></li><li>浏览器发展史上的垃圾回收法主要有<ul><li>引用计数法</li><li>标记清除法</li></ul></li></ul><h1>引用计数法</h1><h2 id="思路">思路</h2><ul><li>变量只是对值进行引用</li><li>当变量引用该值时，引用次数+1</li><li>当该变量的引用被覆盖或者清除时，引用次数-1</li><li>当引用次数为 0 时，就可以安全地释放这块内存。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]; <span class="comment">// [1, 0, 1]这块内存被arr引用  引用次数为1</span></span><br><span class="line">arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; <span class="comment">// [1, 0, 1]的内存引用次数为0被释放</span></span><br><span class="line"><span class="comment">// [0, 1, 0]的内存被arr引用   引用次数为1</span></span><br><span class="line"><span class="keyword">const</span> tmp = arr; <span class="comment">// [0, 1, 0]的内存被tmp引用   引用次数为2</span></span><br></pre></td></tr></table></figure><h2 id=""></h2><h2 id="循环引用问题">循环引用问题</h2><blockquote><p>Netscape Navigator 3.0 采用</p></blockquote><ul><li>在这个例子中，ObjectA 和 ObjectB 的属性分别相互引用</li><li>造成这个函数执行后，Object 被引用的次数不会变成 0，影响了正常的 GC。</li><li>如果执行多次，将造成严重的内存泄漏。</li><li>而标记清除法则不会出现这个问题。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ObjectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">let</span> ObjectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">  ObjectA.p = ObjectB;</span><br><span class="line">  ObjectB.p = ObjectA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example();</span><br></pre></td></tr></table></figure><ul><li>解决方法：在函数结束时将其指向 null</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ObjectA = <span class="literal">null</span>;</span><br><span class="line">ObjectB = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h1>标记清除法</h1><blockquote><p>为了解决循环引用造成的内存泄漏问题，Netscape Navigator 4.0 开始采用标记清除法</p></blockquote><blockquote><p>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理(或 其变体)，只是在运行垃圾回收的频率上有所差异。</p></blockquote><h2 id="思路-2">思路</h2><ul><li>在变量进入执行上下文时打上“进入”标记</li><li>同时在变量离开执行上下文时也打上“离开”标记<ul><li>从此以后，无法访问这个变量</li><li>在下一次垃圾回收时进行内存的释放</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> n * a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记Example进入执行上下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>; <span class="comment">// 标记n进入执行上下文</span></span><br><span class="line">Example(n); <span class="comment">// 标记a,b,c进入执行上下文</span></span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// 标记a, b, c离开执行上下文，等待垃圾回收</span></span><br></pre></td></tr></table></figure><h2 id="const-和-let-声明提升性能">const 和 let 声明提升性能</h2><ul><li>const 和 let 不仅有助于改善代码风格，同时有利于垃圾回收性能的提升</li><li>const 和 let 使 JS 有了块级作用域，当块级作用域比函数作用域更早结束时，垃圾回收程序更早介入</li><li>尽早回收该回收的内存，提升了垃圾回收的性能</li></ul><h1>V8 引擎的垃圾回收</h1><blockquote><p>V8 引擎的垃圾回收采用标记清除法与分代回收法</p></blockquote><blockquote><p>分为新生代和老生代</p></blockquote><h2 id="新生代">新生代</h2><blockquote><p>新生代垃圾回收采用<code>Scavenge</code> 算法</p></blockquote><blockquote><p>分配给常用内存和新分配的小量内存</p></blockquote><ul><li><p>内存大小</p><ul><li>32 位系统 16M 内存</li><li>64 位系统 32M 内存</li></ul></li><li><p>分区</p><ul><li>新生代内存分为以下两区，内存各占一半</li><li>From space</li><li>To space</li></ul></li><li><p>运行</p><ul><li>实际运行的只有 From space</li><li>To space 处于空闲状态</li></ul></li><li><p><code>Scavenge</code>算法</p><ul><li>当 From space 内存使用将要达到上限时开始垃圾回收，将 From space 中的不可达对象都打上标记</li><li>将 From space 的未标记对象复制到 To space。<ul><li>解决了内存散落分块的问题（不连续的内存空间）</li><li>相当于用空间换时间。</li></ul></li><li>然后清空 From space、将其闲置，也就是转变为 To space，俗称反转。</li></ul></li><li><p>新生代 -&gt; 老生代</p><ul><li>新生代存放的是新分配的小量内存，如果达到以下条件中的一个，将被分配至老生代<ul><li>内存大小达到 From space 的 25%</li><li>经历了 From space &lt;-&gt; To space 的一个轮回</li></ul></li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20210607231001850.(null)" alt="img"></p><h2 id="老生代">老生代</h2><blockquote><p>老生代采用<code>mark-sweep</code>标记清除和<code>mark-compact</code>标记整理</p></blockquote><blockquote><p>通常存放较大的内存块和从新生代分配过来的内存块</p></blockquote><ul><li>内存大小<ul><li>32 位系统 700M 左右</li><li>64 位系统 1.4G 左右</li></ul></li><li>分区<ul><li>Old Object Space<ul><li>字面的老生代，存放的是新生代分配过来的内存。</li></ul></li><li>Large Object Space<ul><li>存放其他区域放不下的较大的内存，基本都超过 1M</li></ul></li><li>Map Space<ul><li>存放存储对象的映射关系</li></ul></li><li>Code Space<ul><li>存储编译后的代码</li></ul></li></ul></li><li>回收流程<ul><li>标记分类（三色标记）<ul><li>未被扫描，可回收，下面简称<code>1类</code></li><li>扫描中，不可回收，下面简称<code>2类</code></li><li>扫描完成，不可回收，下面简称<code>3类</code></li></ul></li><li>遍历<ul><li>采用深度优先遍历，遍历每个对象。</li><li>首先将非根部对象全部标记为<code>1类</code>，然后进行深度优先遍历。</li><li>遍历过程中将对象压入栈，这个过程中对象被标记为<code>2类</code>。</li><li>遍历完成对象出栈，这个对象被标记为<code>3类</code>。</li><li>整个过程直至栈空</li></ul></li><li>Mark-sweep<ul><li>标记完成之后，将标记为<code>1类</code>的对象进行内存释放<br><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20210607231013225-20210607231556621.(null)" alt="img"></li></ul></li><li>Mark-compact<ul><li>垃圾回收完成之后，内存空间是不连续的。</li><li>这样容易造成无法分配较大的内存空间的问题，从而触发垃圾回收。</li><li>所以，会有 Mark-compact 步骤将未被回收的内存块整理为连续地内存空间。</li><li>频繁触发垃圾回收会影响引擎的性能，内存空间不足时也会优先触发 Mark-compact</li></ul></li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20210607231009280.(null)" alt="img"></p><h2 id="垃圾回收优化">垃圾回收优化</h2><ul><li>增量标记<ul><li>如果用集中的一段时间进行垃圾回收，新生代倒还好，老生代如果遍历较大的对象，可能会造成卡顿。</li><li>增量标记：使垃圾回收程序和应用逻辑程序交替运行，思想类似 Time Slicing</li></ul></li><li>并行回收<ul><li>在垃圾回收的过程中，开启若干辅助线程，提高垃圾回收效率。</li></ul></li><li>并发回收<ul><li>在逻辑程序执行的过程中，开启若干辅助线程进行垃圾回收，清理和主线程没有任何逻辑关系的内存。</li></ul></li></ul><h1>内存泄露场景</h1><h2 id="全局变量">全局变量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exm1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  exm = <span class="string">&#x27;LeBron&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exm2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.exm = <span class="string">&#x27;LeBron&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Example();</span><br></pre></td></tr></table></figure><h2 id="未清除的定时器">未清除的定时器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// clearInterval(timer)</span></span><br></pre></td></tr></table></figure><h2 id="闭包">闭包</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = debounce(handler, <span class="number">1000</span>); <span class="comment">// fn引用了timeout</span></span><br></pre></td></tr></table></figure><h2 id="未清除的-DOM-元素引用">未清除的 DOM 元素引用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="comment">// 此处引用了DOM元素</span></span><br><span class="line">  button: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;LeBron&#x27;</span>),</span><br><span class="line">  select: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;select&#x27;</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;LeBron&#x27;</span>));</span><br></pre></td></tr></table></figure><h1>如何检测内存泄漏</h1><blockquote><p>这个其实不难，浏览器原带的开发者工具 Performance 就可以</p></blockquote><ul><li>步骤<ul><li>F12 打开开发者工具</li><li>选择 Performance 工具栏</li><li>勾选屏幕截图和 Memory</li><li>点击开始录制</li><li>一段时间之后结束录制</li></ul></li><li>结果<ul><li>堆内存会周期性地分配和释放</li><li>如果堆内存的 min 值在逐渐上升则存在内存泄漏</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20210622234127287.(null)" alt="img"></p><h1>优化内存使用</h1><ol><li>尽量不在 for 循环中定义函数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exm</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">idx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> idx * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//const fn = (idx) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//    return idx * 2;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">const</span> res = fn(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>尽量不在 for 循环中定义对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// const obj = &#123;</span></span><br><span class="line">    <span class="comment">//   a: i,</span></span><br><span class="line">    <span class="comment">//   b: i * 2,</span></span><br><span class="line">    <span class="comment">//   c: i * 3,</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    obj.a = i;</span><br><span class="line">    obj.b = i * <span class="number">2</span>;</span><br><span class="line">    obj.c = i * <span class="number">3</span>;</span><br><span class="line">    res += <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>清空数组</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.length = <span class="number">0</span>; <span class="comment">// 清空了数组，数组类型不变</span></span><br><span class="line"><span class="comment">// arr = []  // 重新申请了一块空数组对象内存</span></span><br></pre></td></tr></table></figure><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;[科普]JavaScript GC&lt;/h1&gt;
&lt;h1&gt;为什么需要垃圾回收&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在 C / C++中，跟踪内存的使用和管理内存对开发者来说是很大的负担
&lt;ul&gt;
&lt;li&gt;JavaScript 是使用垃圾回收机制的语言，也就是说执行环境负责在代码执行时</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="JavaScript" scheme="https://lebronchao.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>[打包优化]Webpack体积压缩</title>
    <link href="https://lebronchao.com/2021/06/07/Webpack%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A9/"/>
    <id>https://lebronchao.com/2021/06/07/Webpack%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A9/</id>
    <published>2021-06-07T15:57:14.000Z</published>
    <updated>2021-06-07T15:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6969018138591494158">打包优化]Webpack 体积压缩 (juejin.cn)</a></p></blockquote><h1>HTTP 压缩</h1><ul><li><p>HTTP 压缩是一种内置在 服务器 和 客户端 之间的，以改进传输速度和带宽利用率的方式;</p></li><li><p>HTTP 压缩的流程什么呢?</p><ul><li>第一步:HTTP 数据在服务器发送前就已经被压缩了;(可以在 webpack 中完成)</li><li>第二步:兼容的浏览器在向服务器发送请求时，会告知服务器自己支持哪些压缩格式;</li><li>第三步:服务器在浏览器支持的压缩格式下，直接返回对应的压缩后的文件，并且在响应头中告知浏览器;</li></ul></li></ul><h2 id="压缩格式">压缩格式</h2><ol><li><p>compress – UNIX 的“compress”程序的方法(历史性原因，不推荐大多数应用使用，应该使用 gzip 或</p><p>deflate);</p></li><li><p>deflate – 基于 deflate 算法(定义于 RFC 1951)的压缩，使用 zlib 数据格式封装;</p></li><li><p>gzip – GNU zip 格式(定义于 RFC 1952)，是目前使用比较广泛的压缩算法;</p></li><li><p>br – 一种新的开源压缩算法，专为 HTTP 内容的编码而设计;</p></li></ol><h2 id="Webpack-对文件压缩">Webpack 对文件压缩</h2><blockquote><p>使用 CompressionPlugin 对文件进行压缩</p></blockquote><ul><li><p>安装</p><ul><li><code>npm install compression-webpack-plugin</code></li></ul></li><li><p>webpack.prod.js</p><ul><li>threshold：x 以上的文件才进行压缩</li><li>minRatio：最小压缩比，小于则不压缩</li><li>test：正则匹配的文件才压缩</li><li>alogorithm：压缩算法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">    threshold: <span class="number">0</span>,</span><br><span class="line">    minRatio: <span class="number">0.6</span>,</span><br><span class="line">    test: <span class="regexp">/\.(css|js)/i</span>,</span><br><span class="line">    algorithm: <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="HTML-文件中代码的压缩">HTML 文件中代码的压缩</h2><ul><li><p>之前使用了 HtmlWebpackPlugin 插件来生成 HTML 的模板，事实上它还有一些其他的配置:</p></li><li><p>inject:设置打包的资源插入的位置</p><ul><li>true、 false 、body、head</li></ul></li><li><p>cache:设置为 true，只有当文件改变时，才会生成新的文件(默认值也是 true)</p></li><li><p>minify:默认会使用一个插件 html-minifier-terser</p></li><li><p>webpack.prod.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    title: <span class="string">&#x27;LeBronChao Webpack&#x27;</span>,</span><br><span class="line">    template: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">    inject: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">    cache: <span class="literal">true</span>,</span><br><span class="line">    minify: isProduction</span><br><span class="line">      ? &#123;</span><br><span class="line">          removeComments: <span class="literal">true</span>, <span class="comment">// 是否删除注释</span></span><br><span class="line">          removeRedundantAttributes: <span class="literal">true</span>, <span class="comment">// 是否删除多余（默认）属性</span></span><br><span class="line">          removeEmptyAttributes: <span class="literal">true</span>, <span class="comment">// 是否删除空属性</span></span><br><span class="line">          collapseWhitespace: <span class="literal">false</span>, <span class="comment">// 折叠空格</span></span><br><span class="line">          removeStyleLinkTypeAttributes: <span class="literal">true</span>, <span class="comment">// 比如link中的type=&quot;text/css&quot;</span></span><br><span class="line">          minifyCSS: <span class="literal">true</span>, <span class="comment">// 是否压缩style标签内的css</span></span><br><span class="line">          minifyJS: &#123;</span><br><span class="line">            <span class="comment">// 压缩JS选项，可参考Terser配置</span></span><br><span class="line">            mangle: &#123;</span><br><span class="line">              toplevel: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="literal">false</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="InlineChunkHtmlPlugin">InlineChunkHtmlPlugin</h2><ul><li><p>另外有一个插件，可以辅助将一些 chunk 出来的模块，内联到 html 中:</p><ul><li>比如 runtime 的代码，代码量不大，但是是必须加载的;</li><li>那么可以直接内联到 html 中;</li></ul></li><li><p>这个插件是在 react-dev-utils 中实现的，所以我们可以安装一下:</p><ul><li><code>npm i react-dev-utils </code></li></ul></li><li><p>在 production 的 plugins 中进行配置（内联 runtime 文件）:</p><ul><li>webpack.prod.js</li><li>参数一为 HtmlWebpackPlugin</li><li>参数二为正则匹配表达式</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InlieChunkHtmlPlugin = <span class="built_in">require</span>(<span class="string">&#x27;react-dev-utils/InlineChunkHtmlPlugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">plugins: [<span class="keyword">new</span> InlieChunkHtmlPlugin(HtmlWebpackPlugin, [<span class="regexp">/runtime.+\.js/</span>])];</span><br></pre></td></tr></table></figure><h2 id="Terser">Terser</h2><ul><li><p>什么是 Terser 呢?</p><ul><li>Terser 是一个 JavaScript 的解释(Parser)、Mangler(绞肉机)/Compressor(压缩机)的工具集;</li><li>早期会使用 uglify-js 来压缩、丑化 JavaScript 代码，但是目前已经不再维护，并且不支持 ES6+的 语法;</li><li>Terser 是从 uglify-es fork 过来的，并且保留它原来的大部分 API 以及适配 uglify-es 和 uglify-js@3 等; 也就是说，Terser 可以帮助压缩、丑化代码，让我们的 bundle 变得更小。</li></ul></li><li><p>因为 Terser 是一个独立的工具，所以它可以单独安装:</p><ul><li><code>npm i terser -g</code></li></ul></li><li><p>可以在命令行中使用 Terser</p><ul><li>因为他们的配置非常多 Compress option 和 Mangle option</li><li>详情查看文档<ul><li><a href="https://github.com/terser/terser#compress-options">https://github.com/terser/terser#compress-options</a></li><li><a href="https://github.com/terser/terser#mangle-options">https://github.com/terser/terser#mangle-options</a></li></ul></li></ul></li></ul><h3 id="Webpack-中配置-Terser">Webpack 中配置 Terser</h3><ul><li><p>首先，需要打开 minimize，让其对代码进行压缩(默认 production 模式下已经打开了)</p></li><li><p>其次，可以在 minimizer 创建一个 TerserPlugin:</p><ul><li>extractComments:默认值为 true，表示会将注释抽取到一个单独的文件中;<ul><li>在开发中，不希望保留这个注释时，可以设置为 false;</li></ul></li><li>parallel:使用多进程并发运行提高构建的速度，默认值是 true，并发运行的默认数量: os.cpus().length - 1;<ul><li>也可以设置自己的个数，但是使用默认值即可;</li></ul></li><li>terserOptions:设置 terser 相关的配置<ul><li>compress:设置压缩相关的选项;</li><li>mangle:设置丑化相关的选项，可以直接设置为 true;</li><li>toplevel:底层变量是否进行转换;</li><li>keep_classnames:保留类的名称;</li></ul></li></ul></li></ul><h2 id="CSS-压缩">CSS 压缩</h2><ul><li><p>另一个代码的压缩是 CSS:</p><ul><li>CSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等;</li><li>CSS 的压缩我们可以使用另外一个插件:css-minimizer-webpack-plugin;</li><li>css-minimizer-webpack-plugin 是使用 cssnano 工具来优化、压缩 CSS(也可以单独使用);</li></ul></li><li><p>安装 css-minimizer-webpack-plugin:</p><ul><li><code>npm i css-minimizer-webpack-plugin</code></li></ul></li><li><p>在 optimization.minimizer 中配置</p></li></ul><h2 id="配置示例">配置示例</h2><ul><li>webpack.prod.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> isProduction = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> CssMiniMizerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    chunkIds: <span class="string">&#x27;deterministic&#x27;</span>,</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">        extractComments: <span class="literal">true</span>,</span><br><span class="line">        parallel: <span class="literal">true</span>,</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          compress: <span class="literal">true</span>,</span><br><span class="line">          mangle: <span class="literal">true</span>,</span><br><span class="line">          toplevel: <span class="literal">false</span>,</span><br><span class="line">          keep_classnames: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> CssMiniMizerPlugin(&#123;</span><br><span class="line">        parallel: <span class="literal">true</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">from</span>: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">          <span class="comment">// 可不写，默认到output</span></span><br><span class="line">          to: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          globOptions: &#123;</span><br><span class="line">            ignore: [<span class="string">&#x27;**/index.html&#x27;</span>, <span class="string">&#x27;**/.DS_Store&#x27;</span>, <span class="string">&#x27;**/abc.txt&#x27;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[<a href="https://juejin.cn/post/6969018138591494158">打包优化]Webpack 体积压缩 (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://juejin.cn/post/6969018138591494158&quot;&gt;打包优化]Webpack 体积压</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>[分享]Webpack打包分析工具</title>
    <link href="https://lebronchao.com/2021/06/07/Webpack%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>https://lebronchao.com/2021/06/07/Webpack%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</id>
    <published>2021-06-07T15:54:31.000Z</published>
    <updated>2021-06-07T15:54:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6968275465572188191">分享]Webpack 打包分析工具 (juejin.cn)</a></p></blockquote><h1>Webpack 打包分析</h1><blockquote><p>分享时间和文件的分析工具，便于进行打包优化。</p></blockquote><h2 id="打包的时间分析">打包的时间分析</h2><ul><li><p>如果希望看到每一个 Loader、每一个 Plugin 消耗的打包时间，可以借助于一个插件:speed-measure-webpack-plugin</p><ul><li>注意:该插件在最新的 webpack 版本中存在一些兼容性的问题(和部分 Plugin 不兼容)</li><li>截止 2021-3-10 日，但是目前该插件还在维护，所以可以等待后续是否更新;</li></ul></li><li><p>安装</p><ul><li><code>npm i speed-measure-webpack-plugin</code></li></ul></li><li><p>使用</p><ul><li>创建插件导出的对象 SpeedMeasurePlugin;</li><li>使用 smp.wrap 包裹我们导出的 webpack 配置;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SpeedMeasurePlugin = <span class="built_in">require</span>(<span class="string">&#x27;speed-measure-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isProduction = env.production;</span><br><span class="line">  process.env.NODE_ENV = isProduction ? <span class="string">&#x27;production&#x27;</span> : <span class="string">&#x27;development&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> config = isProduction ? prodConfig : devConfig;</span><br><span class="line">  <span class="keyword">const</span> webpackConfig = merge(commonConfig(isProduction), config);</span><br><span class="line">  <span class="keyword">return</span> smp.wrap(webpackConfig);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>效果</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/33dce190bd2344059ba35f5923d08985~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210502234038719"></p><h2 id="打包后的文件分析">打包后的文件分析</h2><h3 id="方案一：生成-stats-json-文件">方案一：生成 stats.json 文件</h3><ul><li>编辑 npm script</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;stats&quot;: &quot;webpack --config ./config/webpack.common.js --env production --profile --json=stats.json&quot;,</span><br></pre></td></tr></table></figure><ul><li><p>运行 npm run stats</p><ul><li>根目录下生成了一个 stats.json</li></ul></li><li><p>json 文件内容较复杂，可以将文件上传至https://webpack.github.io/analyse/ 进行分析</p></li><li><p>效果</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e4274bbeb174029a66c2476e471d03e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="方案二：使用-webpack-bundle-analyzer">方案二：使用 webpack-bundle-analyzer</h3><ul><li><p>安装</p><ul><li><code>npm install webpack-bundle-analyzer</code></li></ul></li><li><p>webpack.common.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">plugins: [<span class="keyword">new</span> BundleAnalyzerPlugin()];</span><br></pre></td></tr></table></figure><ul><li><p>在打包 webpack 的时候，这个工具打开一个 8888 端口上的服务，我们可以直观的看到每个包的大小。</p><ul><li>比如有一个包是通过一个 Vue 组件打包的，但是非常的大，那么我们可以考虑是否可以拆分出多个组件，并且对其进行懒加载;</li><li>比如一个图片或者字体文件特别大，是否可以对其进行压缩或者其他的优化处理;</li></ul></li><li><p>效果</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/7736de9810554f7fb63fcc2dce63b65f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210502234139506"></p><p>[<a href="https://juejin.cn/post/6968275465572188191">分享]Webpack 打包分析工具 (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://juejin.cn/post/6968275465572188191&quot;&gt;分享]Webpack 打包分析工</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>[打包优化]Webpack DLL</title>
    <link href="https://lebronchao.com/2021/06/07/WebpackDLL/"/>
    <id>https://lebronchao.com/2021/06/07/WebpackDLL/</id>
    <published>2021-06-07T15:53:03.000Z</published>
    <updated>2021-06-07T15:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6967164397127270436">打包优化]Webpack DLL (juejin.cn)</a></p></blockquote><h1>认识 DLL 库</h1><ul><li><p>什么是 DLL</p><ul><li>DLL 全称是动态链接库(Dynamic Link Library)，是为软件在 Windows 中实现共享函数库的一种实现方式;</li><li>那么 webpack 中也有内置 DLL 的功能，它指的是可以将可以共享，并且不经常改变的代码，抽取成一个共享的库;</li><li>这个库在之后编译的过程中，会被引入到其他项目的代码中，减少的打包的时间;</li></ul></li><li><p>DDL 库的使用分为两步:</p><ul><li>第一步:打包一个 DLL 库;</li><li>第二步:项目中引入 DLL 库</li></ul></li></ul><h2 id="DLL-打包">DLL 打包</h2><blockquote><p>webpack 内置 DllPlugin 帮助生成 DLL 文件</p></blockquote><ul><li>webpack.common.js<ul><li>context：执行上下文，</li><li>entry：<ul><li>key：name（placeholder）</li><li>value：要打包的包名</li></ul></li><li>output（常规）</li><li>plugins<ul><li>DllPlugin<ul><li>name：定义生成 dll 文件的名称</li><li>path：生成 dll 文件的文件路径</li></ul></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; DllPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="function">(<span class="params">isProduction</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    context: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>),</span><br><span class="line">    entry: &#123;</span><br><span class="line">      react: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">&#x27;../dll&#x27;</span>),</span><br><span class="line">      filename: <span class="string">&#x27;dll_[name].js&#x27;</span>,</span><br><span class="line">      library: <span class="string">&#x27;dll_[name]&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> DllPlugin(&#123;</span><br><span class="line">        name: <span class="string">&#x27;[name].manifest.json&#x27;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;../dll/[name].manifest.json&#x27;</span>),</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.dev&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.prod&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isProduction = env.production;</span><br><span class="line">  process.env.NODE_ENV = isProduction ? <span class="string">&#x27;production&#x27;</span> : <span class="string">&#x27;development&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> config = isProduction ? prodConfig : devConfig;</span><br><span class="line">  <span class="keyword">return</span> merge(commonConfig(isProduction), config);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>打包完成后，在根目录下会有一个 dll 文件夹，内有 Dll 文件和相应 manifest.json 文件。</p></blockquote><h2 id="DLL-使用">DLL 使用</h2><ul><li>如果我们的代码中使用了 react、react-dom，有配置 splitChunks 的情况下，他们会进行分包，打包到 一个独立的 chunk 中。<ul><li>但是现在有了 dll_react，不再需要单独去打包它们，可以直接去引用 dll_react 即可:</li><li>第一步:通过 DllReferencePlugin 插件告知要使用的 DLL 库;</li><li>第二步:通过 AddAssetHtmlPlugin 插件，将打包的 DLL 库引入到 Html 模块中;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>),</span><br><span class="line">  manifest: path.resolve(__dirname, <span class="string">&#x27;../dll/react.manifest.json&#x27;</span>),</span><br><span class="line">&#125;),</span><br><span class="line">  <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">    outputPath: <span class="string">&#x27;../build/js&#x27;</span>,</span><br><span class="line">    filepath: path.resolve(__dirname, <span class="string">&#x27;../dll/dll_react.js&#x27;</span>),</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure> <hr/><p>[<a href="https://juejin.cn/post/6967164397127270436">打包优化]Webpack DLL (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://juejin.cn/post/6967164397127270436&quot;&gt;打包优化]Webpack DLL</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>[探索]Webpack DevServer和HMR原理</title>
    <link href="https://lebronchao.com/2021/06/07/WebpackDevServer%E5%92%8CHMR%E5%8E%9F%E7%90%86/"/>
    <id>https://lebronchao.com/2021/06/07/WebpackDevServer%E5%92%8CHMR%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-07T15:49:57.000Z</published>
    <updated>2021-06-07T15:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6966422095274180639">探索]Webpack DevServer 和 HMR 原理 (juejin.cn)</a></p></blockquote><h1>Webpack-Dev-Server</h1><blockquote><p>为什么要搭建本地服务器</p></blockquote><ul><li><p>目前开发的代码，为了运行需要有两个操作</p><ul><li><code>npm run build</code>编译</li><li>通过 live-server 或者直接通过浏览器打开 html 文件，查看效果</li></ul></li><li><p>为了完成自动编译，webpack 提供了几种可选的方式</p><ul><li>Webpack watch mode</li><li>Webpack-dev-server</li><li>Webpack-dev-middleware</li></ul></li></ul><h2 id="Webpack-Watch-Mode">Webpack Watch Mode</h2><ul><li><p>webpack 提供了 watch 模式</p><ul><li>在该模式下，webpack 依赖图中所有文件，只要有一个发生了更新，那么代码将被重新编译。</li><li>不需要手动<code>npm run build</code></li></ul></li><li><p>如何开启？</p><ul><li>方式一：在导出的配置中，添加 watch:true</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;js/bundle.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方式二：在启动 webapck 的命令中，添加–watch 标识</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">npm script:&#123;</span><br><span class="line"> &quot;watch&quot;: &quot;webpack --watch&quot;</span><br><span class="line">&#125;</span><br><span class="line"># npm run watch</span><br></pre></td></tr></table></figure><h2 id="Webpack-Dev-Server">Webpack Dev Server</h2><ul><li><p>上面的方式可以监听到文件的变化，但是没有自动刷新浏览器的功能</p><ul><li>webpack-dev-server 可以实现</li></ul></li><li><p>安装</p><ul><li><code>npm install --save webpack-dev-server</code></li></ul></li><li><p>修改 npm script，同时可在配置文件中 devServer 属性下配置 devServer</p></li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">script:&#123;</span><br><span class="line">    &quot;serve&quot;:&quot;webpack serve&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>webpack-dev-server 在编译之后不会写入到任何输出文件。而是将 bundle 文件保留在内存中<ul><li>事实上 webpck-dev-server 使用了一个叫 memfs 的库。</li></ul></li></ul><h2 id="Webpack-Dev-Middleware">Webpack Dev Middleware</h2><ul><li><p>webpack-dev-middleware 是一个封装器，它可以把 webpack 处理过的文件发送到一个 server</p><ul><li>webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义配置</li><li>搭配一个服务器来使用它，比如 express.</li><li><code>npm install --save express webpack-dev-middleware</code></li></ul></li><li><p>编写 Server.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">&#x27;webpack-dev-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  webpackDevMiddleware(compiler, &#123;</span><br><span class="line">    publicPath: config.output.publicPath,</span><br><span class="line">  &#125;),</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这里是回调函数&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server running&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Node Server.js 即可运行起一个服务，并监听文件更改和刷新浏览器。</li></ul><h2 id="PublicPath">PublicPath</h2><ul><li><p>Output 中有两个很重要的属性：path 和 publicPath</p><ul><li>path：用于指定文件的输出路径，是一个聚堆路径</li><li>publicPath：默认是一个空字符串，它为我们项目中的资源制定一个公共的路径 publicPath</li></ul></li><li><p>这个 publicPath 很不容易理解，其实就是给我们打包的资源，给它一个路径</p><ul><li>资源的路径 = output.publicePath + 打包资源的路径(比如&quot;js/[name].bundle.js&quot;)</li></ul></li><li><p>常用的值</p><ul><li>./ :本地环境下可以使用这个相对路径</li><li>/ :服务器部署时使用，服务器地址 + /js/[name].bundle.js</li></ul></li><li><p>devServer 的 publicPath、output 的 publicPath 和[webpackDevMiddleware 的 publicPath]需一致</p></li></ul><h2 id="ContentBase">ContentBase</h2><ul><li><p>devServer 中 contentBase 对于我们直接访问打包后的资源其实并没有太大的作用，它的主要作用是如果我们打包后的资源，又依赖于其他的一些资源，那么就需要指定从哪里来查找这个内容:</p><ul><li>比如在 index.html 中，我们需要依赖一个 abc.js 文件，这个文件我们存放在 public 文件中;</li><li>在 index.html 中，我们应该如何去引入这个文件?<ul><li>比如代码是这样的:<script src="./public/abc.js"></script>;</li><li>这样打包后浏览器无法通过相对路径去找到这个文件夹;</li><li>所以代码是这样:<script src="/abc.js"></script>;</li><li>如何让它去查找到这个文件的存在? 设置 contentBase 即可;</li></ul></li></ul></li><li><p>当然在 devServer 中还有一个可以监听 contentBase 发生变化后重新编译的一个属性：watchContentBase。</p></li></ul><h2 id="Proxy-代理">Proxy 代理</h2><blockquote><p>proxy 是我们开发中常用的一个配置选项，它的目的设置代理来解决跨域访问的问题</p></blockquote><ul><li>设置<ul><li>target：标识的是代理到的目标地址，比如/api/moment 会被代理到 <a href="http://localhost:8888/api/moment">http://localhost:8888/api/moment</a></li><li>pathRewrite：默认情况下，我们的/api 也会被写入到 URL 中，如果希望删除，可以使用</li><li>secure：默认情况下不接受转发到 https 的服务器，如果希望支持，设置为 false</li><li>changeOrigin：表示是否更新代理后请求 headers 中的 host 地址</li><li>historyApiFallback：解决 SPA 页面在路由跳转后，进行页面刷新返回 404 的错误<ul><li>boolean 值：默认是 false，如果设置为 true，刷新的时候，返回 404 错误时，会自动返回 index.html 的内容</li><li>object 值：可以配置 rewrites 属性<ul><li>可以配置 from 来匹配路径，决定要跳到哪个页面，详情查阅官方文档。</li></ul></li></ul></li></ul></li></ul><h2 id="Other-Config">Other Config</h2><ul><li><p>hotOnly</p><ul><li>默认情况下当代码编译失败修复后会刷新页面，不希望刷新设置 hotOnly:true</li></ul></li><li><p>host 主机地址</p><ul><li>默认值是 localhost</li><li>如果其他 PC 也可以访问可设置 0.0.0.0</li></ul></li><li><p>localhost 和 0.0.0.0 的区别</p><ul><li>localhost 本质上是一个域名会被解析为 127.0.0.1</li><li>127.0.0.1 是一个会换地址，表达得意思是主机自己发出去的包，直接被自己接受<ul><li>正常的数据库包经常 应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 数据链路层 -&gt; 物理层</li><li>而回环地址，在网联络层直接就被获取</li><li>监听 127.0.0.1 时，同个网段下的主机中，通过 ip 地址是不能访问的。</li></ul></li><li>0.0.0.0：监听 IPV4 上所有的地址，再根据端口找到不同的应用程序。<ul><li>监听 0.0.0.0 时，在同一个网段下的主机中，通过 IP 地址是可以访问的。</li></ul></li></ul></li><li><p>Port</p><ul><li>设置监听的端口，默认为 8080</li></ul></li><li><p>open 是否打开浏览器</p><ul><li>默认为 false，true 会打开浏览器</li><li>也可以设置类似于 Google Chrome 等值</li></ul></li><li><p>compress 是否为静态文件开启 gzip compression</p><ul><li>默认是是 false，可以设置为 true</li></ul></li></ul><h2 id="配置示例">配置示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    hostOnly:<span class="literal">true</span>,</span><br><span class="line">    host:<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    port:<span class="number">8080</span>,</span><br><span class="line">    open:<span class="literal">true</span>,</span><br><span class="line">    compress:<span class="literal">true</span>,</span><br><span class="line">    proxy:&#123;</span><br><span class="line">        <span class="string">&quot;/api&quot;</span>:&#123;</span><br><span class="line">            target:<span class="string">&quot;http://localhost:8888&quot;</span>,</span><br><span class="line">            pathRewrite:&#123;</span><br><span class="line">                <span class="string">&quot;^/api&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            secure:<span class="literal">false</span>,</span><br><span class="line">            changeOrigin:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Hot Module Replacement</h1><ul><li><p>什么是 HMR?</p><ul><li>HMR 全称 Hot Module Replacement，翻译为模块热替换</li><li>模块热替换是指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面。</li></ul></li><li><p>HMR 通过如下几种方式，来提高开发的速度。</p><ul><li>不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；</li><li>只需更新需要变化的内容，节省开发时间</li><li>修改了 css、js 源代码，会立即在浏览器更新，相当于直接在浏览器的 devtools 中直接修改样式。</li></ul></li><li><p>如何使用 HMR？</p><ul><li>默认情况下，webpack-dev-server 已经支持 HMR，只需要开启即可。</li><li>在不开启 HMR 的情况下，修改了源代码后，整个页面会自动刷新，使用的是 live reloading。</li></ul></li><li><p>如何开启</p><ul><li>修改 webpack.config.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;js/bundle.js&#x27;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: <span class="literal">true</span>,</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>更新后还是刷新整个浏览器，因为需要定义使用 HMR 的模块。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./App.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;vue更新了&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="框架的-HMR">框架的 HMR</h2><blockquote><p>有一个问题:在开发其他项目时，我们是否需要经常手动去写入 module.hot.accpet 相关的 API 呢?</p></blockquote><ul><li><p>比如开发 Vue、React 项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作?</p></li><li><p>社区已经针对这些有很成熟的解决方案了:</p><ul><li>比如 vue 开发中，我们使用 vue-loader，此 loader 支持 vue 组件的 HMR，提供开箱即用的体验;</li><li>比如 react 开发中，有 React Hot Loader，实时调整 react 组件(目前 React 官方已经弃用了，改成使用 react- refresh);</li></ul></li></ul><h2 id="Vue-的-HMR">Vue 的 HMR</h2><ul><li><p>Vue 的加载需要 vue-loader，而 vue-loader 加载的默认会进行 HMR 处理</p></li><li><p>安装加载 Vue 所需依赖</p><ul><li><code>npm install vue-loader vue-template-compiler</code></li></ul></li><li><p>配置 Webpack.config.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&quot;vue-loader/lib/plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">            use: [<span class="string">&quot;vue-loader&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">   ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[<span class="keyword">new</span> VueLoaderPlugin()]</span><br></pre></td></tr></table></figure><h2 id="React-的-HMR">React 的 HMR</h2><ul><li><p>在之前，React 是借助 React Hot Loader 来实现 HMR，目前已经改成使用 react-refesh 来实现了</p></li><li><p>安装相关依赖</p><ul><li><code>npm install @pmmmwh/react-refresh-webpack-plugin react-refresh</code></li></ul></li><li><p>webpack.config.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactRefreshWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;@pmmmwh/react-refresh-webpack-plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> ReactRefreshWebpackPlugin(),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><ul><li>babel.config.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        useBuiltIns: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">        corejs: <span class="number">3.8</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    [<span class="string">&#x27;@babel/preset-react&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;@babel/preset-typescript&#x27;</span>],</span><br><span class="line">  ],</span><br><span class="line">  plugins: [[<span class="string">&#x27;react-refresh/babel&#x27;</span>]],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="HMR-的原理">HMR 的原理</h2><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/98219680ad66478c89385a4e0fbaacd8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210502184548214"></p><ul><li><p>那么 HMR 的原理是什么呢？如何可以做到只更新一个模块中的内容？</p><ul><li>webpack-dev-server 会创建两个服务：提供静态资源的服务（express）和 Socket（net.Socket）</li><li>Express Server 负责直接提供静态资源服务（打包后的资源直接被浏览器请求和解析）</li></ul></li><li><p>HMR Socket Server 是一个 socket 长连接</p><ul><li>长连接有一个最好的好处是建立连接后双方可以通信（服务器可以直接发送文件到客户端）</li><li>当服务期间听到对应模块发上变化时，会生成两个文件.json（manifest 文件）和.js 文件（update chunk）</li><li>通过长连接，可以直接将这两个文件主动发送给客户端。</li><li>浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新。</li></ul><hr/></li></ul><p>[<a href="https://juejin.cn/post/6966422095274180639">探索]Webpack DevServer 和 HMR 原理 (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://juejin.cn/post/6966422095274180639&quot;&gt;探索]Webpack DevSe</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>Webpack模块化原理和SourceMap</title>
    <link href="https://lebronchao.com/2021/05/25/Webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8CSourceMap/"/>
    <id>https://lebronchao.com/2021/05/25/Webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8CSourceMap/</id>
    <published>2021-05-25T15:31:43.000Z</published>
    <updated>2021-05-25T15:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！<br/><a href="https://juejin.cn/post/6965677810862161950">掘金原文链接</a></p></blockquote><h1>Webpack 模块化</h1><ul><li><p>Webpack 打包的代码，允许我们使用各种各样的模块化，但是最常用的是 CommonJS、ES Module。</p></li><li><p>包括如下原理:</p><ul><li>CommonJS 模块化实现原理;</li><li>ES Module 实现原理;</li><li>CommonJS 加载 ES Module 的原理;</li><li>ES Module 加载 CommonJS 的原理;</li></ul></li></ul><h2 id="CommonJS：">CommonJS：</h2><h3 id="打包前">打包前</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; dateFormat, priceFormat &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./js/format&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dateFormat(<span class="string">&#x27;abc&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(priceFormat(<span class="string">&#x27;abc&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="打包后">打包后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了一个对象</span></span><br><span class="line"><span class="comment">// 模块的路径(key): 函数(value)</span></span><br><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">  <span class="string">&#x27;./src/js/format.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dateFormat = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;2020-12-12&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> priceFormat = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;100.00&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将我们要导出的变量, 放入到module对象中的exports对象</span></span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      dateFormat,</span><br><span class="line">      priceFormat,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象, 作为加载模块的缓存</span></span><br><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是一个函数, 当我们加载一个模块时, 都会通过这个函数来加载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.判断缓存中是否已经加载过</span></span><br><span class="line">  <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_module_cache__[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.给module变量和__webpack_module_cache__[moduleId]赋值了同一个对象</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.加载执行模块</span></span><br><span class="line">  __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.导出module.exports &#123;dateFormat: function, priceForamt: function&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体开始执行代码逻辑</span></span><br><span class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.加载./src/js/format.js</span></span><br><span class="line">  <span class="keyword">const</span> &#123; dateFormat, priceFormat &#125; = __webpack_require__(<span class="string">&#x27;./src/js/format.js&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(dateFormat(<span class="string">&#x27;abc&#x27;</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(priceFormat(<span class="string">&#x27;abc&#x27;</span>));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="ES-Module">ES Module</h2><h3 id="打包前-2">打包前</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum, mul &#125; <span class="keyword">from</span> <span class="string">&#x27;./js/math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><h3 id="打包后-2">打包后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义了一个对象, 对象里面放的是我们的模块映射</span></span><br><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">  <span class="string">&#x27;./src/es_index.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    __unused_webpack_module,</span></span></span><br><span class="line"><span class="function"><span class="params">    __webpack_exports__,</span></span></span><br><span class="line"><span class="function"><span class="params">    __webpack_require__</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用r的目的是记录时一个__esModule -&gt; true</span></span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _js_math__WEBPACK_IMPORTED_MODULE_0__ == exports</span></span><br><span class="line">    <span class="keyword">var</span> _js_math__WEBPACK_IMPORTED_MODULE_0__ =</span><br><span class="line">      __webpack_require__(<span class="string">&#x27;./src/js/math.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(_js_math__WEBPACK_IMPORTED_MODULE_0__.mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(_js_math__WEBPACK_IMPORTED_MODULE_0__.sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;./src/js/math.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    __unused_webpack_module,</span></span></span><br><span class="line"><span class="function"><span class="params">    __webpack_exports__,</span></span></span><br><span class="line"><span class="function"><span class="params">    __webpack_require__</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用了d函数: 给exports设置了一个代理definition</span></span><br><span class="line">    <span class="comment">// exports对象中本身是没有对应的函数</span></span><br><span class="line">    __webpack_require__.d(__webpack_exports__, &#123;</span><br><span class="line">      sum: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">      &#125;,</span><br><span class="line">      mul: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mul;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> mul = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.模块的缓存</span></span><br><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.require函数的实现(加载模块)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_module_cache__[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// __webpack_require__这个函数对象添加了一个属性: d -&gt; 值function</span></span><br><span class="line">  __webpack_require__.d = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, definition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> definition) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        __webpack_require__.o(definition, key) &amp;&amp;</span><br><span class="line">        !__webpack_require__.o(<span class="built_in">exports</span>, key)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, key, &#123;</span><br><span class="line">          enumerable: <span class="literal">true</span>,</span><br><span class="line">          get: definition[key],</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// __webpack_require__这个函数对象添加了一个属性: o -&gt; 值function</span></span><br><span class="line">  __webpack_require__.o = <span class="function"><span class="keyword">function</span> (<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// __webpack_require__这个函数对象添加了一个属性: r -&gt; 值function</span></span><br><span class="line">  __webpack_require__.r = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">&#x27;Module&#x27;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">__webpack_require__(<span class="string">&#x27;./src/es_index.js&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="ES-Module-和-CommonJS-混合导入导出">ES Module 和 CommonJS 混合导入导出</h2><h3 id="打包前-3">打包前</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es module导出内容, CommonJS导入内容</span></span><br><span class="line"><span class="keyword">const</span> &#123; sum, mul &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./js/math&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS导出内容, es module导入内容</span></span><br><span class="line"><span class="keyword">import</span> &#123; dateFormat, priceFormat &#125; <span class="keyword">from</span> <span class="string">&#x27;./js/format&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dateFormat(<span class="string">&#x27;aaa&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(priceFormat(<span class="string">&#x27;bbb&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(abc);</span><br></pre></td></tr></table></figure><h3 id="打包后-3">打包后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">  <span class="string">&#x27;./src/index.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    __unused_webpack_module,</span></span></span><br><span class="line"><span class="function"><span class="params">    __webpack_exports__,</span></span></span><br><span class="line"><span class="function"><span class="params">    __webpack_require__</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="keyword">var</span> _js_format__WEBPACK_IMPORTED_MODULE_0__ =</span><br><span class="line">      __webpack_require__(<span class="string">&#x27;./src/js/format.js&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> _js_format__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(</span><br><span class="line">      _js_format__WEBPACK_IMPORTED_MODULE_0__</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// es module导出内容, CommonJS导入内容</span></span><br><span class="line">    <span class="keyword">const</span> math = __webpack_require__(<span class="string">&#x27;./src/js/math.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CommonJS导出内容, es module导入内容</span></span><br><span class="line">    <span class="built_in">console</span>.log(math.sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(math.mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      _js_format__WEBPACK_IMPORTED_MODULE_0___default().dateFormat(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      _js_format__WEBPACK_IMPORTED_MODULE_0___default().priceFormat(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;./src/js/format.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dateFormat = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;2020-12-12&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> priceFormat = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;100.00&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">      dateFormat,</span><br><span class="line">      priceFormat,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;./src/js/math.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    __unused_webpack_module,</span></span></span><br><span class="line"><span class="function"><span class="params">    __webpack_exports__,</span></span></span><br><span class="line"><span class="function"><span class="params">    __webpack_require__</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    __webpack_require__.d(__webpack_exports__, &#123;</span><br><span class="line">      sum: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">      &#125;,</span><br><span class="line">      mul: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mul;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> mul = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The require function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check if module is in cache</span></span><br><span class="line">  <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_module_cache__[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="comment">// no module.id needed</span></span><br><span class="line">    <span class="comment">// no module.loaded needed</span></span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute the module function</span></span><br><span class="line">  __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the exports of the module</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class="line">  __webpack_require__.n = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getter =</span><br><span class="line">      <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule</span><br><span class="line">        ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">&#x27;default&#x27;</span>];</span><br><span class="line">          &#125;</span><br><span class="line">        : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">          &#125;;</span><br><span class="line">    __webpack_require__.d(getter, &#123; <span class="attr">a</span>: getter &#125;);</span><br><span class="line">    <span class="keyword">return</span> getter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webpack/runtime/define property getters */</span></span><br><span class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// define getter functions for harmony exports</span></span><br><span class="line">  __webpack_require__.d = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, definition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> definition) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        __webpack_require__.o(definition, key) &amp;&amp;</span><br><span class="line">        !__webpack_require__.o(<span class="built_in">exports</span>, key)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, key, &#123;</span><br><span class="line">          enumerable: <span class="literal">true</span>,</span><br><span class="line">          get: definition[key],</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webpack/runtime/hasOwnProperty shorthand */</span></span><br><span class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  __webpack_require__.o = <span class="function"><span class="keyword">function</span> (<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webpack/runtime/make namespace object */</span></span><br><span class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// define __esModule on exports</span></span><br><span class="line">  __webpack_require__.r = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">&#x27;Module&#x27;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">__webpack_require__(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><blockquote><p>原理都是类似的</p></blockquote><ol><li>通过一个 webpack_module 对象来存储模块化代码<ul><li>key 为文件名称</li><li>value 为文件代码</li></ul></li><li>通过 webpack_module_cache 来缓存模块化代码</li><li>通过 webpack_require 来从 webpack_module_cache 或 webpack_module 中读取并从引入代码</li></ol><h2 id="认识-Source-Map">认识 Source-Map</h2><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/SourceMap.jsm">参考文档 </a></p></blockquote><ul><li><p>我们的代码通常运行在浏览器上时，是通过打包压缩的:</p><ul><li>也就是真实跑在浏览器上的代码，和我们编写的代码其实是有差异的;</li><li>比如 ES6 的代码可能被转换成 ES5;</li><li>比如对应的代码行号、列号在经过编译后肯定会不一致;</li><li>比如代码进行丑化压缩时，会将编码名称等修改;</li><li>比如我们使用了 TypeScript 等方式编写的代码，最终转换成 JavaScript;</li></ul></li><li><p>通过 SourceMap 可以调试这种转换后不一致的代码</p><ul><li>source-map 是从已转换的代码，映射到原始的源文件;</li><li>使浏览器可以重构原始源并在调试器中显示重建的原始源;</li><li>更容易定位到源文件错误</li></ul></li></ul><h3 id="如何使用-SourceMap">如何使用 SourceMap</h3><ul><li><p>第一步:根据源文件，生成 source-map 文件，webpack 在打包时，可以通过配置生成 source-map;</p><p><code>devtool:'source-map'</code></p></li><li><p>第二步:在转换后的代码，最后添加一个注释，它指向 sourcemap;</p><p><code>//# sourceMappingURL=common.bundle.js.map</code></p></li><li><p>浏览器会根据我们的注释，查找相应的 source-map，并且根据 source-map 还原我们的代码，方便进行调试。</p></li><li><p>在 Chrome 中，我们可以按照如下的方式打开 source-map:</p><ul><li>√Enable JavaScript source maps</li><li>√Enable CSS source maps</li></ul></li><li><p>最初 source-map 生成的文件带下是原始文件的 10 倍，第二版减少了约 50%，第三版又减少了 50%，所以目前一个 133kb 的文件，最终的 source-map 的大小大概在 300kb。</p></li><li><p>目前的 source-map 长什么样子？</p><ul><li>version:当前使用的版本，也就是最新的第三版;</li><li>sources:从哪些文件转换过来的 source-map 和打包的代码(最初始的文件);</li><li>names:转换前的变量和属性名称(因为目前使用的是 development 模式，所以不需要保留转换前的名称);</li><li>mappings:source-map 用来和源文件映射的信息(比如位置信息等)，一串 base64 VLQ(veriable- length quantity 可变长度值)编码;</li><li>file:打包后的文件(浏览器加载的文件);</li><li>sourceContent:转换前的具体代码信息(和 sources 是对应的关系);</li><li>sourceRoot:所有的 sources 相对的根目录;</li></ul></li></ul><h3 id="生成-SourceMap">生成 SourceMap</h3><blockquote><p>如何在使用 webpack 打包的时候，生成对应的 source-map?</p></blockquote><ul><li><p>webpack 为我们提供了非常多的选项(目前是 26 个)，来处理 source-map;</p></li><li><p>参考文档：<a href="https://webpack.docschina.org/configuration/devtool/">https://webpack.docschina.org/configuration/devtool/</a></p></li><li><p>选择不同的值，生成的 source-map 会稍微有差异，打包的过程也会有性能的差异，可以根据不同的情况进行 选择;</p></li></ul><blockquote><p>下面几个值不会生成 source-map</p></blockquote><ul><li><p>false:不使用 source-map，也就是没有任何和 source-map 相关的内容。</p></li><li><p>none:production 模式下的默认值（什么值都不写），不生成 source-map。</p></li><li><p>eval:development 模式下的默认值，不生成 source-map</p><ul><li>但是它会在 eval 执行的代码中，添加 //# sourceURL=;</li><li>它会被浏览器在执行时解析，并且在调试面板中生成对应的一些文件目录，方便我们调试代码;</li></ul></li></ul><blockquote><p>使用 source-map 的值</p></blockquote><ul><li><p>source-map</p><ul><li>生成独立的 source-map 文件，并在打包后的 JS 文件中有一个注释指向 source-map 文件；<ul><li>注释： `` //# sourceMappingURL=bundle.js.map`</li></ul></li></ul></li><li><p>eval-source-map</p><ul><li>source-map 以 DataUrl 的形式添加到 eval 函数后面</li></ul></li><li><p>inline-source-map</p><ul><li>source-map 以 DataUrl 的形式添加到打包后的 JS 文件后面（注释）</li></ul></li><li><p>cheap-source-map:</p><ul><li>会生成 source-map，但是会更加高效一些(cheap 低开销)，因为它没有生成列映射(Column Mapping)</li><li>因为在开发中，我们只需要行信息通常就可以定位到错误了</li></ul></li><li><p>cheap-module-source-map:</p><ul><li>会生成 source-map，类似于 cheap-source-map，但是对源自 loader 的 source-map 处理会更好。</li><li>对源自 loader 的 source-map 处理会更好，官方也没有给出很好的解释 其实是如果 loader 对我们的源码进行了特殊的处理，比如 babel,会恢复成源文件的代码模块格式，例如不会删除自定义的空行。</li></ul></li><li><p>hidden-source-map:</p><ul><li>会生成 sourcemap，但是不会对 source-map 文件进行引用;</li><li>相当于删除了打包文件中对 sourcemap 的引用注释</li><li># sourceMappingURL=bundle.js.map</li><li>如果手动添加进来，那么 source-map 就会生效了</li></ul></li><li><p>nosources-source-map:</p><ul><li>会生成 sourcemap，但是生成的 sourcemap 只有错误信息的提示，不会生成源代码文件;</li><li>点击错误信息也无法查看源码</li></ul></li></ul><blockquote><p>多个值的组合</p></blockquote><ul><li><p>事实上，webpack 提供给我们的 26 个值，是可以进行多组合的。</p></li><li><p>组合的规则如下:</p></li><li><p>inline-|hidden-|eval:三个值时三选一;</p></li><li><p>nosources:可选值;</p></li><li><p>cheap 可选值，并且可以跟随 module 的值;</p></li></ul><blockquote><p>那么在开发中，最佳的实践是什么呢?</p></blockquote><ul><li><p>开发阶段:推荐使用 source-map 或者 cheap-module-source-map</p><ul><li>这分别是 vue 和 react 使用的值，可以获取调试信息，方便快速开发;</li></ul></li><li><p>测试阶段:推荐使用 source-map 或者 cheap-module-source-map</p><ul><li>测试阶段我们也希望在浏览器下看到正确的错误提示;</li></ul></li><li><p>发布阶段:false、缺省值(不写)</p></li></ul><hr/><p><a href="https://juejin.cn/post/6965677810862161950">掘金原文链接</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;br/&gt;&lt;a href=&quot;https://juejin.cn/post/6965677810862161950&quot;&gt;掘金原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
</feed>
