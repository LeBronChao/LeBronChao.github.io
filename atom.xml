<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeBronChao&#39;s Blog</title>
  
  
  <link href="https://lebronchao.com/atom.xml" rel="self"/>
  
  <link href="https://lebronchao.com/"/>
  <updated>2021-08-01T16:11:46.000Z</updated>
  <id>https://lebronchao.com/</id>
  
  <author>
    <name>LeBronChao-</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[深入浅出LB]手把手带你实现一个负载均衡器</title>
    <link href="https://lebronchao.com/2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://lebronchao.com/2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2021-08-01T16:11:46.000Z</published>
    <updated>2021-08-01T16:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Load Balance负载均衡 🌡</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622002849831.(null)" alt="img"></p><blockquote><p>简介</p></blockquote><p>负载均衡，含义就是根据一定算法将负载（工作任务）进行平衡，分摊到多个操作单元上运行、执行，常见的为Web服务器、企业核心应用服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡在原有的网络结构上提供了一种透明且有效的的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性，同时承受住更大的并发量级。</p><blockquote><p>简单来说就是将大量的并发请求处理转发给多个后端节点处理，减少工作响应时间。</p></blockquote><ul><li><p>避免资源浪费</p></li><li><p>避免服务不可用</p></li></ul><h1>一、分类</h1><h2 id="四层（传输层）">四层（传输层）</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622002908874.png" alt="image-20210622002908874"></p><p>四层即OSI七层模型中的传输层，有TCP、UDP协议，这两种协议中包含源IP、目标IP以外，还包含源端口号及目标端口号。四层负载均衡在接收到客户端请求后，通过修改报文的地址信息（IP + PORT）将流量转发到应用服务器。</p><h2 id="七层（应用层）">七层（应用层）</h2><blockquote><p>代理负载均衡</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622002927473.png" alt="image-20210622002927473"></p><p>七层即OSI七层模型中的应用层，应用层协议较多，常用的为HTTP/HTTPS。七层负载均衡可以给予这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP + PORT进行负载均衡，还可以根据七层的URL、Cookie、浏览器类别、语言、请求类型来决定。</p><blockquote><p>四层负载均衡的本质是转发，七层负载均衡的本质是内容交换和代理。</p></blockquote><table><thead><tr><th></th><th><strong>四层负载均衡</strong></th><th><strong>七层负载均衡</strong></th></tr></thead><tbody><tr><td><strong>基于</strong></td><td>IP + PORT</td><td>URL 或 主机IP</td></tr><tr><td><strong>类似</strong></td><td>路由器</td><td>代理服务器</td></tr><tr><td><strong>复杂度</strong></td><td>低</td><td>高</td></tr><tr><td><strong>性能</strong></td><td>高，无需解析内容</td><td>中，需算法识别URL Header、Cookie等</td></tr><tr><td><strong>安全性</strong></td><td>低，无法识别DDoS攻击</td><td>高，可防御SYN Flood攻击</td></tr><tr><td><strong>扩展功能</strong></td><td>无</td><td>内容缓存、图片防盗链等</td></tr></tbody></table><h1>二、常见算法</h1><blockquote><p>前置数据结构</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> urlObj&#123;</span><br><span class="line">  url:<span class="built_in">string</span>,</span><br><span class="line">  weight:<span class="built_in">number</span> <span class="comment">// 仅在权重轮询时生效</span></span><br><span class="line">&#125;</span><br><span class="line">urlDesc: urlObj[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> urlCollectObj&#123;</span><br><span class="line">  count: <span class="built_in">number</span>, <span class="comment">// 连接数</span></span><br><span class="line">  costTime: <span class="built_in">number</span>, <span class="comment">// 响应时间</span></span><br><span class="line">  connection: <span class="built_in">number</span>, <span class="comment">// 实时连接数</span></span><br><span class="line">&#125;</span><br><span class="line">urlCollect: urlCollectObj[]</span><br></pre></td></tr></table></figure><h2 id="Random">Random</h2><blockquote><p>随机</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622002949591.png" alt="image-20210622002949591"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Random = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  收集url</span></span><br><span class="line">  urlDesc.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    urlCollect.push(val.url);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  生成随机数下标返回相应URL</span></span><br><span class="line">    <span class="keyword">const</span> pos = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * urlCollect.length);</span><br><span class="line">    <span class="keyword">return</span> urlCollect[pos];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Random;</span><br></pre></td></tr></table></figure><h2 id="Weighted-Round-Robin">Weighted Round Robin</h2><blockquote><p>权重轮询算法</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003000250.png" alt="image-20210622003000250"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WeiRoundRobin = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span>,</span><br><span class="line">    urlCollect = [],</span><br><span class="line">    copyUrlDesc = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(urlDesc));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据权重收集url</span></span><br><span class="line">  <span class="keyword">while</span> (copyUrlDesc.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copyUrlDesc.length; i++) &#123;</span><br><span class="line">      urlCollect.push(copyUrlDesc[i].url);</span><br><span class="line">      copyUrlDesc[i].weight--;</span><br><span class="line">      <span class="keyword">if</span> (copyUrlDesc[i].weight === <span class="number">0</span>) &#123;</span><br><span class="line">        copyUrlDesc.splice(i, <span class="number">1</span>);</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 轮询获取URL函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = urlCollect[pos++];</span><br><span class="line">    <span class="keyword">if</span> (pos === urlCollect.length) &#123;</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WeiRoundRobin;</span><br></pre></td></tr></table></figure><h2 id="IP-Hash-URL-Hash">IP Hash &amp; URL Hash</h2><blockquote><p>源IP / URL Hash</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003030857.png" alt="image-20210622003030857"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Hash &#125; = <span class="built_in">require</span>(<span class="string">&quot;../util&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IpHash = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlDesc) &#123;</span><br><span class="line">    <span class="comment">// 收集url</span></span><br><span class="line">    urlCollect.push(urlDesc[key].url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">sourceInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 生成Hash十进制数值</span></span><br><span class="line">    <span class="keyword">const</span> hashInfo = Hash(sourceInfo);</span><br><span class="line">    <span class="comment">// 取余为下标</span></span><br><span class="line">    <span class="keyword">const</span> urlPos = <span class="built_in">Math</span>.abs(hashInfo) % urlCollect.length;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> urlCollect[urlPos];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = IpHash;</span><br></pre></td></tr></table></figure><h2 id="Consistent-Hash">Consistent Hash</h2><blockquote><p>一致性Hash</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003051914.png" alt="image-20210622003051914"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Hash &#125; = <span class="built_in">require</span>(<span class="string">&quot;../util&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ConsistentHash = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlHashMap = &#123;&#125;,</span><br><span class="line">    hashCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlDesc) &#123;</span><br><span class="line">    <span class="comment">// 收集urlHash进数组和生成HashMap</span></span><br><span class="line">    <span class="keyword">const</span> &#123; url &#125; = urlDesc[key];</span><br><span class="line">    <span class="keyword">const</span> hash = Hash(url);</span><br><span class="line">    urlHashMap[hash] = url;</span><br><span class="line">    hashCollect.push(hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将hash数组从小到大排序</span></span><br><span class="line">  hashCollect = hashCollect.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">sourceInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 生成Hash十进制数值</span></span><br><span class="line">    <span class="keyword">const</span> hashInfo = Hash(sourceInfo);</span><br><span class="line">    <span class="comment">// 遍历hash数组找到第一个比源信息hash值大的，并通过hashMap返回url</span></span><br><span class="line">    hashCollect.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &gt;= hashInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> urlHashMap[val];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 没找大则返回最大的</span></span><br><span class="line">    <span class="keyword">return</span> urlHashMap[hashCollect[hashCollect.length - <span class="number">1</span>]];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ConsistentHash;</span><br></pre></td></tr></table></figure><h2 id="Least-Connections">Least Connections</h2><blockquote><p>最小连接数</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003136462.png" alt="image-20210622003136462"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> leastConnections = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">urlCollect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.POSITIVE_INFINITY,</span><br><span class="line">      url = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历对象找到最少连接数的地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> urlCollect) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = urlCollect[key].connection;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; min) &#123;</span><br><span class="line">        min = val;</span><br><span class="line">        url = key;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = leastConnections;</span><br></pre></td></tr></table></figure><blockquote><p>注：urlCollect为负载均属数据统计对象，有以下属性</p></blockquote><ul><li><p>connection实时连接数</p></li><li><p>count处理请求次数</p></li><li><p>costTime响应时间。</p></li></ul><h2 id="FAIR">FAIR</h2><blockquote><p>最小响应时间</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003155965.png" alt="image-20210622003155965"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Fair = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">urlCollect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.POSITIVE_INFINITY,</span><br><span class="line">      url = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 找到耗时最少的url </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlCollect) &#123;</span><br><span class="line">      <span class="keyword">const</span> urlObj = urlCollect[key];</span><br><span class="line">      <span class="keyword">if</span> (urlObj.costTime &lt; min) &#123;</span><br><span class="line">        min = urlObj.costTime;</span><br><span class="line">        url = key;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Fair;</span><br></pre></td></tr></table></figure><blockquote><p>看到这里是不是感觉算法都挺简单的 🥱</p></blockquote><blockquote><p>期待一下模块四的实现吧😏</p></blockquote><h1>三、健康监测</h1><blockquote><p>健康监测即对应用服务器的健康监测，为防止把请求转发到异常的应用服务器上，应使用健康监测策略。应对不同的业务敏感程度，可相应调整策略和频率。</p></blockquote><h2 id="HTTP-HTTPS-健康监测步骤（七层）">HTTP / HTTPS 健康监测步骤（七层）</h2><ol><li>负载均衡节点向应用服务器发送HEAD请求。</li><li>应用服务器接收到HEAD请求后根据情况返回相应状态码。</li><li>若在超时时间内未收到返回的状态码，则判断为超时，健康检查失败。</li><li>若在超时时间内收到返回的状态码，负载均衡节点进行比对，判断健康检查是否成功。</li></ol><h2 id="TCP健康检查步骤（四层）">TCP健康检查步骤（四层）</h2><ol><li>负载均衡节点向内网应用服务器IP + PORT 发TCP SYN请求数据包。</li><li>内网应用服务器收到请求后，若在正常监听，则返回SYN + ACK数据包。</li><li>若在超时时间内未收到返回的数据包，则判断服务无响应、健康检查失败，并向内网应用服务器发送RST数据包中断TCP连接。</li><li>若在超时时间内收到返回的数据包，则判定服务健康运行，发起RST数据包中断TCP连接。</li></ol><h2 id="UDP健康检查步骤（四层）">UDP健康检查步骤（四层）</h2><ol><li>负载均衡节点向内网应用服务器IP + PORT发送UDP报文。</li><li>若内网应用服务器未正常监听，则返回<code>PORT XX unreachable</code>的ICMP报错信息，反之为正常。</li><li>若在超时时间内收到了报错信息，则判断服务异常，健康检查失败。</li><li>若在超时时间内未收到报错信息，则判断服务健康运行。</li></ol><h1>四、VIP技术</h1><blockquote><p>Vrtual IP</p></blockquote><h2 id="虚拟IP">虚拟IP</h2><ul><li>在TCP / IP架构下，所有想上网的电脑，不论以何种形式连上网络，都不需要有一个唯一的IP地址。事实上IP地址是主机硬件物理地址的一种抽象。</li><li>简单来说地址分为两种<ul><li>MAC物理地址</li><li>IP逻辑地址</li></ul></li><li>虚拟IP是一个未分配给真实主机的IP，也就是说对外提供的服务器的主机除了有一个真实IP还有一个虚IP，这两个IP中的任意一个都可以连接到这台主机。<ul><li>通过虚拟IP对应真实主机的MAC地址实现</li></ul></li><li>虚拟IP一般用作达到高可用的目的，比如让所有项目中的数据库链接配置都是这个虚拟IP，当主服务器发生故障无法对外提供服务时，动态将这个虚IP切换到备用服务器。</li></ul><h2 id="虚拟IP原理">虚拟IP原理</h2><ol><li>ARP是地址解析协议，作用为将一个IP地址转换为MAC地址。</li><li>每台主机都有ARP高速缓存，存储同一个网络内IP地址与MAC地址的映射关系，主机发送数据会先从这个缓存中查询目标IP对应MAC地址，向这个MAC地址发送数据。操作系统自动维护这个缓存。</li><li>Linux下可用ARP命令操作ARP高速缓存</li></ol><ul><li><p>比如存在主机A（192.168.1.6）和主机B（192.168.1.8）。A作为对外服务的主服务器，B作为备份机器，两台服务器之间通过HeartBeat通信。</p></li><li><p>即主服务器会定时给备份服务器发送数据包，告知主服务器正常，当备份服务器在规定时间内没有收到主服务器的HeartBeat，会认为主服务器宕机。</p></li><li><p>此时备份服务器就升级为主服务器。</p><ul><li>服务器B将自己的ARP缓存发送出去，告知路由器修改路由表，告知虚拟IP地址应该指向192.168.1.8.</li><li>这时外接再次访问虚拟IP的时候，机器B就会变成主服务器，而A降级为备份服务器。</li><li>这样就完成了主从机器的切换，这一切对外都是无感知、透明的。</li></ul></li></ul><h1>五、基于 nodejs 实现一个简单的负载均衡</h1><h2 id="预期效果">预期效果</h2><blockquote><p>编辑config.js后<code>npm run start</code>即可启动均衡器和后端服务节点</p></blockquote><ul><li><p>urlDesc：后端服务节点配置对象，weight仅在WeightRoundRobin算法时起作用</p></li><li><p>port：均衡器监听端口</p></li><li><p>algorithm：算法名称（模块二中的算法均已实现）</p></li><li><p>workerNum：后端服务端口开启进程数，提供并发能力。</p></li><li><p>balancerNum：均衡器端口开启进程数，提供并发能力。</p></li><li><p>workerFilePath：后端服务节点执行文件，推荐使用绝对路径。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ALGORITHM, BASE_URL&#125; = <span class="built_in">require</span>(<span class="string">&quot;./constant&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    urlDesc: [</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16666</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">6</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16667</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16668</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16669</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16670</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16671</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16672</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    algorithm: ALGORITHM.RANDOM,</span><br><span class="line">    workerNum: <span class="number">5</span>，</span><br><span class="line">    balancerNum: <span class="number">5</span>，</span><br><span class="line">    workerFilePath:path.resolve(__dirname, <span class="string">&quot;./worker.js&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="架构设计图">架构设计图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003323078.png" alt="image-20210622003323078"></p><h2 id="先来看看主流程-main-js">先来看看主流程 main.js</h2><ol><li><p>初始化负载均衡统计对象balanceDataBase</p><ul><li>balanceDataBase是一个DataBase类实例，用于统计负载均衡数据（后续会讲到）.</li></ul></li><li><p>运行均衡器</p><ul><li>多进程模型，提供并发能力。</li></ul></li><li><p>运行后端服务节点</p><ul><li>多线程+多进程模型，运行多个服务节点并提供并发能力。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;urlDesc, balancerNum&#125; = <span class="built_in">require</span>(<span class="string">&quot;./config&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> &#123;DataBase&#125; = <span class="built_in">require</span>(<span class="string">&quot;./util&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;Worker&#125; = <span class="built_in">require</span>(<span class="string">&#x27;worker_threads&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runWorker = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 防止监听端口数 &gt; CPU核数</span></span><br><span class="line">    <span class="keyword">const</span> urlObjArr = urlDesc.slice(<span class="number">0</span>, cpusLen);</span><br><span class="line">    <span class="comment">// 初始化创建子线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; urlObjArr.length; i++) &#123;</span><br><span class="line">        createWorkerThread(urlObjArr[i].url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runBalancer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置子进程执行文件</span></span><br><span class="line">    cluster.setupMaster(&#123;<span class="attr">exec</span>: path.resolve(__dirname, <span class="string">&quot;./balancer.js&quot;</span>)&#125;);</span><br><span class="line">    <span class="comment">// 初始化创建子进程</span></span><br><span class="line">    <span class="keyword">let</span> max</span><br><span class="line">    <span class="keyword">if</span> (balancerNum) &#123;</span><br><span class="line">        max = balancerNum &gt; cpusLen ? cpusLen : balancerNum</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        createBalancer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化负载均衡数据统计对象</span></span><br><span class="line"><span class="keyword">const</span> balanceDataBase = <span class="keyword">new</span> DataBase(urlDesc);</span><br><span class="line"><span class="comment">// 运行均衡器</span></span><br><span class="line">runBalancer();</span><br><span class="line"><span class="comment">// 运行后端服务节点</span></span><br><span class="line">runWorker();</span><br></pre></td></tr></table></figure><h3 id="创建均衡器（createBalancer函数）">创建均衡器（createBalancer函数）</h3><ol><li>创建进程</li><li>监听进程通信消息<ul><li>监听更新响应时间事件并执行更新函数<ul><li>用于FAIR算法（最小响应时间）。</li></ul></li><li>监听获取统计对象事件并返回</li></ul></li><li>监听异常退出并重新创建，进程守护。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createBalancer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">    worker.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 监听更新响应时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&quot;updateCostTime&quot;</span>) &#123;</span><br><span class="line">            balanceDataBase.updateCostTime(msg.URL, msg.costTime)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 监听获取url统计对象事件并返回</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&quot;getUrlCollect&quot;</span>) &#123;</span><br><span class="line">            worker.send(&#123;<span class="attr">type</span>: <span class="string">&quot;getUrlCollect&quot;</span>, <span class="attr">urlCollect</span>: balanceDataBase.urlCollect&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 监听异常退出事件并重新创建进程</span></span><br><span class="line">    worker.on(<span class="string">&quot;exit&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        createBalancer();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建后端服务节点（createWorkerThread函数）">创建后端服务节点（createWorkerThread函数）</h3><ol><li><p>创建线程</p></li><li><p>解析需要监听的端口</p></li><li><p>向子线程通信，发送需要监听的端口</p></li><li><p>通过线程通信，监听子线程事件</p><ul><li><p>监听连接事件，并触发处理函数。</p></li><li><p>监听断开连接事件并触发处理函数。</p></li><li><p>用于统计负载均衡分布和实时连接数。</p></li></ul></li><li><p>监听异常退出并重新创建，线程守护。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createWorkerThread = <span class="function">(<span class="params">listenUrl</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(path.resolve(__dirname, <span class="string">&quot;./workerThread.js&quot;</span>));</span><br><span class="line">    <span class="comment">// 获取监听端口</span></span><br><span class="line">    <span class="keyword">const</span> listenPort = listenUrl.split(<span class="string">&quot;:&quot;</span>)[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 向子线程发送要监听的端口号</span></span><br><span class="line">    worker.postMessage(&#123;<span class="attr">type</span>: <span class="string">&quot;port&quot;</span>, <span class="attr">port</span>: listenPort&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收子线程消息统计进程被访问次数</span></span><br><span class="line">    worker.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 监听连接事件并触发计数事件</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&quot;connect&quot;</span>) &#123;</span><br><span class="line">            balanceDataBase.add(msg.port);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 监听断开连接事件并触发计数事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (msg.type === <span class="string">&quot;disconnect&quot;</span>) &#123;</span><br><span class="line">            balanceDataBase.sub(msg.port);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 监听异常退出事件并重新创建进程</span></span><br><span class="line">    worker.on(<span class="string">&quot;exit&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        createWorkerThread(listenUrl);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再来看看均衡器工作流程-balancer-js">再来看看均衡器工作流程 balancer.js</h2><ol><li>获取getURL工具函数</li><li>监听请求并代理<ol><li>获取需要传入getURL工具函数的参数。</li><li>通过getURL工具函数获取均衡代理目的地址URL</li><li>记录请求开始时间</li><li>处理跨域</li><li>返回响应</li><li>通过进程通信，触发响应时间更新事件。</li></ol></li></ol><blockquote><p>注1：LoadBalance函数即通过算法名称返回不同的getURL工具函数，各算法实现见模块二：常见算法</p></blockquote><blockquote><p>注2：getSource函数即处理参数并返回，getURL为上面讲到的获取URL工具函数。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> LoadBalance = <span class="built_in">require</span>(<span class="string">&quot;./algorithm&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&quot;axios&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> &#123;urlFormat, ipFormat&#125; = <span class="built_in">require</span>(<span class="string">&quot;./util&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;ALGORITHM, BASE_URL&#125; = <span class="built_in">require</span>(<span class="string">&quot;./constant&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;urlDesc, algorithm, port&#125; = <span class="built_in">require</span>(<span class="string">&quot;./config&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取转发URL工具函数</span></span><br><span class="line">    <span class="keyword">const</span> getURL = LoadBalance(urlDesc.slice(<span class="number">0</span>, cpusLen), algorithm);</span><br><span class="line">    <span class="comment">// 监听请求并均衡代理</span></span><br><span class="line">    app.get(<span class="string">&quot;/&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取需要传入的参数</span></span><br><span class="line">        <span class="keyword">const</span> source = <span class="keyword">await</span> getSource(req);</span><br><span class="line">        <span class="comment">// 获取URL</span></span><br><span class="line">        <span class="keyword">const</span> URL = getURL(source);</span><br><span class="line">        <span class="comment">// res.redirect(301, URL) 重定向负载均衡</span></span><br><span class="line">        <span class="comment">// 记录请求开始时间</span></span><br><span class="line">        <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="comment">// 代理请求</span></span><br><span class="line">        axios.get(URL).then(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取负载均衡统计对象并返回</span></span><br><span class="line">            <span class="keyword">const</span> urlCollect = <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">            <span class="comment">// 处理跨域</span></span><br><span class="line">            res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            response.data.urlCollect = urlCollect;</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            res.send(response.data);</span><br><span class="line">            <span class="comment">// 记录相应时间并更新</span></span><br><span class="line">            <span class="keyword">const</span> costTime = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">            process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;updateCostTime&quot;</span>, costTime, URL&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 负载均衡服务器开始监听请求</span></span><br><span class="line">    app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Load Balance Server Running at <span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getSource = <span class="keyword">async</span> (req) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (algorithm) &#123;</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.IP_HASH:</span><br><span class="line">            <span class="keyword">return</span> ipFormat(req);</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.URL_HASH:</span><br><span class="line">            <span class="keyword">return</span> urlFormat(req);</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.CONSISTENT_HASH:</span><br><span class="line">            <span class="keyword">return</span> urlFormat(req);</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.LEAST_CONNECTIONS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.FAIR:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="如何在均衡器中获取负载均衡统计对象-getUrlCollect">如何在均衡器中获取负载均衡统计对象 getUrlCollect</h3><ol><li>通过进程通信，向父进程发送获取消息。</li><li>同时开始监听父进程通信消息，接收后使用Promise resovle返回。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取负载均衡统计对象</span></span><br><span class="line"><span class="keyword">const</span> getUrlCollect = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;getUrlCollect&quot;</span>&#125;)</span><br><span class="line">            process.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.type === <span class="string">&quot;getUrlCollect&quot;</span>) &#123;</span><br><span class="line">                    resolve(msg.urlCollect)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现服务节点并发-workerThread-js">如何实现服务节点并发 workerThread.js</h2><blockquote><p>使用多线程+多进程模型，为每个服务节点提供并发能力。</p></blockquote><h3 id="主进程流程">主进程流程</h3><ol><li>根据配置文件，创建相应数量服务节点。<ol><li>创建进程</li><li>监听父线程消息（服务节点监听端口），并转发给子进程。</li><li>监听子进程消息，并转发给父线程（建立连接、断开连接事件）。</li><li>监听异常退出并重新建立。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> &#123;parentPort&#125; = <span class="built_in">require</span>(<span class="string">&#x27;worker_threads&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;workerNum, workerFilePath&#125; = <span class="built_in">require</span>(<span class="string">&quot;./config&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    <span class="comment">// 创建工作进程函数</span></span><br><span class="line">    <span class="keyword">const</span> createWorker = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 创建进程</span></span><br><span class="line">        <span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">        <span class="comment">// 监听父线程消息，并转发给子进程。</span></span><br><span class="line">        parentPort.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.type === <span class="string">&quot;port&quot;</span>) &#123;</span><br><span class="line">                worker.send(&#123;<span class="attr">type</span>: <span class="string">&quot;port&quot;</span>, <span class="attr">port</span>: msg.port&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 监听子进程消息并转发给父线程</span></span><br><span class="line">        worker.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">            parentPort.postMessage(msg);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 监听进程异常退出并重新创建</span></span><br><span class="line">        worker.on(<span class="string">&quot;exit&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            createWorker();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按配置创建进程，但不可大于CPU核数</span></span><br><span class="line">    <span class="keyword">let</span> max</span><br><span class="line">    <span class="keyword">if</span> (workerNum) &#123;</span><br><span class="line">        max = workerNum &gt; cpusLen ? cpusLen : workerNum</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        createWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 后端服务执行文件</span></span><br><span class="line">    <span class="built_in">require</span>(workerFilePath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="子进程流程-worker-js（config-workerFilePath）">子进程流程 worker.js（config.workerFilePath）</h3><ol><li>通过进程间通信，向父进程发送消息，触发建立连接事件。</li><li>返回相应。</li><li>通过进程间通信，向父进程发送消息，触发断开连接事件。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">let</span> port = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发连接事件</span></span><br><span class="line">    process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;connect&quot;</span>, port&#125;);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;HTTP Version: &quot;</span> + req.httpVersion);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Connection PORT Is &quot;</span> + port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&quot;Hello My PORT is &quot;</span> + port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回响应</span></span><br><span class="line">    res.send(&#123;msg&#125;);</span><br><span class="line">    <span class="comment">// 触发断开连接事件</span></span><br><span class="line">    process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;disconnect&quot;</span>, port&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收主进通信消息中的端口口并监听</span></span><br><span class="line">process.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.type === <span class="string">&quot;port&quot;</span>) &#123;</span><br><span class="line">        port = msg.port;</span><br><span class="line">        app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Worker Listening &quot;</span> + port);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="最后来看看DataBase类">最后来看看DataBase类</h2><ul><li>成员：</li></ul><ol><li>status：任务队列状态</li><li>urlCollect：数据统计对象（提供给各算法使用 / 展示数据）<ol><li>count：处理请求数</li><li>costTime：响应时间</li><li>connection：实时连接数</li></ol></li><li>add方法<ol><li>增加连接数和实时连接数</li></ol></li><li>sub方法<ol><li>减少实时连接数</li></ol></li><li>updateCostTime方法<ol><li>更新响应时间</li></ol></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBase</span> </span>&#123;</span><br><span class="line">    urlCollect = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="title">constructor</span> (<span class="params">urlObj</span>) &#123;</span><br><span class="line">        urlObj.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.urlCollect[val.url] = &#123;</span><br><span class="line">                count: <span class="number">0</span>,</span><br><span class="line">                costTime: <span class="number">0</span>,</span><br><span class="line">                connection: <span class="number">0</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加连接数和实时连接数</span></span><br><span class="line">    add (port) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].count++;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].connection++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少实时连接数</span></span><br><span class="line">    sub (port) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].connection--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新响应时间</span></span><br><span class="line">    updateCostTime (url, time) &#123;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].costTime = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><blockquote><p>做了个可视化图表来看均衡效果(Random)✔️</p></blockquote><blockquote><p>看起来均衡效果还不错🧐</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622003557369.(null)" alt="img"></p><h1>小作业</h1><blockquote><p>想手动实现一下负载均衡器 / 看看源码的同学都可以看看 👉🏻   <a href="https://github.com/LeBronChao/LoadBalancer">代码仓库</a></p></blockquote><h1>六、知识扩展</h1><h2 id="cluster多进程为什么可以监听一个端口">cluster多进程为什么可以监听一个端口?</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003752283.png" alt="image-20210622003752283"></p><ol><li>通过cluster.isMaster判断是否为主进程，主进程不负责任务处理，只负责管理和调度工作子进程。</li><li>master主进程启动了一个TCP服务器，真正监听端口的只有这个TCP服务器。请求触发了这个TCP服务器的<code>connection</code>事件后，通过句柄转发（IPC）给工作进程处理。<ol><li>句柄转发可转发TCP服务器、TCP套接字、UDP套接字、IPC管道</li><li>IPC只支持传输字符串，不支持传输对象（可序列化）。</li><li>转发流程：父进程发送 -&gt; stringfy &amp;&amp; send(fd) -&gt; IPC -&gt; get(fd) &amp;&amp; parse -&gt; 子进程接收</li><li>fd为句柄文件描述符。</li></ol></li><li>如何选择工作进程?<ol><li>cluster模块内置了RoundRobin算法，轮询选择工作进程。</li></ol></li><li>为什么不直接用cluster进行负载均衡?<ol><li>手动实现可根据不同场景选择不同的负载均衡算法。</li></ol></li></ol><h2 id="Node怎么实现进程间通信的？">Node怎么实现进程间通信的？</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622003758932.(null)" alt="img"></p><ol><li>常见的进程间通信方式<ol><li>管道通信<ol><li>匿名管道</li><li>命名管道</li></ol></li><li>信号量</li><li>共享内存</li><li>Socket</li><li>消息队列</li></ol></li><li>Node中实现IPC通道是依赖于libuv。Windows下由命名管道实现，*nix系统则采用Domain Socket实现。</li><li>表现在应用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。</li><li>IPC管道是如何建立的？<ol><li>父进程先通过环境变量告知子进程管道的文件描述符</li><li>父进程创建子进程</li><li>子进程启动，通过文件描述符连接已存在的IPC管道，与父进程建立连接。</li></ol></li></ol><h2 id="多进程-VS-多线程">多进程 VS 多线程</h2><h3 id="多进程">多进程</h3><ol><li>数据共享复杂，需要IPC。数据是分开的，同步简单。</li><li>占用内存多，CPU利用率低。</li><li>创建销毁复杂，速度慢</li><li>进程独立运行，不会相互影响</li><li>可用于多机多核分布式，易于扩展</li></ol><h3 id="多线程">多线程</h3><ol><li>共享进程数据，数据共享简单，同步复杂。</li><li>占用内存少，CPU利用率高。</li><li>创建销毁简单，速度快。</li><li>线程同呼吸共命运。</li><li>只能用于多核分布式。</li></ol><h1>七、由本次分享产生的一些想法</h1><blockquote><p>欢迎留言讨论</p></blockquote><ol><li>Node.js非阻塞异步I/O速度快，前端扩展服务端业务？</li><li>企业实践，说明Node还是可靠的？<ol><li>阿里Node中台架构</li><li>腾讯CloudBase云开发Node</li><li>大量Node.js全栈工程师岗位</li></ol></li><li>Node计算密集型不友好？<ol><li>Serverless盛行，计算密集型用C++/Go/Java编写，以Faas的方式调用。</li></ol></li><li>Node生态不如其他成熟的语言<ol><li>阿里输出了Java生态</li><li>是不是可以看准趋势，打造Node生态以增强团队影响力。</li></ol></li><li>未雨绸缪，将Node &amp; 服务端业务知识加入学习计划 / 规划专题分享？</li><li>讨论</li></ol><ul><li><a href="https://www.zhihu.com/question/357717742/answer/926367671"> Node.js 做 Web 后端优势为什么这么大？ - 知乎 (zhihu.com)</a></li></ul><h1>八、参考资料</h1><ol><li><a href="https://help.aliyun.com/document_detail/85958.html">健康检查概述 - 负载均衡</a></li><li>《深入浅出Node.js》</li><li><a href="http://nodejs.cn/">Node.js (nodejs.cn)</a></li><li><a href="https://juejin.cn/post/6844903908385488903#heading-17">深入理解Node.js 中的进程与线程 </a></li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Load Balance负载均衡 🌡&lt;/h1&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-lazy-src=&quot;https://bloginfo.lebronchao.com/doc-image/(null)-202106220028498</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://lebronchao.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://lebronchao.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="负载均衡" scheme="https://lebronchao.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="Node" scheme="https://lebronchao.com/tags/Node/"/>
    
    <category term="进程" scheme="https://lebronchao.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="https://lebronchao.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="进程间通信" scheme="https://lebronchao.com/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>[建议收藏]你想知道的Vue3核心源码这里都有</title>
    <link href="https://lebronchao.com/2021/07/07/Vue3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/"/>
    <id>https://lebronchao.com/2021/07/07/Vue3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/</id>
    <published>2021-07-06T17:09:08.000Z</published>
    <updated>2021-07-06T17:09:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Effect和Reactive</h1><blockquote><p>effect作为Vue响应式原理中的核心，在Computed、Watch、Reactive中都有出现</p><p>主要和Reactive(Proxy)、track、trigger等函数配合实现收集依赖，触发依赖更新</p></blockquote><ul><li>Effect<ul><li>副作用依赖函数</li></ul></li><li>Track<ul><li>依赖收集</li></ul></li><li>Trigger<ul><li>依赖触发</li></ul></li></ul><h2 id="Effect">Effect</h2><blockquote><p>effect可以被理解为一个副作用函数，被当做依赖收集，在响应式数据更新后被触发。</p><p>Vue的响应式API例如Computed、Watch都有用到effect来实现</p></blockquote><ul><li>先来看看入口函数<ul><li>入口函数主要是一些逻辑处理，核心逻辑位于createReactiveEffect</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions = EMPTY_OBJ</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 如果已经是effect，则重置</span></span><br><span class="line">  <span class="keyword">if</span> (isEffect(fn)) &#123;</span><br><span class="line">    fn = fn.raw</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建effect</span></span><br><span class="line">  <span class="keyword">const</span> effect = createReactiveEffect(fn, options)</span><br><span class="line">  <span class="comment">// 如果不是惰性执行，先执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createReactiveEffect</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> effectStack: ReactiveEffect[] = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveEffect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params"></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有激活，说明调用了effect stop函数</span></span><br><span class="line">    <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">      <span class="comment">// 无调度者则直接返回，否则执行fn</span></span><br><span class="line">      <span class="keyword">return</span> options.scheduler ? <span class="literal">undefined</span> : fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断EffectStack中有没有effect，有则不处理</span></span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(effect)) &#123;</span><br><span class="line">      <span class="comment">// 清除effect</span></span><br><span class="line">      cleanup(effect)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 开始重新收集依赖</span></span><br><span class="line"><span class="comment">        * 压入stack</span></span><br><span class="line"><span class="comment">        * 将effect设置为activeEffect</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        enableTracking()</span><br><span class="line">        effectStack.push(effect)</span><br><span class="line">        activeEffect = effect</span><br><span class="line">        <span class="keyword">return</span> fn()</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 完成后将effect弹出</span></span><br><span class="line"><span class="comment">        * 重置依赖</span></span><br><span class="line"><span class="comment">        * 重置activeEffect</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        effectStack.pop()</span><br><span class="line">        resetTracking()</span><br><span class="line">        activeEffect = effectStack[effectStack.length - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> ReactiveEffect</span><br><span class="line">  effect.id = uid++ <span class="comment">// 自增id，effect唯一标识</span></span><br><span class="line">  effect.allowRecurse = !!options.allowRecurse</span><br><span class="line">  effect._isEffect = <span class="literal">true</span> <span class="comment">// 是否是effect</span></span><br><span class="line">  effect.active = <span class="literal">true</span>  <span class="comment">// 是否激活</span></span><br><span class="line">  effect.raw = fn   <span class="comment">// 挂载原始对象</span></span><br><span class="line">  effect.deps = []  <span class="comment">// 当前effect的dep数组</span></span><br><span class="line">  effect.options = options  <span class="comment">// 传入的options</span></span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次effect运行都会重新收集依赖，deps是effect的依赖数组，需要全部清空</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params">effect: ReactiveEffect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deps &#125; = effect</span><br><span class="line">  <span class="keyword">if</span> (deps.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">      deps[i].delete(effect)</span><br><span class="line">    &#125;</span><br><span class="line">    deps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Track">Track</h2><blockquote><p>Track这个函数常出现在reactive的getter函数中，用于依赖收集</p><p>源码详解见注释</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target: <span class="built_in">object</span>, <span class="keyword">type</span>: TrackOpTypes, key: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// activeEffect为空表示没有依赖</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// targetMap依赖管理Map，用于收集依赖</span></span><br><span class="line">  <span class="comment">// 检查targetMap中有没有target，没有则新建</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dep用来收集依赖函数，当监听的key值发生变化，触发dep中的依赖函数更新</span></span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">    <span class="comment">// 开发环境会触发onTrack，仅用于调试</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        effect: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trigger">Trigger</h2><blockquote><p>Trigger常出现在reactive中的setter函数中，用于触发依赖更新</p><p>源码详解见注释</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  newValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;unknown, unknown&gt; | <span class="built_in">Set</span>&lt;unknown&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取依赖Map，如果没有则不需要触发</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// never been tracked</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用Set保存需要触发的effect，避免重复</span></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="comment">// 定义依赖添加函数</span></span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd: <span class="built_in">Set</span>&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect || effect.allowRecurse) &#123;</span><br><span class="line">          effects.add(effect)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将depsMap中的依赖添加到effects中</span></span><br><span class="line">  <span class="comment">// 只为了理解和原理的话   各个分支不用细看</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    depsMap.forEach(add)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    depsMap.forEach(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;</span><br><span class="line">        add(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.ADD:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          add(depsMap.get(ITERATE_KEY))</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isIntegerKey(key)) &#123;</span><br><span class="line">          <span class="comment">// new index added to array -&gt; length changes</span></span><br><span class="line">          add(depsMap.get(<span class="string">&#x27;length&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.DELETE:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          add(depsMap.get(ITERATE_KEY))</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.SET:</span><br><span class="line">        <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">          add(depsMap.get(ITERATE_KEY))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装effects执行函数</span></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect: ReactiveEffect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.options.onTrigger) &#123;</span><br><span class="line">      effect.options.onTrigger(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在scheduler则调用</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发effects中的所有依赖函数</span></span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactive">Reactive</h2><blockquote><p>了解了Track用于依赖收集，Trigger用于依赖触发，那么他们的调用时机是什么时候呢?来看看Reactive的源码就清楚了，源码详解见注释。</p><p>注：源码结构较为复杂（封装），为便于理解原理，以下为简化源码。</p></blockquote><ul><li>总结来说<ul><li>在getter时进行依赖收集</li><li>在setter时触发依赖更新</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target:<span class="built_in">object</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | symbol, receiver: <span class="built_in">object</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">            track(target, TrackOpTypes.GET, key)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span> | symbol, value: unknown, receiver: <span class="built_in">object</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key]</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">            <span class="comment">// trigger(target, TriggerOpTypes.ADD, key, value)</span></span><br><span class="line">            trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Computed</h1><blockquote><p>Computed是Vue中常用且好用的一个属性，这个属性的值在依赖改变后同步进行改变，在依赖未改变时使用缓存的值。</p></blockquote><ul><li>Vue2<ul><li>在Vue2中Computed的实现通过嵌套watcher，实现响应式数据的依赖收集，间接链式触发依赖更新。</li></ul></li><li>Vue3中出现了effect，重新实现了Computed属性<ul><li>effect可以被理解为副作用函数，被当做依赖收集，在响应式数据更新后被触发。</li></ul></li></ul><blockquote><p>Show me the Code</p></blockquote><ul><li>读完这段computed函数会发现，这里只是做了简要的getter和setter的赋值处理<ul><li>computed支持两种写法<ul><li>函数</li><li>getter、setter</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computed</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> getter: ComputedGetter&lt;T&gt;</span><br><span class="line">  <span class="keyword">let</span> setter: ComputedSetter&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOptions)) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">&#x27;Write operation failed: computed value is readonly&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ComputedRefImpl(</span><br><span class="line">    getter,</span><br><span class="line">    setter,</span><br><span class="line">    isFunction(getterOrOptions) || !getterOrOptions.set</span><br><span class="line">  ) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心逻辑都在ComputedRefImpl中，我们接着往下看<ul><li>通过dirty变量标记数据是否为旧数据</li><li>在响应式数据更新后将dirty赋值为true</li><li>在下一次get时，dirty为true时进行重新计算，并将dirty赋值为false</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputedRefImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _value!: T</span><br><span class="line">  <span class="keyword">private</span> _dirty = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> effect: ReactiveEffect&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> [ReactiveFlags.IS_READONLY]: <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    getter: ComputedGetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> _setter: ComputedSetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    isReadonly: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">      lazy: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 响应式数据更新后将dirty赋值为true</span></span><br><span class="line">      <span class="comment">// 下次执行getter判断dirty为true即重新计算computed值</span></span><br><span class="line">      scheduler: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">          <span class="built_in">this</span>._dirty = <span class="literal">true</span></span><br><span class="line">          <span class="comment">// 派发所有引用当前计算属性的副作用函数effect </span></span><br><span class="line">          trigger(toRaw(<span class="built_in">this</span>), TriggerOpTypes.SET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>[ReactiveFlags.IS_READONLY] = isReadonly</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span></span><br><span class="line">    <span class="keyword">const</span> self = toRaw(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// 当响应式数据更新后dirty为true</span></span><br><span class="line">    <span class="comment">// 重新计算数据后，将dirty赋值为false</span></span><br><span class="line">    <span class="keyword">if</span> (self._dirty) &#123;</span><br><span class="line">      self._value = <span class="built_in">this</span>.effect()</span><br><span class="line">      self._dirty = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    track(self, TrackOpTypes.GET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回计算后的值</span></span><br><span class="line">    <span class="keyword">return</span> self._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._setter(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Watch</h1><blockquote><p>Watch主要用于对某个变量的监听，并做相应的处理</p><p>Vue3中不仅重构了watch，还多了一个WatchEffect API</p></blockquote><ul><li>Watch</li></ul><blockquote><p>用于对某个变量的监听，同时可以通过callBack拿到新值和旧值</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">watch(state, <span class="function">(<span class="params">state, prevState</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>WatchEffect</li></ul><blockquote><p>每次更新都会执行，自动收集使用到的依赖</p></blockquote><blockquote><p>无法获取到新值和旧值，可手动停止监听</p></blockquote><blockquote><p><code>onInvalidate(fn)</code>传入的回调会在 <code>watchEffect</code> 重新运行或者 <code>watchEffect</code> 停止的时候执行</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watchEffect(<span class="function">(<span class="params">onInvalidate</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    onInvalidate(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)    </span><br><span class="line"><span class="comment">// 手动停止监听</span></span><br><span class="line">stop()</span><br></pre></td></tr></table></figure><h2 id="watch和watchEffect的不同点">watch和watchEffect的不同点</h2><ul><li>watch惰性执行，watchEffect每次代码加载都会执行</li><li>watch可指定监听变量，watchEffect自动依赖收集</li><li>watch可获取新旧值，watchEffect不行</li><li>watchEffect有onInvalidate功能，watch没有</li><li>watch只可监听ref、reactive等对象，watchEffect只可监听具体属性</li></ul><h2 id="Source-Code">Source Code</h2><blockquote><p>Show me the Code</p></blockquote><ul><li>这里可以看到watch和watchEffet的核心逻辑都封装到了doWatch中</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watch</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span>&lt;<span class="title">T</span> = <span class="title">any</span>, <span class="title">Immediate</span> <span class="title">extends</span> <span class="title">Readonly</span>&lt;<span class="title">boolean</span>&gt; = <span class="title">false</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: T | WatchSource&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptions&lt;Immediate&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !isFunction(cb)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`\`watch(fn, options?)\` signature has been moved to a separate API. `</span> +</span><br><span class="line">        <span class="string">`Use \`watchEffect(fn, options?)\` instead. \`watch\` now only `</span> +</span><br><span class="line">        <span class="string">`supports \`watch(source, cb, options?) signature.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doWatch(source <span class="keyword">as</span> <span class="built_in">any</span>, cb, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptionsBase</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(effect, <span class="literal">null</span>, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doWatch</li></ul><blockquote><p>以下为删减版源码，理解核心原理即可</p><p>详情见注释</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: WatchSource | WatchSource[] | WatchEffect | object,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: WatchCallback | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123; immediate, deep, flush, onTrack, onTrigger &#125;: WatchOptions = EMPTY_OBJ,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance = currentInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> getter: <span class="function">() =&gt;</span> any</span><br><span class="line">  <span class="keyword">let</span> forceTrigger = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> isMultiSource = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对不同的情况做getter赋值</span></span><br><span class="line">  <span class="keyword">if</span> (isRef(source)) &#123;</span><br><span class="line">    <span class="comment">// ref通过.value获取</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> (source <span class="keyword">as</span> Ref).value</span><br><span class="line">    forceTrigger = !!(source <span class="keyword">as</span> Ref)._shallow</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(source)) &#123;</span><br><span class="line">    <span class="comment">// reactive直接获取</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> source</span><br><span class="line">    deep = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(source)) &#123;</span><br><span class="line">    <span class="comment">// 如果是数组，做遍历处理</span></span><br><span class="line">    isMultiSource = <span class="literal">true</span></span><br><span class="line">    forceTrigger = source.some(isReactive)</span><br><span class="line">    getter = <span class="function">() =&gt;</span></span><br><span class="line">      source.map(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRef(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> s.value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> traverse(s)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER, [</span><br><span class="line">            instance &amp;&amp; (instance.proxy <span class="keyword">as</span> any)</span><br><span class="line">          ])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warnInvalidSource(s)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(source)) &#123;</span><br><span class="line">    <span class="comment">// 如果是函数的情况</span></span><br><span class="line">    <span class="comment">// 有cb则为watch，没有则为watchEffect</span></span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// getter with cb</span></span><br><span class="line">      getter = <span class="function">() =&gt;</span></span><br><span class="line">        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER, [</span><br><span class="line">          instance &amp;&amp; (instance.proxy <span class="keyword">as</span> any)</span><br><span class="line">        ])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// no cb -&gt; simple effect</span></span><br><span class="line">      getter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance &amp;&amp; instance.isUnmounted) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> callWithAsyncErrorHandling(</span><br><span class="line">          source,</span><br><span class="line">          instance,</span><br><span class="line">          ErrorCodes.WATCH_CALLBACK,</span><br><span class="line">          [onInvalidate]</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常情况</span></span><br><span class="line">    getter = NOOP</span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    __DEV__ &amp;&amp; warnInvalidSource(source)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 深度监听逻辑处理</span></span><br><span class="line">  <span class="keyword">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class="line">    <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">    getter = <span class="function">() =&gt;</span> traverse(baseGetter())</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> cleanup: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">let</span> onInvalidate: InvalidateCbRegistrator = <span class="function">(<span class="params">fn: () =&gt; <span class="keyword">void</span></span>) =&gt;</span> &#123;</span><br><span class="line">    cleanup = runner.options.onStop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录oldValue，并通过runner获取newValue</span></span><br><span class="line">  <span class="comment">// callback的封装处理为job</span></span><br><span class="line">  <span class="keyword">let</span> oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE</span><br><span class="line">  <span class="keyword">const</span> job: SchedulerJob = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!runner.active) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// watch(source, cb)</span></span><br><span class="line">      <span class="keyword">const</span> newValue = runner()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        deep ||</span><br><span class="line">        forceTrigger ||</span><br><span class="line">        (isMultiSource</span><br><span class="line">          ? (newValue <span class="keyword">as</span> any[]).some(<span class="function">(<span class="params">v, i</span>) =&gt;</span></span><br><span class="line">              hasChanged(v, (oldValue <span class="keyword">as</span> any[])[i])</span><br><span class="line">            )</span><br><span class="line">          : hasChanged(newValue, oldValue)) ||</span><br><span class="line">        (__COMPAT__ &amp;&amp;</span><br><span class="line">          isArray(newValue) &amp;&amp;</span><br><span class="line">          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// cleanup before running cb again</span></span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [</span><br><span class="line">          newValue,</span><br><span class="line">          <span class="comment">// pass undefined as the old value when it&#x27;s changed for the first time</span></span><br><span class="line">          oldValue === INITIAL_WATCHER_VALUE ? <span class="literal">undefined</span> : oldValue,</span><br><span class="line">          onInvalidate</span><br><span class="line">        ])</span><br><span class="line">        oldValue = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// watchEffect</span></span><br><span class="line">      runner()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// important: mark the job as a watcher callback so that scheduler knows</span></span><br><span class="line">  <span class="comment">// it is allowed to self-trigger (#1727)</span></span><br><span class="line">  job.allowRecurse = !!cb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过读取配置，处理job的触发时机</span></span><br><span class="line">  <span class="comment">// 并再次将job的执行封装到scheduler中</span></span><br><span class="line">  <span class="keyword">let</span> scheduler: ReactiveEffectOptions[<span class="string">&#x27;scheduler&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123; <span class="comment">// 同步执行</span></span><br><span class="line">    scheduler = job</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123; <span class="comment">// 更新后执行</span></span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">    <span class="comment">// 更新前执行</span></span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance || instance.isMounted) &#123;</span><br><span class="line">        queuePreFlushCb(job)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// with &#x27;pre&#x27; option, the first call must happen before</span></span><br><span class="line">        <span class="comment">// the component is mounted so it is called synchronously.</span></span><br><span class="line">        job()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用effect副作用处理依赖收集，在依赖更新后调用scheduler（其中封装了callback的执行）</span></span><br><span class="line">  <span class="keyword">const</span> runner = effect(getter, &#123;</span><br><span class="line">    lazy: <span class="literal">true</span>,</span><br><span class="line">    onTrack,</span><br><span class="line">    onTrigger,</span><br><span class="line">    scheduler</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收集依赖</span></span><br><span class="line">  recordInstanceBoundEffect(runner, instance)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取配置，进行watch初始化</span></span><br><span class="line">  <span class="comment">// 是否有cb</span></span><br><span class="line">  <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">    <span class="comment">// 是否立刻执行</span></span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      job()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      oldValue = runner()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是否更新后执行</span></span><br><span class="line">    queuePostRenderEffect(runner, instance &amp;&amp; instance.suspense)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    runner()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回手动停止函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    stop(runner)</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      remove(instance.effects!, runner)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Mixin</h1><blockquote><p>Mixin意为混合，是公共逻辑封装利器。</p><p>原理比较简单，那就是合并。</p></blockquote><ul><li>合并分为对象的合并和生命周期的合并<ul><li>对象，mergeOption<ul><li>类型Object.assign的合并，会出现覆盖现象</li></ul></li><li>生命周期，mergeHook<ul><li>合并会将两个生命周期放入一个队列，依次调用</li></ul></li></ul></li><li>mergeOptions</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  to: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">from</span>: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance?: ComponentInternalInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  strats = instance &amp;&amp; instance.appContext.config.optionMergeStrategies</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__COMPAT__ &amp;&amp; isFunction(<span class="keyword">from</span>)) &#123;</span><br><span class="line">    <span class="keyword">from</span> = <span class="keyword">from</span>.options</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; mixins, <span class="attr">extends</span>: extendsOptions &#125; = <span class="keyword">from</span></span><br><span class="line"></span><br><span class="line">  extendsOptions &amp;&amp; mergeOptions(to, extendsOptions, instance, strats)</span><br><span class="line">  mixins &amp;&amp;</span><br><span class="line">    mixins.forEach(<span class="function">(<span class="params">m: ComponentOptionsMixin</span>) =&gt;</span></span><br><span class="line">      mergeOptions(to, m, instance, strats)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 对mixin中的对象进行遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果存在则进行覆盖处理</span></span><br><span class="line">    <span class="keyword">if</span> (strats &amp;&amp; hasOwn(strats, key)) &#123;</span><br><span class="line">      to[key] = strats[key](to[key], <span class="keyword">from</span>[key], instance &amp;&amp; instance.proxy, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不存在则直接赋值</span></span><br><span class="line">      to[key] = <span class="keyword">from</span>[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mergeHook</li></ul><blockquote><p>简单粗暴放进Set，调用时依次调用</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  to: <span class="built_in">Function</span>[] | <span class="built_in">Function</span> | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">from</span>: <span class="built_in">Function</span> | <span class="built_in">Function</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([...toArray(to), ...toArray(<span class="keyword">from</span>)]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Vuex4</h1><blockquote><p>Vuex是在Vue中常用的状态管理库，在Vue3发布后，这个状态管理库也随之发出了适配Vue3的Vuex4</p></blockquote><h2 id="快速过Vuex3-x原理">快速过Vuex3.x原理</h2><ul><li><p>为什么每个组件都可以通过</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store</span><br></pre></td></tr></table></figure><p>访问到store数据？</p><ul><li>在beforeCreate时，通过mixin的方式注入了store</li></ul></li><li><p>为什么Vuex中的数据都是响应式的</p><ul><li>创建store的时候调用的是<code>new Vue</code>,创建了一个Vue实例，相当于借用了Vue的响应式。</li></ul></li><li><p>mapXxxx是怎么获取到store中的数据和方法的</p><ul><li>mapXxxx只是一个语法糖，底层实现也是从$store中获取然后返回到computed / methods中。</li></ul></li></ul><blockquote><p>总的来看，可以把Vue3.x理解为一个每个组件都注入了的mixin?</p></blockquote><h2 id="Vuex4原理探究">Vuex4原理探究</h2><blockquote><p>去除冗余代码看本质</p></blockquote><h3 id="createStore">createStore</h3><ul><li>从createStore开始看起<ul><li>可以发现Vuex4中的state是通过reactive API去创建的响应式数据，Vuex3中是通过new Vue实例</li><li>dispatch、commit的实现基本是封装了一层执行，不用过于关心</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Store(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span></span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">options = &#123;&#125;</span>)&#123;</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">        <span class="built_in">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br><span class="line">        <span class="keyword">const</span> state = <span class="built_in">this</span>._modules.root.state</span><br><span class="line">        resetStoreState(<span class="built_in">this</span>, state)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// bind commit and dispatch to self</span></span><br><span class="line">        <span class="keyword">const</span> store = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="built_in">this</span></span><br><span class="line">        <span class="built_in">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span> (<span class="params"><span class="keyword">type</span>, payload</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> dispatch.call(store, <span class="keyword">type</span>, payload)</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span> (<span class="params"><span class="keyword">type</span>, payload, options</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> commit.call(store, <span class="keyword">type</span>, payload, options)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreState</span> (<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">    store._state = reactive(&#123;</span><br><span class="line">        data: state</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="install">install</h3><ul><li>Vuex是以插件的形式在Vue中使用的，在createApp时调用install安装</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>&lt;<span class="title">HostElement</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  render: RootRenderFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate?: RootHydrateFunction</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CreateAppFunction</span>&lt;<span class="title">HostElement</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略部分代码....</span></span><br><span class="line">    <span class="keyword">const</span> app: App = (context.app = &#123;</span><br><span class="line">      _uid: uid++,</span><br><span class="line">      _component: rootComponent <span class="keyword">as</span> ConcreteComponent,</span><br><span class="line">      _props: rootProps,</span><br><span class="line">      _container: <span class="literal">null</span>,</span><br><span class="line">      _context: context,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 省略部分代码....</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">use</span>(<span class="params">plugin: Plugin, ...options: <span class="built_in">any</span>[]</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (installedPlugins.has(plugin)) &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warn(<span class="string">`Plugin has already been applied to target app.`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plugin &amp;&amp; isFunction(plugin.install)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin.install(app, ...options)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(plugin)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin(app, ...options)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`A plugin must either be a function or an object with an &quot;install&quot; `</span> +</span><br><span class="line">              <span class="string">`function.`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 省略部分代码 ....</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Store 类的install<ul><li>实现通过inject获取</li><li>实现this.$store获取</li></ul></li></ul><blockquote><p>下面接着看provide实现</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">install (app, injectKey) &#123;</span><br><span class="line">  <span class="comment">// 实现通过inject获取</span></span><br><span class="line">  app.provide(injectKey || storeKey, <span class="built_in">this</span>)</span><br><span class="line">  <span class="comment">// 实现this.$store获取</span></span><br><span class="line">  app.config.globalProperties.$store = <span class="built_in">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="app-provide实现">app.provide实现</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">provide</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 已存在则警告</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; (key <span class="keyword">as</span> <span class="built_in">string</span> | symbol) <span class="keyword">in</span> context.provides) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`App already provides property with key &quot;<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>&quot;. `</span> +</span><br><span class="line">        <span class="string">`It will be overwritten with the new value.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将store放入context的provide中</span></span><br><span class="line">  context.provides[key <span class="keyword">as</span> <span class="built_in">string</span>] = value</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// context相关   context为上下文对象</span></span><br><span class="line"><span class="keyword">const</span> context = createAppContext()</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppContext</span>(<span class="params"></span>): <span class="title">AppContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app: <span class="literal">null</span> <span class="keyword">as</span> <span class="built_in">any</span>,</span><br><span class="line">    config: &#123;</span><br><span class="line">      isNativeTag: NO,</span><br><span class="line">      performance: <span class="literal">false</span>,</span><br><span class="line">      globalProperties: &#123;&#125;,</span><br><span class="line">      optionMergeStrategies: &#123;&#125;,</span><br><span class="line">      errorHandler: <span class="literal">undefined</span>,</span><br><span class="line">      warnHandler: <span class="literal">undefined</span>,</span><br><span class="line">      compilerOptions: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mixins: [],</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    directives: &#123;&#125;,</span><br><span class="line">    provides: <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-useStore">Vue.useStore</h3><ul><li>在Vue3 Composition API中使用Vuex</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> store = useStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>useStore的实现</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useStore</span> (<span class="params">key = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> inject(key !== <span class="literal">null</span> ? key : storeKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-inject">Vue.inject</h3><ul><li>通过provide时存入的key取出store</li><li>有父级实例则取父级实例的provides，没有则取根实例的provides</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inject</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key: InjectionKey&lt;<span class="built_in">any</span>&gt; | <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  treatDefaultAsFactory = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = currentInstance || currentRenderingInstance</span><br><span class="line">  <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">    <span class="comment">// 有父级实例则取父级实例的provides，没有则取根实例的provides</span></span><br><span class="line">    <span class="keyword">const</span> provides =</span><br><span class="line">      instance.parent == <span class="literal">null</span></span><br><span class="line">        ? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides</span><br><span class="line">        : instance.parent.provides</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过provide时存入的key取出store</span></span><br><span class="line">    <span class="keyword">if</span> (provides &amp;&amp; (key <span class="keyword">as</span> <span class="built_in">string</span> | symbol) <span class="keyword">in</span> provides) &#123;</span><br><span class="line">      <span class="keyword">return</span> provides[key <span class="keyword">as</span> <span class="built_in">string</span>]</span><br><span class="line">    <span class="comment">// 省略一部分代码......</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-provide">Vue.provide</h3><ul><li>Vue的provide API也比较简单，相当于直接通过key/value赋值</li><li>当前实例provides和父级实例provides相同时，通过原型链建立连接</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">provide</span>&lt;<span class="title">T</span>&gt;(<span class="params">key: InjectionKey&lt;T&gt; | <span class="built_in">string</span> | <span class="built_in">number</span>, value: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!currentInstance) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      warn(<span class="string">`provide() can only be used inside setup().`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> provides = currentInstance.provides</span><br><span class="line">    <span class="keyword">const</span> parentProvides =</span><br><span class="line">      currentInstance.parent &amp;&amp; currentInstance.parent.provides</span><br><span class="line">    <span class="keyword">if</span> (parentProvides === provides) &#123;</span><br><span class="line">      provides = currentInstance.provides = <span class="built_in">Object</span>.create(parentProvides)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TS doesn&#x27;t allow symbol as index type</span></span><br><span class="line">    provides[key <span class="keyword">as</span> <span class="built_in">string</span>] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注入">注入</h3><ul><li>为什么每个组件实例都有Store对象了?<ul><li>在创建组件实例的时候注入了provides</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponentInstance</span>(<span class="params">vnode, parent, suspense</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">type</span> = vnode.type;</span><br><span class="line">    <span class="keyword">const</span> appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;</span><br><span class="line">    <span class="keyword">const</span> instance = &#123;</span><br><span class="line">        parent,</span><br><span class="line">        appContext,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        provides: parent ? parent.provides : <span class="built_in">Object</span>.create(appContext.provides),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可从vue中引入provide、inject、getCurrentInstance等API进行库开发 / 高阶用法，这里不过多赘述。</p></blockquote><h1>Diff算法优化</h1><blockquote><p>了解Vue3的Diff算法优化前，可以先了解一下<a href="https://juejin.cn/post/6944887985531781133">Vue2的Diff算法</a></p><p>本部分注重把算法讲清楚，将不进行逐行源码分析</p></blockquote><ul><li>Vue3中的主要优化点为<ul><li>在updateChildren时双端比较 -&gt; 最长递增子序列</li><li>全量Diff -&gt; 静态标记 + 非全量Diff</li><li>静态提升</li></ul></li></ul><h2 id="updateChildren">updateChildren</h2><ul><li>Vue2<ul><li>头 - 头比较</li><li>尾 - 尾比较</li><li>头 - 尾比较</li><li>尾 - 头比较</li></ul></li><li>Vue3<ul><li>头 - 头比较</li><li>尾 - 尾比较</li><li>基于最长递增子序列进行移动 / 删除 / 新增</li></ul></li></ul><h3 id="举个🌰">举个🌰</h3><ul><li>oldChild [a,b,c,d,e,f,g]</li><li>newChild [a,b,f,c,d,e,h,g]</li></ul><ol><li>首先进行头 - 头比较,比较到不一样的节点时跳出循环<ul><li>得到[a,b]</li></ul></li><li>然后进行尾 - 尾比较，比较到不一样的节点时跳出循环<ul><li>得到[g]</li></ul></li><li>剩余[f,c,d,e,h]<ul><li>通过newIndexToOldIndexMap生成数组[5, 2, 3, 4, -1]</li><li>得出最长递增子序列[2, 3, 4]对应节点为[c, d, e]</li><li>剩余的节点基于[c, d, e]进行移动 / 新增 / 删除</li></ul></li></ol><blockquote><p><strong>最长递增子序列</strong> 减少Dom元素的移动，达到最少的 dom 操作以减小开销。</p><p>关于最长递增子序列算法可以看看<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md">最长递增子序列</a></p></blockquote><h2 id="静态标记">静态标记</h2><blockquote><p>Vue2中对vdom进行全量Diff，Vue3中增加了静态标记进行非全量Diff</p><p>对vnode打了像以下枚举内的静态标记</p></blockquote><ul><li>patchFlag</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="built_in">enum</span> PatchFlags&#123;</span><br><span class="line">  TEXT = <span class="number">1</span> ,  <span class="comment">//动态文本节点</span></span><br><span class="line">  CLASS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">//2   动态class</span></span><br><span class="line">  STYLE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">//4   动态style</span></span><br><span class="line">  PROPS = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">//8                动态属性，但不包含类名和样式</span></span><br><span class="line">  FULL_PROPS = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">//16   具有动态key属性，当key改变时，需进行完整的diff比较</span></span><br><span class="line">  HYDRATE_EVENTS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,<span class="comment">//32  带有监听事件的节点</span></span><br><span class="line">  STABLE_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">//64  一个不会改变子节点顺序的fragment</span></span><br><span class="line">  KEYED_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,  <span class="comment">//128 带有key属性的fragment或部分子节点有key</span></span><br><span class="line">  UNKEYEN_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,   <span class="comment">//256  子节点没有key的fragment</span></span><br><span class="line">  NEED_PATCH = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">//512   一个节点只会进行非props比较</span></span><br><span class="line">  DYNAMIC_SLOTS = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,<span class="comment">//1024   动态slot</span></span><br><span class="line">  HOISTED = -<span class="number">1</span>,   <span class="comment">//静态节点 </span></span><br><span class="line">  <span class="comment">//指示在diff过程中要退出优化模式</span></span><br><span class="line">  BAIL = -<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个🌰-2">举个🌰</h3><ul><li>模板长这样</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>生成vdom源码</li></ul><blockquote><p>对msg变量进行了标记</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.msg), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><ul><li>对vnode进行标记，将需要动态更新和不需要动态更新的节点进行分类</li><li>静态节点仅需创建一次，渲染直接复用，不参与diff算法流程。</li></ul><h2 id="静态提升">静态提升</h2><ul><li><p>Vue2中无论是元素是否参与更新，每次都会重新创建</p></li><li><p>Vue3中对于不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停地复用</p></li><li><p>以后每次进行render的时候，就不会重复创建这些静态的内容，而是直接从一开始就创建好的常量中取就行了。</p></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 静态提升前</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>),</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>),</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>),</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.msg), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 静态提升后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span>_createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span>_createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span>_createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    _hoisted_2,</span><br><span class="line">    _hoisted_3,</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.msg), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><h1>cacheHandlers 事件侦听器缓存</h1><ul><li><p>默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化</p></li><li><p>但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。</p></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">&quot;onClick&quot;</span>&gt;btn&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用缓存前</span></span><br><span class="line"><span class="comment">// 这里我们还没有开启事件监听缓存，熟悉的静态标记 8 /* PROPS */ 出现了，</span></span><br><span class="line"><span class="comment">// 它将标签的 Props （属性） 标记动态属性。</span></span><br><span class="line"><span class="comment">// 如果我们存在属性不会改变，不希望这个属性被标记为动态，那么就需要 cacheHandler 的出场了。</span></span><br><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">onClick</span>: _ctx.onClick &#125;, <span class="string">&quot;btn&quot;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">&quot;onClick&quot;</span>])</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用缓存后</span></span><br><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      onClick: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.onClick(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;btn&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>它的意思很明显，onClick 方法被存入 cache。</p><p>在使用的时候，如果能在缓存中找到这个方法，那么它将直接被使用。</p><p>如果找不到，那么将这个方法注入缓存。</p><p>总之，就是把方法给缓存了。</p></blockquote><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Effect和Reactive&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;effect作为Vue响应式原理中的核心，在Computed、Watch、Reactive中都有出现&lt;/p&gt;
&lt;p&gt;主要和Reactive(Proxy)、track、trigger等函数配合实现收集</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="Vue" scheme="https://lebronchao.com/tags/Vue/"/>
    
    <category term="SPA" scheme="https://lebronchao.com/tags/SPA/"/>
    
    <category term="源码分析" scheme="https://lebronchao.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>[深入浅出]JavaScript GC 垃圾回收机制</title>
    <link href="https://lebronchao.com/2021/06/22/JavaScipt-GC/"/>
    <id>https://lebronchao.com/2021/06/22/JavaScipt-GC/</id>
    <published>2021-06-22T15:32:35.000Z</published>
    <updated>2021-06-22T15:32:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1>[科普]JavaScript GC</h1><h1>为什么需要垃圾回收</h1><ul><li>在C / C++中，跟踪内存的使用和管理内存对开发者来说是很大的负担<ul><li>JavaScript是使用垃圾回收机制的语言，也就是说执行环境负责在代码执行时管理内存，帮开发者卸下了这个负担</li><li>通过自动内存管理实现内存的分配和资源的回收</li><li>基本思路很简单，确定哪个变量不会再被使用了，把它的内存空间释放</li><li>这个过程是周期性的，意思是这个垃圾回收程序每隔一段时间就会运行一次</li></ul></li><li>像JS中的对象、字符串、对象的内存是不固定的，只有真正用到的时候才会动态分配内存<ul><li>这些内存需在不使用后进行释放以便再次使用，否则在计算机可用内存耗尽后造成崩溃</li></ul></li><li>浏览器发展史上的垃圾回收法主要有<ul><li>引用计数法</li><li>标记清除法</li></ul></li></ul><h1>引用计数法</h1><h2 id="思路">思路</h2><ul><li>变量只是对值进行引用</li><li>当变量引用该值时，引用次数+1</li><li>当该变量的引用被覆盖或者清除时，引用次数-1</li><li>当引用次数为0时，就可以安全地释放这块内存。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]   <span class="comment">// [1, 0, 1]这块内存被arr引用  引用次数为1</span></span><br><span class="line">arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]  <span class="comment">// [1, 0, 1]的内存引用次数为0被释放  </span></span><br><span class="line">                 <span class="comment">// [0, 1, 0]的内存被arr引用   引用次数为1</span></span><br><span class="line"><span class="keyword">const</span> tmp = arr  <span class="comment">// [0, 1, 0]的内存被tmp引用   引用次数为2</span></span><br></pre></td></tr></table></figure><h2 id=""></h2><h2 id="循环引用问题">循环引用问题</h2><blockquote><p>Netscape Navigator 3.0 采用</p></blockquote><ul><li>在这个例子中，ObjectA和ObjectB的属性分别相互引用</li><li>造成这个函数执行后，Object被引用的次数不会变成0，影响了正常的GC。</li><li>如果执行多次，将造成严重的内存泄漏。</li><li>而标记清除法则不会出现这个问题。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ObjectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">let</span> ObjectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    ObjectA.p = ObjectB;</span><br><span class="line">    ObjectB.p = ObjectA;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example();</span><br></pre></td></tr></table></figure><ul><li>解决方法：在函数结束时将其指向null</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ObjectA = <span class="literal">null</span>;</span><br><span class="line">ObjectB = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h1>标记清除法</h1><blockquote><p>为了解决循环引用造成的内存泄漏问题，Netscape Navigator 4.0 开始采用标记清除法</p></blockquote><blockquote><p>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理(或 其变体)，只是在运行垃圾回收的频率上有所差异。</p></blockquote><h2 id="思路-2">思路</h2><ul><li>在变量进入执行上下文时打上“进入”标记</li><li>同时在变量离开执行上下文时也打上“离开”标记<ul><li>从此以后，无法访问这个变量</li><li>在下一次垃圾回收时进行内存的释放</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> n * a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记Example进入执行上下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;  <span class="comment">// 标记n进入执行上下文</span></span><br><span class="line">Example(n);   <span class="comment">// 标记a,b,c进入执行上下文</span></span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// 标记a, b, c离开执行上下文，等待垃圾回收</span></span><br></pre></td></tr></table></figure><h2 id="const和let声明提升性能">const和let声明提升性能</h2><ul><li>const和let不仅有助于改善代码风格，同时有利于垃圾回收性能的提升</li><li>const和let使JS有了块级作用域，当块级作用域比函数作用域更早结束时，垃圾回收程序更早介入</li><li>尽早回收该回收的内存，提升了垃圾回收的性能</li></ul><h1>V8引擎的垃圾回收</h1><blockquote><p>V8引擎的垃圾回收采用标记清除法与分代回收法</p></blockquote><blockquote><p>分为新生代和老生代</p></blockquote><h2 id="新生代">新生代</h2><blockquote><p>新生代垃圾回收采用<code>Scavenge</code> 算法</p></blockquote><blockquote><p>分配给常用内存和新分配的小量内存</p></blockquote><ul><li><p>内存大小</p><ul><li>32位系统16M内存</li><li>64位系统32M内存</li></ul></li><li><p>分区</p><ul><li>新生代内存分为以下两区，内存各占一半</li><li>From space</li><li>To space</li></ul></li><li><p>运行</p><ul><li>实际运行的只有From space</li><li>To space处于空闲状态</li></ul></li><li><p><code>Scavenge</code>算法</p><ul><li>当From space内存使用将要达到上限时开始垃圾回收，将From space中的不可达对象都打上标记</li><li>将From space的未标记对象复制到To space。<ul><li>解决了内存散落分块的问题（不连续的内存空间）</li><li>相当于用空间换时间。</li></ul></li><li>然后清空From space、将其闲置，也就是转变为To space，俗称反转。</li></ul></li><li><p>新生代 -&gt; 老生代</p><ul><li>新生代存放的是新分配的小量内存，如果达到以下条件中的一个，将被分配至老生代<ul><li>内存大小达到From space的25%</li><li>经历了From space &lt;-&gt; To space的一个轮回</li></ul></li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210607231001850.(null)" alt="img"></p><h2 id="老生代">老生代</h2><blockquote><p>老生代采用<code>mark-sweep</code>标记清除和<code>mark-compact</code>标记整理</p></blockquote><blockquote><p>通常存放较大的内存块和从新生代分配过来的内存块</p></blockquote><ul><li>内存大小<ul><li>32位系统700M左右</li><li>64位系统1.4G左右</li></ul></li><li>分区<ul><li>Old Object Space<ul><li>字面的老生代，存放的是新生代分配过来的内存。</li></ul></li><li>Large Object Space<ul><li>存放其他区域放不下的较大的内存，基本都超过1M</li></ul></li><li>Map Space<ul><li>存放存储对象的映射关系</li></ul></li><li>Code Space<ul><li>存储编译后的代码</li></ul></li></ul></li><li>回收流程<ul><li>标记分类（三色标记）<ul><li>未被扫描，可回收，下面简称<code>1类</code></li><li>扫描中，不可回收，下面简称<code>2类</code></li><li>扫描完成，不可回收，下面简称<code>3类</code></li></ul></li><li>遍历<ul><li>采用深度优先遍历，遍历每个对象。</li><li>首先将非根部对象全部标记为<code>1类</code>，然后进行深度优先遍历。</li><li>遍历过程中将对象压入栈，这个过程中对象被标记为<code>2类</code>。</li><li>遍历完成对象出栈，这个对象被标记为<code>3类</code>。</li><li>整个过程直至栈空</li></ul></li><li>Mark-sweep<ul><li>标记完成之后，将标记为<code>1类</code>的对象进行内存释放<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210607231013225-20210607231556621.(null)" alt="img"></li></ul></li><li>Mark-compact<ul><li>垃圾回收完成之后，内存空间是不连续的。</li><li>这样容易造成无法分配较大的内存空间的问题，从而触发垃圾回收。</li><li>所以，会有Mark-compact步骤将未被回收的内存块整理为连续地内存空间。</li><li>频繁触发垃圾回收会影响引擎的性能，内存空间不足时也会优先触发Mark-compact</li></ul></li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210607231009280.(null)" alt="img"></p><h2 id="垃圾回收优化">垃圾回收优化</h2><ul><li>增量标记<ul><li>如果用集中的一段时间进行垃圾回收，新生代倒还好，老生代如果遍历较大的对象，可能会造成卡顿。</li><li>增量标记：使垃圾回收程序和应用逻辑程序交替运行，思想类似Time Slicing</li></ul></li><li>并行回收<ul><li>在垃圾回收的过程中，开启若干辅助线程，提高垃圾回收效率。</li></ul></li><li>并发回收<ul><li>在逻辑程序执行的过程中，开启若干辅助线程进行垃圾回收，清理和主线程没有任何逻辑关系的内存。</li></ul></li></ul><h1>内存泄露场景</h1><h2 id="全局变量">全局变量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exm1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    exm = <span class="string">&#x27;LeBron&#x27;</span>   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exm2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.exm = <span class="string">&#x27;LeBron&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Example()</span><br></pre></td></tr></table></figure><h2 id="未清除的定时器">未清除的定时器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// clearInterval(timer)</span></span><br></pre></td></tr></table></figure><h2 id="闭包">闭包</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = debounce(handler, <span class="number">1000</span>); <span class="comment">// fn引用了timeout</span></span><br></pre></td></tr></table></figure><h2 id="未清除的DOM元素引用">未清除的DOM元素引用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// 此处引用了DOM元素</span></span><br><span class="line">    button:<span class="built_in">document</span>.getElementById(<span class="string">&#x27;LeBron&#x27;</span>),</span><br><span class="line">    select:<span class="built_in">document</span>.getElementById(<span class="string">&#x27;select&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;LeBron&#x27;</span>))</span><br></pre></td></tr></table></figure><h1>如何检测内存泄漏</h1><blockquote><p>这个其实不难，浏览器原带的开发者工具Performance就可以</p></blockquote><ul><li>步骤<ul><li>F12打开开发者工具</li><li>选择Performance工具栏</li><li>勾选屏幕截图和Memory</li><li>点击开始录制</li><li>一段时间之后结束录制</li></ul></li><li>结果<ul><li>堆内存会周期性地分配和释放</li><li>如果堆内存的min值在逐渐上升则存在内存泄漏</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622234127287.(null)" alt="img"></p><h1>优化内存使用</h1><ol><li>尽量不在for循环中定义函数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exm</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">idx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> idx * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//const fn = (idx) =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//    return idx * 2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">const</span> res = fn(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>尽量不在for循环中定义对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// const obj = &#123;</span></span><br><span class="line">    <span class="comment">//   a: i,</span></span><br><span class="line">    <span class="comment">//   b: i * 2,</span></span><br><span class="line">    <span class="comment">//   c: i * 3,</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    obj.a = i;</span><br><span class="line">    obj.b = i * <span class="number">2</span>;</span><br><span class="line">    obj.c = i * <span class="number">3</span>;</span><br><span class="line">    res += <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>清空数组</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.length = <span class="number">0</span>; <span class="comment">// 清空了数组，数组类型不变</span></span><br><span class="line"><span class="comment">// arr = []  // 重新申请了一块空数组对象内存</span></span><br></pre></td></tr></table></figure><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;[科普]JavaScript GC&lt;/h1&gt;
&lt;h1&gt;为什么需要垃圾回收&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在C / C++中，跟踪内存的使用和管理内存对开发者来说是很大的负担
&lt;ul&gt;
&lt;li&gt;JavaScript是使用垃圾回收机制的语言，也就是说执行环境负责在代码执行时管理</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="JavaScript" scheme="https://lebronchao.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>[打包优化]Webpack体积压缩</title>
    <link href="https://lebronchao.com/2021/06/07/Webpack%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A9/"/>
    <id>https://lebronchao.com/2021/06/07/Webpack%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A9/</id>
    <published>2021-06-07T15:57:14.000Z</published>
    <updated>2021-06-07T15:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6969018138591494158">打包优化]Webpack体积压缩 (juejin.cn)</a></p></blockquote><h1>HTTP压缩</h1><ul><li><p>HTTP压缩是一种内置在 服务器 和 客户端 之间的，以改进传输速度和带宽利用率的方式;</p></li><li><p>HTTP压缩的流程什么呢?</p><ul><li>第一步:HTTP数据在服务器发送前就已经被压缩了;(可以在webpack中完成)</li><li>第二步:兼容的浏览器在向服务器发送请求时，会告知服务器自己支持哪些压缩格式;</li><li>第三步:服务器在浏览器支持的压缩格式下，直接返回对应的压缩后的文件，并且在响应头中告知浏览器;</li></ul></li></ul><h2 id="压缩格式">压缩格式</h2><ol><li><p>compress – UNIX的“compress”程序的方法(历史性原因，不推荐大多数应用使用，应该使用gzip或</p><p>deflate);</p></li><li><p>deflate – 基于deflate算法(定义于RFC 1951)的压缩，使用zlib数据格式封装;</p></li><li><p>gzip – GNU zip格式(定义于RFC 1952)，是目前使用比较广泛的压缩算法;</p></li><li><p>br – 一种新的开源压缩算法，专为HTTP内容的编码而设计;</p></li></ol><h2 id="Webpack对文件压缩">Webpack对文件压缩</h2><blockquote><p>使用CompressionPlugin对文件进行压缩</p></blockquote><ul><li><p>安装</p><ul><li><code>npm install compression-webpack-plugin</code></li></ul></li><li><p>webpack.prod.js</p><ul><li>threshold：x以上的文件才进行压缩</li><li>minRatio：最小压缩比，小于则不压缩</li><li>test：正则匹配的文件才压缩</li><li>alogorithm：压缩算法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span>  CompressionPlugin(&#123;</span><br><span class="line">        threshold: <span class="number">0</span>,</span><br><span class="line">        minRatio:<span class="number">0.6</span>,</span><br><span class="line">        test:<span class="regexp">/\.(css|js)/i</span>,</span><br><span class="line">        algorithm:<span class="string">&quot;gzip&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="HTML文件中代码的压缩">HTML文件中代码的压缩</h2><ul><li><p>之前使用了HtmlWebpackPlugin插件来生成HTML的模板，事实上它还有一些其他的配置:</p></li><li><p>inject:设置打包的资源插入的位置</p><ul><li>true、 false 、body、head</li></ul></li><li><p>cache:设置为true，只有当文件改变时，才会生成新的文件(默认值也是true)</p></li><li><p>minify:默认会使用一个插件html-minifier-terser</p></li><li><p>webpack.prod.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: <span class="string">&quot;LeBronChao Webpack&quot;</span>,</span><br><span class="line">        template: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">        inject:<span class="string">&quot;body&quot;</span>,</span><br><span class="line">        cache:<span class="literal">true</span>,</span><br><span class="line">        minify: isProduction ? &#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>, <span class="comment">// 是否删除注释</span></span><br><span class="line">            removeRedundantAttributes:<span class="literal">true</span>, <span class="comment">// 是否删除多余（默认）属性</span></span><br><span class="line">            removeEmptyAttributes:<span class="literal">true</span>,  <span class="comment">// 是否删除空属性</span></span><br><span class="line">            collapseWhitespace:<span class="literal">false</span>,  <span class="comment">// 折叠空格</span></span><br><span class="line">            removeStyleLinkTypeAttributes:<span class="literal">true</span>, <span class="comment">// 比如link中的type=&quot;text/css&quot;</span></span><br><span class="line">            minifyCSS:<span class="literal">true</span>, <span class="comment">// 是否压缩style标签内的css</span></span><br><span class="line">            minifyJS:&#123;  <span class="comment">// 压缩JS选项，可参考Terser配置</span></span><br><span class="line">                mangle:&#123;</span><br><span class="line">                    toplevel: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;: <span class="literal">false</span></span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="InlineChunkHtmlPlugin">InlineChunkHtmlPlugin</h2><ul><li><p>另外有一个插件，可以辅助将一些chunk出来的模块，内联到html中:</p><ul><li>比如runtime的代码，代码量不大，但是是必须加载的;</li><li>那么可以直接内联到html中;</li></ul></li><li><p>这个插件是在react-dev-utils中实现的，所以我们可以安装一下:</p><ul><li><code>npm i react-dev-utils </code></li></ul></li><li><p>在production的plugins中进行配置（内联runtime文件）:</p><ul><li>webpack.prod.js</li><li>参数一为HtmlWebpackPlugin</li><li>参数二为正则匹配表达式</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InlieChunkHtmlPlugin = <span class="built_in">require</span>(<span class="string">&quot;react-dev-utils/InlineChunkHtmlPlugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> InlieChunkHtmlPlugin(HtmlWebpackPlugin,[<span class="regexp">/runtime.+\.js/</span>])</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Terser">Terser</h2><ul><li><p>什么是Terser呢?</p><ul><li>Terser是一个JavaScript的解释(Parser)、Mangler(绞肉机)/Compressor(压缩机)的工具集;</li><li>早期会使用 uglify-js来压缩、丑化JavaScript代码，但是目前已经不再维护，并且不支持ES6+的 语法;</li><li>Terser是从 uglify-es fork 过来的，并且保留它原来的大部分API以及适配 uglify-es和uglify-js@3等; 也就是说，Terser可以帮助压缩、丑化代码，让我们的bundle变得更小。</li></ul></li><li><p>因为Terser是一个独立的工具，所以它可以单独安装:</p><ul><li><code>npm i terser -g</code></li></ul></li><li><p>可以在命令行中使用Terser</p><ul><li>因为他们的配置非常多Compress option和Mangle option</li><li>详情查看文档<ul><li><a href="https://github.com/terser/terser#compress-options">https://github.com/terser/terser#compress-options</a></li><li><a href="https://github.com/terser/terser#mangle-options">https://github.com/terser/terser#mangle-options</a></li></ul></li></ul></li></ul><h3 id="Webpack中配置Terser">Webpack中配置Terser</h3><ul><li><p>首先，需要打开minimize，让其对代码进行压缩(默认production模式下已经打开了)</p></li><li><p>其次，可以在minimizer创建一个TerserPlugin:</p><ul><li>extractComments:默认值为true，表示会将注释抽取到一个单独的文件中;<ul><li>在开发中，不希望保留这个注释时，可以设置为false;</li></ul></li><li>parallel:使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量: os.cpus().length - 1;<ul><li>也可以设置自己的个数，但是使用默认值即可;</li></ul></li><li>terserOptions:设置terser相关的配置<ul><li>compress:设置压缩相关的选项;</li><li>mangle:设置丑化相关的选项，可以直接设置为true;</li><li>toplevel:底层变量是否进行转换;</li><li>keep_classnames:保留类的名称;</li></ul></li></ul></li></ul><h2 id="CSS压缩">CSS压缩</h2><ul><li><p>另一个代码的压缩是CSS:</p><ul><li>CSS压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等;</li><li>CSS的压缩我们可以使用另外一个插件:css-minimizer-webpack-plugin;</li><li>css-minimizer-webpack-plugin是使用cssnano工具来优化、压缩CSS(也可以单独使用);</li></ul></li><li><p>安装 css-minimizer-webpack-plugin:</p><ul><li><code>npm i css-minimizer-webpack-plugin</code></li></ul></li><li><p>在optimization.minimizer中配置</p></li></ul><h2 id="配置示例">配置示例</h2><ul><li>webpack.prod.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProduction = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> CssMiniMizerPlugin = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        chunkIds: <span class="string">&quot;deterministic&quot;</span>,</span><br><span class="line">        minimize:<span class="literal">true</span>,</span><br><span class="line">        minimizer:[</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                extractComments:<span class="literal">true</span>,</span><br><span class="line">                parallel:<span class="literal">true</span>,</span><br><span class="line">                terserOptions:&#123;</span><br><span class="line">                    compress:<span class="literal">true</span>,</span><br><span class="line">                    mangle:<span class="literal">true</span>,</span><br><span class="line">                    toplevel:<span class="literal">false</span>,</span><br><span class="line">                    keep_classnames:<span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> CssMiniMizerPlugin(&#123;</span><br><span class="line">                parallel:<span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">            patterns: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">from</span>: <span class="string">&quot;public&quot;</span>,</span><br><span class="line">                    <span class="comment">// 可不写，默认到output</span></span><br><span class="line">                    to: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    globOptions: &#123;</span><br><span class="line">                        ignore: [<span class="string">&quot;**/index.html&quot;</span>, <span class="string">&quot;**/.DS_Store&quot;</span>, <span class="string">&quot;**/abc.txt&quot;</span>],</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<a href="https://juejin.cn/post/6969018138591494158">打包优化]Webpack体积压缩 (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://juejin.cn/post/6969018138591494158&quot;&gt;打包优化]Webpack体积压缩</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>[分享]Webpack打包分析工具</title>
    <link href="https://lebronchao.com/2021/06/07/Webpack%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>https://lebronchao.com/2021/06/07/Webpack%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</id>
    <published>2021-06-07T15:54:31.000Z</published>
    <updated>2021-06-07T15:54:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6968275465572188191">分享]Webpack打包分析工具 (juejin.cn)</a></p></blockquote><h1>Webpack打包分析</h1><blockquote><p>分享时间和文件的分析工具，便于进行打包优化。</p></blockquote><h2 id="打包的时间分析">打包的时间分析</h2><ul><li><p>如果希望看到每一个Loader、每一个Plugin消耗的打包时间，可以借助于一个插件:speed-measure-webpack-plugin</p><ul><li>注意:该插件在最新的webpack版本中存在一些兼容性的问题(和部分Plugin不兼容)</li><li>截止2021-3-10日，但是目前该插件还在维护，所以可以等待后续是否更新;</li></ul></li><li><p>安装</p><ul><li><code>npm i speed-measure-webpack-plugin</code></li></ul></li><li><p>使用</p><ul><li>创建插件导出的对象 SpeedMeasurePlugin;</li><li>使用 smp.wrap 包裹我们导出的webpack配置;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SpeedMeasurePlugin = <span class="built_in">require</span>(<span class="string">&quot;speed-measure-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin()</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isProduction = env.production;</span><br><span class="line">    process.env.NODE_ENV = isProduction ? <span class="string">&quot;production&quot;</span> : <span class="string">&quot;development&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> config = isProduction ? prodConfig : devConfig</span><br><span class="line">    <span class="keyword">const</span> webpackConfig = merge(commonConfig(isProduction), config)</span><br><span class="line">    <span class="keyword">return</span> smp.wrap(webpackConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>效果</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/33dce190bd2344059ba35f5923d08985~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210502234038719"></p><h2 id="打包后的文件分析">打包后的文件分析</h2><h3 id="方案一：生成stats-json文件">方案一：生成stats.json文件</h3><ul><li>编辑npm script</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;stats&quot;: &quot;webpack --config ./config/webpack.common.js --env production --profile --json=stats.json&quot;, </span><br></pre></td></tr></table></figure><ul><li><p>运行npm run stats</p><ul><li>根目录下生成了一个stats.json</li></ul></li><li><p>json文件内容较复杂，可以将文件上传至https://webpack.github.io/analyse/ 进行分析</p></li><li><p>效果</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e4274bbeb174029a66c2476e471d03e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="方案二：使用webpack-bundle-analyzer">方案二：使用webpack-bundle-analyzer</h3><ul><li><p>安装</p><ul><li><code>npm install webpack-bundle-analyzer</code></li></ul></li><li><p>webpack.common.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;BundleAnalyzerPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><p>在打包webpack的时候，这个工具打开一个8888端口上的服务，我们可以直观的看到每个包的大小。</p><ul><li>比如有一个包是通过一个Vue组件打包的，但是非常的大，那么我们可以考虑是否可以拆分出多个组件，并且对其进行懒加载;</li><li>比如一个图片或者字体文件特别大，是否可以对其进行压缩或者其他的优化处理;</li></ul></li><li><p>效果</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/7736de9810554f7fb63fcc2dce63b65f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210502234139506"></p><p>[<a href="https://juejin.cn/post/6968275465572188191">分享]Webpack打包分析工具 (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://juejin.cn/post/6968275465572188191&quot;&gt;分享]Webpack打包分析工具</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>[打包优化]Webpack DLL</title>
    <link href="https://lebronchao.com/2021/06/07/WebpackDLL/"/>
    <id>https://lebronchao.com/2021/06/07/WebpackDLL/</id>
    <published>2021-06-07T15:53:03.000Z</published>
    <updated>2021-06-07T15:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6967164397127270436">打包优化]Webpack DLL (juejin.cn)</a></p></blockquote><h1>认识DLL库</h1><ul><li><p>什么是DLL</p><ul><li>DLL全称是动态链接库(Dynamic Link Library)，是为软件在Windows中实现共享函数库的一种实现方式;</li><li>那么webpack中也有内置DLL的功能，它指的是可以将可以共享，并且不经常改变的代码，抽取成一个共享的库;</li><li>这个库在之后编译的过程中，会被引入到其他项目的代码中，减少的打包的时间;</li></ul></li><li><p>DDL库的使用分为两步:</p><ul><li>第一步:打包一个DLL库;</li><li>第二步:项目中引入DLL库</li></ul></li></ul><h2 id="DLL打包">DLL打包</h2><blockquote><p>webpack内置DllPlugin帮助生成DLL文件</p></blockquote><ul><li>webpack.common.js<ul><li>context：执行上下文，</li><li>entry：<ul><li>key：name（placeholder）</li><li>value：要打包的包名</li></ul></li><li>output（常规）</li><li>plugins<ul><li>DllPlugin<ul><li>name：定义生成dll文件的名称</li><li>path：生成dll文件的文件路径</li></ul></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;DllPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;merge&#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="function">(<span class="params">isProduction</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        context: path.resolve(__dirname, <span class="string">&quot;../&quot;</span>),</span><br><span class="line">        entry: &#123;</span><br><span class="line">            react:[<span class="string">&quot;react&quot;</span>,<span class="string">&quot;react-dom&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">           path:path.resolve(__dirname,<span class="string">&quot;../dll&quot;</span>),</span><br><span class="line">            filename:<span class="string">&quot;dll_[name].js&quot;</span>,</span><br><span class="line">            library:<span class="string">&quot;dll_[name]&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> DllPlugin(&#123;</span><br><span class="line">                name:<span class="string">&#x27;[name].manifest.json&#x27;</span>,</span><br><span class="line">                path:path.resolve(__dirname, <span class="string">&quot;../dll/[name].manifest.json&quot;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.dev&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.prod&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isProduction = env.production;</span><br><span class="line">    process.env.NODE_ENV = isProduction ? <span class="string">&quot;production&quot;</span> : <span class="string">&quot;development&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> config = isProduction ? prodConfig : devConfig</span><br><span class="line">    <span class="keyword">return</span> merge(commonConfig(isProduction), config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打包完成后，在根目录下会有一个dll文件夹，内有Dll文件和相应manifest.json文件。</p></blockquote><h2 id="DLL使用">DLL使用</h2><ul><li>如果我们的代码中使用了react、react-dom，有配置splitChunks的情况下，他们会进行分包，打包到 一个独立的chunk中。<ul><li>但是现在有了dll_react，不再需要单独去打包它们，可以直接去引用dll_react即可:</li><li>第一步:通过DllReferencePlugin插件告知要使用的DLL库;</li><li>第二步:通过AddAssetHtmlPlugin插件，将打包的DLL库引入到Html模块中;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">    context:path.resolve(__dirname, <span class="string">&quot;../&quot;</span>),</span><br><span class="line">    manifest:path.resolve(__dirname,<span class="string">&quot;../dll/react.manifest.json&quot;</span>)</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">    outputPath:<span class="string">&quot;../build/js&quot;</span>,</span><br><span class="line">    filepath:path.resolve(__dirname, <span class="string">&quot;../dll/dll_react.js&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure> <hr/><p>[<a href="https://juejin.cn/post/6967164397127270436">打包优化]Webpack DLL (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://juejin.cn/post/6967164397127270436&quot;&gt;打包优化]Webpack DLL</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>[探索]Webpack DevServer和HMR原理</title>
    <link href="https://lebronchao.com/2021/06/07/WebpackDevServer%E5%92%8CHMR%E5%8E%9F%E7%90%86/"/>
    <id>https://lebronchao.com/2021/06/07/WebpackDevServer%E5%92%8CHMR%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-07T15:49:57.000Z</published>
    <updated>2021-06-07T15:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6966422095274180639">探索]Webpack DevServer和HMR原理 (juejin.cn)</a></p></blockquote><h1>Webpack-Dev-Server</h1><blockquote><p>为什么要搭建本地服务器</p></blockquote><ul><li><p>目前开发的代码，为了运行需要有两个操作</p><ul><li><code>npm run build</code>编译</li><li>通过live-server或者直接通过浏览器打开html文件，查看效果</li></ul></li><li><p>为了完成自动编译，webpack提供了几种可选的方式</p><ul><li>Webpack watch mode</li><li>Webpack-dev-server</li><li>Webpack-dev-middleware</li></ul></li></ul><h2 id="Webpack-Watch-Mode">Webpack Watch Mode</h2><ul><li><p>webpack提供了watch模式</p><ul><li>在该模式下，webpack依赖图中所有文件，只要有一个发生了更新，那么代码将被重新编译。</li><li>不需要手动<code>npm run build</code></li></ul></li><li><p>如何开启？</p><ul><li>方式一：在导出的配置中，添加watch:true</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;js/bundle.js&quot;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:<span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：在启动webapck的命令中，添加–watch标识</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">npm script:&#123;</span><br><span class="line"> &quot;watch&quot;: &quot;webpack --watch&quot;</span><br><span class="line">&#125;</span><br><span class="line"># npm run watch</span><br></pre></td></tr></table></figure><h2 id="Webpack-Dev-Server">Webpack Dev Server</h2><ul><li><p>上面的方式可以监听到文件的变化，但是没有自动刷新浏览器的功能</p><ul><li>webpack-dev-server可以实现</li></ul></li><li><p>安装</p><ul><li><code>npm install --save webpack-dev-server</code></li></ul></li><li><p>修改npm script，同时可在配置文件中devServer属性下配置devServer</p></li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">script:&#123;</span><br><span class="line">    &quot;serve&quot;:&quot;webpack serve&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>webpack-dev-server在编译之后不会写入到任何输出文件。而是将bundle文件保留在内存中<ul><li>事实上webpck-dev-server使用了一个叫memfs的库。</li></ul></li></ul><h2 id="Webpack-Dev-Middleware">Webpack Dev Middleware</h2><ul><li><p>webpack-dev-middleware是一个封装器，它可以把webpack处理过的文件发送到一个server</p><ul><li>webpack-dev-server在内部使用了它，然而它也可以作为一个单独的package来使用，以便根据需求进行更多自定义配置</li><li>搭配一个服务器来使用它，比如express.</li><li><code>npm install --save express webpack-dev-middleware</code></li></ul></li><li><p>编写Server.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">&quot;webpack-dev-middleware&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>  app = express()</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&quot;./webpack.config&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config)</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler,&#123;</span><br><span class="line">    publicPath:config.output.publicPath</span><br><span class="line">&#125;),<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这里是回调函数&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Server running&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Node Server.js即可运行起一个服务，并监听文件更改和刷新浏览器。</li></ul><h2 id="PublicPath">PublicPath</h2><ul><li><p>Output中有两个很重要的属性：path和publicPath</p><ul><li>path：用于指定文件的输出路径，是一个聚堆路径</li><li>publicPath：默认是一个空字符串，它为我们项目中的资源制定一个公共的路径publicPath</li></ul></li><li><p>这个publicPath很不容易理解，其实就是给我们打包的资源，给它一个路径</p><ul><li>资源的路径 = output.publicePath + 打包资源的路径(比如&quot;js/[name].bundle.js&quot;)</li></ul></li><li><p>常用的值</p><ul><li>./ :本地环境下可以使用这个相对路径</li><li>/ :服务器部署时使用，服务器地址 + /js/[name].bundle.js</li></ul></li><li><p>devServer的publicPath、output的publicPath和[webpackDevMiddleware的publicPath]需一致</p></li></ul><h2 id="ContentBase">ContentBase</h2><ul><li><p>devServer中contentBase对于我们直接访问打包后的资源其实并没有太大的作用，它的主要作用是如果我们打包后的资源，又依赖于其他的一些资源，那么就需要指定从哪里来查找这个内容:</p><ul><li>比如在index.html中，我们需要依赖一个 abc.js 文件，这个文件我们存放在 public文件中;</li><li>在index.html中，我们应该如何去引入这个文件?<ul><li>比如代码是这样的:<script src="./public/abc.js"></script>;</li><li>这样打包后浏览器无法通过相对路径去找到这个文件夹;</li><li>所以代码是这样:<script src="/abc.js"></script>;</li><li>如何让它去查找到这个文件的存在? 设置contentBase即可;</li></ul></li></ul></li><li><p>当然在devServer中还有一个可以监听contentBase发生变化后重新编译的一个属性：watchContentBase。</p></li></ul><h2 id="Proxy代理">Proxy代理</h2><blockquote><p>proxy是我们开发中常用的一个配置选项，它的目的设置代理来解决跨域访问的问题</p></blockquote><ul><li>设置<ul><li>target：标识的是代理到的目标地址，比如/api/moment会被代理到http://localhost:8888/api/moment</li><li>pathRewrite：默认情况下，我们的/api也会被写入到URL中，如果希望删除，可以使用</li><li>secure：默认情况下不接受转发到https的服务器，如果希望支持，设置为false</li><li>changeOrigin：表示是否更新代理后请求headers中的host地址</li><li>historyApiFallback：解决SPA页面在路由跳转后，进行页面刷新返回404的错误<ul><li>boolean值：默认是false，如果设置为true，刷新的时候，返回404错误时，会自动返回index.html的内容</li><li>object值：可以配置rewrites属性<ul><li>可以配置from来匹配路径，决定要跳到哪个页面，详情查阅官方文档。</li></ul></li></ul></li></ul></li></ul><h2 id="Other-Config">Other Config</h2><ul><li><p>hotOnly</p><ul><li>默认情况下当代码编译失败修复后会刷新页面，不希望刷新设置hotOnly:true</li></ul></li><li><p>host主机地址</p><ul><li>默认值是localhost</li><li>如果其他PC也可以访问可设置0.0.0.0</li></ul></li><li><p>localhost和0.0.0.0的区别</p><ul><li>localhost本质上是一个域名会被解析为127.0.0.1</li><li>127.0.0.1是一个会换地址，表达得意思是主机自己发出去的包，直接被自己接受<ul><li>正常的数据库包经常 应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 数据链路层 -&gt; 物理层</li><li>而回环地址，在网联络层直接就被获取</li><li>监听127.0.0.1时，同个网段下的主机中，通过ip地址是不能访问的。</li></ul></li><li>0.0.0.0：监听IPV4上所有的地址，再根据端口找到不同的应用程序。<ul><li>监听0.0.0.0时，在同一个网段下的主机中，通过IP地址是可以访问的。</li></ul></li></ul></li><li><p>Port</p><ul><li>设置监听的端口，默认为8080</li></ul></li><li><p>open是否打开浏览器</p><ul><li>默认为false，true会打开浏览器</li><li>也可以设置类似于Google Chrome等值</li></ul></li><li><p>compress是否为静态文件开启gzip compression</p><ul><li>默认是是false，可以设置为true</li></ul></li></ul><h2 id="配置示例">配置示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    hostOnly:<span class="literal">true</span>,</span><br><span class="line">    host:<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    port:<span class="number">8080</span>,</span><br><span class="line">    open:<span class="literal">true</span>,</span><br><span class="line">    compress:<span class="literal">true</span>,</span><br><span class="line">    proxy:&#123;</span><br><span class="line">        <span class="string">&quot;/api&quot;</span>:&#123;</span><br><span class="line">            target:<span class="string">&quot;http://localhost:8888&quot;</span>,</span><br><span class="line">            pathRewrite:&#123;</span><br><span class="line">                <span class="string">&quot;^/api&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            secure:<span class="literal">false</span>,</span><br><span class="line">            changeOrigin:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Hot Module Replacement</h1><ul><li><p>什么是HMR?</p><ul><li>HMR全称Hot Module Replacement，翻译为模块热替换</li><li>模块热替换是指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面。</li></ul></li><li><p>HMR通过如下几种方式，来提高开发的速度。</p><ul><li>不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；</li><li>只需更新需要变化的内容，节省开发时间</li><li>修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的devtools中直接修改样式。</li></ul></li><li><p>如何使用HMR？</p><ul><li>默认情况下，webpack-dev-server已经支持HMR，只需要开启即可。</li><li>在不开启HMR的情况下，修改了源代码后，整个页面会自动刷新，使用的是live reloading。</li></ul></li><li><p>如何开启</p><ul><li>修改webpack.config.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;js/bundle.js&quot;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:<span class="literal">true</span>,</span><br><span class="line">    mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">      hot:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>更新后还是刷新整个浏览器，因为需要定义使用HMR的模块。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">&quot;./App.vue&quot;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;vue更新了&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="框架的HMR">框架的HMR</h2><blockquote><p>有一个问题:在开发其他项目时，我们是否需要经常手动去写入 module.hot.accpet相关的API呢?</p></blockquote><ul><li><p>比如开发Vue、React项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作?</p></li><li><p>社区已经针对这些有很成熟的解决方案了:</p><ul><li>比如vue开发中，我们使用vue-loader，此loader支持vue组件的HMR，提供开箱即用的体验;</li><li>比如react开发中，有React Hot Loader，实时调整react组件(目前React官方已经弃用了，改成使用react- refresh);</li></ul></li></ul><h2 id="Vue的HMR">Vue的HMR</h2><ul><li><p>Vue的加载需要vue-loader，而vue-loader加载的默认会进行HMR处理</p></li><li><p>安装加载Vue所需依赖</p><ul><li><code>npm install vue-loader vue-template-compiler</code></li></ul></li><li><p>配置Webpack.config.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&quot;vue-loader/lib/plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">            use: [<span class="string">&quot;vue-loader&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">   ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[<span class="keyword">new</span> VueLoaderPlugin()]</span><br></pre></td></tr></table></figure><h2 id="React的HMR">React的HMR</h2><ul><li><p>在之前，React是借助React Hot Loader来实现HMR，目前已经改成使用react-refesh来实现了</p></li><li><p>安装相关依赖</p><ul><li><code>npm install @pmmmwh/react-refresh-webpack-plugin react-refresh</code></li></ul></li><li><p>webpack.config.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactRefreshWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;@pmmmwh/react-refresh-webpack-plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> ReactRefreshWebpackPlugin(),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><ul><li>babel.config.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    presets: [</span><br><span class="line">        [<span class="string">&quot;@babel/preset-env&quot;</span>, &#123;</span><br><span class="line">            useBuiltIns: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">            corejs: <span class="number">3.8</span></span><br><span class="line">        &#125;],</span><br><span class="line">        [<span class="string">&quot;@babel/preset-react&quot;</span>],</span><br><span class="line">        [<span class="string">&quot;@babel/preset-typescript&quot;</span>]</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">        [<span class="string">&#x27;react-refresh/babel&#x27;</span>]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HMR的原理">HMR的原理</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/98219680ad66478c89385a4e0fbaacd8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210502184548214"></p><ul><li><p>那么HMR的原理是什么呢？如何可以做到只更新一个模块中的内容？</p><ul><li>webpack-dev-server会创建两个服务：提供静态资源的服务（express）和Socket（net.Socket）</li><li>Express Server负责直接提供静态资源服务（打包后的资源直接被浏览器请求和解析）</li></ul></li><li><p>HMR Socket Server是一个socket长连接</p><ul><li>长连接有一个最好的好处是建立连接后双方可以通信（服务器可以直接发送文件到客户端）</li><li>当服务期间听到对应模块发上变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li><li>通过长连接，可以直接将这两个文件主动发送给客户端。</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新。</li></ul><hr/></li></ul><p>[<a href="https://juejin.cn/post/6966422095274180639">探索]Webpack DevServer和HMR原理 (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;p&gt;[&lt;a href=&quot;https://juejin.cn/post/6966422095274180639&quot;&gt;探索]Webpack DevSe</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>Webpack模块化原理和SourceMap</title>
    <link href="https://lebronchao.com/2021/05/25/Webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8CSourceMap/"/>
    <id>https://lebronchao.com/2021/05/25/Webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8CSourceMap/</id>
    <published>2021-05-25T15:31:43.000Z</published>
    <updated>2021-05-25T15:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！<br/><a href="https://juejin.cn/post/6965677810862161950">掘金原文链接</a></p></blockquote><h1>Webpack模块化</h1><ul><li><p>Webpack打包的代码，允许我们使用各种各样的模块化，但是最常用的是CommonJS、ES Module。</p></li><li><p>包括如下原理:</p><ul><li>CommonJS模块化实现原理;</li><li>ES Module实现原理;</li><li>CommonJS加载ES Module的原理;</li><li>ES Module加载CommonJS的原理;</li></ul></li></ul><h2 id="CommonJS：">CommonJS：</h2><h3 id="打包前">打包前</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; dateFormat, priceFormat &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./js/format&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dateFormat(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(priceFormat(<span class="string">&quot;abc&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="打包后">打包后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了一个对象</span></span><br><span class="line"><span class="comment">// 模块的路径(key): 函数(value)</span></span><br><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">  <span class="string">&quot;./src/js/format.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> dateFormat = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2020-12-12&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> priceFormat = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;100.00&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将我们要导出的变量, 放入到module对象中的exports对象</span></span><br><span class="line">      <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        dateFormat,</span><br><span class="line">        priceFormat</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象, 作为加载模块的缓存</span></span><br><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是一个函数, 当我们加载一个模块时, 都会通过这个函数来加载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.判断缓存中是否已经加载过</span></span><br><span class="line">  <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_module_cache__[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.给module变量和__webpack_module_cache__[moduleId]赋值了同一个对象</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = __webpack_module_cache__[moduleId] = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.加载执行模块</span></span><br><span class="line">  __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.导出module.exports &#123;dateFormat: function, priceForamt: function&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体开始执行代码逻辑</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.加载./src/js/format.js</span></span><br><span class="line">  <span class="keyword">const</span> &#123; dateFormat, priceFormat &#125; = __webpack_require__(<span class="string">&quot;./src/js/format.js&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(dateFormat(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(priceFormat(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h2 id="ES-Module">ES Module</h2><h3 id="打包前-2">打包前</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum, mul &#125; <span class="keyword">from</span> <span class="string">&quot;./js/math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><h3 id="打包后-2">打包后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义了一个对象, 对象里面放的是我们的模块映射</span></span><br><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">  <span class="string">&quot;./src/es_index.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 调用r的目的是记录时一个__esModule -&gt; true</span></span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// _js_math__WEBPACK_IMPORTED_MODULE_0__ == exports</span></span><br><span class="line">      <span class="keyword">var</span> _js_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">&quot;./src/js/math.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(_js_math__WEBPACK_IMPORTED_MODULE_0__.mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">      <span class="built_in">console</span>.log(_js_math__WEBPACK_IMPORTED_MODULE_0__.sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    &#125;),</span><br><span class="line">  <span class="string">&quot;./src/js/math.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用了d函数: 给exports设置了一个代理definition</span></span><br><span class="line">      <span class="comment">// exports对象中本身是没有对应的函数</span></span><br><span class="line">      __webpack_require__.d(__webpack_exports__, &#123;</span><br><span class="line">        <span class="string">&quot;sum&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> sum; &#125;,</span><br><span class="line">        <span class="string">&quot;mul&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> mul; &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> mul = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.模块的缓存</span></span><br><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.require函数的实现(加载模块)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_module_cache__[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = __webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// __webpack_require__这个函数对象添加了一个属性: d -&gt; 值function</span></span><br><span class="line">  __webpack_require__.d = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, definition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> definition) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(<span class="built_in">exports</span>, key)) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, key, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">get</span>: definition[key] &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// __webpack_require__这个函数对象添加了一个属性: o -&gt; 值function </span></span><br><span class="line">  __webpack_require__.o = <span class="function"><span class="keyword">function</span> (<span class="params">obj, prop</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop); &#125;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// __webpack_require__这个函数对象添加了一个属性: r -&gt; 值function</span></span><br><span class="line">  __webpack_require__.r = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">&#x27;Module&#x27;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__webpack_require__(<span class="string">&quot;./src/es_index.js&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="ES-Module和CommonJS混合导入导出">ES Module和CommonJS混合导入导出</h2><h3 id="打包前-3">打包前</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es module导出内容, CommonJS导入内容</span></span><br><span class="line"><span class="keyword">const</span> &#123; sum, mul &#125; = <span class="built_in">require</span>(<span class="string">&quot;./js/math&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS导出内容, es module导入内容</span></span><br><span class="line"><span class="keyword">import</span> &#123; dateFormat, priceFormat &#125; <span class="keyword">from</span> <span class="string">&quot;./js/format&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dateFormat(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(priceFormat(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(abc);</span><br></pre></td></tr></table></figure><h3 id="打包后-3">打包后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> __webpack_modules__ = (&#123;</span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">      &quot;use strict&quot;</span>;</span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line">      <span class="keyword">var</span> _js_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">&quot;./src/js/format.js&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> _js_format__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_js_format__WEBPACK_IMPORTED_MODULE_0__);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// es module导出内容, CommonJS导入内容</span></span><br><span class="line">      <span class="keyword">const</span> math = __webpack_require__(<span class="string">&quot;./src/js/math.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CommonJS导出内容, es module导入内容</span></span><br><span class="line">      <span class="built_in">console</span>.log(math.sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">      <span class="built_in">console</span>.log(math.mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">      <span class="built_in">console</span>.log(_js_format__WEBPACK_IMPORTED_MODULE_0___default().dateFormat(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">      <span class="built_in">console</span>.log(_js_format__WEBPACK_IMPORTED_MODULE_0___default().priceFormat(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">    &#125;),</span><br><span class="line">  <span class="string">&quot;./src/js/format.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> dateFormat = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2020-12-12&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> priceFormat = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;100.00&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        dateFormat,</span><br><span class="line">        priceFormat</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;./src/js/math.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      </span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line">      __webpack_require__.d(__webpack_exports__, &#123;</span><br><span class="line">        <span class="string">&quot;sum&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> sum; &#125;,</span><br><span class="line">        <span class="string">&quot;mul&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> mul; &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> mul = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The require function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check if module is in cache</span></span><br><span class="line">  <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_module_cache__[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = __webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="comment">// no module.id needed</span></span><br><span class="line">    <span class="comment">// no module.loaded needed</span></span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute the module function</span></span><br><span class="line">  __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the exports of the module</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class="line">  __webpack_require__.n = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getter = <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule ?</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">&#x27;default&#x27;</span>]; &#125; :</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>; &#125;;</span><br><span class="line">    __webpack_require__.d(getter, &#123; <span class="attr">a</span>: getter &#125;);</span><br><span class="line">    <span class="keyword">return</span> getter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webpack/runtime/define property getters */</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// define getter functions for harmony exports</span></span><br><span class="line">  __webpack_require__.d = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, definition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> definition) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(<span class="built_in">exports</span>, key)) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, key, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">get</span>: definition[key] &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webpack/runtime/hasOwnProperty shorthand */</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  __webpack_require__.o = <span class="function"><span class="keyword">function</span> (<span class="params">obj, prop</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop); &#125;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webpack/runtime/make namespace object */</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// define __esModule on exports</span></span><br><span class="line">  __webpack_require__.r = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">&#x27;Module&#x27;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">__webpack_require__(<span class="string">&quot;./src/index.js&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><blockquote><p>原理都是类似的</p></blockquote><ol><li>通过一个webpack_module对象来存储模块化代码<ul><li>key为文件名称</li><li>value为文件代码</li></ul></li><li>通过webpack_module_cache来缓存模块化代码</li><li>通过webpack_require来从webpack_module_cache或webpack_module中读取并从引入代码</li></ol><h2 id="认识Source-Map">认识Source-Map</h2><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/SourceMap.jsm">参考文档 </a></p></blockquote><ul><li><p>我们的代码通常运行在浏览器上时，是通过打包压缩的:</p><ul><li>也就是真实跑在浏览器上的代码，和我们编写的代码其实是有差异的;</li><li>比如ES6的代码可能被转换成ES5;</li><li>比如对应的代码行号、列号在经过编译后肯定会不一致;</li><li>比如代码进行丑化压缩时，会将编码名称等修改;</li><li>比如我们使用了TypeScript等方式编写的代码，最终转换成JavaScript;</li></ul></li><li><p>通过SourceMap可以调试这种转换后不一致的代码</p><ul><li>source-map是从已转换的代码，映射到原始的源文件;</li><li>使浏览器可以重构原始源并在调试器中显示重建的原始源;</li><li>更容易定位到源文件错误</li></ul></li></ul><h3 id="如何使用SourceMap">如何使用SourceMap</h3><ul><li><p>第一步:根据源文件，生成source-map文件，webpack在打包时，可以通过配置生成source-map;</p><p><code>devtool:'source-map'</code></p></li><li><p>第二步:在转换后的代码，最后添加一个注释，它指向sourcemap;</p><p><code>//# sourceMappingURL=common.bundle.js.map</code></p></li><li><p>浏览器会根据我们的注释，查找相应的source-map，并且根据source-map还原我们的代码，方便进行调试。</p></li><li><p>在Chrome中，我们可以按照如下的方式打开source-map:</p><ul><li>√Enable JavaScript source maps</li><li>√Enable CSS source maps</li></ul></li><li><p>最初source-map生成的文件带下是原始文件的10倍，第二版减少了约50%，第三版又减少了50%，所以目前一个 133kb的文件，最终的source-map的大小大概在300kb。</p></li><li><p>目前的source-map长什么样子？</p><ul><li>version:当前使用的版本，也就是最新的第三版;</li><li>sources:从哪些文件转换过来的source-map和打包的代码(最初始的文件);</li><li>names:转换前的变量和属性名称(因为目前使用的是development模式，所以不需要保留转换前的名称);</li><li>mappings:source-map用来和源文件映射的信息(比如位置信息等)，一串base64 VLQ(veriable- length quantity可变长度值)编码;</li><li>file:打包后的文件(浏览器加载的文件);</li><li>sourceContent:转换前的具体代码信息(和sources是对应的关系);</li><li>sourceRoot:所有的sources相对的根目录;</li></ul></li></ul><h3 id="生成SourceMap">生成SourceMap</h3><blockquote><p>如何在使用webpack打包的时候，生成对应的source-map?</p></blockquote><ul><li><p>webpack为我们提供了非常多的选项(目前是26个)，来处理source-map;</p></li><li><p>参考文档：<a href="https://webpack.docschina.org/configuration/devtool/">https://webpack.docschina.org/configuration/devtool/</a></p></li><li><p>选择不同的值，生成的source-map会稍微有差异，打包的过程也会有性能的差异，可以根据不同的情况进行 选择;</p></li></ul><blockquote><p>下面几个值不会生成source-map</p></blockquote><ul><li><p>false:不使用source-map，也就是没有任何和source-map相关的内容。</p></li><li><p>none:production模式下的默认值（什么值都不写），不生成source-map。</p></li><li><p>eval:development模式下的默认值，不生成source-map</p><ul><li>但是它会在eval执行的代码中，添加 //# sourceURL=;</li><li>它会被浏览器在执行时解析，并且在调试面板中生成对应的一些文件目录，方便我们调试代码;</li></ul></li></ul><blockquote><p>使用source-map的值</p></blockquote><ul><li><p>source-map</p><ul><li>生成独立的source-map文件，并在打包后的JS文件中有一个注释指向source-map文件；<ul><li>注释：   `` //# sourceMappingURL=bundle.js.map`</li></ul></li></ul></li><li><p>eval-source-map</p><ul><li>source-map以DataUrl的形式添加到eval函数后面</li></ul></li><li><p>inline-source-map</p><ul><li>source-map以DataUrl的形式添加到打包后的JS文件后面（注释）</li></ul></li><li><p>cheap-source-map:</p><ul><li>会生成source-map，但是会更加高效一些(cheap低开销)，因为它没有生成列映射(Column Mapping)</li><li>因为在开发中，我们只需要行信息通常就可以定位到错误了</li></ul></li><li><p>cheap-module-source-map:</p><ul><li>会生成source-map，类似于cheap-source-map，但是对源自loader的source-map处理会更好。</li><li>对源自loader的source-map处理会更好，官方也没有给出很好的解释 其实是如果loader对我们的源码进行了特殊的处理，比如babel,会恢复成源文件的代码模块格式，例如不会删除自定义的空行。</li></ul></li><li><p>hidden-source-map:</p><ul><li>会生成sourcemap，但是不会对source-map文件进行引用;</li><li>相当于删除了打包文件中对sourcemap的引用注释</li><li># sourceMappingURL=bundle.js.map</li><li>如果手动添加进来，那么source-map就会生效了</li></ul></li><li><p>nosources-source-map:</p><ul><li>会生成sourcemap，但是生成的sourcemap只有错误信息的提示，不会生成源代码文件;</li><li>点击错误信息也无法查看源码</li></ul></li></ul><blockquote><p>多个值的组合</p></blockquote><ul><li><p>事实上，webpack提供给我们的26个值，是可以进行多组合的。</p></li><li><p>组合的规则如下:</p></li><li><p>inline-|hidden-|eval:三个值时三选一;</p></li><li><p>nosources:可选值;</p></li><li><p>cheap可选值，并且可以跟随module的值;</p></li></ul><blockquote><p>那么在开发中，最佳的实践是什么呢?</p></blockquote><ul><li><p>开发阶段:推荐使用 source-map或者cheap-module-source-map</p><ul><li>这分别是vue和react使用的值，可以获取调试信息，方便快速开发;</li></ul></li><li><p>测试阶段:推荐使用 source-map或者cheap-module-source-map</p><ul><li>测试阶段我们也希望在浏览器下看到正确的错误提示;</li></ul></li><li><p>发布阶段:false、缺省值(不写)</p></li></ul><hr/><p><a href="https://juejin.cn/post/6965677810862161950">掘金原文链接</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;br/&gt;&lt;a href=&quot;https://juejin.cn/post/6965677810862161950&quot;&gt;掘金原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>Webpack_Plugin知识分享</title>
    <link href="https://lebronchao.com/2021/05/22/Webpack-Plugin%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    <id>https://lebronchao.com/2021/05/22/Webpack-Plugin%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/</id>
    <published>2021-05-22T09:09:50.000Z</published>
    <updated>2021-05-22T09:09:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！<br/><a href="https://juejin.cn/post/6963822022434504734">掘金原文链接</a></p></blockquote><h1>认识Plugin</h1><ul><li><p>Loader是用于特定的模块类型进行转换;</p></li><li><p>Plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等;</p></li></ul><h1>常用Plugin</h1><h2 id="CleanWebpackPlugin">CleanWebpackPlugin</h2><ul><li><p>每次修改了一些配置，重新打包时，都需要手动删除dist文件夹:</p></li><li><p>我们可以借助于一个插件来帮助我们完成，这个插件就是CleanWebpackPlugin;</p></li></ul><h3 id="安装：">安装：</h3><ul><li><code>npm install clean-webpack-plugin --save</code></li></ul><h3 id="配置：">配置：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> CleanWebpackPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="HtmlWebpackPlugin">HtmlWebpackPlugin</h2><ul><li><p>我们的HTML文件是编写在根目录下的，而最终打包的dist文件夹中是没有index.html文件的。</p></li><li><p>在进行项目部署的时，必然也是需要有对应的入口文件index.html;</p></li><li><p>所以我们也需要对index.html进行打包处理;</p></li></ul><h3 id="安装">安装</h3><ul><li><code>npm install html-webpack-plugin --save</code></li></ul><h3 id="配置">配置</h3><ul><li><p>可传入变量例如title，</p></li><li><p>可自定义模板，template填写模板路径</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">&quot;LeBronChao Webpack&quot;</span>,</span><br><span class="line">      template: <span class="string">&quot;./public/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="模板和变量引用方法">模板和变量引用方法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>LeBronChao Webpack<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="效果">效果</h3><ul><li><p>现在自动在build文件夹中，生成了一个index.html的文件</p></li><li><p>该文件中也自动添加了我们打包的bundle.js文件</p></li><li><p>这个文件是如何生成的呢?</p><ul><li>默认情况下是根据ejs的一个模板来生成的;</li><li>在html-webpack-plugin的源码中，有一个default_index.ejs模块;</li></ul></li></ul><h2 id="DefinePlugin">DefinePlugin</h2><blockquote><p>用于定义全局常量</p></blockquote><h3 id="安装-2">安装</h3><ul><li>Webpack内置，无需安装</li></ul><h3 id="配置-2">配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; DefinePlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> DefinePlugin(&#123;</span><br><span class="line">      BASE_URL: <span class="string">&quot;&#x27;./favicon.ico&#x27;&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ol><li>定义的变量赋值时若为字符串需嵌套字符串，若为变量在&quot;&quot;内填写变量，如上。</li></ol></blockquote><h3 id="模板中的使用方法">模板中的使用方法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>LeBronChao Webpack<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CopyWebpackPlugin">CopyWebpackPlugin</h2><ul><li>在vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist文件夹中。<ul><li>这个复制的功能，我们可以使用CopyWebpackPlugin来完成;</li></ul></li></ul><h3 id="安装：-2">安装：</h3><ul><li><code>npm install copy-webpack-plugin --save</code></li></ul><h3 id="配置：-2">配置：</h3><ul><li><p>复制的规则在patterns中设置;</p></li><li><p>from:设置从哪一个源中开始复制;</p></li><li><p>to:复制到的位置，可以省略，会默认复制到打包的目录下,路径编写以打包目录为根目录;</p></li><li><p>globOptions:设置一些额外的选项，其中ignore可以编写需要忽略的文件:</p><ul><li>DS_Store:mac目录下会自动生成的一个文件;</li><li>index.html:也不需要复制，因为我们已经通过HtmlWebpackPlugin完成了index.html的生成;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">from</span>: <span class="string">&quot;public&quot;</span>,</span><br><span class="line">          <span class="comment">// 可不写，默认到output</span></span><br><span class="line">          to: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">          globOptions: &#123;</span><br><span class="line">            ignore: [<span class="string">&quot;**/index.html&quot;</span>, <span class="string">&quot;**/.DS_Store&quot;</span>, <span class="string">&quot;**/abc.txt&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>自定义Plugin</h1><ul><li><p>webpack有两个非常重要的类Compiler和Compilation</p><ul><li>他们通过注入插件的方式，来监听webpack的所有生命周期</li><li>插件的注入离不开各种各样的Hook</li><li>Hook来源于Tapable库</li></ul></li><li><p>想自定义Plugin，先了解一个库Tapable</p><ul><li>Tapable是官方编写和维护的一个库</li><li>Tapable是管理着需要的Hook，这些Hook可以应用到插件中</li></ul></li></ul><h2 id="Tapable-Hook分类">Tapable Hook分类</h2><ul><li><p>同步Sync</p><ul><li>SyncHook</li><li>SyncBailHook</li><li>SyncWaterfallHook</li><li>SyncLoopHook</li></ul></li><li><p>异步Async</p><ul><li>Paralle（并行）<ul><li>AsyncPrarllelHook</li><li>AsyncParallelBailHook</li></ul></li><li>Series（串行）<ul><li>AsyncSeriesHook</li><li>AsyncSeriesBailHook</li><li>AsyncSeriresWaterfallHook</li></ul></li><li>同步和异步的<ul><li>以sync开头的为同步hook</li><li>以async开头的，两个事件处理回调，不会等待上一次处理回调结束后再执行下一次回调。</li></ul></li></ul></li><li><p>其他的类别</p><ul><li>baill：当有返回值时，就不会执行后续的事件触发了。</li><li>Loop：当返回值为true时，就会反复执行该事件，当返回值为undefined或者不返回内容时，退出事件</li><li>Waterfall：当返回值不为undefined时，会将这次返回的结果作为下次事件的第一个参数</li><li>Parallel：并行，会同时执行事件处理回调的Hook</li><li>Series：串行，会等待上一事件处理回调的Hook</li></ul></li></ul><h2 id="Hook的使用过程">Hook的使用过程</h2><ol><li><p>创建Hook对象</p><ul><li>New 对象传入的数组为需传入参数key</li></ul></li><li><p>注册Hook中的事件</p></li><li><p>触发事件</p></li></ol><ul><li>plugin.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;SyncWaterfallHook&#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tapableTest</span></span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hooks = &#123;</span><br><span class="line">            syncHook:<span class="keyword">new</span> SyncWaterfallHook([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.hooks.syncHook.tap(<span class="string">&quot;event1&quot;</span>,<span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;event1&quot;</span>, name, age);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;event1&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.hooks.syncHook.tap(<span class="string">&quot;event2&quot;</span>,<span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;event2&quot;</span>, name, age);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">emit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.hooks.syncHook.call(<span class="string">&quot;lebron&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index= <span class="keyword">new</span> tapableTest()</span><br><span class="line">index.emit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// event1 lebron 21 </span></span><br><span class="line"><span class="comment">// event2 event1 21</span></span><br></pre></td></tr></table></figure><h2 id="自定义一个AutoUploadPlugin">自定义一个AutoUploadPlugin</h2><blockquote><p>前端开发完成后，经常要打包上传代码。个人开发者一般会使用Nginx部署服务，每次上传代码太麻烦了，自己写个Plugin让他自动上传到Nginx文件夹吧。</p></blockquote><ul><li>plugin配置<ul><li>host：主机地址</li><li>username：主机用户名</li><li>password：主机ssh登录密码</li><li>remotePath：远程部署服务的文件夹</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AutoUploadPlugin = <span class="built_in">require</span>(<span class="string">&quot;../plugins/autoUploadPlugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlgin(),</span><br><span class="line">    <span class="keyword">new</span> AutoUploadPlugin(&#123;</span><br><span class="line">        host:<span class="string">&quot;xx.xx.xx.xx&quot;</span>,</span><br><span class="line">        username:<span class="string">&quot;root&quot;</span>,</span><br><span class="line">        password:<span class="string">&quot;xxxxxxx&quot;</span>,</span><br><span class="line">        remotePath:<span class="string">&quot;/test&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>AutoUploadPlugin.js<ul><li><p>借助node-ssh库完成远程系列操作</p><ol><li><code>npm i node-ssh</code></li></ol></li><li><p>Constructor</p><ol><li><p>生成ssh对象</p></li><li><p>接收options参数-</p></li></ol></li><li><p>每个Plugin都需要一个apply函数来注册插件</p><ol><li>通过compiler对象调用hooks注册事件</li><li>通过compilation对象获取打包输出文件夹路径</li><li>建立ssh连接</li><li>删除远程服务器中原本的内容</li><li>上传生成后的文件到服务器</li><li>关闭ssh连接</li><li>执行回调</li></ol></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; NodeSSH &#125; = <span class="built_in">require</span>(<span class="string">&quot;node-ssh&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoUploadPlugin</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.ssh = <span class="keyword">new</span> NodeSSH()</span><br><span class="line">        <span class="built_in">this</span>.options = options</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply (compiler) &#123;</span><br><span class="line">        <span class="comment">// 使用文件生成后的钩子</span></span><br><span class="line">        compiler.hooks.afterEmit.tapAsync(<span class="string">&quot;AutoUploadPlugin&quot;</span>, <span class="keyword">async</span> (compilation, callback) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 获取输出的文件夹路径</span></span><br><span class="line">            <span class="keyword">const</span> outputPath = compilation.outputOptions.path</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 连接服务器（ssh）</span></span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.connectServer()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 删除原来目录中的内容</span></span><br><span class="line">            <span class="keyword">const</span> serverDir = <span class="built_in">this</span>.options.remotePath</span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.ssh.execCommand(<span class="string">`rm -rf <span class="subst">$&#123;serverDir&#125;</span>/*`</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 上传文件到服务器</span></span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.uploadFiles(outputPath, serverDir)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 关闭SSH</span></span><br><span class="line">            <span class="built_in">this</span>.ssh.dispose();</span><br><span class="line"></span><br><span class="line">            callback()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> connectServer () &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">this</span>.ssh.connect(&#123;</span><br><span class="line">            host: <span class="built_in">this</span>.options.host,</span><br><span class="line">            username: <span class="built_in">this</span>.options.username,</span><br><span class="line">            password: <span class="built_in">this</span>.options.password</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> uploadFiles (localPath, remotePath) &#123;</span><br><span class="line">        <span class="keyword">const</span> status = <span class="keyword">await</span> <span class="built_in">this</span>.ssh.putDirectory(localPath, remotePath, &#123;</span><br><span class="line">            <span class="comment">// 递归上传所有文件</span></span><br><span class="line">            recursive: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 并发数</span></span><br><span class="line">            concurrency: <span class="number">10</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Upload &quot;</span> + status ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = AutoUploadPlugin</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6963822022434504734">掘金原文链接</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;br/&gt;&lt;a href=&quot;https://juejin.cn/post/6963822022434504734&quot;&gt;掘金原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>Webpack Loader知识分享</title>
    <link href="https://lebronchao.com/2021/05/18/Webpack%20Loader%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    <id>https://lebronchao.com/2021/05/18/Webpack%20Loader%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/</id>
    <published>2021-05-18T15:57:56.000Z</published>
    <updated>2021-05-18T15:57:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p></blockquote><h1>认识Loader</h1><blockquote><p>Loader可以用于对模块的源代码进行转换；</p><p>在加载这个模块时，webpack其实并不知道如何对其进行加载，我们必须定制对应的loader来完成这个功能。</p></blockquote><h2 id="loader配置方式">loader配置方式</h2><ul><li><p>内联方式：<code>import &quot;css-loader!../css/index.css&quot;</code>; loader和文件路径用！分隔</p></li><li><p>配置方式：webpack.config.js</p></li><li><p>配置方式表示的意思是在我们的webpack.config.js文件中写明配置信息</p><ul><li>module.rules中允许我们配置多个loader（因为我们也会继续使用其他Loader，来完成其他文件的加载）</li><li>这种方式可以更好地标识loader配置，也方便后期的维护，同时也让你对各个Loader有一个全局的概览；</li></ul></li><li><p>module.rules的配置如下</p></li><li><p>rules属性对应的值是一个数组：[Rule]</p></li><li><p>数组中存放的是一个个Rule，Rule是一个对象，对象中可以设置多个属性</p><ul><li>test属性：用于多resource（资源）文件名进行匹配，通常会设置成正则表达式；</li><li>use属性：对应的值是一个数组[useEntry]<ul><li>执行顺序从后往前，比如解析css，css-loader应在style-loader后面。</li><li>UseEntry是一个对象，可以通过对象的属性来设置一些其他属性<ul><li>loader：必须有一个loader属性，对应的值是一个字符串</li><li>options：可选的属性，值是一个字符串或者对象，值会被传入到loader中；</li><li>query：目前已被options替代</li></ul></li><li>传递字符串（如：use:[‘style-loader’]）是loader属性的简写（如：use:[{loader:‘style-loader’}]）</li></ul></li></ul></li></ul><h1>常见Loader</h1><h2 id="CSS-loader">CSS loader</h2><ul><li><p>我们可以将css文件也看成是一个模块，我们是通过import来加载这个模块的</p></li><li><p>那么需要一个什么样的loader呢</p><ul><li><p>对于加载css文件来说，我们需要一个可以读取css文件的loader</p></li><li><p>最常用的是css-loader</p></li><li><p>只负责解析css文件，不会作用于页面，此外还需要style-loader作用于页面</p><p><code>npm i style-loader --save</code></p></li></ul></li><li><p>css-loader的安装：</p><p><code>npm install css-loader --save</code></p></li><li><p>以下为一个css-loader的配置文件</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">//资源文件匹配正则表达式</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 简写：</span></span><br><span class="line">          <span class="comment">// “css-loader”</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>less同理</p><p><code>npm install less-loader less --save</code>安装这两个插件后</p></li><li><p>依次在use数组内写入style-loader、css-loader、less-loader</p></li></ul><h2 id="浏览器兼容性">浏览器兼容性</h2><ul><li><p>如果在css兼容性和js兼容性下共享我们的配置兼容性条件呢</p><ul><li>就是当我么们设置了一个条件：&gt;1% last 2 version Firefox、Chrome… not dead 都是可选项，多个选项以，分隔为 || 条件；and为&amp;&amp;关系；可用not条件</li><li>意思为js、css兼容市场占有率大于1%的Firefox、Chrome浏览器和最新的两个版本，并且24个月内有官方支持和更新的浏览器（dead过滤条件）</li></ul></li><li><p>在根目录.browserlistrc文件编写条件</p></li><li><p>通过可实现对市场占有比率的要去，版本要求等进行配置，适配浏览器</p></li><li><p>所用工具：</p><ul><li>数据来源：browserlist，浏览器市场占有率，精确到每个版本</li><li>处理插件：autoprefixer、babel、postcss-preset-env等</li></ul></li></ul><h2 id="认识PostCSS工具">认识PostCSS工具</h2><ul><li><p>什么是PostCSS工具呢？</p><ul><li>PostCSS是一个通过JavaScript来转换样式的工具</li><li>这个工具可以帮助我们进行一些CSS样式的转换和适配，比如自动添加浏览器前缀、css样式的充值；</li><li>但是实现这些功能，我们需要借助于PostCSS插件</li></ul></li><li><p>如何使用PostCSS</p></li></ul><ol><li>查找PostCSS在构建工具中的扩展，比如webpack中的postcss-loader；</li><li>选择可以添加你需要的PostCss相关插件</li></ol><h3 id="手动使用PostCSS">手动使用PostCSS</h3><blockquote><p>使用postcss-cli操作，需要用到autoprefixer插件</p></blockquote><ol><li><code>npm install postcss postcss-cli --save</code></li><li><code>npm install autoprefixer --save</code></li><li><code>npx postcss --use autoprefixer  -o '输出路径'   '输出路径' </code>，例如：<ol><li><code>npx postcss --use autoprefixer  -o ./src/css/result.css ./src/css/user.css</code></li></ol></li></ol><h3 id="Webpack配置文件使用PostCSS">Webpack配置文件使用PostCSS</h3><ol><li>安装postcss-loader和autoprefixer<ul><li><code>npm install postcss-loader autoprefixer --save</code></li></ul></li><li>编写配置文件<ul><li>css-loader处理前先用postcss-loader处理</li><li>在options的postcssOptions中，配置plugins，使用autoprefixer</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">//资源文件匹配正则表达式</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 简写：</span></span><br><span class="line">          <span class="comment">// “css-loader”</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              postcssOptions: &#123;</span><br><span class="line">                plugins: [<span class="built_in">require</span>(<span class="string">&quot;autoprefixer&quot;</span>)],</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="postcss-preset-env">postcss-preset-env</h3><ul><li><p>事实上，在配置postcss-loader时，我们配置插件并不需要使用autoprefixer。</p></li><li><p>我们可以使用另外一个插件:postcss-preset-env</p><ul><li><p>postcss-preset-env也是一个postcss的插件;</p></li><li><p>它可以帮助我们将一些现代的CSS特性，转成大多数浏览器认识的CSS，并且会根据目标浏览器或者运行时环 境添加所需的polyfill;</p><ul><li>例如八位的十六进制颜色会帮我们转换成RGBA</li></ul></li><li><p>也包括会自动帮助我们添加autoprefixer(所以相当于已经内置了autoprefixer);</p></li><li><p>首先，我们需要安装postcss-preset-env:</p><p><code>npm install postcss-preset-env --save</code></p></li><li><p>之后，我们直接修改掉之前的autoprefixer即可:</p></li></ul></li><li><p>配置简化</p><ul><li>在use中只写postcss-loader</li><li>在项目根目录建立postcss.config.js，写入配置</li></ul></li></ul><blockquote><p>webpack.config.js</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">//资源文件匹配正则表达式</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 简写：</span></span><br><span class="line">          <span class="comment">// “css-loader”</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;postcss-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>postcss.config.js</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">      <span class="comment">// 引入</span></span><br><span class="line">      <span class="comment">// require(&quot;postcss-preset-env&quot;)</span></span><br><span class="line">      <span class="comment">//简写</span></span><br><span class="line">      <span class="string">&quot;postcss-preset-env&quot;</span></span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="效果">效果</h3><blockquote><p>Before</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:fullscreen</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    user-select: none;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">2s</span> ease;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>After</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">:-webkit-full-screen&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:-ms-fullscreen&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:fullscreen</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">       -moz-user-select: none;</span><br><span class="line">        -ms-user-select: none;</span><br><span class="line">            user-select: none;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">2s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVzZXIuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUZBOztBQUVBOztBQUZBOztBQUVBOztBQUVBO0lBQ0kseUJBQWlCO09BQWpCLHNCQUFpQjtRQUFqQixxQkFBaUI7WUFBakIsaUJBQWlCO0lBQ2pCLHVCQUF1QjtBQUMzQiIsImZpbGUiOiJyZXN1bHQuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiOmZ1bGxzY3JlZW57XG5cbn1cblxuLmNvbnRlbnR7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgdHJhbnNpdGlvbjogYWxsIDJzIGVhc2U7XG59Il19 */</span></span><br></pre></td></tr></table></figure><h2 id="importLoaders">importLoaders</h2><ul><li><p>正常css文件解析遇到@import，不会再从use数组最后一个loader开始重新解析</p></li><li><p>通过设置importLoaders可以实现递归解析</p></li><li><p>填写的数字为在use数组中往后的loader的数量</p></li><li><p>例如：</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">//资源文件匹配正则表达式</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 简写：</span></span><br><span class="line">          <span class="comment">// “css-loader”</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;less-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="File-Loader">File Loader</h2><blockquote><p>希望解析、读取文件，例如图片</p></blockquote><ol><li>安装file-loader<ul><li><code>npm install --save file-loader</code></li></ul></li><li>编写配置文件</li></ol><blockquote><p>rule：</p></blockquote><ul><li>options解释：<ul><li>name:输出名称，[name]名称引用，.字符，[hash:6]哈希信息截取6位，[ext]后缀名</li><li>ouputPath:输出的文件夹，也可以在文件名前加 img/</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader:<span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">              name:<span class="string">&quot;[name].[hash:6].[ext]&quot;</span>,</span><br><span class="line">              outputPath:<span class="string">&quot;img&quot;</span></span><br><span class="line">              <span class="comment">// limit（url-loader）</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>和file-loader有同样功能的还有url-loader<ul><li>不同的是，它不是打包，而是把图片转为BASE64编码。</li><li>可以通过use对象的options下写入limit属性，限制大小，对小图片进行BASE4编码，减少请求数。</li></ul></li></ul><h2 id="Asset-module-type">Asset module type</h2><ul><li><p>我们当前使用的webpack版本是webpack5:</p><ul><li>在webpack5之前，加载这些资源我们需要使用一些loader，比如raw-loader 、url-loader、file-loader;</li><li>在webpack5之后，我们可以直接使用资源模块类型(asset module type)，来替代上面的这些loader;</li></ul></li><li><p>资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader:</p><ul><li>asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现;</li><li>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现;</li><li>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现;</li><li>asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源</li></ul></li><li><p>比如加载图片，我们可以使用下面的方式:</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打包图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// BASE64编码并限制大小</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/inline&quot;</span>,</span><br><span class="line">        parser: &#123;</span><br><span class="line">          dataUrlCondition: &#123;</span><br><span class="line">            maxSize: <span class="number">100</span> * <span class="number">1024</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 混合使用，限制大小，判断打包方式</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        parser: &#123;</span><br><span class="line">          dataUrlCondition: &#123;</span><br><span class="line">            maxSize: <span class="number">100</span> * <span class="number">1024</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>但是，如何可以自定义文件的输出路径和文件名呢?<ul><li>方式一:修改output，添加assetModuleFilename属性;</li><li>方式二:在Rule中，添加一个generator属性，并且设置filename;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一 ouput对象</span></span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    assetModuleFilename: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 方式二 rule对象（推荐）</span></span><br><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="加载字体文件">加载字体文件</h3><blockquote><p>rule对象：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.ttf|eot|woff2?$/i</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;font/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1>自定义Loader</h1><blockquote><p>Loader是用于对模块的源代码进行转换处理，之前已经使用过很多Loader，例如css-loader、style-loader、babel-loader等</p></blockquote><ul><li><p>Loader本质是一个导出为函数的JavaScript模块</p></li><li><p>Loader runner库会调用这个函数，然后将上一个loader产生的结果或者资源文件传入进去。</p></li><li><p>编写一个自定义Loader会接收三个参数</p><ul><li>content：资源文件参数</li><li>map：sourcemap相关数据</li><li>meta：一些元数据</li></ul></li><li><p>注：传入的路径是和content有关系的</p><ul><li>webpack.config.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    context: path.resolve(__dirname, <span class="string">&quot;../&quot;</span>),</span><br><span class="line">    entry: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">       path:path.resolve(__dirname,<span class="string">&quot;../build&quot;</span>),</span><br><span class="line">        filename:<span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&quot;./loaders/demoLoader.js&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果希望直接去加载loader文件夹，可以配置resoveLoader属性</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&quot;demoLoader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;,</span><br><span class="line">resolveLoader:&#123;</span><br><span class="line">    modules:[<span class="string">&quot;./loaders&quot;</span>, <span class="string">&quot;node_modules&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个Loader使用执行顺序<ul><li>从后向前，从右向左</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules:[</span><br><span class="line">    &#123;</span><br><span class="line">        test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&quot;demoLoader1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;demoLoader2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;demoLoader3&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210502234237127.png" alt="image.png"></p><h2 id="Pitch-Loader和enforce">Pitch-Loader和enforce</h2><blockquote><p>事实上还有另一种Loader，称之为PitchLoader</p></blockquote><ul><li><p>其实这也是为什么loader的执行顺序是相反的</p><ul><li>run-loader先优先执行PitchLoader，在执行PitchLoader时进行loaderIndex++；</li><li>run-loader之后会执行NormalLoader，在执行NormalLoader时进行loaderIndex–；</li></ul></li><li><p>那么，怎么改变他们的执行顺序?</p><ul><li>可以拆分成多个Rule对象，通过enforce来改变它们的顺序</li><li>enforce是rule对象的一个属性。</li></ul></li><li><p>enforce一共有四种方式</p><ul><li>默认所有loader都是normal</li><li>在行内设置的loader都是inline</li><li>也可以通过enforce设置pre和post</li></ul></li><li><p>在Pitch和Normal它们的执行顺序分别是</p><ul><li>post、inline、normal、pre</li><li>pre、normal、inline、post</li></ul></li></ul><h2 id="同步的Loader">同步的Loader</h2><ul><li><p>什么是同步loader?</p><ul><li>默认创建的Loader就是同步的Loader</li><li>这个Loader必须通过return或者this.callback来返回结果，交给下一个loader来处理</li><li>通常在有错误的情况下，会使用this.callback</li></ul></li><li><p>this.callback用法如下</p><ul><li>第一个参数为ERR或者null</li><li>第二个参数是string或者buffer</li><li>loader.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;loader&quot;</span>, content)</span><br><span class="line">    <span class="built_in">this</span>.callback(<span class="literal">null</span>,content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步的Loader">异步的Loader</h2><ul><li><p>什么是异步的Loader</p><ul><li>有时候使用Loader进行一些异步的操作</li><li>我们希望在异步操作完成之后，再返回这个loader处理的结果</li><li>这个时候就要使用异步的Loader了</li></ul></li><li><p>loader-runner已经在执行loader时给我们提供了方法，让loader变成一个异步的loader</p></li><li><p>loader.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="built_in">this</span>.async()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;async loader&quot;</span>,content)</span><br><span class="line">        callback(<span class="literal">null</span>, content)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传入和获取参数">传入和获取参数</h2><ul><li><p>在使用loader时传入参数，</p></li><li><p>可以通过webpack官方提供的一个解析库loader-utils</p><ul><li><code>npm i loader-utils</code></li></ul></li><li><p>webpack.config.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">    use:[</span><br><span class="line">        <span class="string">&quot;syncLoader&quot;</span>,</span><br><span class="line">        <span class="string">&quot;asyncLoader&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            loader:<span class="string">&quot;optionLoader&quot;</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                type:<span class="string">&quot;options&quot;</span>,</span><br><span class="line">                desc:<span class="string">&quot;demo&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>optionLoader.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; getOptions &#125;  = <span class="built_in">require</span>(<span class="string">&quot;loader-utils&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = getOptions(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;asyncLoader&quot;</span>,content, options)</span><br><span class="line">        callback(<span class="literal">null</span>, content)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  asyncLoader console.log(&quot;main.js&quot;) &#123; type: &#x27;options&#x27;, desc: &#x27;demo&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="参数校验">参数校验</h2><ul><li><p>可以通过wepack官方提供的校验库schema-utils</p><ul><li><code>npm i schema-utils</code></li></ul></li><li><p>schema.json（校验规则）</p></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;objcet&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;请输入正确的参数类型&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;描述必须为字符串类型&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;additionalProperties&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>loader.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; getOptions &#125;  = <span class="built_in">require</span>(<span class="string">&quot;loader-utils&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; validate &#125; = <span class="built_in">require</span>(<span class="string">&quot;schema-utils&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> loaderSchema = <span class="built_in">require</span>(<span class="string">&quot;../schema/schema.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = getOptions(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    validate(loaderSchema, options)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;asyncLoader&quot;</span>,content, options)</span><br><span class="line">        callback(<span class="literal">null</span>, content)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="babel-loader案例">babel-loader案例</h2><ul><li><p>我们知道babel-loader可以进行JS代码转换</p></li><li><p>接下来尝试定义一个自己的babel-loader</p></li><li><p>myBabelLoader.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; getOptions &#125;  = <span class="built_in">require</span>(<span class="string">&quot;loader-utils&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; validate &#125; = <span class="built_in">require</span>(<span class="string">&quot;schema-utils&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> babelSchema = <span class="built_in">require</span>(<span class="string">&quot;../schema/babel.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> option = getOptions(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    validate(babelSchema, option)</span><br><span class="line"></span><br><span class="line">    babel.transform(content, option, <span class="function">(<span class="params">err, res</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            callback(err)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            callback(<span class="literal">null</span>, res.code)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>babelSchema.json</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;array&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;additinalProperties&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>webapck.config.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">            use:[</span><br><span class="line">                <span class="string">&quot;syncLoader&quot;</span>,</span><br><span class="line">                <span class="string">&quot;asyncLoader&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader:<span class="string">&quot;optionLoader&quot;</span>,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        type:<span class="string">&quot;options&quot;</span>,</span><br><span class="line">                        desc:<span class="string">&quot;demo&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader:<span class="string">&quot;myBabelLoader&quot;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets:[<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="自定义md-loader">自定义md-loader</h2><ul><li><p>借助marked和highlight库实现markdownLoader</p><ul><li><code>npm i marked highlight.js</code></li></ul></li><li><p>webpack.config.js</p><ul><li>配置css加载和md加载规则</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules:[</span><br><span class="line">    &#123;</span><br><span class="line">      test:<span class="regexp">/\.css$/i</span>,</span><br><span class="line">      use:[</span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test:<span class="regexp">/\.md$/i</span>,</span><br><span class="line">      use:[<span class="string">&quot;mdLoader&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>mdLoader.js<ul><li>使用marked和highlight处理content，并返回模块化代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">&quot;marked&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> hljs = <span class="built_in">require</span>(<span class="string">&quot;highlight.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    marked.setOptions(&#123;</span><br><span class="line">        highlight:<span class="function"><span class="keyword">function</span> (<span class="params">code,lang</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hljs.highlight(lang, code).value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> htmlContent = marked(content)</span><br><span class="line">    <span class="keyword">const</span> innerContent = <span class="string">&quot;`&quot;</span> + htmlContent + <span class="string">&quot;`&quot;</span></span><br><span class="line">    <span class="keyword">const</span> moduleCode = <span class="string">`var code=<span class="subst">$&#123;innerContent&#125;</span>;export default code;`</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(moduleCode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> moduleCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>main.js<ul><li>同时引入css文件</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> md <span class="keyword">from</span> <span class="string">&quot;./index.md&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;highlight.js/styles/default.css&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;main.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ele = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>)</span><br><span class="line">ele.innerHTML = md;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ele)</span><br></pre></td></tr></table></figure><ul><li>效果</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210502234524690.png" alt="image-20210502234524690"></p><ul><li><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p></li><li><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p></li><li><p>持续分享技术博文，关注微信公众号👇🏻</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;br/&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;认识Loader&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Loader可以用于对模块的源代码进行转换；&lt;/p</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Loader" scheme="https://lebronchao.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>初识Webpack</title>
    <link href="https://lebronchao.com/2021/05/12/%E5%88%9D%E8%AF%86Webpack/"/>
    <id>https://lebronchao.com/2021/05/12/%E5%88%9D%E8%AF%86Webpack/</id>
    <published>2021-05-11T16:53:03.000Z</published>
    <updated>2021-05-11T16:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！</p><p>如果觉得文章不错，欢迎关注、点赞和分享！</p></blockquote><h1>Webpack初体验</h1><h2 id="用Webpack解决什么问题">用Webpack解决什么问题</h2><ol><li>模块化</li><li>高级特性、开发效率、安全性<ul><li>ES6+、Typescript、sacc、less</li></ul></li><li>监听文件变化并反映到浏览器上，提高开发效率</li><li>开发完成后的打包，压缩、合并、tree-shaking等以及其他相关的优化</li></ol><h2 id="Webpack是什么">Webpack是什么</h2><ul><li><p>Webpck是一个静态的模块化打包工具，为现代的JS应用程序</p></li><li><p>我们来对上面的解释进行拆解：</p><ul><li>打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具。</li><li>静态的static：这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）</li><li>模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等</li><li>现代的modern：现代前端开发面临各种各样的问题，才催生了webpack的出现和发展</li></ul></li></ul><h2 id="Webpack和Vite">Webpack和Vite</h2><blockquote><p>Webpack会被Vite取代吗？</p></blockquote><ol><li>vite推出后确实引起了很多的反响，也有很多人看好vite的发展</li><li>但是目前vite取代webpack还有很长的路要走<ul><li>目前vue项目支持使用vite，也支持使用webpack</li><li>vite最终打包的过程，依然需要借助于rollup完成</li></ul></li><li>vite核心思想并不是首创<ul><li>事实上，vite的思想和之前的snowpack是重合的，而且相对目前来说snowpack会更加成熟</li><li>当然，后续发展来看vite可能会超越snowpack</li></ul></li><li>webpack的更新迭代<ul><li>webpack在发展工程中，也会不断改进自己，借鉴其他工具的一些优势和思想</li><li>在这么多年的发展中，无论是自身的优势还是生态都是非常强大的。</li></ul></li></ol><blockquote><p>关于Vite的思考</p></blockquote><ol><li><p>学习任何的东西，重要的是学习核心思想</p><ul><li>学习了JS学TS不是从0开始</li><li>学习了Vue，学React也不是从0开始</li></ul></li><li><p>任何工具的出现，都是更好地服务于我们开发</p><ul><li><p>无论是vite的出现，还是以后新的工具出现，不要有任何排斥的思想；</p></li><li><p>我们要深刻地明白，工具都是为了更好地给我们提供服务</p></li><li><p>不可能出现了某个工具，让我们的开发效率变得更低，而这个工具却可以变得非常流行，这是不存在的</p></li></ul></li></ol><h1>Webpack默认打包</h1><ul><li><p>我们可以通过webpack进行打包，之后运行打包之后的代码</p><ul><li><p>在目录下直接执行webpack命令</p><p><code>webpack</code></p></li><li><p>直接在终端执行webpack可能本机安装版本和项目版本不同，所以在package.json中定义命令例如：“build”:“webpack”，这样就会根据package.json中的webpack版本进行打包（前提是已install）。</p></li></ul></li><li><p>生成一个dist文件夹，里面存放一个main.js文件，就是打包之后的文件</p><ul><li>这个文件中的代码被压缩和丑化了</li><li>暂时不关心他是如何做到的，后续我讲webpack实现模块化原理时会再次讲到。</li><li>另外发现代码中依然存在ES6的语法，比如箭头函数、const等，这是因为默认情况下webpack并不清楚我们打包后的文件是否需要转成ES5之前的语法，后续我们需要通过babel来进行转换和设置；</li></ul></li><li><p>发现可以正常进行打包的，但是有一个问题，webpack是如何确地入口的？</p><ul><li>事实上，我们运行webpack时，webpack会查找到当前目录下的src/index.js作为入口</li><li>所以，如果当前项目中没有src/index.js，那么会报错</li></ul></li><li><p>当然也可以通过配置来指定入口和出口，例如(通常写配置文件)</p><p><code>npx webpack --entry ./src/main.js --output-path ./build</code></p></li></ul><h1>Webpack配置文件</h1><ul><li><p>通常情况下，webpack需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然是不可以的。</p></li><li><p>我们可以在根目录下创建一个webpack.config.js文件，来作为webpack的配置文件,例如</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>继续执行webpack命令，依然可以正常打包</p></li><li><p>也可以不使用webpack.config.js作为文件名，使用命令定义路径和文件名即可，例如</p></li><li><p><code>webpack --config  ./wk.congfig.js</code></p></li></ul><h1>Webpack依赖图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null).png" alt="img"></p><blockquote><p>webpack到底是如何对我们的项目进行打包的呢？</p></blockquote><ul><li><p>事实上webpack在处理应用程序的时候，它会根据命令或者配置文件找到入门文件；</p></li><li><p>从入口开始，会生成一个依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块（比如js文件、css文件、字体等）</p></li><li><p>然后遍历图结构，打包一个个模块（根据文件的不同使用不同的loader解析）</p></li></ul><h1>Mode配置</h1><ul><li><p>Mode配置选项，可以告知webpack使用响应模式的内置优化:</p></li><li><p>默认值是production(什么都不设置的情况下);</p></li><li><p>可选值有:‘none’ | ‘development’ | ‘production’;</p></li><li><p>这几个选项有什么样的区别呢?</p></li></ul><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>developtment</code></td><td>会将<code>DefinePlugin</code>中<code>process.env.NODE_ENV</code>的值设置为``developtment`，为模块和chunk启用有效的名</td></tr><tr><td><code>production</code></td><td>会将``DefinePlugin<code>中</code>process.env.NODE_ENV<code>的值设置为</code>production<code>。为模块和chunk启用确定性的混淆名称，</code>FlagDependencyUsagePlugin<code>，</code>FlagInlcudeedChunkPlugin<code>，</code>ModuleConcatenationPlugin<code>，</code>NoEmitOnErrorsPlugin<code>和</code>TerserPlugin`</td></tr><tr><td><code>none</code></td><td>不使用任何默认优化选项</td></tr></tbody></table><blockquote><p>Mode配置代表配置了更多</p></blockquote><ul><li>绿色选项 = 所有红色选项</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210502174148481.(null)" alt="img"></p><h1>Webpack核心流程</h1><blockquote><p>引用于[<a href="https://juejin.cn/post/6949040393165996040">万字总结] 一文吃透 Webpack 核心原理</a></p></blockquote><p>这个过程核心完成了 <strong>内容转换 + 资源合并</strong> 两种功能，实现上包含三个阶段：</p><ul><li><p>初始化阶段：</p><ol><li><strong>初始化参数</strong>：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li><li><strong>创建编译器对象</strong>：用上一步得到的参数创建 Compiler 对象</li><li><strong>初始化编译环境</strong>：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li><li><strong>开始编译</strong>：执行 compiler 对象的 run 方法</li><li><strong>确定入口</strong>：根据配置中的 entry 找出所有的入口文件，调用 compilition.addEntry 将入口文件转换为 dependence 对象</li></ol></li><li><p>构建阶段：</p><ol><li><strong>编译模块(make)</strong>：根据 entry 对应的 dependence 创建 module 对象，调用 loader 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><strong>完成模块编译</strong>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 <strong>依赖关系图</strong></li></ol></li><li><p>生成阶段：</p><ol><li><strong>输出资源(seal)</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><strong>写入文件系统(emitAssets)</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol></li></ul><blockquote><p>单次构建过程自上而下按顺序执行，下面会展开聊聊细节，在此之前，对上述提及的各类技术名词不太熟悉的同学，可以先看看简介：</p></blockquote><ul><li><p><code>Entry</code>：编译入口，webpack 编译的起点</p></li><li><p><code>Compiler</code>：编译管理器，webpack 启动后会创建 compiler 对象，该对象一直存活知道结束退出</p></li><li><p><code>Compilation</code>：单次编辑过程的管理器，比如<code>watch = true</code> 时，运行过程中只有一个 <code>compiler </code>但每次文件变更触发重新编译时，都会创建一个新的 <code>compilation</code> 对象</p></li><li><p><code>Dependence</code>：依赖对象，webpack 基于该类型记录模块间依赖关系</p></li><li><p><code>Module</code>：webpack 内部所有资源都会以“module”对象形式存在，所有关于资源的操作、转译、合并都是以 “module” 为基本单位进行的</p></li><li><p><code>Chunk</code>：编译完成准备输出时，webpack 会将 <code>module</code> 按特定的规则组织成一个一个的 <code>chunk</code>，这些 <code>chunk</code> 某种程度上跟最终输出一一对应</p></li><li><p><code>Loader</code>：资源内容转换器，其实就是实现从内容 A 转换 B 的转换器</p></li><li><p><code>Plugin</code>：webpack构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程</p></li></ul><p>webpack 编译过程都是围绕着这些关键对象展开的，更详细完整的信息，可以参考 <a href="https://juejin.cn/post/6948763207397965855">Webpack 知识图谱</a> 。</p><h1>Webpack和Gulp</h1><ul><li><p>gulp的核心理念是task runner</p><ul><li>可以定义自己的一系列任务，等待任务被执行;</li><li>基于文件Stream的构建流; p我们可以使用gulp的插件体系来完成某些任务;</li></ul></li><li><p>webpack的核心理念是module bundler pwebpack是一个模块化的打包工具;</p><ul><li>可以使用各种各样的loader来加载不同的模块;</li><li>可以使用各种各样的插件在webpack打包的生命周期完成其他的任务;</li></ul></li><li><p>gulp相对于webpack的优缺点:</p><ul><li>gulp相对于webpack思想更加的简单、易用，更适合编写一些自动化的任务;</li><li>但是目前对于大型项目（Vue、React、Angular）并不会使用gulp来构建，比如默认gulp是不支持模块化的。</li></ul></li></ul><h1>优质文章推荐：</h1><ol><li>[<a href="https://juejin.cn/post/6949040393165996040">万字总结] 一文吃透 Webpack 核心原理</a></li><li>[<a href="https://juejin.cn/post/6955421936373465118">源码解读] Webpack 插件架构深度讲解</a></li><li><a href="https://juejin.cn/post/6955878306981871623">十分钟精进 Webpack：module.issuer 属性详解</a></li><li><a href="https://juejin.cn/post/6958811421224206343">有点难的 webpack 知识点：Dependency Graph 深度解析</a></li><li><a href="https://juejin.cn/post/6960472347329429511">分享几个 Webpack 实用分析工具</a></li><li><a href="https://juejin.cn/post/6948763207397965855">分享一份 Webpack 知识图谱</a></li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写作不易，未经作者允许禁止以任何形式转载！&lt;/p&gt;
&lt;p&gt;如果觉得文章不错，欢迎关注、点赞和分享！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Webpack初体验&lt;/h1&gt;
&lt;h2 id=&quot;用Webpack解决什么问题&quot;&gt;用Webpack解决什么</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="https://lebronchao.com/tags/Webpack/"/>
    
    <category term="打包构建" scheme="https://lebronchao.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"/>
    
    <category term="前端" scheme="https://lebronchao.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://lebronchao.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>摄影 | 湾区之光</title>
    <link href="https://lebronchao.com/2021/04/06/%E6%91%84%E5%BD%B1-%E6%B9%BE%E5%8C%BA%E4%B9%8B%E5%85%89/"/>
    <id>https://lebronchao.com/2021/04/06/%E6%91%84%E5%BD%B1-%E6%B9%BE%E5%8C%BA%E4%B9%8B%E5%85%89/</id>
    <published>2021-04-05T17:20:12.000Z</published>
    <updated>2021-04-05T17:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 24-70GM<br>出镜：无<br>地点：华侨城·欢乐港湾</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09976.JPG" alt="DSC09976"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09985.JPG" alt="DSC09985"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00001.JPG" alt="DSC00001"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00006.JPG" alt="DSC00006"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00028.JPG" alt="DSC00028"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00033.JPG" alt="DSC00033"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00044.JPG" alt="DSC00044"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00003.JPG" alt="DSC00003"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09997.JPG" alt="DSC09997"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09978.JPG" alt="DSC09978"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09987.JPG" alt="DSC09987"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00083.JPG" alt="DSC00083"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00150.JPG" alt="DSC00150"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00155.JPG" alt="DSC00155"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00161.JPG" alt="DSC00161"></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机身：SONY A7M2&lt;br&gt;
镜头：SONY 24-70GM&lt;br&gt;
出镜：无&lt;br&gt;
地点：华侨城·欢乐港湾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;note info simple&quot;&gt;&lt;p&gt;点击可看大图&lt;/p&gt;
&lt;/di</summary>
      
    
    
    
    <category term="摄影" scheme="https://lebronchao.com/categories/%E6%91%84%E5%BD%B1/"/>
    
    
    <category term="摄影" scheme="https://lebronchao.com/tags/%E6%91%84%E5%BD%B1/"/>
    
    <category term="风光" scheme="https://lebronchao.com/tags/%E9%A3%8E%E5%85%89/"/>
    
    <category term="摩天轮" scheme="https://lebronchao.com/tags/%E6%91%A9%E5%A4%A9%E8%BD%AE/"/>
    
    <category term="欢乐港湾" scheme="https://lebronchao.com/tags/%E6%AC%A2%E4%B9%90%E6%B8%AF%E6%B9%BE/"/>
    
  </entry>
  
  <entry>
    <title>Vue进阶 Diff算法详解 |  学习笔记</title>
    <link href="https://lebronchao.com/2021/03/24/Vue%E8%BF%9B%E9%98%B6-Diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://lebronchao.com/2021/03/24/Vue%E8%BF%9B%E9%98%B6-Diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-24T15:42:55.000Z</published>
    <updated>2021-03-24T15:42:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、虚拟DOM</h1><blockquote><p>什么是虚拟DOM？</p></blockquote><p>虚拟DOM就是把真实DOM树的结构和信息抽象出来，以对象的形式模拟树形结构，如下：</p><p>真实DOM:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的虚拟DOM就是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode = &#123;</span><br><span class="line">    tag: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    children:[ &#123;<span class="attr">tag</span>:<span class="string">&#x27;p&#x27;</span>, <span class="attr">text</span>:<span class="string">&#x27;Hello World&#x27;</span>&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么需要虚拟DOM？</p></blockquote><p>渲染真实DOM会有一定的开销，如果每次修改数据都进行真实DOM渲染，都会引起DOM树的重绘和重排，性能开销很大。那么有没有可能只修改一小部分数据而不渲染整个DOM呢？虚拟DOM和Diff算法可以实现。</p><blockquote><p>怎么实现？</p></blockquote><ol><li>先根据真实DOM生成一颗虚拟DOM树</li><li>当某个DOM节点数据发生改变时，生成一个新的Vnode</li><li>新的Vnode和旧的oldVnode进行对比</li><li>通过patch函数一边比对一边给真实DOM打补丁或者创建Vnode、移除oldVnode等</li></ol><blockquote><p>有什么不一样？</p></blockquote><ol><li>真实DOM操作为一个属性一个属性去修改，开销较大。</li><li>虚拟DOM直接修改整个DOM节点再替换真实DOM</li></ol><blockquote><p>还有什么好处？</p></blockquote><p>Vue的虚拟DOM数据更新机制是<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97">异步更新队列</a>，并不是数据变更马上更新DOM，而是被推进一个数据更新异步队列统一更新。想要马上拿到DOM更新后DOM信息？有个API叫 <a href="https://cn.vuejs.org/v2/api/">Vue.nextTick</a></p><h1>二、 Diff算法</h1><h2 id="传统Diff算法">传统Diff算法</h2><blockquote><p>遍历两棵树中的每一个节点，每两个节点之间都要做一次比较。</p></blockquote><blockquote><p>比如 a-&gt;e 、a-&gt;d 、a-&gt;b、a-&gt;c、a-&gt;a</p></blockquote><ul><li>遍历完成的时间复杂度达到了O(n^2)</li><li>对比完差异后还要计算最小转换方式，实现后复杂度来到了O(n^3)</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210326001324690.png" alt="img"></p><h2 id="Vue优化的Diff算法">Vue优化的Diff算法</h2><blockquote><p>Vue的diff算法只会比较同层级的元素，不进行跨层级比较</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210324234529318-20210326001327579.(null)" alt="img"></p><h1>三、 Vue中的Diff算法实现</h1><h2 id="Vnode分类">Vnode分类</h2><ul><li>EmptyVNode: 没有内容的注释节点</li><li>TextVNode: 文本节点</li><li>ElementVNode: 普通元素节点</li><li>ComponentVNode: 组件节点</li><li>CloneVNode: 克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true</li></ul><h2 id="Patch函数">Patch函数</h2><blockquote><p>patch函数接收以下参数：</p></blockquote><ol><li>oldVnode：旧的虚拟节点</li><li>Vnode：新的虚拟节点</li><li>hydrating：是否要和真实DOM混合</li><li>removeOnly：特殊的flag，用于 transition-group</li></ol><blockquote><p>处理流程大致分为以下步骤：</p></blockquote><ol><li>vnode不存在，oldVnode存在时，移除oldVnode</li><li>vnode存在，oldVnode不存在时，创建vnode</li><li>vnode和oldVnode都存在时<ol><li>如果vnode和oldVnode是同一个节点（通过sameVnode函数对比  后续详解），通过patchVnode进行后续比对工作</li><li>如果vnode和oldVnode不是同一个节点，那么根据vnode创建新的元素并挂载至oldVnode父元素下。如果组件根节点被替换，遍历更新父节点element。然后移除旧节点。如果oldVnode是服务端渲染元素节点，需要用hydrate函数将虚拟dom和真是dom进行映射</li></ol></li></ol><blockquote><p>源码如下，已写好注释便于阅读</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果vnode不存在，但是oldVnode存在，移除oldVnode</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果oldVnode不存在，但是vnode存在时，创建vnode</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 剩余情况为vnode和oldVnode都存在</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否为真实DOM元素</span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// 如果vnode和oldVnode是同一个（通过sameVnode函数进行比对  后续详解）</span></span><br><span class="line">        <span class="comment">// 受用patchVnode函数进行后续比对工作 （函数后续详解）</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// vnode和oldVnode不是同一个的情况</span></span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">          <span class="comment">// 如果存在真实的节点，存在data-server-render属性</span></span><br><span class="line">          <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            <span class="comment">// 当旧的Vnode是服务端渲染元素，hydrating记为true</span></span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 需要用hydrate函数将虚拟DOM和真实DOM进行映射</span></span><br><span class="line">          <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">            <span class="comment">// 需要合并到真实DOM上</span></span><br><span class="line">            <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              <span class="comment">// 调用insert钩子</span></span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">              <span class="keyword">return</span> oldVnode</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                <span class="string">&#x27;The client-side rendered virtual DOM tree is not matching &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;server-rendered content. This is likely caused by incorrect &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;HTML markup, for example nesting block-level elements inside &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;full client-side render.&#x27;</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果不是服务端渲染元素或者合并到真实DOM失败，则创建一个空的Vnode节点去替换它</span></span><br><span class="line">          oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取oldVnode父节点</span></span><br><span class="line">        <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">        <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据vnode创建一个真实DOM节点并挂载至oldVnode的父节点下</span></span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果组件根节点被替换，遍历更新父节点Element</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">          <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">          <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">          <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm = vnode.elm</span><br><span class="line">            <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// #6513</span></span><br><span class="line">              <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">              <span class="comment">// e.g. for directives that uses the &quot;inserted&quot; hook.</span></span><br><span class="line">              <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">              <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">                <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor = ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁旧节点</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">          <span class="comment">// 移除老节点</span></span><br><span class="line">          removeVnodes(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          <span class="comment">// 调用destroy钩子</span></span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用insert钩子并返回节点</span></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="sameVnode函数">sameVnode函数</h2><blockquote><p>Vue怎么判断是不是同一个节点？流程如下：</p></blockquote><ol><li>判断Key值是否一样</li><li>tag的值是否一样</li><li>isComment，这个不用太关注。</li><li>数据一样</li><li>sameInputType()，专门对表单输入项进行判断的：input一样但是里面的type不一样算不同的inputType</li></ol><blockquote><p>从这里可以看出key对diff算法的辅助作用，可以快速定位是否为同一个元素，必须保证唯一性。</p></blockquote><blockquote><p>如果你用的是index作为key，每次打乱顺序key都会改变，导致这种判断失效，降低了Diff的效率。</p></blockquote><blockquote><p>因此，用好key也是Vue性能优化的一种方式。</p></blockquote><ul><li>源码如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="patchVnode函数">patchVnode函数</h2><blockquote><p>前置条件vnode和oldVnode是同一个节点</p></blockquote><blockquote><p>执行流程：</p></blockquote><ol><li>如果oldVnode和vnode引用一致，可以认为没有变化，return</li><li>如果oldVnode的isAsyncPlaceholder属性为true，跳过检查异步组件，return</li><li>如果oldVnode跟vnode都是静态节点，且具有相同的key，同时vnode是克隆节点或者v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上，也不用再有其他操作，return</li><li>如果vnode不是文本节或注释节点<ol><li>如果vnode和oldVnode都有子节点并且两者子节点不一致时，就调用updateChildren更新子节点</li><li>如果只有vnode有自子节点，则调用addVnodes创建子节点</li><li>如果只有oldVnode有子节点，则调用removeVnodes把这些子节点都删除</li><li>如果vnode文本为undefined，则清空vnode.elm文本</li></ol></li><li>如果vnode是文本节点但是和oldVnode文本内容不同，只需更新文本。</li></ol><blockquote><p>源代码如下，已写好注释便于阅读</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新老节点引用一致，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果oldVnode的isAsyncPlaceholder属性为true，跳过检查异步组件</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode.isAsyncPlaceholder = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新旧都是静态节点，vnode的key也相同</span></span><br><span class="line">    <span class="comment">// 新vnode是克隆所得或新vnode有 v-once属性</span></span><br><span class="line">    <span class="comment">// 则进行赋值，然后返回。vnode的componentInstance 保持不变</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">      isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">      vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="comment">// 执行data.hook.prepatch 钩子</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取子元素列表</span></span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      <span class="comment">// 遍历调用 cbs.update 钩子函数，更新oldVnode所有属性</span></span><br><span class="line">      <span class="comment">// 包括attrs、class、domProps、events、style、ref、directives</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      <span class="comment">// 执行data.hook.update 钩子</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Vnode 的 text选项为undefined</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">//新老节点的children不同，执行updateChildren方法</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// oldVnode children不存在 执行 addVnodes方法</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        <span class="comment">// vnode不存在执行removeVnodes方法</span></span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        <span class="comment">// 新旧节点都是undefined，且老节点存在text，清空文本。</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">      <span class="comment">// 新老节点文本内容不同，更新文本</span></span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">      <span class="comment">// 执行data.hook.postpatch钩子，至此 patch完成</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="updateChildren函数">updateChildren函数</h2><blockquote><p>重点！！！</p></blockquote><blockquote><p>前置条件：vnode和oldVnode的children不相等</p></blockquote><blockquote><p>整体的执行思路如下：</p></blockquote><ol><li><p>vnode头对比oldVnode头</p></li><li><p>vnode尾对比oldVnode尾</p></li><li><p>vnode头对比oldVnode尾</p></li><li><p>vnode尾对比oldVnode头</p><ul><li>只要符合一种情况就进行patch，移动节点，移动下标等操作</li></ul></li><li><p>都不对再在oldChild中找一个key和newStart相同的节点</p><ul><li><p>找不到，新建一个。</p></li><li><p>找到，获取这个节点，判断它和newStartVnode是不是同一个节点</p><ul><li>如果是相同节点，进行patch  然后将这个节点插入到oldStart之前，newStart下标继续移动</li><li>如果不是相同节点，需要执行createElm创建新元素</li></ul></li></ul></li></ol><blockquote><p>为什么会有头对尾、尾对头的操作？</p></blockquote><ul><li>可以快速检测出reverse操作，加快diff效率。</li></ul><blockquote><p>源码如下   已写好注释便于阅读：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义变量</span></span><br><span class="line">   <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>  <span class="comment">// 老节点Child头下标</span></span><br><span class="line">   <span class="keyword">let</span> newStartIdx = <span class="number">0</span>  <span class="comment">// 新节点Child头下标</span></span><br><span class="line">   <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>  <span class="comment">// 老节点Child尾下标</span></span><br><span class="line">   <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]      <span class="comment">// 老节点Child头结点</span></span><br><span class="line">   <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// 老节点Child尾结点</span></span><br><span class="line">   <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span>   <span class="comment">// 新节点Child尾下标</span></span><br><span class="line">   <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]       <span class="comment">// 新节点Child头结点</span></span><br><span class="line">   <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]  <span class="comment">// 新节点Child尾结点</span></span><br><span class="line">   <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">   <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">   <span class="comment">// during leaving transitions</span></span><br><span class="line">   <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">     checkDuplicateKeys(newCh)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义循环</span></span><br><span class="line">   <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">     <span class="comment">// 存在检测</span></span><br><span class="line">     <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果老结点Child头和新节点Child头是同一个节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">       <span class="comment">// patch差异</span></span><br><span class="line">       patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">       <span class="comment">// patch完成  移动节点位置  继续比对下一个节点</span></span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果老结点Child尾和新节点Child尾是同一个节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">       <span class="comment">// patch差异</span></span><br><span class="line">       patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">       <span class="comment">// patch完成  移动节点位置 继续比对下一个节点</span></span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">       newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果老结点Child头和新节点Child尾是同一个节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        <span class="comment">// patch差异</span></span><br><span class="line">       patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">       <span class="comment">// 把oldStart节点放到oldEnd节点后面</span></span><br><span class="line">       canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">       <span class="comment">// patch完成  移动节点位置 继续比对下一个节点</span></span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">       newEndVnode = newCh[--newEndIdx]</span><br><span class="line">     <span class="comment">// 如果老结点Child尾和新节点Child头是同一个节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        <span class="comment">// patch差异</span></span><br><span class="line">       patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">       <span class="comment">// 把oldEnd节点放到oldStart节点前面</span></span><br><span class="line">       canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">       <span class="comment">// patch完成  移动节点位置 继续比对下一个节点</span></span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 如果没有相同的Key，执行createElm方法创建元素</span></span><br><span class="line">       <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">       idxInOld = isDef(newStartVnode.key) ?</span><br><span class="line">         oldKeyToIdx[newStartVnode.key] :</span><br><span class="line">         findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">       <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">         createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 有相同的Key，判断这两个节点是否为sameNode</span></span><br><span class="line">         vnodeToMove = oldCh[idxInOld]</span><br><span class="line">         <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">           <span class="comment">// 如果是相同节点，进行patch  然后举将oldStart插入到oldStart之前，newStart下标继续移动</span></span><br><span class="line">           patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">           oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">           canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果不是相同节点，需要执行createElm创建新元素</span></span><br><span class="line">           createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// oldStartIdx &gt; oldEndIdx说明oldChild先遍历完，使用addVnode方法添加newStartIdx指向的节点到newEndIdx的节点</span></span><br><span class="line">   <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">     refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">     addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">     <span class="comment">// 如果newStartIdx &gt; newEndIdx说明newChild先遍历完，remove掉oldChild未遍历完的节点</span></span><br><span class="line">     removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1>四、总结</h1><ol><li>正确使用key，可以快速执行sameVnode比对，加速Diff效率，可以作为性能优化的一个点。</li><li>DIff只做同级比较，使用sameVnode函数比对，文本节点直接替换文本内容。</li><li>子元素列表的Diff，进行头对头、尾对尾、头对尾等系列比较，直到遍历完两个元素的子元素列表。<ul><li>或一个列表先遍历完了，直接addVnode / removeVnode。</li></ul></li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、虚拟DOM&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是虚拟DOM？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虚拟DOM就是把真实DOM树的结构和信息抽象出来，以对象的形式模拟树形结构，如下：&lt;/p&gt;
&lt;p&gt;真实DOM:&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="Vue" scheme="https://lebronchao.com/tags/Vue/"/>
    
    <category term="Diff 算法" scheme="https://lebronchao.com/tags/Diff-%E7%AE%97%E6%B3%95/"/>
    
    <category term="虚拟DOM" scheme="https://lebronchao.com/tags/%E8%99%9A%E6%8B%9FDOM/"/>
    
  </entry>
  
  <entry>
    <title>浅析HTTP缓存</title>
    <link href="https://lebronchao.com/2021/03/20/%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98/"/>
    <id>https://lebronchao.com/2021/03/20/%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98/</id>
    <published>2021-03-20T03:38:49.000Z</published>
    <updated>2021-03-20T03:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1>为什么需要缓存</h1><ul><li>通过缓存机制，可以在相应场景下复用以前获取的资源。</li><li>显著提高网站的性能和响应速度</li><li>减少网络流量和等待渲染时间</li><li>降低服务器压力</li></ul><h1>HTTP缓存类型</h1><ul><li>强缓存</li><li>协商缓存</li></ul><h1>强缓存</h1><p>对于强缓存，服务器返回的静态资源响应头会设置一个强制缓存的时间，在缓存时间内，如刷新浏览器请求相同资源，在缓存时间未过期的情况下，则直接使用已缓存资源。如缓存资源已过期，执行协商缓存策略。</p><ul><li>以下为与强缓存相关的HTTP头部字段</li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>用途</strong></th><th>实例</th><th><strong>优先级</strong></th><th><strong>HTTP版本</strong></th></tr></thead><tbody><tr><td>Expires</td><td>强缓存的过期日期</td><td>Expires:Thu,06 Aug 2021 14:36:18 GMT</td><td>低</td><td>1.0</td></tr><tr><td>Cache-Control</td><td>指定指令实现缓存机制</td><td>Cache-Control:max-age=60</td><td>高</td><td>1.1</td></tr></tbody></table><h2 id="Expires">Expires</h2><ul><li>响应头Expires字段包含强缓存资源的过期时间</li><li>值为0表示资源已过期或非强缓存</li></ul><h2 id="Cache-Control">Cache-Control</h2><p>通用消息头字段，通过指令来实现缓存机制。说明一下容易弄混的两个字段，其他指令参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">指令大全</a>。</p><ul><li>no-cache</li></ul><p>在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</p><ul><li>no-store</li></ul><p>缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</p><h2 id="Expires-和-Cache-Control-的区别">Expires 和 Cache-Control 的区别</h2><ul><li>时间区别<ul><li>Expires 过期时间为绝对时间，指未来某个时间点缓存过期。</li><li>Cache-Control 为相对时间，相对于当前时间，如 60s 后缓存过期</li></ul></li><li>优先级<ul><li>Expires 的优先级低于 Cache-Control 字段</li><li>同时存在 Cache-Control 和 Expires时，以 Cache-Control 指令为准</li></ul></li><li>HTTP 版本<ul><li>Expires 是HTTP/1.0 提出的，其浏览器兼容性更好</li><li>Cache-Control 是 HTTP/1.1 提出的，浏览器兼容性不佳，所以 Expires 和 Cache-Control 可以同时存在，在不支持 Cache-Control的浏览器则以Expires为准</li></ul></li></ul><h1>协商缓存</h1><ul><li>协商缓存即和服务器协商是否使用缓存，通过判断后决定重新加载资源 or HTTP StatusCode 304</li><li>以下字段决定是否使用协商缓存，而非强缓存：</li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>协商缓存</strong></th><th><strong>优先级</strong></th></tr></thead><tbody><tr><td>Pragma</td><td>Pragma:no-cache</td><td>高</td></tr><tr><td>Cache-Control</td><td>Cache-Control:no-cache / Cache-Control:max-age=0</td><td>低</td></tr></tbody></table><h2 id="Pragma">Pragma</h2><ul><li>Pragma是一个HTTP1.0中规定的通用首部，如果 Cache-Control不存在的话，它的行为与 Cache-Control: no-cache 一致。强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行协商验证。</li><li>Pragma的值就只有一个，no-cache，并且它的优先级比Cache-Control高。</li></ul><h2 id="Cache-Control-2">Cache-Control</h2><ul><li>上文介绍过Cache-Control，它的指令既可以用于强缓存又可应用于协商缓存策略中</li><li>其中Cache-Control: no-cache 和 Cache-Control: max-age=0 的作用一样，强制要求发起请求给服务器进行验证 (协商资源验证)。</li></ul><h1>协商策略</h1><p>当出现Pragma字段或者Cache-Control:no-cache时，就需要使用协商策略，常见的两对协商缓存字段如下</p><ul><li>ETag/If-None-Match</li><li>Last-Modified/If-Modfied-Since</li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>对应字段</strong></th><th><strong>值</strong></th><th><strong>描述</strong></th><th><strong>优先级</strong></th></tr></thead><tbody><tr><td>Last-Modified</td><td>If-Modified-Since</td><td>GMT时间</td><td>服务端资源的最后修改时间</td><td>低</td></tr><tr><td>If-Modified-Since</td><td>Last-Modified</td><td>GMT时间</td><td>上次请求响应头的Last-Modified，验证是否为服务端资源最后修改的时间，是返回304，否返回200。</td><td>低</td></tr><tr><td>Etag</td><td>If-None-Match</td><td>内容hash/文件信息</td><td>服务器缓存资源的文件信息或文件内容生成的哈希值</td><td>高</td></tr><tr><td>If-None-Match</td><td>Etag</td><td>内容hash/文件信息</td><td>上次请求响应头的ETag，验证服务器资源有没有修改，有返回200，没有返回304。</td><td>高</td></tr></tbody></table><h2 id="优缺点">优缺点</h2><ul><li>如果服务端修改了一段代码，然后又改回去了。<ul><li>此时资源文件的修改时间变了</li><li>实际上文件没有发生改变</li><li>这样缓存就失效了，产生了不必要的传输</li></ul></li><li>而ETag可以根据内容生成的hash来比较的，只要资源文件内容不变，就会应用客户端的缓存，减少不必要的传输。</li><li>所以ETag比Last-Modified缓存更精确、高效和节省带宽。</li></ul><h1>ETag</h1><h2 id="什么是ETag？">什么是ETag？</h2><p>Etag是 Entity tag的缩写，可以理解为“被请求资源的摘要标识”，Etag是服务端的一个资源的标识，在 HTTP 响应头中将其传送到客户端，类似这样，ETag:W/“50b1c1d4f775c61:df3”</p><h2 id="ETag格式">ETag格式</h2><ul><li>ETag:W/“xxxxxxxx”</li><li>ETag:“xxxxxxx”</li></ul><h3 id="强类型验证">强类型验证</h3><ul><li>比对资源每个字节都要一样。</li></ul><h3 id="W-前缀代表使用弱类型验证">W/前缀代表使用弱类型验证</h3><ul><li>不需要每个字节都一样，例如页脚的时间or展示的广告不一样，都可以认为是一样的。构建应用于弱验证类型的标签（etag）体系可能会比较复杂，因为这会涉及到对页面上不同的元素的重要性进行排序，但是会对缓存性能优化相当有帮助。</li></ul><h2 id="ETag生成需要满足什么条件？">ETag生成需要满足什么条件？</h2><ol><li>当文件更改时，ETag值必须改变</li><li>尽量便于计算，不会特别耗CPU。<ol><li>利用摘要算法生成（MD5, SHA128, SHA256）需慎重考虑，这些为CPU密集型运算。</li></ol></li><li>必须横向扩展，分布式部署时多个服务器节点上生成的ETag值保持一致。</li></ol><h2 id="ETag是怎么生成的（Nginx）">ETag是怎么生成的（Nginx）</h2><p><a href="https://github.com/nginx/nginx/blob/6c3838f9ed45f5c2aa6a971a0da3cb6ffe45b61e/src/http/ngx_http_core_module.c#L1582">Nginx的源码</a>中ETag由last_modified和content_length拼接而成</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">etag-&gt;value.len = ngx_sprintf(etag-&gt;value.data, <span class="string">&quot;\&quot;%xT-%xO\&quot;&quot;</span>,</span><br><span class="line">                                  r-&gt;headers_out.last_modified_time,</span><br><span class="line">                                  r-&gt;headers_out.content_length_n)</span><br><span class="line">                      - etag-&gt;value.data;                                </span><br></pre></td></tr></table></figure><ul><li>翻译为以下伪代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">etag = header.last_modified + <span class="string">&quot;-&quot;</span> + header.content_lenth</span><br></pre></td></tr></table></figure><ul><li>总结：Nginx中ETag由响应头的Last-Modified和Content-Length表示为十六进制组合而成。</li></ul><h3 id="Lodash网站请求检验">Lodash网站请求检验</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/lodash%E8%AF%B7%E6%B1%82-20210325234424565.png" alt="img"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LAST_MODIFIED = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;5fc4907d&#x27;</span>, <span class="number">16</span>) * <span class="number">1000</span>).toJSON()</span><br><span class="line"><span class="keyword">const</span> CONTENT_LENGTH = <span class="built_in">parseInt</span>(<span class="string">&#x27;f48&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(LAST_MODIFIED) <span class="comment">// 2020-11-30T06:26:05.000Z</span></span><br><span class="line"><span class="built_in">console</span>.log(CONTENT_LENGTH) <span class="comment">// 3912</span></span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-20210325234424619.png" alt="img"></p><ul><li>既然在nginx中ETag由Last-Modified和Content-Length组成，那它便算是一个加强版的Last-Modified了，那加强在什么地方呢？</li><li>Last-Modified只能作用于秒级的改变，而 nginx 中的 ETag 添加了文件大小的附加条件，不仅和修改时间有关，也和内容有关，使之更加精确。</li></ul><h2 id="Last-Modified是怎么生成的">Last-Modified是怎么生成的</h2><p>在linux中</p><ul><li>mtime：modified time指文件内容改变的时间戳</li><li>ctime：change time指文件属性改变的时间戳，属性包括mtime。而在 windows 上，它表示的是creation time</li><li>而HTTP服务选择Last-Modified时一般会选择mtime，表示文件内容修改的时间，来兼容Windows和Linux。</li><li>以下为<a href="https://github.com/nginx/nginx/blob/4bf4650f2f10f7bbacfe7a33da744f18951d416d/src/http/modules/ngx_http_static_module.c#L217">nginx源码</a></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r-&gt;headers_out.status = NGX_HTTP_OK;     </span><br><span class="line">r-&gt;headers_out.content_length_n = of.size;     </span><br><span class="line">r-&gt;headers_out.last_modified_time = of.mtime;</span><br></pre></td></tr></table></figure><h2 id="如果-http-响应头中-ETag-值改变了，是否意味着文件内容一定已经更改？">如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改？</h2><ul><li>不一定</li><li>文件在一秒内发生了改变而且文件大小不变</li><li>这种情况非常极端，概率很低</li><li>因此在正常情况下可以容忍一个不太完美但是高效的算法。</li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;为什么需要缓存&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;通过缓存机制，可以在相应场景下复用以前获取的资源。&lt;/li&gt;
&lt;li&gt;显著提高网站的性能和响应速度&lt;/li&gt;
&lt;li&gt;减少网络流量和等待渲染时间&lt;/li&gt;
&lt;li&gt;降低服务器压力&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;HTTP缓存类型&lt;</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="HTTP" scheme="https://lebronchao.com/tags/HTTP/"/>
    
    <category term="缓存" scheme="https://lebronchao.com/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="计算机网络" scheme="https://lebronchao.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vue的前世今生</title>
    <link href="https://lebronchao.com/2021/03/11/Vue%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>https://lebronchao.com/2021/03/11/Vue%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2021-03-11T02:32:23.000Z</published>
    <updated>2021-03-11T02:32:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Vue的前世今生</h1><ul><li>2013 尤雨溪个人项目</li><li>2014.2 0.1版本发布</li><li>2015.10  1.0版本发布<ul><li>模板语法改进</li></ul></li><li>2016.9  2.0版本发布<ul><li>跨端</li><li>新的渲染机制</li></ul></li><li>2019.10 3.0 alpha发布<ul><li>性能</li><li>架构</li><li>按需引入</li><li>Composition API</li><li>Proxy observer</li><li>AOT优化</li></ul></li></ul><h1>Vue 1 响应式原理</h1><h2 id="构建响应式对象流程">构建响应式对象流程</h2><ul><li>walk函数遍历data对象中的属性，调用defineReactive将其变成响应式对象<ul><li>对于对象属性进行递归调用walk，以保证data整个对象树中的属性都是响应式对象。</li></ul></li><li>defineReactive中使用watchers数组储存watcher，使用Object.defineProperty的get函数收集watcher和返回值，set函数用来设置值和对watchers中的watcher进行视图更新。</li></ul><h2 id="Walk函数实现">Walk函数实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).foreach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        defineReactive(data, key, data[key])</span><br><span class="line">        <span class="comment">//对象递归调用walk</span></span><br><span class="line">        walk(data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defineReactive函数实现">defineReactive函数实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldValue = value;</span><br><span class="line">    <span class="keyword">const</span> watchers = []</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//收集watcher</span></span><br><span class="line">            watchers.push(currentWatcher)</span><br><span class="line">            <span class="keyword">return</span> oldValue</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue === oldValue) <span class="keyword">return</span>;</span><br><span class="line">            oldValue = newValue;</span><br><span class="line">            watchers.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> wathcer.update())<span class="comment">//更新视图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看了这么久Watcher到底是什么？">看了这么久Watcher到底是什么？</h2><p><img src= "/img/loading.gif" data-lazy-src="http://bloginfo.lebronchao.com/doc-image/16ab1c1b0537a783" alt=""></p><ul><li>Watcher用于获取数据和更新视图，并实现vue指令<ul><li>watcher从data中get数据render视图，同时data中的响应式对象劫持当前watcher并“储存”起来</li><li>data更新数据会触发响应式对象的set函数，把get数据时“储存”的watchers取出遍历，“通知”其更新视图。</li><li>watcher“接到data中的数据更新通知”，重新render视图。</li><li>视图发生变化会触发data的中响应式对象的set函数，循环形成数据流。</li></ul></li><li>例：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vm指向当前组件，el指向当前dom节点，第三个参数为标签类型，第四个为回调函数</span></span><br><span class="line"><span class="comment">// currentWatcher为全局变量指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通渲染的watcher</span></span><br><span class="line">Watcher(vm, el, <span class="string">&#x27;text&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 将currentWatcher对象指向当前watcher（vdom节点）供响应式对象的get函数获取</span></span><br><span class="line">    currentWatcher = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 读取显示的内容</span></span><br><span class="line">    el.textContext = <span class="built_in">eval</span>(<span class="string">&#x27;vm.data.text&#x27;</span>)</span><br><span class="line">    <span class="comment">// 解绑currentWatcher，防止发生错误。</span></span><br><span class="line">    currentWatcher = <span class="literal">null</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//带v-if指令的watcher</span></span><br><span class="line">Watcher(vm, el, <span class="string">&#x27;text&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 将currentWatcher对象指向当前watcher（vdom节点）供响应式对象的get函数获取</span></span><br><span class="line">    currentWatcher = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 实现v-if指令，通过判断变量值决定是否显示该元素,v-show原理类似</span></span><br><span class="line">    el.style.display = <span class="built_in">eval</span>(<span class="string">&#x27;Boolean(vm.data.text)&#x27;</span>) ? <span class="string">&#x27;block&#x27;</span> : <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    <span class="comment">// 解绑currentWatcher，防止发生错误。</span></span><br><span class="line">    currentWatcher = <span class="literal">null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>Vue 1 中存在的几个明显问题</h1><ol><li>启动时拦截所有组件的状态，进行递归响应式代理影响首次渲染速度</li><li>内存占用率高，一个“指令”，“computed计算属性”，“handlebar表达式”等等均需要创建一个watcher，watcher数量过多导致内存占用率高。</li><li>模板经过编译后直接操作dom，无法跨端。</li></ol><h1>Vue中的优化</h1><ol><li>新的渲染引擎 - vdom</li><li>Watcher依赖力度调整</li><li>其他<ol><li>API、语法糖重新设计与定义</li><li>生命周期调整</li><li>双向数据流 -&gt; 单向数据流</li><li>支持了jsx语法</li><li>等等…</li></ol></li></ol><h2 id="新的渲染引擎-vdom">新的渲染引擎 - vdom</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">if</span>=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;text&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue-loader 编译后的 compile render</span></span><br><span class="line"><span class="comment">// h函数用于生成Vdom节点，第一个参数为当前组件，第二个参数为属性，第三个属性为子节点</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.text</span><br><span class="line">     ? h(</span><br><span class="line">         <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">         <span class="literal">null</span>,</span><br><span class="line">         h(<span class="built_in">this</span>.text, <span class="literal">null</span>,[])</span><br><span class="line">     )</span><br><span class="line">     : vm.createEmptyVNode()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Watcher依赖力度调整">Watcher依赖力度调整</h2><p>watcher不再与单个dom节点、指令关联，一个component对应一个watcher，极大减少了vue 1 中watcher数量过多导致的内存问题。同时以来vdom diff在渲染时能以最小的代价来更新dom。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Watch(compoent, vm, <span class="string">&#x27;text&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newVnode = component.render()</span><br><span class="line">    <span class="keyword">const</span> oldVnode = component.render()</span><br><span class="line">    <span class="comment">//通过diff算法返回新旧节点的差异</span></span><br><span class="line">    <span class="keyword">const</span> patches = vm.diff(newVnode, oldVnode)</span><br><span class="line">    <span class="comment">// 通过patch函数对该组件应用差异</span></span><br><span class="line">    vm.patch(component, patches);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vdom带来的优势">vdom带来的优势</h2><ol><li>框架屏蔽具体渲染细节，抽象了渲染层，组建的抽象能力得以提升，不再依赖浏览器运行，进而可以跨段，如SSR、同构渲染一姐小程序、weex、uni-app等框架。</li><li>通过静态分析进行更多的AOT（Ahead Of Time）编译优化。</li><li>附加能力：大量组件更新时以最小的代价去更新dom。</li><li>vdom对比直接操作dom要慢，大部分情况下效率比vue 1 差，虽然牺牲了一点性能，但是使得vue获得更多特性及优化空间。</li></ol><h2 id="AOT编译优化">AOT编译优化</h2><h3 id="Cache-static-element">Cache static element</h3><ul><li>缓存静态节点、属性，避免重复创建</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">        Static</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">        &#123;&#123;dynmic&#125;&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">const</span> __static1=h(<span class="string">&#x27;span&#x27;</span>,&#123;</span><br><span class="line">    class:&#x27;foo&#x27;</span><br><span class="line">&#125;, <span class="string">&#x27;static&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">        __static1,</span><br><span class="line">        h(<span class="string">&#x27;span&#x27;</span>, <span class="built_in">this</span>.dynamic)</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Component-fast-path">Component fast path</h3><ul><li>编译后 直接判断是组件、原生标签还是文本节点，避免不必要的分支判断，提升性能。</li><li>提高vdom diff时的效率</li></ul><h4 id="Vue2优化前">Vue2优化前</h4><ul><li>每次都要调用h函数去做分支判断</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">&lt;Comp&gt;&lt;/Comp&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue2</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createFragment([</span><br><span class="line">        h(Comp, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">        h(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            h(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        ])</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">type, attrs, children</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isComponent(type))&#123;</span><br><span class="line">        <span class="comment">//创建component vnode</span></span><br><span class="line">        <span class="keyword">return</span> createComponentVNode(type, attrs, children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isDomElement(type))&#123;</span><br><span class="line">        <span class="comment">//创建原生dom vnode</span></span><br><span class="line">        <span class="keyword">return</span> createElementVNode(type, attrs, children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建纯string节点</span></span><br><span class="line">    <span class="keyword">return</span> createStringVNode(type, attrs, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vue3优化后">Vue3优化后</h4><ul><li>编译后直接调用不同的createVNode方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createFragment([</span><br><span class="line">        createComponentVNode(Comp, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">        createElmentVNode(<span class="string">&#x27;div&#x27;</span>,<span class="literal">null</span>, [</span><br><span class="line">           createElmentVNode(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        ])</span><br><span class="line">    ])</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="SSR-optimize">SSR optimize</h3><ul><li>SSR时采用字符串拼接，不创建vnode。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译前</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">            &#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;comp/</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">        <span class="built_in">this</span>.ssrString(</span><br><span class="line">            <span class="string">`&lt;p class=&quot;foo&quot;&gt;`</span></span><br><span class="line">            + <span class="built_in">this</span>.msg</span><br><span class="line">            + <span class="string">&#x27;&lt;/p&gt;&#x27;</span></span><br><span class="line">        ),</span><br><span class="line">        h(comp)</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Inline-handler">Inline handler</h3><ul><li>缓存dom上的event handler，避免重复创建。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">&lt;div @click=<span class="string">&quot;count++&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">import</span> &#123;getBoundMethod&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>,&#123;</span><br><span class="line">        onClick:getBoundMethod(__fn1,<span class="built_in">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Vue3变更</h1><h2 id="Proxy-Reactive-State">Proxy Reactive State</h2><ul><li>Vue3改用Proxy去生成响应式对象</li><li>Vue1/2中遍历和递归所有data中的属性去生成响应式对象</li><li>Vue3中改为仅在get获取这个属性的时候才去生成响应式对象，延迟了响应式对象生成，加快了首屏渲染速度。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue1/2中的做法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).foreach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        defineReactive(data, key, data[key])</span><br><span class="line">        <span class="comment">//对象递归调用walk</span></span><br><span class="line">        walk(data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue3中的做法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> observerd = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> result = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">             <span class="comment">//只有在取对象子属性的时候才递归</span></span><br><span class="line">            reactive(result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> oldValue = target[key]</span><br><span class="line">            <span class="keyword">if</span> (value == oldValue)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">let</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observerd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Composition-API">Composition API</h2><ul><li>Vue2中，代码根据数据、方法、计算属性等进行分块，导致可能同一个业务功能的代码需要反复上下地跳着去看。<ul><li>虽然有Mixin，但业务和业务之间的关系，包括命名空间都会出现一定问题。</li></ul></li><li>Vue3中引入Composition API使得开发者可以根据业务将代码分块，按需引入响应式对象、watch、生命周期钩子等各种属性，使用方法类似React Hooks，使得开发者更灵活地开发。<ul><li>详情见<a href="https://vue3js.cn/docs/zh/">Vue3中文文档 - vuejs (vue3js.cn)</a></li></ul></li></ul><h3 id="Vue2">Vue2</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;   </span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> &#123;       </span><br><span class="line">            counter: <span class="number">0</span>     </span><br><span class="line">        &#125;   </span><br><span class="line">   &#125;,   </span><br><span class="line">   watch: &#123;     </span><br><span class="line">       <span class="function"><span class="title">counter</span>(<span class="params">newValue, oldValue</span>)</span> &#123;       </span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;The new counter value is: &#x27;</span> + <span class="built_in">this</span>.counter)     </span><br><span class="line">       &#125;   </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue3">Vue3</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>) </span><br><span class="line">watch(counter, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;The new counter value is: &#x27;</span> + counter.value) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Why-use-Composition-API">Why use Composition API</h3><ul><li>mixin、hoc、composition api都是为了解决代码复用的问题。但是mixin、hoc过于灵活没有规范，导致开发人员容易写出零散、难以维护的逻辑。</li><li>Compostion API规避了mixin、hoc存在的缺陷，提供固定的编程模式-&gt;函数组合，对各模块解耦使得更优雅、更容易地去组合复用。</li><li>以组件状态为例，传统写法所有state都在一个component，杂糅在一起，语义化不强，compostion api使得state按照不同的逻辑分离出来，抽象出状态层组件。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    template:<span class="string">&#x27;#modal&#x27;</span>,</span><br><span class="line">    mixins:[Mixin1, Mixin2],</span><br><span class="line">    methods:&#123;</span><br><span class="line">        <span class="function"><span class="title">click</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.sendLog()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        appChild:Child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看完以上代码会发现以下问题<ul><li>sendLog到底来自哪个Mixin</li><li>mixin1，mixin2之间有没有逻辑关系</li><li>mixin1，mixin2如果都注入了sendLog使用哪个</li><li>如果使用hoc的方式，hoc增加了两个组件实例消耗，多了两次diff。</li><li>再来多几个mixin，这个组件更难维护。</li></ul></li><li>明显地体现了Composition API的好处</li></ul><h2 id="Time-Slicing">Time Slicing</h2><ul><li>Vue3最开始实现了这个特性，不过后面移除了</li><li>原因总结为以下两条<ul><li>基于响应式原理及AOT编译优化，相比react而言vue vdom diff具有很高的效率</li><li>Time Slicing只在一些极端情况下有明显作用，引入会降低vdom diff效率，阻塞UI渲染，收益不大。</li></ul></li></ul><h2 id="按需引入、支持treeshaking">按需引入、支持treeshaking</h2><ul><li>Vue各模块（响应式、SSR、runtime等）的解耦，可按需引入。</li></ul><h1>Vue vs React</h1><h2 id="相同点">相同点</h2><ol><li>基于MVVM思想：响应式数据驱动试图更新</li><li>提供组件化的解决方案</li><li>跨端：基于vdom的渲染引擎</li></ol><h2 id="核心差异">核心差异</h2><ol><li>定位<ol><li>React是一个Library，只专注于state到view的映射，状态、路由、动画等解决方案均来自于社区。</li><li>Vue是一个渐进式Framework，设计之初考虑开发者可能面临的问题，官方提供路由、状态管理、动画、插件等比较齐全的解决方案，不强制使用，譬如模块机制、依赖注入，可以通过插件机制很好和社区方案集成。</li><li>Library，职责范围小，开发效率低，需借助外力，但是易于扩展。对维护团队而言，保持版本间兼容成本较低。更容易集中精力专注于核心变更。</li><li>Framework，职责范围大，开发效率高，内置一套解决方案，扩展程度低。对维护团队而言，保持版本间兼容成本较高。</li></ol></li><li>渲染引擎<ol><li>Vue进行数据拦截/代理，它对侦测数据的变化更准确，改变了多少数据，就触发多少更新多少。</li><li>React setState触发局部整体刷新，没有追踪数据变更，做到精确更新，所以提供给开发者shouldComponentUpdate去除一些不必要的更新。</li><li>基于这个响应式设计，间接影响了核心架构的Composition API、React Hooks的实现。</li></ol></li><li>模板DSL<ol><li>Vue template语法更接近html，静态表达能力很强，基于声明式的能力，更方便做AOT编译优化。</li><li>JSX语法可以认为是JS基础上又增加了对html的支持，本质还是命令式变成。静态表达能力偏弱，导致优化信息不足，无法很好地做静态编译。</li></ol></li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Vue的前世今生&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;2013 尤雨溪个人项目&lt;/li&gt;
&lt;li&gt;2014.2 0.1版本发布&lt;/li&gt;
&lt;li&gt;2015.10  1.0版本发布
&lt;ul&gt;
&lt;li&gt;模板语法改进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2016.9  2.0版本</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="Vue" scheme="https://lebronchao.com/tags/Vue/"/>
    
    <category term="底层原理" scheme="https://lebronchao.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>浅析前端路由Router</title>
    <link href="https://lebronchao.com/2021/02/15/%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1Router/"/>
    <id>https://lebronchao.com/2021/02/15/%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1Router/</id>
    <published>2021-02-15T02:16:34.000Z</published>
    <updated>2021-02-15T07:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1>前端路由介绍</h1><h2 id="什么前端路由">什么前端路由</h2><p>路由这个概念最早出现在后端，通过⽤户请求的url导航到具体的html⻚⾯。现在的前端路由不同</p><p>于传统路由，它不需要服务器解析，⽽是可以通过hash函数或者history API来实现。在前端开发中，我</p><p>们可以使⽤路由设置访问路径，并根据路径与组件的映射关系切换组件的显示，⽽这整个过程都是在同</p><p>⼀个⻚⾯中实现的，不涉及⻚⾯间的跳转，这也就是我们常说的单⻚应⽤（spa）。</p><h2 id="前端路由带来了什么">前端路由带来了什么</h2><h3 id="相⽐多⻚应⽤-mpa-来说，spa有以下优点：">相⽐多⻚应⽤(mpa)来说，spa有以下优点：</h3><ul><li>不涉及html⻚⾯跳转，内容改变不需要重新加载⻚⾯，对服务器压⼒⼩。</li><li>只涉及组件之间的切换，因此跳转流畅，⽤户体验好。</li><li>⻚⾯效果会⽐较炫酷（⽐如切换⻚⾯内容时的转场动画）。</li><li>组件化开发便捷。</li></ul><h3 id="但是同时spa也有以下缺点：">但是同时spa也有以下缺点：</h3><ul><li>⾸屏加载过慢。</li><li>不利于seo。</li><li>⻚⾯复杂度提⾼很多。</li></ul><h1>⽤原⽣ <strong>js</strong> 实现前端路由</h1><h2 id="什么前端路由-2">什么前端路由</h2><p>路由这个概念最早出现在后端，通过⽤户请求的 url 导航到具体的 html ⻚⾯。现在的前端路由不同于</p><p>传统路由，它不需要服务器解析，⽽是可以通过 hash 函数或者 h5 history API 来实现。在前端开发</p><p>中，我们可以使⽤路由设置访问路径，并根据路径与组件的映射关系切换组件的显示，⽽这整个过程都</p><p>是在同⼀个⻚⾯中实现的，不涉及⻚⾯间的跳转，这也就是我们常说的单⻚应⽤（spa）。</p><h2 id="原⽣-js-实现前端路由">原⽣ <strong>js</strong> 实现前端路由</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>lesson2<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/user&quot;</span>&gt;</span>用户中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> view = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, onLoad);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听hash变化</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, onHashChange);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">onLoad</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      view = <span class="built_in">document</span>.getElementById(<span class="string">&quot;view&quot;</span>);</span></span><br><span class="line">      onHashChange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">onHashChange</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">switch</span> (location.hash) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="string">&quot;#/home&quot;</span>:</span></span><br><span class="line"><span class="javascript">          view.innerHTML = <span class="string">&quot;首页&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="string">&quot;#/user&quot;</span>:</span></span><br><span class="line"><span class="javascript">          view.innerHTML = <span class="string">&quot;用户中心&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="string">&quot;#/login&quot;</span>:</span></span><br><span class="line"><span class="javascript">          view.innerHTML = <span class="string">&quot;登录&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">break</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>环境配置与 react-router 简介</h1><h2 id="资源">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="目标">目标</h2><ol><li>掌握 cra 环境</li><li>掌握 react-router 的基本使用</li></ol><h2 id="知识点">知识点</h2><h3 id="快速开始">快速开始</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-react-app router-nut</span><br><span class="line"><span class="built_in">cd</span> router-nut</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure><h3 id="配置-less-与装饰器">配置 less 与装饰器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @craco/craco craco-less @babel/plugin-proposal-decorators</span><br></pre></td></tr></table></figure><p>根目录下添加 craco.config.js 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// * 配置完成后记得重启下</span></span><br><span class="line"><span class="keyword">const</span> CracoLessPlugin = <span class="built_in">require</span>(<span class="string">&quot;craco-less&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  babel: &#123;</span><br><span class="line">    <span class="comment">//用来支持装饰器</span></span><br><span class="line">    plugins: [[<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123;<span class="attr">legacy</span>: <span class="literal">true</span>&#125;]]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123;</span><br><span class="line">      plugin: CracoLessPlugin</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改 package.json</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;start&quot;: &quot;craco start&quot;,</span><br><span class="line">   &quot;build&quot;: &quot;craco build&quot;,</span><br><span class="line">   &quot;test&quot;: &quot;craco test&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="react-router-简介">react-router 简介</h3><p>react-router 包含 3 个库，react-router、react-router-dom 和 react-router-native。react-router 提供最基本的路由功能，实际使用的时候我们不会直接安装 react-router，而是根据应用运行的环境选择安装 react-router-dom（在浏览器中使用）或 react-router-native（在 rn 中使用）。react-router-dom 和 react-router-native 都依赖 react-router，所以在安装时，react-router 也会自动安装，创建 web 应用。</p><h4 id="安装">安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure><h4 id="BrowserRouter-与-HashRouter-对比">BrowserRouter 与 HashRouter 对比</h4><ol><li>HashRouter 最简单，不需要服务器端渲染，靠浏览器的#的来区分 path 就可以，BrowserRouter 需要服务器端对不同的 URL 返回不同的 HTML，后端配置可<a href="https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html">参考</a>。</li><li>BrowserRouter 使用 HTML5 history API（ pushState，replaceState 和 popstate 事件），让页面的 UI 同步与 URL。</li><li>HashRouter 不支持 location.key 和 location.state，动态路由跳转需要通过?传递参数。</li><li>Hash history 不需要服务器任何配置就可以运行，如果你刚刚入门，那就使用它吧。但是我们不推荐在实际线上环境中用到它，因为每一个 web 应用都应该渴望使用 <code>browserHistory</code>。</li></ol><h4 id="MemoryRouter">MemoryRouter</h4><p>把 URL 的历史记录保存在内存中的 <code>&lt;Router&gt;</code>（不读取、不写入地址栏）。在测试和非浏览器环境中很有用，如 React Native。</p><h4 id="基本使用">基本使用</h4><p>react-router 中奉行一切皆组件的思想，路由器-<strong>Router</strong>、链接-<strong>Link</strong>、路由-<strong>Route</strong>、独占-<strong>Switch</strong>、重定向-<strong>Redirect</strong>都以组件形式存在</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Link&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> HomePage <span class="keyword">from</span> <span class="string">&quot;./pages/HomePage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> UserPage <span class="keyword">from</span> <span class="string">&quot;./pages/UserPage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> LoginPage <span class="keyword">from</span> <span class="string">&quot;./pages/LoginPage&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/&quot;</span>&gt;首页&lt;/Link&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/user&quot;</span>&gt;用户中心&lt;/Link&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/login&quot;</span>&gt;登录&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 根路由要添加exact，实现精确匹配 */</span>&#125;</span><br><span class="line">        &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;HomePage&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;UserPage&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/login&quot;</span> component=&#123;LoginPage&#125; /&gt;</span><br><span class="line">      &lt;/Router&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h1>Route 渲染内容的三种方式</h1><h2 id="资源-2">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="目标-2">目标</h2><ol><li>掌握 Route 渲染内容的三种方式</li><li>掌握 404 路由</li></ol><h2 id="知识点-2">知识点</h2><p>Route 渲染优先级：children&gt;component&gt;render。</p><p>三者能接收到同样的[route props]，包括 match, location and history，但是当不匹配的时候，children 的 match 为 null。</p><p>这三种方式互斥，你只能用一种。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Link, Switch&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> HomePage <span class="keyword">from</span> <span class="string">&quot;./pages/HomePage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> UserPage <span class="keyword">from</span> <span class="string">&quot;./pages/UserPage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> LoginPage <span class="keyword">from</span> <span class="string">&quot;./pages/LoginPage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> _404Page <span class="keyword">from</span> <span class="string">&quot;./pages/_404Page&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          setCount(count + <span class="number">1</span>);</span><br><span class="line">        &#125;&#125;&gt;</span><br><span class="line">        add: &#123;count&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/&quot;</span>&gt;首页&lt;/Link&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/user&quot;</span>&gt;用户中心&lt;/Link&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/login&quot;</span>&gt;登录&lt;/Link&gt;</span><br><span class="line">        &#123;<span class="comment">/* 独占路由 */</span>&#125;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route</span><br><span class="line">            path=<span class="string">&quot;/&quot;</span></span><br><span class="line">            exact</span><br><span class="line">            <span class="comment">//children=&#123;children&#125;</span></span><br><span class="line">            component=&#123;HomePage&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ! 渲染component的时候会调用React.createElement，如果使用下面这种匿名函数的形式，每次都会生成一个新的匿名的函数，</span></span><br><span class="line">            <span class="comment">// ! 导致生成的组件的type总是不相同，这个时候会产生重复的卸载和挂载</span></span><br><span class="line">            <span class="comment">//!  错误举例 课下自己尝试下 观察下HomePage的didMount和willUnmount函数 */&#125;</span></span><br><span class="line">            <span class="comment">//component=&#123;() =&gt; &lt;HomePage /&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// render=&#123;render&#125;</span></span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;UserPage&#125; /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/login&quot;</span> component=&#123;LoginPage&#125; /&gt;</span><br><span class="line">          &lt;Route component=&#123;_404Page&#125; /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/Router&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;children props&quot;</span>, props); <span class="comment">//sy-log</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>children<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;props props&quot;</span>, props); <span class="comment">//sy-log</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>render<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="children：func">children：func</h3><p>有时候，不管 location 是否匹配，你都需要渲染一些内容，这时候你可以用 children。</p><p>除了不管 location 是否匹配都会被渲染之外，其它工作方法与 render 完全一样。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Link, Route&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItemLink</span>(<span class="params">&#123;to, name, ...rest&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Route</span><br><span class="line">      path=&#123;to&#125;</span><br><span class="line">      children=&#123;<span class="function">(<span class="params">&#123;match&#125;</span>) =&gt;</span> (</span><br><span class="line">        &lt;li className=&#123;match ? <span class="string">&quot;active&quot;</span> : <span class="string">&quot;&quot;</span>&#125;&gt;</span><br><span class="line">          &lt;Link to=&#123;to&#125; &#123;...rest&#125;&gt;</span><br><span class="line">            &#123;name&#125;</span><br><span class="line">          &lt;/Link&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteChildren</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;RouteChildren&lt;/h3&gt;</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">            &lt;ListItemLink to=<span class="string">&quot;/somewhere&quot;</span> name=<span class="string">&quot;链接1&quot;</span> /&gt;</span><br><span class="line">            &lt;ListItemLink to=<span class="string">&quot;/somewhere-else&quot;</span> name=<span class="string">&quot;链接2&quot;</span> /&gt;</span><br><span class="line">          &lt;/ul&gt;</span><br><span class="line">        &lt;/Router&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="render：func">render：func</h3><p>但是当你用 render 的时候，你调用的只是个函数。但是它和 component 一样，能访问到所有的[route props]。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便的内联渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/home&quot;</span> render=&#123;<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125; /&gt;</span><br><span class="line">  &lt;/Router&gt;,</span><br><span class="line">  node</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapping/composing</span></span><br><span class="line"><span class="comment">//把route参数传递给你的组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FadingRoute</span>(<span class="params">&#123;component: Component, ...rest&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Route &#123;...rest&#125; render=&#123;<span class="function"><span class="params">routeProps</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...routeProps</span>&#125; /&gt;</span></span>&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;FadingRoute path=<span class="string">&quot;/cool&quot;</span> component=&#123;Something&#125; /&gt;</span><br><span class="line">  &lt;/Router&gt;,</span><br><span class="line">  node</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="component-component">component: component</h3><p>只在当 location 匹配的时候渲染。</p><h3 id="注意">注意</h3><p>当你用<code>component</code>的时候，Route 会用你指定的组件和 React.createElement 创建一个新的[React element]。这意味着当你提供的是一个内联函数的时候，每次 render 都会创建一个新的组件。这会导致不再更新已经现有组件，而是直接卸载然后再去挂载一个新的组件。因此，当用到内联函数的内联渲染时，请使用 render 或者 children。</p><p>Route 核心渲染代码如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/0082zybply1gc7moo8djgj311c0u0wv0-20210325005548144-20210326000547431.jpg" alt="image20200224174023810"></p><h3 id="404-页面">404 页面</h3><p>设定一个没有 path 的路由在路由列表最后面，表示一定匹配</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/&quot;</span> exact component=&#123;HomePage&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;UserPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/login&quot;</span> component=&#123;LoginPage&#125; /&gt;</span><br><span class="line">  &lt;Route component=&#123;_404Page&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><h1>动态路由</h1><h2 id="资源-3">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="目标-3">目标</h2><ol><li>动态路由</li></ol><h2 id="知识点-3">知识点</h2><h3 id="动态路由">动态路由</h3><p>使用:id的形式定义动态路由</p><p>定义路由:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/product/:id&quot;</span> component=&#123;Product&#125; /&gt;</span><br></pre></td></tr></table></figure><p>添加导航链接:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Link to=&#123;<span class="string">&quot;/product/123&quot;</span>&#125;&gt;搜索&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>创建Search组件并获取参数:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">&#123;location, match&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;match&quot;</span>, match); <span class="comment">//sy-log</span></span><br><span class="line">  <span class="keyword">const</span> &#123;id&#125; = match.params;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Product-&#123;id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>嵌套路由</h1><h2 id="资源-4">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="⽬标">⽬标</h2><ul><li>掌握嵌套路由</li></ul><h2 id="知识点-4">知识点</h2><h3 id="嵌套路由">嵌套路由</h3><p>Route组件嵌套在其他⻚⾯组件中就产⽣了嵌套关系</p><p>修改Product，添加新增和详情</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&#123;url + &quot;&#x2F;detail&quot;&#125; component&#x3D;&#123;Detail&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">&#123;match&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;match&quot;</span>, match); <span class="comment">//sy-log</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;params, url&#125; = match;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;id&#125; = params;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">&lt;div&gt; </span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Search-&#123;id&#125;&lt;/h1&gt; </span><br><span class="line"></span><br><span class="line">&lt;Link to=&#123;url + <span class="string">&quot;/detail&quot;</span>&#125;&gt;详情&lt;/Link&gt; </span><br><span class="line"></span><br><span class="line">&lt;Route path=&#123;url + <span class="string">&quot;/detail&quot;</span>&#125; component=&#123;Detail&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt; );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>⼿写实现<strong>BrowserRouter</strong>、<strong>Route</strong>、<strong>Link</strong></h1><h2 id="资源-5">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="⽬标-2">⽬标</h2><ul><li>react-router初步实现</li></ul><h2 id="知识点-5">知识点</h2><h3 id="跨层级传输数据-Context">跨层级传输数据 Context</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Context做数据跨层级传递</span></span><br><span class="line"><span class="comment">// step1: 创建context对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RouterContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// step2: 使用context对象的Provider传递value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step3: 子组件消费value： Consumer、useContext、contextType</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现Router">实现<strong>Router</strong></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RouterContext&#125; <span class="keyword">from</span> <span class="string">&quot;./Context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">computeRootMatch</span>(<span class="params">pathname</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">url</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">params</span>: &#123;&#125;, <span class="attr">isExact</span>: pathname === <span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            location: props.history.location</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.unlisten = props.history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                location</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.unlisten) &#123;</span><br><span class="line">            <span class="built_in">this</span>.unlisten();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;RouterContext.Provider</span><br><span class="line">                value=&#123;&#123;</span><br><span class="line">                    history: <span class="built_in">this</span>.props.history,</span><br><span class="line">                    location: <span class="built_in">this</span>.state.location,</span><br><span class="line">                    match: Router.computeRootMatch(<span class="built_in">this</span>.state.location.pathname)</span><br><span class="line">                &#125;&#125;&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">            &lt;/RouterContext.Provider&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现BrowserRouter">实现<strong>BrowserRouter</strong></h3><p><strong>BrowserRouter</strong>：历史记录管理对象history初始化及向下传递，location变更监听</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createBrowserHistory&#125; <span class="keyword">from</span> <span class="string">&quot;history&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&quot;./Router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.history = createBrowserHistory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Route">实现<strong>Route</strong></h3><p>路由配置，匹配检测，内容渲染</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// match 按照互斥规则 优先渲染顺序为children component render null，children如果是function执⾏function，是节点直接渲染</span></span><br><span class="line"><span class="comment">// 不match children 或者null （只渲染function）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;RouterContext.Consumer&gt;</span><br><span class="line">                &#123;<span class="function"><span class="params">context</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 优先从props中取值</span></span><br><span class="line">                    <span class="keyword">const</span> location = <span class="built_in">this</span>.props.location || context.location;</span><br><span class="line">                    <span class="comment">// 优先从props中取值计算</span></span><br><span class="line">                    <span class="keyword">const</span> match = <span class="built_in">this</span>.props.computedMatch</span><br><span class="line">                        ? <span class="built_in">this</span>.props.computedMatch</span><br><span class="line">                        : <span class="built_in">this</span>.props.path</span><br><span class="line">                            ? matchPath(location.pathname, <span class="built_in">this</span>.props)</span><br><span class="line">                            : context.match;</span><br><span class="line">                    <span class="keyword">const</span> props = &#123;</span><br><span class="line">                        ...context,</span><br><span class="line">                        location,</span><br><span class="line">                        match</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">let</span> &#123;path, children, component, render&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">                    <span class="comment">// match 渲染这三者之⼀：children component render或者null</span></span><br><span class="line">                    <span class="comment">// 不match，渲染children 或者 null</span></span><br><span class="line">                    <span class="keyword">return</span> (</span><br><span class="line">                        &lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class="line">                            &#123;match</span><br><span class="line">                                ? children</span><br><span class="line">                                    ? <span class="keyword">typeof</span> children === <span class="string">&quot;function&quot;</span></span><br><span class="line">                                        ? children(props)</span><br><span class="line">                                        : children</span><br><span class="line">                                    : component</span><br><span class="line">                                        ? React.createElement(component, props)</span><br><span class="line">                                        : render</span><br><span class="line">                                            ? render(props)</span><br><span class="line">                                            : <span class="literal">null</span></span><br><span class="line">                                : <span class="keyword">typeof</span> children === <span class="string">&quot;function&quot;</span></span><br><span class="line">                                    ? children(props)</span><br><span class="line">                                    : <span class="literal">null</span>&#125;</span><br><span class="line">                        &lt;/RouterContext.Provider&gt;</span><br><span class="line">                    );</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &lt;/RouterContext.Consumer&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现<strong>Link</strong></p><p>Link.js: 跳转链接，处理点击事件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RouterContext&#125; <span class="keyword">from</span> <span class="string">&quot;./RouterContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Link</span>(<span class="params">&#123;to, children, ...restProps&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = React.useContext(RouterContext);</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    context.history.push(to);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=&#123;to&#125; &#123;...restProps&#125; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Switch">实现<strong>Switch</strong></h3><p>渲染与该地址匹配的第⼀个⼦节点 <Route> 或者 <Redirect> 。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component, isValidElement&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RouterContext&#125; <span class="keyword">from</span> <span class="string">&quot;./Context&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> matchPath <span class="keyword">from</span> <span class="string">&quot;./matchPath&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Switch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;RouterContext.Consumer&gt;</span><br><span class="line">                &#123;<span class="function"><span class="params">context</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> &#123;location&#125; = context;</span><br><span class="line">                    <span class="keyword">let</span> match, element;</span><br><span class="line">                    <span class="comment">// children element | array</span></span><br><span class="line">                    React.Children.forEach(<span class="built_in">this</span>.props.children, <span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">                            element = child;</span><br><span class="line">                            <span class="keyword">const</span> &#123;path&#125; = child.props;</span><br><span class="line">                            match = path</span><br><span class="line">                                ? matchPath(location.pathname, child.props)</span><br><span class="line">                                : context.match;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">return</span> match</span><br><span class="line">                        ? React.cloneElement(element, &#123;<span class="attr">computedMatch</span>: match&#125;)</span><br><span class="line">                        : <span class="literal">null</span>;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &lt;/RouterContext.Consumer&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前端路由介绍&lt;/h1&gt;
&lt;h2 id=&quot;什么前端路由&quot;&gt;什么前端路由&lt;/h2&gt;
&lt;p&gt;路由这个概念最早出现在后端，通过⽤户请求的url导航到具体的html⻚⾯。现在的前端路由不同&lt;/p&gt;
&lt;p&gt;于传统路由，它不需要服务器解析，⽽是可以通过hash函数或者history A</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="React" scheme="https://lebronchao.com/tags/React/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="底层原理" scheme="https://lebronchao.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Router" scheme="https://lebronchao.com/tags/Router/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript入门 | 学习笔记</title>
    <link href="https://lebronchao.com/2021/01/22/TypeScript%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://lebronchao.com/2021/01/22/TypeScript%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-22T07:42:34.000Z</published>
    <updated>2021-01-22T07:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TypeScript学习笔记">TypeScript学习笔记</h3><h3 id="TS简介">TS简介</h3><blockquote><p>Ts微软开发，包含ES6、包含ES5</p></blockquote><p>编译 tsc xx.ts<br>每一次都得编译，可以自动编译</p><h3 id="开发工具中配置typescirpt自动编译">开发工具中配置typescirpt自动编译</h3><p>vscode:</p><ol><li>创建tsconfig.json文件 tsc --init 生成配置文件</li><li>tsconfig.json配置文件中，修改outDir配置项，取消注释然后修改为.js</li><li>vscode中，点击上方栏位run task，选择ts监听</li><li>完成</li></ol><h3 id="TS类型">TS类型</h3><ul><li>与es5中的区别</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5：类型变化不报错</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">flag = <span class="number">234</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts：必须指定类型</span></span><br><span class="line">typescript</span><br><span class="line"><span class="keyword">var</span> flag:<span class="built_in">boolean</span>=<span class="literal">true</span>;</span><br><span class="line">flag = <span class="number">131</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h4 id="TS类型：">TS类型：</h4><ul><li>boolean</li><li>number</li><li>string</li><li>array数组：<br>方式1：var arr:number[] = [1,2,3]//制定arr里面全是数字<br>方式2：var arr:Array= [1,2,3]</li></ul><h4 id="元组类型（tuple）">元组类型（tuple）</h4><ul><li>方式1：属于数组的一种，即数组中每一个元素指定类型</li><li>方式2：var arr:[number, string]=[123,“this is ts”];</li></ul><h4 id="枚举类型-enum">枚举类型(enum)</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用来标识状态码</span></span><br><span class="line"><span class="built_in">enum</span> Flag&#123;</span><br><span class="line">   success=<span class="number">1</span>,</span><br><span class="line">     error=<span class="number">2</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> f:Flag=Flag.error;</span><br><span class="line"> <span class="built_in">console</span>.log(f);<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 没有标识符没有赋值，那么打印的就是下标</span></span><br><span class="line"><span class="built_in">enum</span> Color&#123;blue,red,orange&#125;;</span><br><span class="line"> <span class="keyword">var</span> c:Color=Color.red;</span><br><span class="line"> <span class="built_in">console</span>.log(c);  <span class="comment">//1，下标</span></span><br><span class="line"> <span class="built_in">enum</span> Color&#123;blue,red=<span class="number">3</span>,orange&#125;;</span><br><span class="line"> <span class="keyword">var</span> c:Color=Color.red;</span><br><span class="line"> <span class="built_in">console</span>.log(c);  <span class="comment">//3</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 常用来标识状态码</span></span><br><span class="line"> <span class="built_in">enum</span> Err&#123;</span><br><span class="line">  <span class="string">&#x27;undefined&#x27;</span>=-<span class="number">1</span>,</span><br><span class="line">   <span class="string">&#x27;null&#x27;</span>=-<span class="number">2</span>,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> c:Err=Err.null</span><br><span class="line"> <span class="built_in">console</span>.log(c) <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><h4 id="任意类型any">任意类型any</h4><ul><li>类似ES5不指定变量类型的var</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="built_in">any</span>=<span class="number">123</span>;</span><br><span class="line">num = <span class="literal">true</span>;<span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><h4 id="null类型和undefined其他数据类型的子类型">null类型和undefined其他数据类型的子类型</h4><ul><li>变量定义之后没有赋值，报undefined</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个元素可能是number类型，可能是null或者undefined</span></span><br><span class="line"><span class="keyword">var</span> num:<span class="built_in">number</span> | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="void和java一样-没有返回值类型">void和java一样 没有返回值类型</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果方法没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;asdf&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果方法有返回值：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">number</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="never类型，代表从来不会出现的值，是其他类型（包括null‘和undefined）的子类型，代表从不会出现的值">never类型，代表从来不会出现的值，是其他类型（包括null‘和undefined）的子类型，代表从不会出现的值</h4><ul><li>自己理解为上述类型之外的数据类型</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下，接收Err类型的数据</span></span><br><span class="line">   <span class="keyword">var</span> a:<span class="built_in">never</span>;</span><br><span class="line">   a = <span class="literal">undefined</span>;<span class="comment">//报错</span></span><br><span class="line">   a = (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Throw Err(<span class="string">&quot;报错&quot;</span>)</span><br><span class="line">   &#125;)()</span><br></pre></td></tr></table></figure><h3 id="函数的定义">函数的定义</h3><ul><li>ES5中：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">var</span> run2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TS中：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">var</span> fun2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ts中定义方法传参">ts中定义方法传参</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getInfo= <span class="function"><span class="keyword">function</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法可选参数">方法可选参数</h3><blockquote><p>es5里方法实参和形参可以不一样，但是ts必须一致，如果不一样就需要配置可选参数</p></blockquote><ul><li>参数后边加?可以设置参数可选传</li><li>可选参数必须配置到参数的最后边</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age?<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认参数">默认参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认参数，直接在形参赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span>=<span class="number">20</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩余参数">剩余参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span>, c:<span class="built_in">number</span>, d:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b+c+d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三点运算符：接收不固定参数的（剩余参数）的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">…rest:<span class="built_in">number</span>[]</span>):<span class="title">number</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum= <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;rest.length;i++)&#123;</span><br><span class="line">sum+=rest[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载">函数重载</h3><ul><li>类似java，同名但是不同参数的多个函数方法</li><li>ts为了兼容es5，以及es6，和java有区别</li><li>es5中，出现同名方法时候，下面的方法会替换上面的方法</li><li>ts中的重载：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">age:<span class="built_in">number</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">str:<span class="built_in">any</span></span>):<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> str ===<span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我叫：&quot;</span>+ str;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我的年龄是:&quot;</span> + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数">箭头函数</h3><p>箭头函数里面的this指向上下文</p><h3 id="类">类</h3><p>1、ES5中定义类：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=<span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">alert(p.name);</span><br></pre></td></tr></table></figure><p>2、构造函数和原型链里面定义</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明的构造方法</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">       <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">       <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">           alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 原型链的属性和方法</span></span><br><span class="line">   Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">   Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       alert(xx)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">   p.work();</span><br></pre></td></tr></table></figure><p>3、静态方法</p><p>4、es5中的继承-对象冒充继承</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要实现Web类 继承 Person类  原型链+对象冒充的组合继承模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要实现Web类 继承 Person类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>); <span class="comment">//对象冒充继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web();</span><br><span class="line">w.run();<span class="comment">//执行父类Person的run，对象冒充可以继承构造函数里面的属性和方法</span></span><br><span class="line">w.work();<span class="comment">// 对象冒充可以继承构造函数的属性和方法 但是没办法继承原型链的属性和方法（prototype）</span></span><br></pre></td></tr></table></figure><ul><li>关于call：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.error(add.call(obj, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 10</span></span><br><span class="line">大统上的说法就是，call改变了<span class="built_in">this</span>的指向。然后，介绍<span class="built_in">this</span> xxx什么一大堆名词，反正不管你懂不懂，成功绕晕你就已经ok了，但是实际发生的过程，可以看成下面的样子。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">给o对象添加一个add属性，这个时候 <span class="built_in">this</span> 就指向了 o，</span><br><span class="line">o.add(<span class="number">5</span>,<span class="number">7</span>)得到的结果和add.call(o, <span class="number">5</span>, <span class="number">6</span>)相同。</span><br></pre></td></tr></table></figure><p>5、原型链继承方法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// web原型链方式继承 person</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">web</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">web.prototype= <span class="keyword">new</span> person();<span class="comment">// 原型链继承</span></span><br><span class="line"></span><br><span class="line">web.work();<span class="comment">// 可以工作，可以继承原型链属性方法</span></span><br></pre></td></tr></table></figure><p>6、原型链实现继承的问题？？无法给父类传参</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> person(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">p.run(); <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// 继承，无法给父类传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Web.prototype= <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">&#x27;sss&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">w.run();<span class="comment">// 父类会alert出来“undefiend在运动”</span></span><br><span class="line"><span class="comment">// 实例化子类时候没法给父类传参</span></span><br></pre></td></tr></table></figure><p>7、原型链+构造函数的组合继承模式</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> person(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">p.run(); <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// 继承，无法给父类传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>,name,age); <span class="comment">// 对象冒充继承 可以继承构造函数里面的属性和方法 实例化子类可以给父类传参</span></span><br><span class="line">&#125;</span><br><span class="line">Web.prototype = <span class="keyword">new</span> Person();<span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">&#x27;sss&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">w.run();<span class="comment">// 父类会alert出来“undefiend在运动”</span></span><br><span class="line"><span class="comment">// 实例化子类时候没法给父类传参</span></span><br></pre></td></tr></table></figure><p>8、原型链+对象冒充的另一种写法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> person(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">p.run(); <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// 继承，无法给父类传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>,name,age); <span class="comment">// 对象冒充继承 可以继承构造函数里面的属性和方法 实例化子类可以给父类传参</span></span><br><span class="line">&#125;</span><br><span class="line">Web.prototype = Person.prototype; <span class="comment">// 和方法7中不同的是这里！！！</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">&#x27;sss&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">w.run();<span class="comment">// 父类会alert出来“undefiend在运动”</span></span><br><span class="line"><span class="comment">// 实例化子类时候没法给父类传参</span></span><br></pre></td></tr></table></figure><h3 id="类的定义">类的定义</h3><p>1、ts中定义类，类似java：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>()</span>&#123;</span><br><span class="line">    name:<span class="built_in">string</span>; <span class="comment">//属性 前面省略了private</span></span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">n:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    run():<span class="built_in">void</span>&#123;</span><br><span class="line">        log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、继承</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">alert(w.run());</span><br></pre></td></tr></table></figure><p>3、类里面的修饰符</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">ts提供了三种修饰符：</span><br><span class="line"><span class="keyword">public</span>(默认的)： 公有 在类里面、子类类外边都可以访问</span><br><span class="line"><span class="keyword">protected</span>：在类里面、子类里面可以访问、在类外部无法访问</span><br><span class="line"><span class="keyword">private</span>：在类里面可以访问、子类、类外部没法访问</span><br></pre></td></tr></table></figure><h3 id="静态属性-静态方法">静态属性 静态方法</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.run1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">// 实例方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.run2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 静态方法</span></span><br><span class="line"></span><br><span class="line">调用实例方法：(实例化之后才能调用的)</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.run1();</span><br><span class="line"></span><br><span class="line">调用静态方法：</span><br><span class="line">Person.run2();</span><br></pre></td></tr></table></figure><blockquote><p>为什么会有静态方法和实例方法之分？<br>JQuery的实例方法css()方法和静态方法$.get()方法大概原码为：</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生命一个节点/元素对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.element = 获取dome节点的方法;</span><br><span class="line">    <span class="built_in">this</span>.css = <span class="function"><span class="keyword">function</span>(<span class="params">str, value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.element.style[str] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $方法去实例化这个BAse对象、实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Base(element); <span class="comment">// 实例化一个方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法get</span></span><br><span class="line">$.<span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 那么css调用时候就可以这样写</span></span><br><span class="line">实例方法:</span><br><span class="line">$(<span class="string">&quot;#box&quot;</span>).css(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line">静态方法：</span><br><span class="line">$.get(<span class="string">&#x27;url&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>另一种方式声明静态方法，利用static关键字声明：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">static</span> sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;<span class="comment">// 静态方法 里面没办法直接调用类里面的属性，</span></span><br><span class="line">        alert(<span class="string">&quot;静态方法：&quot;</span>+Person.sex);<span class="comment">// 如果调用this.name就会报错！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $.get()&#123;// jq里面的get就是静态方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态">多态</h3><blockquote><p>父类定义一个方法不去实现，让继承他的子类去实现，每一个子类都有不同的表现</p></blockquote><h3 id="抽象方法">抽象方法</h3><ul><li>用来定义一个标准</li><li>ts中的抽象类，它是提供其他类继承的基类，不能直接被实例化</li><li>用abstract关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现</li><li>abstract 抽象方法只能放在抽象类中</li><li>抽象类和抽象方法用来定义标准，基类要求他的子类必须包含某种方法</li><li>抽象方法只能出现在抽象类中</li><li>抽象类中必须包含至少一个抽象方法，不然没有意义</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line">    <span class="keyword">abstract</span> eat():<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类无法直接实例化</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal();<span class="comment">// 这句话是错的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">&quot;sss&quot;</span>)</span><br><span class="line">d.eat();<span class="comment">// sss吃</span></span><br></pre></td></tr></table></figure><h3 id="接口">接口</h3><blockquote><p>也是定义标准，定义了行为和动作的规范</p></blockquote><p>1、属性接口</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了这个方法的参数是jsonObjec，而且必须有</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelInfo:&#123;label:<span class="built_in">string</span>&#125;</span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(labelInfo.label);</span><br><span class="line">&#125;</span><br><span class="line">printLabel(<span class="string">&quot;ssss&quot;</span>); <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">printLabel(&#123;<span class="attr">name</span>:<span class="string">&quot;asdf&quot;</span>&#125;); <span class="comment">// 错误</span></span><br><span class="line">printLabel(&#123;<span class="attr">label</span>:<span class="string">&quot;sss&quot;</span>&#125;); <span class="comment">// 正确，打印sss</span></span><br></pre></td></tr></table></figure><p>2、接口，对批量方法进行约束</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对批量方法传入参数进行约束</span></span><br><span class="line"><span class="comment">// 传入对象的约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明类型</span></span><br><span class="line"><span class="keyword">interface</span> FullName&#123;</span><br><span class="line">    firstName:<span class="built_in">string</span>; <span class="comment">// 注意是;结束</span></span><br><span class="line">    secondName:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法名中引用FullName类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">name:FullName</span>)</span>&#123;</span><br><span class="line">    log(name.firstName +<span class="string">&quot;  &quot;</span>+ name.secondName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式一（下方调用方式是会报错的，interface定义的属性object只能包含firstName和secondName）</span></span><br><span class="line">printName(&#123;</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">    firstName: <span class="string">&quot;张&quot;</span>,</span><br><span class="line">    secondName: <span class="string">&quot;三&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式二，下方引入其他的object即可忽略多余参数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">    firstName: <span class="string">&quot;张&quot;</span>,</span><br><span class="line">    secondName: <span class="string">&quot;三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">printName(obj);<span class="comment">// 这个不报错</span></span><br></pre></td></tr></table></figure><p>3、接口、可选属性，加?问号表示可传可不传</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> FullName&#123;</span><br><span class="line">    firstName:<span class="built_in">string</span>;</span><br><span class="line">    secondName?:<span class="built_in">string</span>;<span class="comment">// secondName可传可不传</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、模拟封装一个ajax</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config&#123;</span><br><span class="line">    <span class="keyword">type</span>:<span class="built_in">string</span>;</span><br><span class="line">    url:<span class="built_in">string</span>;</span><br><span class="line">    data?:<span class="built_in">string</span>;</span><br><span class="line">    dataType:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、函数类型接口、对方法传入的参数、以及返回值进行约束、批量约束</p><ul><li>例子：定义加密的函数类型接口</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> encrypt&#123;</span><br><span class="line"><span class="comment">// 定义了函数参数为string、value，返回string</span></span><br><span class="line">(key:<span class="built_in">string</span>,<span class="attr">value</span>:<span class="built_in">string</span>):<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> md5:encrypt=<span class="function"><span class="keyword">function</span>(<span class="params">key:<span class="built_in">string</span>, value:<span class="built_in">string</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line"><span class="comment">// 实现encrypt类型的函数return key+value;//模拟下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6、可索引接口：对数组、对象的约束</p><ul><li>ts定义数组方法：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr:<span class="built_in">number</span>[]=[<span class="number">123</span>,<span class="number">234</span>];</span><br><span class="line"><span class="keyword">var</span> arr1:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;222&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>对数组的约束，数组类型接口</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserArray&#123;</span><br><span class="line">    <span class="comment">// 表示数组中index必须是number，value必须是string</span></span><br><span class="line">    [index:numer]:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr:UserArray=[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;22312&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>对对象的约束，对象类型接口</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserObj&#123;</span><br><span class="line">    [index:<span class="built_in">string</span>]:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj:UserObj=&#123;<span class="attr">name</span>:<span class="string">&quot;2342&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>对类的约束，类类型接口，和抽象类有点相似</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal&#123;</span><br><span class="line">    <span class="comment">// 规定实现类必须要有name属性和eat方法</span></span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    eat(str:<span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    name:<span class="built_in">string</span>;<span class="comment">// 若没此属性，ts会编译报错</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        log(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的扩展：接口可以继承接口</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal&#123;</span><br><span class="line">   eat():<span class="built_in">void</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">   work():<span class="built_in">void</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="title">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">       <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// eat必须定义</span></span><br><span class="line">      <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+<span class="string">&quot;吃&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// work也必须定义</span></span><br><span class="line">      <span class="function"><span class="title">work</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+<span class="string">&quot;工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Animal&#123;</span><br><span class="line">   eat():<span class="built_in">void</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">   work():<span class="built_in">void</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span>&#123;</span><br><span class="line">   <span class="comment">//构造方法省略</span></span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="title">coding</span>(<span class="params">code:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+ <span class="string">&quot;  &quot;</span>+code)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Programmer</span> <span class="title">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">       <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// eat必须定义</span></span><br><span class="line">      <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+<span class="string">&quot;吃&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// work也必须定义</span></span><br><span class="line">      <span class="function"><span class="title">work</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+<span class="string">&quot;工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="泛型">泛型</h3><blockquote><p>和any有什么区别？</p></blockquote><ul><li>any放弃了类型检查</li><li>如果想做到传入什么类型就返回什么类型，例如传入number就返回number，这时候就可以使用泛型</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value:<span class="built_in">any</span></span>):<span class="title">any</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;&quot;</span><span class="comment">//什么类型都可以</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="泛型：">泛型：</h4><ul><li>软件工程中，我们不仅要创建一致的定义好的API，同时也要考虑可重用性，组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能</li><li>在像c#和java中，可以使用泛型来创建可重用的组件，一个组件可支持多种类型的数据，这样用户就可以以自己的数据类型来使用组件</li><li>通俗理解：泛型就是解决 类 接口 方法的重用性、以及对不特定数据类型的支持</li><li>可以支持不特定的数据类型</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;<span class="comment">//传入什么返回什么</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样调用</span></span><br><span class="line">getData&lt;<span class="built_in">number</span>&gt;(<span class="number">123123</span>);</span><br><span class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;12131&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以写成：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;<span class="comment">//传入什么返回什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型类，比如有个最小堆算法，需要同时支持返回数字和字符串两种类型，通过类的泛型来实现，示例：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> list:<span class="built_in">number</span>[]=[];</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">num:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.list.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    min():<span class="built_in">number</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> minNum = <span class="built_in">this</span>.list[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="built_in">this</span>.list.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minNum&gt;<span class="built_in">this</span>.list[i])&#123;</span><br><span class="line">                minNum=<span class="built_in">this</span>.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MinClass();</span><br><span class="line">m.add(<span class="number">3</span>);</span><br><span class="line">m.add(<span class="number">2</span>);</span><br><span class="line">log(m.min());<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>但是上边的只能传入数字类型，是否可以用泛型解决？可以：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> list:T[]=[];</span><br><span class="line">    add(num:T):<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.list.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    min():T&#123;</span><br><span class="line">        <span class="keyword">var</span> minNum = <span class="built_in">this</span>.list[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="built_in">this</span>.list.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minNum&gt;<span class="built_in">this</span>.list[i])&#123;</span><br><span class="line">                minNum=<span class="built_in">this</span>.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用，实例化时候要先声明参数类型&lt;bumber</span></span><br><span class="line"><span class="keyword">var</span> m1 = <span class="keyword">new</span> MinClass&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">m1.add(<span class="number">2</span>);</span><br><span class="line">m1.add(<span class="number">4</span>);</span><br><span class="line">log(m.min());<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h5 id="函数类型接口">函数类型接口</h5><ul><li>指定特殊类型的方法：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ConfigFn&#123;</span><br><span class="line">   (value1:<span class="built_in">string</span>, <span class="attr">value2</span>:<span class="built_in">string</span>):<span class="built_in">string</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> setData:ConfigFn=<span class="function"><span class="keyword">function</span>(<span class="params">value1:<span class="built_in">string</span>, value2:<span class="built_in">string</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">   setData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三);</span></span><br></pre></td></tr></table></figure><ul><li>泛型接口写法1：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config&#123;</span><br><span class="line">   &lt;T&gt;(value:T):T;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> getData:ConfigFn=<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   getData&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>泛型接口写法2：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">interface</span> Config&lt;T&gt;&#123;</span><br><span class="line">   (value:T):T;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> myGetData:ConfigFn&lt;<span class="built_in">string</span>&gt;=getData;</span><br><span class="line"></span><br><span class="line">   myGetData(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>把类作为参数来约束数据传入的类型</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">   username:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       password:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MySqlDb</span></span>&#123;</span><br><span class="line">   add(user:User):<span class="built_in">boolean</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(user);</span><br><span class="line">           retrun <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用</span></span><br><span class="line">   <span class="keyword">var</span> u = <span class="keyword">new</span> User();</span><br><span class="line">   u.username=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">   u.password=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> Db = <span class="keyword">new</span> MySqlDb();</span><br><span class="line">   Db.add(u);<span class="comment">// console.log(u)</span></span><br></pre></td></tr></table></figure><ul><li>上述方法可以改为泛型类</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作数据库的泛型类，这样可以规范插入数据库数据的类规范</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySqlDb</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   add(info:T):<span class="built_in">boolean</span>&#123;</span><br><span class="line">       log(info);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 想给User表增加数据</span></span><br><span class="line">   <span class="comment">// 1、定义一个User类 和数据库进行映射</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">   username:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       password:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> u = <span class="keyword">new</span> User();</span><br><span class="line">   u.username= <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">   u.password=<span class="string">&quot;2312&quot;</span>；</span><br><span class="line">   <span class="keyword">var</span> Db = <span class="keyword">new</span> MySqlDb&lt;User&gt;();<span class="comment">// 这一步很关键，要定义User类型</span></span><br><span class="line">   Db.add(u);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2、文章类，数据库映射</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Article</span></span>&#123;</span><br><span class="line">   title:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       desc:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       status:<span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line">       <span class="title">constructor</span>(<span class="params">params:&#123;</span></span><br><span class="line"><span class="params">       title:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="params">           desc:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="params">           status?<span class="built_in">number</span> | <span class="literal">undefined</span>;<span class="regexp">//</span> status可选参数</span></span><br><span class="line"><span class="params">       &#125;</span>)&#123;</span><br><span class="line">       <span class="built_in">this</span>.title=params.title;</span><br><span class="line">           <span class="built_in">this</span>.desc=params.desc;</span><br><span class="line">           <span class="built_in">this</span>.status=params.status;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用</span></span><br><span class="line">   <span class="keyword">var</span> a = <span class="keyword">new</span> Article(&#123;</span><br><span class="line">   title:<span class="string">&quot;分类&quot;</span>,</span><br><span class="line">       desc:<span class="string">&quot;111&quot;</span>,</span><br><span class="line">       status:<span class="number">1</span></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//类当前参数的泛型类</span></span><br><span class="line">   <span class="keyword">var</span> Db = MySqlDB&lt;Article&gt;();<span class="comment">// 指定类型</span></span><br><span class="line">   Db.add(a);<span class="comment">// log a</span></span><br></pre></td></tr></table></figure><h3 id="实战：要实现TS封装统一操作Mysql-Mongodb-Mssql的底层库">实战：要实现TS封装统一操作Mysql Mongodb Mssql的底层库</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先定义一个接口，用于提供各类型数据库规范</span></span><br><span class="line">   <span class="keyword">interface</span> DBI&lt;T&gt;&#123;</span><br><span class="line">   add(info:T):<span class="built_in">boolean</span>;</span><br><span class="line">       update(info:T, <span class="attr">id</span>:<span class="built_in">number</span>):<span class="built_in">boolean</span>;</span><br><span class="line">       <span class="keyword">delete</span>(id:<span class="built_in">number</span>):<span class="built_in">boolean</span>;</span><br><span class="line">       get(id:<span class="built_in">number</span>):<span class="built_in">any</span>[];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义一个操作mysql的类，注意 要实现泛型接口 这个类也应该一定是个泛型类</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MysqlDb</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">DBI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   add(info:T): <span class="built_in">boolean</span>&#123;</span><br><span class="line">       log(info);</span><br><span class="line">       &#125;</span><br><span class="line">       update...</span><br><span class="line">       <span class="keyword">delete</span>...</span><br><span class="line">       get...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 操作数据表，定义一个User类和数据库进行映射，并进行MySql数据的插入操作</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">   username:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       password:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> u = <span class="keyword">new</span> User();</span><br><span class="line">   u.username = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">   u.password=<span class="string">&quot;213&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> oMysql = <span class="keyword">new</span> MysqlDb&lt;User&gt;();<span class="comment">// 声明User类型参数</span></span><br><span class="line">   oMysql.add(u);<span class="comment">// 插入</span></span><br></pre></td></tr></table></figure><h3 id="模块">模块</h3><p>概念：</p><ul><li>把一些公共的功能单独抽离成一个文件作为一个模块</li><li>模块里面的变量 函数 类等默认都是私有的，如果我们要在外部访问模块内的数据（函数、变量、类）</li><li>我们就需要通过export暴露模块里面的数据</li><li>然后其他地方通过import引入模块就可以使用模块内的数据</li></ul><p>模块暴露export：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  方式一</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; a &#125;</span><br></pre></td></tr></table></figure><p>模块导入import:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, a <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">a();</span><br><span class="line">alias();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模块默认导出default，一个模块只能用一次<br>暴露：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引入(不用花括号)：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">a();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DB库用模块化封装// 省略了，代码比较简单</p><h3 id="TS命名空间">TS命名空间</h3><blockquote><p>内部模块，主要用于组织代码，避免命名冲突，<br>个人理解：模块之中再分模块<br>定义模块、并导出不同命名空间：</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="keyword">interface</span> Animal&#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        eat(): <span class="built_in">void</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">export</span> Class Dog <span class="keyword">implements</span> Animal&#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        eat:<span class="function"><span class="title">void</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            log(<span class="built_in">this</span>.name +<span class="string">&quot;在空间A中吃狗粮&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> B&#123;</span><br><span class="line">    <span class="keyword">interface</span> Animal&#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        eat(): <span class="built_in">void</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">export</span> Class Dog <span class="keyword">implements</span> Animal&#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        eat:<span class="function"><span class="title">void</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            log(<span class="built_in">this</span>.name +<span class="string">&quot;在空间A中吃狗粮&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>调用：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> A.Dog(<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">d.eat();<span class="comment">// 小黑在空间A中吃狗粮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> B.Dog(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line">dog.eat(); <span class="comment">// 小花在空间B中吃狗粮</span></span><br></pre></td></tr></table></figure><h3 id="装饰器">装饰器</h3><p>定义：</p><ul><li>装饰器是一种特殊类型的声明，他能够被附加到类声明，方法，属性或者参数上，可以修改类的行为。</li><li>通俗的将装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。</li><li>常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器</li><li>装饰器的写法：普通装饰器（无法传参）、装饰器工厂（可传参）</li><li>装饰器是过去几年中js最大的成就之一，已经是ES7的标准特性之一</li></ul><h4 id="类装饰器：普通装饰器">类装饰器：普通装饰器</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">    <span class="comment">// params就是当前类</span></span><br><span class="line">    params.prototype.apiUrl = <span class="string">&quot;动态扩展的属性&quot;</span>;</span><br><span class="line">    params.prototype.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我是一个run方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@logClass</span>  <span class="comment">// 类装饰器，普通装饰器，无法传参，默认吧class传入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类装饰器：装饰器工厂">类装饰器：装饰器工厂</h4><p>作用：</p><ol><li>修改构造函数</li><li>扩展类属性和方法<br>定义：</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">params:<span class="built_in">string</span></span>)</span>&#123;<span class="comment">// params是下方传过来的参数</span></span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span></span>)</span>&#123;<span class="comment">// target相当于是默认传过来的</span></span><br><span class="line">           log(target);</span><br><span class="line">           log(params);</span><br><span class="line">           target.prototype.apiUrl = params;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@logClass</span>(<span class="string">&quot;https://baidu.com&quot;</span>)<span class="comment">// 可以传参</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> http:<span class="built_in">any</span> = <span class="keyword">new</span> HttpClient();</span><br><span class="line">   <span class="built_in">console</span>.log(http.apiUrl);<span class="comment">// https://baidu.com</span></span><br><span class="line"></span><br><span class="line">可以修改构造函数的写法</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">target:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">       log(target);</span><br><span class="line">       <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">target</span></span>&#123;</span><br><span class="line">           apiUrl:<span class="built_in">any</span> = <span class="string">&quot;我是修改后的新数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="built_in">this</span>.apiUrl = <span class="built_in">this</span>.apiUrl + <span class="string">&quot;----&quot;</span>;</span><br><span class="line">               log(<span class="built_in">this</span>.apiUrl);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@logClass</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> apiUrl:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.apiUrl = <span class="string">&quot;我是构造函数里面的apiUrl&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           log(<span class="built_in">this</span>.apiUrl)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> http= <span class="keyword">new</span> HttpClient();</span><br><span class="line">   http.getData();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="属性装饰器">属性装饰器</h4><p>作用：</p><ol><li>可以给属性赋值</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">params:<span class="built_in">string</span></span>)</span>&#123;<span class="comment">// params是下方传过来的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span></span>)</span>&#123;<span class="comment">// target相当于是默认传过来的</span></span><br><span class="line">        log(target);</span><br><span class="line">        log(params);</span><br><span class="line">        target.prototype.apiUrl = params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProperty</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 固定写法，参数中，target为类对象，attr为参数名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, attr:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(target);</span><br><span class="line">        log(attr);</span><br><span class="line">        target[attr] = params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@logClass</span>(<span class="string">&quot;https://baidu.com&quot;</span>)<span class="comment">// 可以传参</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个属性修饰器的作用就是给url赋值初始值</span></span><br><span class="line">    <span class="meta">@logProperty</span>(<span class="string">&quot;http://baidu.com&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> url:<span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http:<span class="built_in">any</span> = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="built_in">console</span>.log(http.apiUrl);<span class="comment">// https://baidu.com</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法装饰器">方法装饰器</h4><p>用的是最多的</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, desc:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(target); <span class="comment">// 类属性</span></span><br><span class="line">        log(methodName); <span class="comment">// 方法名字 getData</span></span><br><span class="line">        log(desc); <span class="comment">// 方法的描述，desc.value是方法描述</span></span><br><span class="line">        target.apiUrl = <span class="string">&quot;xxx&quot;</span>; <span class="comment">// 修改雷属性</span></span><br><span class="line">        target.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            log(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> url:<span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@get</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        log(<span class="built_in">this</span>.url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http:<span class="built_in">any</span> = <span class="keyword">new</span> HttpClient();</span><br><span class="line">log(http.apiUrl); <span class="comment">// https://www.baidu.com‘</span></span><br><span class="line">http.run(); <span class="comment">// log run</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修改当前的方法（主要作用是装饰方法，并把方法的参数给变换类型）：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法装饰其主要作用就是把参数都给格式化成string类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, desc:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(target); <span class="comment">// 类属性 </span></span><br><span class="line">        log(methodName); <span class="comment">// 方法名字 getData</span></span><br><span class="line">        log(desc.value); <span class="comment">// 方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想修改下方法，装饰一下，让他们的所有参数变成string类型，并且打印出来</span></span><br><span class="line">        <span class="keyword">var</span> oMethod = desc.value;</span><br><span class="line">        desc.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args:<span class="built_in">any</span>[]</span>)</span>&#123;</span><br><span class="line">            args = args.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">String</span>(value);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用apply进行对象冒充，对getdata进行修改，如果没有apply就相当于是把getData方法给替换掉了</span></span><br><span class="line"></span><br><span class="line">            oMethod.apply(<span class="built_in">this</span>, args);<span class="comment">// this就是指function(...args:any[])这个函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> url:<span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@get</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params">...args:<span class="built_in">any</span>[]</span>)</span>&#123;</span><br><span class="line">        log(args);</span><br><span class="line">        log(<span class="string">&quot;我是getData方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http:<span class="built_in">any</span> = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.get(<span class="number">123</span>,<span class="string">&quot;xxx&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 就会先打印[&quot;123&quot;, &quot;xxx&quot;]后打印 我是getData方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法参数装饰器">方法参数装饰器</h4><p>用的比较少，类装饰器也可以实现这个功能</p><ul><li>运行时候当做函数被调用，可以使用参数张诗琪为累的原型增加一些元素数据，传入下列三个参数：</li><li>1对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li><li>2方法的名字</li><li>3参数在函数参数列表中的索引</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logParams</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, paramsIndex:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(params);<span class="comment">// xxxx</span></span><br><span class="line">        log(target); <span class="comment">// 原型对象</span></span><br><span class="line">        log(methodName);<span class="comment">// getData</span></span><br><span class="line">        log(paramsIndex); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> url:<span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"><span class="meta">@logParams</span>(<span class="string">&quot;xxxx&quot;</span>) uuid:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(uuid); <span class="comment">// iii</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> HttpClient();</span><br><span class="line">a.getData(<span class="string">&quot;iii&quot;</span>);</span><br><span class="line"></span><br><span class="line">先后输出：</span><br><span class="line"><span class="number">1.</span> xxxx</span><br><span class="line"><span class="number">2.</span> 原型对象</span><br><span class="line"><span class="number">3.</span> getData</span><br><span class="line"><span class="number">4.</span> <span class="number">0</span> </span><br><span class="line"><span class="number">5.</span> iii</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="装饰器执行顺序">装饰器执行顺序</h4><p>当存在  多个装饰器时候：</p><ul><li><p>执行优先级：属性装饰器&gt;方法装饰器&gt;方法参数装饰器&gt;类装饰器</p></li><li><p>如果有多个同样的装饰器，它会先从后边执行</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;TypeScript学习笔记&quot;&gt;TypeScript学习笔记&lt;/h3&gt;
&lt;h3 id=&quot;TS简介&quot;&gt;TS简介&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Ts微软开发，包含ES6、包含ES5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译 tsc xx.ts&lt;br&gt;</summary>
      
    
    
    
    <category term="Front End" scheme="https://lebronchao.com/categories/Front-End/"/>
    
    
    <category term="Web开发" scheme="https://lebronchao.com/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Front End" scheme="https://lebronchao.com/tags/Front-End/"/>
    
    <category term="TypeScript" scheme="https://lebronchao.com/tags/TypeScript/"/>
    
    <category term="JavaScript超集" scheme="https://lebronchao.com/tags/JavaScript%E8%B6%85%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统 | 第八章 数据库编程</title>
    <link href="https://lebronchao.com/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
    <id>https://lebronchao.com/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</id>
    <published>2021-01-21T02:31:24.000Z</published>
    <updated>2021-01-21T06:54:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="嵌入式SQL">嵌入式SQL</h2><ul><li>SQL语言提供了两种不同的使用方式<ul><li>交互式</li><li>嵌入式</li></ul></li><li>为什么要引入嵌入式SQL<ul><li>SQL语言是非过程性语言</li><li>事务处理应用需要高级语言</li></ul></li><li>这两种方式细节上有差别，在程序设计的环境下，SQL语句要做某些必要的扩充</li></ul><h3 id="嵌入式SQL的处理过程">嵌入式SQL的处理过程</h3><ul><li><p>主语言<br>嵌入式SQL是将SQL语句嵌入程序设计语言中，被嵌入的程序设计语言，如C、C++、Java，称为宿主语言，简称主语言。</p></li><li><p>处理过程<br>预编译方法</p></li><li><p>为了区分SQL语句与主语言语句，所有SQL语句必须加前缀EXEC SQL，</p><ul><li><p>主语言为C语言时，语句格式：<br>EXEC SQL &lt;SQL语句&gt;;</p></li><li><p>主语言为Java语言时，语句格式：<br># SQL &lt;SQL语句&gt;;</p></li><li><p>主语言为C++语言时</p><p>使用ADO：</p></li></ul></li></ul><h3 id="嵌入式SQL语句与主语言之间的通信">嵌入式SQL语句与主语言之间的通信</h3><ul><li><p>将SQL嵌入到高级语言中混合编程，程序中会含有两种不同计算模型的语句</p><ul><li>SQL语句<br>描述性的面向集合的语句<br>负责操纵数据库</li><li>高级语言语句<br>过程性的面向记录的语句<br>负责控制逻辑流程</li><li>它们之间应该如何通信？</li></ul></li><li><p>数据库工作单元与源程序工作单元之间的通信<br>（1）向主语言传递SQL语句的执行状态信息，使主语言能够据此控制程序流程，主要用SQL通信区实现<br>（2）主语言向SQL语句提供参数，主要用主变量实现<br>（3）将SQL语句查询数据库的结果交主语言处理，主要用主变量和游标实现</p></li><li><p>SQLCA： SQL Communication Area<br>SQLCA是一个数据结构</p></li><li><p>SQLCA的用途</p><ul><li>SQL语句执行后，系统反馈给应用程序信息<br>描述系统当前工作状态<br>描述运行环境</li><li>这些信息将送到SQL通信区中</li><li>应用程序从SQL通信区中取出这些状态信息，据此决定接下来执行的语句</li></ul></li><li><p>SQLCA使用方法</p><ul><li>定义SQLCA<ul><li>用EXEC SQL INCLUDE SQLCA定义</li></ul></li><li>使用SQLCA<ul><li>SQLCA中有一个存放每次执行SQL语句后返回代码的变量SQLCODE</li><li>如果SQLCODE等于预定义的常量SUCCESS，则表示SQL语句成功，否则表示出错</li><li>应用程序每执行完一条SQL 语句之后都应该测试一下SQLCODE的值，以了解该SQL语句执行情况并做相应处理</li></ul></li></ul></li><li><p>主变量</p><ul><li>嵌入式SQL语句中可以使用主语言的程序变量来输入或输出数据</li><li>在SQL语句中使用的主语言程序变量简称为主变量（Host Variable）</li></ul></li><li><p>主变量的类型</p><ul><li>输入主变量<br>由应用程序对其赋值，SQL语句引用</li><li>输出主变量<br>由SQL语句对其赋值或设置状态信息，返回给应用程序</li></ul></li><li><p>指示变量</p><ul><li>是一个整型变量，用来“指示”所指主变量的值或条件</li><li>一个主变量可以附带一个指示变量（Indicator Variable）</li><li>指示变量的用途<ul><li>指示输入主变量是否为空值</li><li>检测输出变量是否为空值，值是否被截断</li></ul></li></ul></li><li><p>在SQL语句中使用主变量和指示变量的方法<br>说明主变量和指示变量<br>BEGIN DECLARE SECTION<br>…<br>…  （说明主变量和指示变量）<br>…<br>END DECLARE SECTION</p></li><li><p>在SQL语句中使用主变量和指示变量的方法（续）</p><ul><li>使用主变量<br>说明之后的主变量可以在SQL语句中任何一个能够使用表达式的地方出现<br>为了与数据库对象名（表名、视图名、列名等）区别，SQL语句中的主变量名前要加冒号（:）作为标志</li><li>使用指示变量<br>指示变量前也必须加冒号标志<br>必须紧跟在所指主变量之后</li></ul></li><li><p>在SQL语句之外（主语言语句中）使用主变量和指示变量的方法<br>可以直接引用，不必加冒号</p></li><li><p>为什么要使用游标</p><ul><li>SQL语言与主语言具有不同数据处理方式</li><li>SQL语言是面向集合的，一条SQL语句原则上可以产生或处理多条记录</li><li>主语言是面向记录的，一组主变量一次只能存放一条记录</li><li>仅使用主变量并不能完全满足SQL语句向应用程序输出数据的要求</li><li>嵌入式SQL引入了游标的概念，用来协调这两种不同的处理方式</li></ul></li><li><p>游标</p><ul><li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果</li><li>每个游标区都有一个名字</li><li>用户可以用SQL语句逐一从游标中获取记录，并赋给主变量，交由主语言进一步处理</li></ul></li><li><p>建立数据库连接<br>EXEC SQL CONNECT TO target[AS connection-name][USER user-name];<br>target是要连接的数据库服务器<br>常见的服务器标识串，如<dbname>@<hostname>:<port><br>包含服务器标识的SQL串常量<br>DEFAULT</p></li><li><p>connect-name是可选的连接名，连接名必须是一个有效的标识符</p></li><li><p>在整个程序内只有一个连接时可以不指定连接名</p></li><li><p>程序运行过程中可以修改当前连接<br>EXEC SQL SET CONNECTION connection-name<br>|DEFAULT;</p></li><li><p>关闭数据库连接<br>EXEC SQL DISCONNECT [connection];</p></li></ul><h3 id="不用游标的SQL语句">不用游标的SQL语句</h3><ul><li>不用游标的SQL语句的种类<ul><li>说明性语句</li><li>数据定义语句</li><li>数据控制语句</li><li>查询结果为单记录的SELECT语句</li><li>非CURRENT形式的增删改语句</li></ul></li></ul><h3 id="使用游标的SQL语句">使用游标的SQL语句</h3><ul><li>必须使用游标的SQL语句<ul><li>查询结果为多条记录的SELECT语句</li><li>CURRENT形式的UPDATE语句</li><li>CURRENT形式的DELETE语句</li></ul></li></ul><h3 id="动态SQL">动态SQL</h3><ul><li>静态嵌入式SQL<br>静态嵌入式SQL语句能够满足一般要求<br>无法满足要到执行时才能够确定要提交的SQL语句、查询的条件</li><li>动态嵌入式SQL<br>允许在程序运行过程中临时“组装”SQL语句<br>支持动态组装SQL语句和动态参数两种形式</li></ul><ol><li><p>使用SQL语句主变量</p></li><li><p>动态参数执行准备好的语句（EXECUTE）</p></li><li><p>动态参数</p></li></ol><ul><li><p>主变量</p></li><li><p>[例8.6]  创建基本表TEST。</p><p>​EXEC SQL BEGIN DECLARE SECTION;<br>​       const char *stmt=“CREATE TABLE test(a int);”;<br>​               /<em>SQL语句主变量，内容是创建表的SQL语句</em>/<br>​EXEC SQL END DECLARE SECTION;<br>​    …<br>​EXEC SQL EXECUTE IMMEDIATE :stmt;<br>​               /<em>执行动态SQL语句</em>/</p></li><li><p>动态参数</p><ul><li>SQL语句中的可变元素</li><li>使用参数符号（?）表示该位置的数据在运行时设定</li><li>和主变量的区别<ul><li>动态参数的输入不是编译时完成绑定</li><li>而是通过 PREPARE语句准备主变量和执行语句EXECUTE绑定数据或主变量来完成</li></ul></li></ul></li><li><p>使用动态参数的步骤<br>（1）声明SQL语句主变量<br>（2）准备SQL语句（PREPARE）<br>EXEC SQL PREPARE &lt;语句名&gt;<br>FROM &lt;SQL语句主变量&gt;;</p><p>EXEC SQL EXECUTE &lt;语句名&gt;<br>[INTO &lt;主变量表&gt;]<br>[USING &lt;主变量或常量&gt;];</p></li><li><p>准备好的SQL</p></li><li><p>[例8.7] 向TEST中插入元组。<br>EXEC SQL BEGIN DECLARE SECTION;<br>const char *stmt = “INSERT INTO test VALUES(?);”;<br>/*声明SQL主变量内容是INSERT语句 */<br>EXEC SQL END DECLARE SECTION;<br>…<br>EXEC SQL PREPARE mystmt FROM :stmt; /<em>准备语句</em>/<br>…<br>EXEC SQL EXECUTE mystmt USING 100;<br>/*执行语句，设定INSERT语句插入值100 <em>/<br>EXEC SQL EXECUTE mystmt USING 200;<br>/</em> 执行语句，设定INSERT语句插入值200 */</p></li></ul><h2 id="过程化SQL">过程化SQL</h2><h3 id="过程化SQL的块结构">过程化SQL的块结构</h3><ul><li><p>SQL的扩展</p><ul><li>增加了过程化语句功能</li><li>基本结构是块</li><li>块之间可以互相嵌套</li><li>每个块完成一个逻辑操作</li></ul></li><li><p>过程化SQL块的基本结构</p><ol><li><p>定义部分<br>DECLARE 变量、常量、游标、异常等<br>定义的变量、常量等只能在该基本块中使用<br>当基本块执行结束时，定义就不再存在</p></li><li><p>执行部分<br>BEGIN</p><p>SQL语句、过程化SQL的流程控制语句</p></li></ol><p>EXCEPTION<br>异常处理部分        <br>END；</p></li></ul><h3 id="变量和常量的定义">变量和常量的定义</h3><ol><li>变量定义<br>变量名 数据类型 [[NOT NULL]:=初值表达式]或<br>变量名 数据类型 [[NOT NULL] 初值表达式]</li><li>常量定义<br>常量名 数据类型 CONSTANT :=常量表达式<br>常量必须要给一个值，并且该值在存在期间或常量的作用域内不能改变。如果试图修改它，过程化SQL将返回一个异常</li><li>赋值语句<br>变量名称 :=表达式</li></ol><h3 id="流程控制">流程控制</h3><p>过程化SQL功能</p><ol><li><p>条件控制语句</p></li><li><p>循环控制语句</p></li><li><p>错误处理</p></li></ol><ul><li><p>条件控制语句<br>IF-THEN，IF-THEN-ELSE和嵌套的IF语句<br>（1）IF condition THEN<br>Sequence_of_statements;<br>END IF;<br>（2）IF condition THEN<br>Sequence_of_statements1;<br>ELSE<br>Sequence_of_statements2;<br>END IF;<br>（3）在THEN和ELSE子句中还可以再包含IF语句，即IF语句可以嵌套</p></li><li><p>循环控制语句<br>LOOP，WHILE-LOOP和FOR-LOOP<br>（1）简单的循环语句LOOP<br>LOOP<br>Sequence_of_statements;<br>END LOOP;<br>多数数据库服务器的过程化SQL都提供EXIT、BREAK或<br>LEAVE等循环结束语句，保证LOOP语句块能够结束</p><p>（2）WHILE-LOOP<br>WHILE condition LOOP<br>Sequence_of_statements;<br>END LOOP;<br>每次执行循环体语句之前，首先对条件进行求值<br>如果条件为真，则执行循环体内的语句序列<br>如果条件为假，则跳过循环并把控制传递给下一个语句</p><p>（3）FOR-LOOP<br>FOR count IN [REVERSE] bound1 … bound2 LOOP<br>Sequence_of_statements;<br>END LOOP;</p></li><li><ol start="3"><li>错误处理</li></ol><ul><li>如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句</li><li>SQL标准对数据库服务器提供什么样的异常处理做出了建议，要求过程化SQL管理器提供完善的异常处理机制</li></ul></li></ul><h2 id="存储过程和函数">存储过程和函数</h2><h3 id="存储过程">存储过程</h3><ul><li><p>过程化SQL块类型</p><ul><li>命名块<br>编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块</li><li>匿名块<br>每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用</li></ul></li><li><p>存储过程：</p><p>由过程化SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只要调用即可。</p><ul><li>存储过程的优点<br>（1）运行效率高<br>（2）降低了客户机和服务器之间的通信量<br>（3）方便实施企业规则</li></ul></li><li><p>存储过程的用户接口<br>（1）创建存储过程<br>（2）执行存储过程<br>（3）修改存储过程<br>（4）删除存储过程</p></li><li><p>（1）创建存储过程<br>CREATE OR REPLACE PROCEDURE 过程名([参数1,参数2,…]) AS &lt;过程化SQL块&gt;；<br>过程名：数据库服务器合法的对象标识<br>参数列表：用名字来标识调用时给出的参数值，必须指定值的数据类型。参数也可以定义输入参数、输出参数或输入/输出参数，默认为输入参数<br>过程体：是一个&lt;过程化SQL块&gt;，包括声明部分和可执行语句部分</p></li><li><p>[例8.8] 利用存储过程来实现下面的应用：从账户1转指定数额的款项到账户2中。</p><p>​CREATE OR REPLACE PROCEDURE TRANSFER(inAccount INT,outAccount  INT,amount FLOAT)<br>​       /<em>定义存储过程TRANSFER，其参数为转入账户、转出账户、转账额度</em>/<br>​AS DECLARE/<em>定义变量</em>/<br>​        totalDepositOut Float;<br>​             totalDepositIn Float;<br>​inAccountnum INT;</p><p>BEGIN                             /*检查转出账户的余额 */<br>SELECT Total INTO totalDepositOut FROM Accout<br>WHERE accountnum=outAccount;<br>IF totalDepositOut IS NULL THEN<br>/<em>如果转出账户不存在或账户中没有存款</em>/<br>ROLLBACK;    /<em>回滚事务</em>/<br>RETURN;<br>END IF;</p><p>IF totalDeposit Out&lt; amount THEN    /<em>如果账户存款不足</em>/<br>ROLLBACK; /<em>回滚事务</em>/<br>RETURN;<br>END IF;</p><p>SELECT Accountnum INTO inAccountnum FROM Account<br>WHERE accountnum=inAccount;</p><p>IF inAccount IS NULL THEN  /<em>如果转入账户不存在</em>/<br>ROLLBACK;           /<em>回滚事务</em>/<br>RETURN;<br>ENDIF;</p><p>UPDATE Account SET total=total-amount WHERE accountnum=outAccount;<br>/* 修改转出账户余额，减去转出额 <em>/<br>UPDATE Account SET total=total + amount<br>WHERE   accountnum=inAccount;<br>/</em> 修改转入账户余额，增加转入额 <em>/<br>COMMIT;                       /</em> 提交转账事务 */<br>END;</p></li><li><p>（2）执行存储过程<br>CALL/PERFORM  PROCEDURE 过程名([参数1,参数2,…])；<br>使用CALL或者PERFORM等方式激活存储过程的执行<br>在过程化SQL中，数据库服务器支持在过程体中调用其他存储过程</p></li><li><p>[例8.9] 从账户01003815868转10000元到01003813828账户中。<br>CALL PROCEDURE TRANSFER(01003813828,01003815868,10000);</p></li><li><p>（3）修改存储过程<br>ALTER PROCEDURE 过程名1  RENAME TO 过程名2;</p></li><li><p>（4）删除存储过程<br>DROP  PROCEDURE 过程名()；</p></li></ul><h3 id="函数">函数</h3><ul><li>函数和存储过程的异同<br>同：都是持久性存储模块<br>异：函数必须指定返回的类型</li></ul><ol><li>函数的定义语句格式<br>CREATE OR REPLACE FUNCTION 函数名 ([参数1,参数2,…]) RETURNS &lt;类型&gt;  AS &lt;过程化SQL块&gt;;</li><li>函数的执行语句格式<br>CALL/SELECT 函数名 ([参数1,参数2,…]);</li><li>修改函数<br>重命名<br>ALTER FUNCTION 过程名1 RENAME TO 过程名2;<br>重新编译<br>ALTER FUNCTION 过程名 COMPILE;</li></ol><p>存储过程：</p><ul><li>优点：<ul><li>有if/else,case,while等控制语句，通过编写存储过程，可以实现一些逻辑比较复杂的功能；</li><li>模块化；对一些功能进行了封装，代码的复用；</li><li>响应速度快，只有在首次执行时需要经过编译和优化步骤，后被调用直接执行，省去了重新编写代码计算的步骤。</li><li>减少网络传输。存储过程直接就在数据库服务器上跑，所有的数据访问都在服务器内部进行，不需要传输数据到其它终端。</li><li>方便DBA优化。所有的SQL集中在一个地方</li></ul></li><li>缺点：<br>复杂的业务逻辑。没办法应用缓存。</li></ul><p>触发器</p><ul><li>优点：<ul><li>安全。以基于数据库的值使用户具有操作数据库的某种权利。可以跟踪用户对数据库的操作。</li><li>触发器能够拒绝或回退那些破坏相关完整性的变化，取消试图进行数据更新的事务。当插入一个与其主健不匹配的外部键时，这种触发器会起作用。</li></ul></li><li>缺点：*数据集数据量又较大时，触发器效果会非常低（因为自动计算数据值，需要变动整个数据集导致效率下降）<ul><li>对于批量操作并不适合使用触发器，使用触发器实现的业务逻辑在出现问题时很难进行定位。</li></ul></li></ul><h2 id="ODBC编程">ODBC编程</h2><ul><li>ODBC优点<ul><li>移植性好</li><li>能同时访问不同的数据库</li><li>共享多个数据资源</li></ul></li></ul><h3 id="ODBC概述">ODBC概述</h3><ul><li><p>ODBC产生的原因</p><ul><li>由于不同的数据库管理系统的存在，在某个关系数据库管理系统下编写的应用程序就不能在另一个关系数据库管理系统下运行</li><li>许多应用程序需要共享多个部门的数据资源，访问不同的关系数据库管理系统</li></ul></li><li><p>ODBC</p><ul><li>是微软公司开放服务体系（Windows Open Services Architecture，WOSA）中有关数据库的一个组成部分</li><li>提供了一组访问数据库的应用程序编程接口（Application Programming Interface，API ）</li></ul></li><li><p>ODBC约束力</p><ul><li>规范应用开发</li><li>规范关系数据库管理系统应用接口</li></ul></li></ul><h3 id="ODBC工作原理概述">ODBC工作原理概述</h3><ul><li><p>ODBC应用系统的体系结构</p><ol><li><p>用户应用程序</p></li><li><p>ODBC驱动程序管理器</p></li><li><p>数据库驱动程序</p></li><li><p>数据源</p></li></ol></li><li><p>ODBC应用程序包括的内容</p><ul><li>请求连接数据库</li><li>向数据源发送SQL语句</li><li>为SQL语句执行结果分配存储空间，定义所读取的数据格式</li><li>获取数据库操作结果或处理错误</li><li>进行数据处理并向用户提交处理结果</li><li>请求事务的提交和回滚操作</li><li>断开与数据源的连接</li></ul></li><li><p>驱动程序管理器：用来管理各种驱动程序</p><ul><li>包含在ODBC32.DLL中</li><li>管理应用程序和驱动程序之间的通信</li><li>建立、配置或删除数据源，并查看系统当前所安装的数据库ODBC驱动程序</li></ul></li><li><p>主要功能：</p><ul><li>装载ODBC驱动程序</li><li>选择和连接正确的驱动程序</li><li>管理数据源</li><li>检查ODBC调用参数的合法性</li><li>记录ODBC函数的调用等</li></ul></li><li><p>ODBC驱动程序类型</p><ul><li>单束<br>数据源和应用程序在同一台机器上<br>驱动程序直接完成对数据文件的I/O操作<br>驱动程序相当于数据管理器</li><li>多束<br>支持客户机—服务器、客户机—应用服务器/数据库服务器等网络环境下的数据访问<br>由驱动程序完成数据库访问请求的提交和结果集接收<br>应用程序使用驱动程序提供的结果集管理接口操纵执行后的结果数据</li></ul></li><li><p>数据源：是最终用户需要访问的数据，包含了数据库位置和数据库类型等信息，是一种数据连接的抽象</p></li><li><p>数据源对最终用户是透明的</p><ul><li>ODBC给每个被访问的数据源指定唯一的数据源名（Data Source Name，简称DSN），并映射到所有必要的、用来存取数据的低层软件</li><li>在连接中，用数据源名来代表用户名、服务器名、所连接的数据库名等</li><li>最终用户无须知道数据库管理系统或其他数据管理软件、网络以及有关ODBC驱动程序的细节</li></ul></li><li><p>例如，假设某个学校在SQL Server和KingbaseES上创建了两个数据库：学校人事数据库和教学科研数据库。<br>学校的信息系统要从这两个数据库中存取数据<br>为了方便地与两个数据库连接，为学校人事数据库创建一个数据源名PERSON，为教学科研数据库创建一个名为EDU的数据源<br>当要访问每一个数据库时，只要与PERSON和EDU连接即可，不需要记住使用的驱动程序、服务器名称、数据库名</p></li></ul><h3 id="ODBC-API基础">ODBC API基础</h3><ul><li><p>ODBC 应用程序编程接口的一致性</p><ul><li>API一致性<br>包含核心级、扩展1级、扩展2级</li><li>语法一致性<br>包含最低限度SQL语法级、核心SQL语法级、扩展SQL语法级</li></ul></li><li><ol><li><p>函数概述</p></li><li><p>句柄及其属性</p></li><li><p>数据类型</p></li></ol></li><li><p>ODBC 3.0 标准提供了76个函数接口</p><ul><li>分配和释放环境句柄、连接句柄、语句句柄</li><li>连接函数（SQLDriverconnect等）</li><li>与信息相关的函数（SQLGetinfo、SQLGetFuction等）</li><li>事务处理函数（如SQLEndTran）</li><li>执行相关函数（SQLExecdirect、SQLExecute等）</li><li>编目函数，ODBC 3.0提供了11个编目函数，如SQLTables、SQLColumn等。应用程序可以通过对编目函数的调用来获取数据字典的信息，如权限、表结构等</li></ul></li><li><p>句柄是32位整数值，代表一个指针</p></li><li><p>ODBC 3.0中句柄分类</p><ul><li>环境句柄</li><li>连接句柄</li><li>语句句柄</li><li>描述符句柄</li></ul></li><li><p>应用程序句柄之间的关系（续）</p><ul><li>在一个连接中可以建立多个语句句柄，它不只是一个SQL语句，还包括SQL语句产生的结果集以及相关的信息等</li><li>在ODBC 3.0中又提出了描述符句柄的概念，它是描述SQL语句的参数、结果集列的元数据集合</li></ul></li><li><p>ODBC数据类型</p><ul><li>SQL数据类型：用于数据源</li><li>C数据类型 ：用于应用程序的C代码</li></ul></li><li><p>应用程序可以通过SQLGetTypeInfo来获取不同的驱动程序对于数据类型的支持情况</p></li><li><p>[例8.11] 将KingbaseES数据库中Student表的数据备份到SQL Server数据库中。</p><ul><li>该应用涉及两个不同的关系数据库管理系统中的数据源</li><li>使用ODBC来开发应用程序，只要改变应用程序中连接函数（SQLConnect）的参数，就可以连接不同关系数据库管理系统的驱动程序，连接两个数据源</li></ul></li><li><p>操作步骤</p><ol><li><p>配置数据源</p></li><li><p>初始化环境</p></li><li><p>建立连接</p></li><li><p>分配语句句柄</p></li><li><p>执行SQL语句</p></li><li><p>结果集处理</p></li><li><p>中止处理</p></li></ol></li><li><p>应用程序中止步骤</p><ul><li>释放语句句柄</li><li>释放数据库连接</li><li>与数据库服务器断开</li><li>释放ODBC环境</li></ul></li></ul><h2 id="小结">小结</h2><ul><li>嵌入式SQL把SQL语句嵌入到某种高级语言中</li><li>SQL与主语言具有不同的数据处理方式</li><li>本章讲解了以下内容<ul><li>嵌入式SQL</li><li>过程化SQL</li><li>存储过程和函数</li><li>ODBC编程</li></ul></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;嵌入式SQL&quot;&gt;嵌入式SQL&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SQL语言提供了两种不同的使用方式
&lt;ul&gt;
&lt;li&gt;交互式&lt;/li&gt;
&lt;li&gt;嵌入式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为什么要引入嵌入式SQL
&lt;ul&gt;
&lt;li&gt;SQL语言是非过程性语言&lt;/li</summary>
      
    
    
    
    <category term="数据库" scheme="https://lebronchao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库" scheme="https://lebronchao.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="SQL" scheme="https://lebronchao.com/tags/SQL/"/>
    
    <category term="后端" scheme="https://lebronchao.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统 | 第七章 数据库设计</title>
    <link href="https://lebronchao.com/2021/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>https://lebronchao.com/2021/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-01-20T02:31:24.000Z</published>
    <updated>2021-01-20T06:54:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重点和难点">重点和难点</h2><ul><li><p>重点：</p><p>掌握数据库设计步骤和数据库设计过程中的各级模式设计方法。特别是数据库概念结构的设计和逻辑结构的设计，这是数据库设计过程中最重要的两个环节。牢固掌握用E-R图来表示概念模型的方法，掌握E-R图的设计，E-R图向关系模型的转换。</p></li><li><p>难点：</p><p>技术上的难点是E-R图的设计和数据模型的优化，包括对现实世界进行抽象的能力，提取实体、属性、实体型之间的联系，正确划分实体与属性的能力。如何把第6章关系数据理论与本章结合，用关系数据理论指导数据库的逻辑设计。真正的难点是理论与实际的结合。</p></li></ul><h2 id="数据库设计概述">数据库设计概述</h2><ul><li>数据库设计<ul><li>数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</li><li>信息管理要求：在数据库中应该存储和管理哪些数据对象 。</li><li>数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。</li><li>数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境 。</li><li>高效率的运行环境<ul><li>数据库数据的存取效率高</li><li>数据库存储空间的利用率高</li><li>数据库系统运行管理的效率高</li></ul></li></ul></li></ul><h3 id="数据库设计的特点">数据库设计的特点</h3><ul><li><p>数据库建设的基本规律</p><ul><li>三分技术，七分管理，十二分基础数据</li><li>管理<ul><li>数据库建设项目管理</li><li>企业（即应用部门）的业务管理</li></ul></li><li>基础数据<ul><li>数据的收集、整理、组织和不断更新</li></ul></li></ul></li><li><p>结构（数据）设计和行为（处理）设计相结合</p><ul><li>将数据库结构设计和数据处理设计密切结合</li></ul></li><li><p>结构和行为分离的设计</p><ul><li>传统的软件工程：重 行为设计<br>忽视对应用中数据语义的分析和抽象，只要有可能就尽量推迟数据结构设计的决策</li><li>早期的数据库设计：重 结构设计<br>致力于数据模型和数据库建模方法研究，忽视了行为设计对结构设计的影响</li></ul></li></ul><h3 id="数据库设计方法">数据库设计方法</h3><ul><li><p>大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。</p></li><li><p>它要求多方面的知识和技术。主要包括：</p><ul><li>计算机的基础知识</li><li>软件工程的原理和方法</li><li>程序设计的方法和技巧</li><li>数据库的基本知识</li><li>数据库设计技术</li><li>应用领域的知识</li></ul></li><li><p>手工试凑法</p><ul><li>设计质量与设计人员的经验和水平有直接关系</li><li>缺乏科学理论和工程方法的支持，工程的质量难以保证</li><li>数据库运行一段时间后常常又不同程度地发现各种问题，增加了维护代价</li></ul></li><li><p>规范设计法</p><ul><li>手工设计方法</li><li>基本思想<br>过程迭代和逐步求精</li><li>典型方法<ul><li>新奥尔良（New Orleans）方法</li><li>基于E-R模型的数据库设计方法</li><li>3NF（第三范式）的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言（UML）方法</li></ul></li></ul></li></ul><h3 id="数据库设计的基本步骤">数据库设计的基本步骤</h3><ul><li><p>数据库设计分6个阶段</p><ul><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li></ul></li><li><p>需求分析和概念设计独立于任何数据库管理系统</p></li><li><p>逻辑设计和物理设计与选用的数据库管理系统密切相关</p></li><li><p>参加数据库设计的人员</p><ul><li>系统分析人员和数据库设计人员<br>自始至终参与数据库设计，其水平决定了数据库系统的质量</li><li>数据库管理员和用户代表<br>主要参加需求分析与数据库的运行和维护</li><li>应用开发人员<br>包括程序员和操作员<br>在实施阶段参与进来，分别负责编制程序和准备软硬件环境</li></ul></li></ul><ol><li><p>需求分析阶段<br>是否做得充分与准确，决定了构建数据库的速度和质量</p></li><li><p>概念结构设计阶段<br>通过对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型</p></li><li><p>逻辑结构设计阶段<br>将概念结构转换为某个数据库管理系统所支持的数据模型，并对其进行优化</p></li><li><p>物理结构设计阶段<br>为逻辑数据结构选取一个最适合应用环境的物理结构<br>包括存储结构和存取方法</p></li><li><p>数据库实施阶段<br>根据逻辑设计和物理设计的结果构建数据库<br>编写与调试应用程序<br>组织数据入库并进行试运行</p></li><li><p>数据库运行和维护阶段<br>经过试运行后即可投入正式运行<br>在运行过程中必须不断对其进行评估、调整与修改</p></li></ol><ul><li>设计一个完善的数据库应用系统 往往是上述6个阶段的不断反复</li><li>这个设计步骤既是数据库设计的过程，也包括了数据库应用系统的设计过程</li><li>把数据库的设计和对数据库中数据处理的设计紧密结合起来，将这两个方面的需求分析、抽象、设计、实现在各个阶段同时进行，相互参照，相互补充，以完善两方面的设计</li></ul><h2 id="需求分析">需求分析</h2><h3 id="需求分析的任务">需求分析的任务</h3><ul><li><p>需求分析就是分析用户的要求</p><ul><li>是设计数据库的起点</li><li>结果是否准确地反映了用户的实际要求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用</li></ul></li><li><p>详细调查现实世界要处理的对象（组织、部门、企业等）</p></li><li><p>充分了解原系统（手工系统或计算机系统）工作概况</p></li><li><p>明确用户的各种需求</p></li><li><p>在此基础上确定新系统的功能</p></li><li><p>新系统必须充分考虑今后可能的扩充和改变</p></li><li><p>调查的重点是“数据”和“处理”，获得用户对数据库的要求<br>（1）信息要求<br>用户需要从数据库中获得信息的内容与性质<br>由信息要求可以导出数据要求，即在数据库中需要存储哪些数据<br>（2）处理要求<br>用户要完成的处理功能<br>对处理性能的要求<br>（3）安全性与完整性要求</p></li><li><p>确定用户最终需求的难点</p><ul><li>用户缺少计算机知识，不能准确地表达自己的需求，他们所提出的需求往往不断地变化。</li><li>设计人员缺少用户的专业知识，不易理解用户的真正需求，甚至误解用户的需求</li></ul></li><li><p>解决方法</p><p>设计人员必须不断深入地与用户进行交流，才能逐步确定用户的实际需求</p></li></ul><h3 id="需求分析的方法">需求分析的方法</h3><ul><li>调查清楚用户的实际需求并进行初步分析</li><li>与用户达成共识</li><li>分析与表达这些需求</li></ul><p>（1）调查组织机构情况<br>（2）调查各部门的业务活动情况<br>（3）协助用户明确对新系统的各种要求，包括信息要求、处理要求、完全性与完整性要求<br>（4）确定新系统的边界</p><h4 id="常用调查方法">常用调查方法</h4><p>（1）跟班作业<br>通过亲身参加业务工作了解业务活动的情况<br>（2）开调查会<br>通过与用户座谈来了解业务活动情况及用户需求<br>（3）请专人介绍<br>（4）询问<br>对某些调查中的问题，可以找专人询问<br>（5）设计调查表请用户填写<br>调查表设计合理，则很有效<br>（6）查阅记录<br>查阅与原系统有关的数据记录</p><ul><li>分析方法<ul><li>结构化分析方法（Structured Analysis，简称SA方法）<ul><li>SA方法从最上层的系统组织机构入手</li><li>采用自顶向下、逐层分解的方式分析系统</li></ul></li></ul></li><li>对用户需求进行分析与表达后，需求分析报告必须提交给用户，征得用户的认可</li></ul><h3 id="数据字典">数据字典</h3><ul><li><p>数据字典是关于数据库中数据的描述，即元数据，不是数据本身</p></li><li><p>数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善</p></li><li><p>数据字典是进行详细的数据收集和数据分析所获得的主要结果</p></li><li><p>注意：<br>和关系数据库管理系统中数据字典的区别和联系</p></li><li><p>数据字典的内容</p><ul><li>数据项</li><li>数据结构</li><li>数据流</li><li>数据存储</li><li>处理过程</li></ul></li><li><p>数据项是数据的最小组成单位</p></li><li><p>若干个数据项可以组成一个数据结构</p></li><li><p>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容</p></li></ul><h3 id="需求分析小结">需求分析小结</h3><ul><li><p>把需求收集和分析作为数据库设计的第一阶段是十分重要的。</p></li><li><p>第一阶段收集的基础数据（用数据字典来表达）是下一步进行概念设计的基础。</p></li><li><p>强调两点</p><p>（1）设计人员应充分考虑到可能的扩充和改变，使设计易于更改，系统易于扩充<br>（2）必须强调用户的参与</p></li></ul><h2 id="概念结构设计">概念结构设计</h2><h3 id="概念模型">概念模型</h3><ul><li>将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计</li><li>概念模型的特点<br>（1）能真实、充分地反映现实世界，是现实世界的一个真实模型。<br>（2）易于理解，从而可以用它和不熟悉计算机的用户交换意见。<br>（3）易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充。<br>（4）易于向关系、网状、层次等各种数据模型转换</li><li>描述概念模型的工具<ul><li>E-R模型</li></ul></li></ul><h3 id="E-R模型">E-R模型</h3><ul><li><p>实体之间的联系<br>两个实体型之间的联系：<br>①一对一联系（1∶1）<br>②一对多联系（1∶n）<br>③多对多联系（m∶n）</p></li><li><p>一对一联系（1∶1）</p><ul><li>如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1∶1。</li><li>例如，学校里一个班级只有一个正班长，而一个班长只在一个班中任职，则班级与班长之间具有一对一联系。</li></ul></li><li><p>一对多联系（1∶n）</p><ul><li>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1∶n。</li><li>例如，一个班级中有若干名学生，而每个学生只在一个班级中学习，则班级与学生之间具有一对多联系。</li></ul></li><li><p>多对多联系（m∶n）</p><ul><li>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体集B具有多对多联系，记为m∶n。</li><li>例如，一门课程同时有若干个学生选修，而一个学生可以同时选修多门课程，则课程与学生之间具有多对多联系。</li></ul></li><li><p>联系的度：参与联系的实体型的数目</p><ul><li>2个实体型之间的联系度为2，也称为二元联系；</li><li>3个实体型之间的联系度为3，称为三元联系；</li><li>N个实体型之间的联系度为N，也称为N元联系</li></ul></li><li><p>E-R图</p><ul><li>E-R图提供了表示实体型、属性和联系的方法：<ul><li>实体型：用矩形表示，矩形框内写明实体名。</li><li>属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来。<br>例如，学生实体具有学号、姓名、性别、出生年份、系、入学时间等属性，用E-R图表示如图7.9所示</li></ul></li></ul></li></ul><h3 id="概念结构设计-2">概念结构设计</h3><ul><li>实体与属性的划分原则<ul><li>为了简化E-R图的处置，现实世界的事物能作为属性对待的，尽量作为属性对待。</li><li>两条准则：<ul><li>作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。</li><li>属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。</li></ul></li></ul></li></ul><h2 id="逻辑结构设计">逻辑结构设计</h2><h3 id="E-R图向关系模型的转换">E-R图向关系模型的转换</h3><ul><li><p>转换内容</p><ul><li>E-R图由实体型、实体的属性和实体型之间的联系三个要素组成</li><li>关系模型的逻辑结构是一组关系模式的集合</li><li>将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转化为关系模式</li></ul></li><li><p>转换原则</p><ul><li>一个实体型转换为一个关系模式。<ul><li>关系的属性：实体的属性</li><li>关系的码：实体的码</li></ul></li><li>实体型间的联系有以下不同情况<br>一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。<br>① 转换为一个独立的关系模式<br>关系的属性：与该联系相连的各实体的码以及联系本身的属性<br>关系的候选码：每个实体的码均是该关系的候选码</li><li>联系形成的关系独立存在：<br>职工（职工号，姓名，年龄）<br>产品（产品号，产品名，价格）<br>负责（职工号，产品号）</li><li>一个1:1联系的转换（续）<br>②与某一端实体对应的关系模式合并<br>合并后关系的属性：加入对应关系的码和联系本身的属性<br>合并后关系的码：不变</li><li>“负责”与“职工”两关系合并：<br>职工（职工号，姓名，年龄，产品号）<br>产品（产品号，产品名，价格）<br>也可以“负责”与“产品”两关系合并：<br>职工（职工号，姓名，年龄）<br>产品（产品号，产品名，价格，职工号）</li><li>一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。<br>①转换为一个独立的关系模式<br>关系的属性：与该联系相连的各实体的码以及联系本身的属性<br>关系的码：n端实体的码</li><li>联系形成的关系独立存在：<br>仓库（仓库号，地点，面积）<br>产品（产品号，产品名，价格）<br>仓储（产品号，仓库号，数量）</li><li>一个m:n联系转换为一个关系模式<br>关系的属性：与该联系相连的各实体的码以及联系本身的属性<br>关系的码：各实体码的组合<br>[例]“选修”联系是一个m:n联系，可以将它转换为如下关系模式，其中学号与课程号为关系的组合码：<br>　　  选修（学号，课程号，成绩）</li><li>三个或三个以上实体间的一个多元联系转换为一个关系模式。<br>关系的属性：与该多元联系相连的各实体的码以及联系本身的属性<br>关系的码：各实体码的组合</li><li>供应商（供应商号，供应商名，地址）<br>零件（零件号，零件名，单价）<br>产品（产品号，产品名，型号）<br>供应（供应商号，零件号，产品号，数量）</li></ul></li></ul><h3 id="数据模型的优化">数据模型的优化</h3><ul><li><p>一般的数据模型还需要向特定数据库管理系统规定的模型进行转换。</p></li><li><p>转换的主要依据是所选用的数据库管理系统的功能及限制。没有通用规则。</p></li><li><p>对于关系模型来说，这种转换通常都比较简单。</p></li><li><p>一般的数据模型还需要向特定数据库管理系统规定的模型进行转换。</p></li><li><p>转换的主要依据是所选用的数据库管理系统的功能及限制。没有通用规则。</p></li><li><p>对于关系模型来说，这种转换通常都比较简单。</p></li><li><p>优化数据模型的方法:<br>（1）确定数据依赖<br>按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间数据依赖。<br>（2）对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。</p><p>（3）按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。<br>（4）按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。</p><p>（5）对关系模式进行必要分解，提高数据操作效率和存储空间的利用率。</p><ul><li><p>常用分解方法</p></li><li><p>水平分解</p><ul><li><p>什么是水平分解<br>把(基本)关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。</p></li><li><p>如何分解</p><p>对符合80/20的，把经常被使用的数据（约20%）<br>水平分解出来，形成一个子关系。<br>水平分解为若干子关系，使每个事务存取的数据对应一个子关系。</p></li></ul></li><li><p>垂直分解</p><ul><li>什么是垂直分解<br>把关系模式R的属性分解为若干子集合，形成若干子关系模式。</li><li>垂直分解的原则<br>经常在一起使用的属性从R中分解出来形成一个子关系模式</li><li>垂直分解的优点<br>可以提高某些事务的效率</li><li>垂直分解的缺点<br>可能使另一些事务不得不执行连接操作，降低了效率</li></ul></li></ul></li><li><p>并不是规范化程度越高的关系就越优</p><ul><li>当查询经常涉及两个或多个关系模式的属性时，系统必须经常地进行连接运算</li><li>连接运算的代价是相当高的</li><li>因此在这种情况下，第二范式甚至第一范式也许是适合的。</li></ul></li><li><p>非BCNF的关系模式虽然会存在不同程度的更新异常，但如果在实际应用中对此关系模式只是查询，并不执行更新操作，就不会产生实际影响。</p></li><li><p>对于一个具体应用来说，到底规范化进行到什么程度，需要权衡响应时间和潜在问题两者的利弊才能决定</p></li></ul><h3 id="设计用户子模式">设计用户子模式</h3><ul><li>定义数据库模式主要是从系统的时间效率、空间效率、易维护等角度出发。</li><li>定义用户外模式时应该更注重考虑用户的习惯与方便。包括三个方面：<ul><li>（1）使用更符合用户习惯的别名<br>合并各分E-R图曾做了消除命名冲突的工作，以使数据库系统中同一关系和属性具有唯一的名字。这在设计数据库整体结构时是非常必要的。<br>用视图机制可以在设计用户视图时可以重新定义某些属性名，使其与用户习惯一致，以方便使用。</li><li>（2）针对不同级别的用户定义不同的视图，以保证系统的安全性。<br>假设有关系模式产品（产品号，产品名，规格，单价，生产车间，生产负责人，产品成本，产品合格率，质量等级），可以在产品关系上建立两个视图：<br>为一般顾客建立视图：    产品1（产品号，产品名，规格，单价）<br>为产品销售部门建立视图：    产品2（产品号，产品名，规格，单价，车间，<br>生产负责人）</li><li>（3）简化用户对系统的使用</li><li>如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图。</li></ul></li></ul><h2 id="物理结构设计">物理结构设计</h2><ul><li><p>什么是数据库的物理设计</p><ul><li>数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。</li><li>为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。</li></ul></li><li><p>数据库物理设计的步骤</p><ul><li>确定数据库的物理结构<br>在关系数据库中主要指存取方法和存储结构;</li><li>对物理结构进行评价<br>评价的重点是时间和空间效率</li><li>若评价结果满足原设计要求，则可进入到物理实施阶段。否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型。</li></ul></li></ul><h3 id="数据库物理设计的内容和方法">数据库物理设计的内容和方法</h3><ul><li><p>设计物理数据库结构的准备工作</p><ul><li>充分了解应用环境，详细分析要运行的事务，以获得选择物理数据库设计所需参数。</li><li>充分了解所用关系型数据库管理系统的内部特征，特别是系统提供的存取方法和存储结构。</li></ul></li><li><p>选择物理数据库设计所需参数</p><ul><li>数据库查询事务<ul><li>查询的关系</li><li>查询条件所涉及的属性</li><li>连接条件所涉及的属性</li><li>查询的投影属性</li></ul></li><li>数据更新事务<ul><li>被更新的关系</li><li>每个关系上的更新操作条件所涉及的属性</li><li>修改操作要改变的属性值</li></ul></li><li>每个事务在各关系上运行的频率和性能要求</li></ul></li><li><p>关系数据库物理设计的内容</p><ul><li>为关系模式选择存取方法（建立存取路径）</li><li>设计关系、索引等数据库文件的物理存储结构</li></ul></li></ul><h3 id="关系模式存取方法选择">关系模式存取方法选择</h3><ul><li><p>数据库系统是多用户共享的系统，对同一个关系要建立多条存取路径才能满足多用户的多种应用要求。</p></li><li><p>物理结构设计的任务之一是根据关系数据库管理系统支持的存取方法确定选择哪些存取方法。</p></li><li><p>数据库管理系统常用存取方法</p><ul><li>B+树索引存取方法</li><li>Hash索引存取方法</li><li>聚簇存取方法</li></ul></li><li><p>选择索引存取方法的主要内容</p><ul><li>根据应用要求确定</li><li>对哪些属性列建立索引</li><li>对哪些属性列建立组合索引</li><li>对哪些索引要设计为唯一索引</li></ul></li><li><p>选择索引存取方法的一般规则</p><ul><li>如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）</li><li>如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引</li><li>如果一个（或一组）属性经常在连接操作的连接条件中 出现，则考虑在这个（或这组）属性上建立索引</li></ul></li><li><p>关系上定义的索引数过多会带来较多的额外开销</p><ul><li>维护索引的开销</li><li>查找索引的开销</li></ul></li><li><p>选择Hash存取方法的规则</p><ul><li>如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一<ul><li>该关系的大小可预知，而且不变；</li><li>该关系的大小动态改变，但所选用的数据库管理系统提供了动态Hash存取方法。</li></ul></li></ul></li><li><p>什么是聚簇</p><ul><li>为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇。该属性（或属性组）称为聚簇码（cluster key）</li><li>许多关系型数据库管理系统都提供了聚簇功能</li><li>聚簇存放与聚簇索引的区别</li></ul></li><li><p>聚簇索引</p><ul><li>建立聚簇索引后，基表中数据也需要按指定的聚簇属性值的升序或降序存放。也即聚簇索引的索引项顺序与表中元组的物理顺序一致。</li><li>在一个基本表上最多只能建立一个聚簇索引</li></ul></li><li><p>聚簇索引的适用条件</p><ul><li><p>很少对基表进行增删操作</p></li><li><p>很少对其中的长列进行修改操作</p></li></ul></li><li><p>聚簇的用途<br>对于某些类型的查询，可以提高查询效率</p><ol><li>大大提高按聚簇属性进行查询的效率<br>[例] 假设学生关系按所在系建有索引，现在要查询信息系的所有学生名单。<br>计算机系的500名学生分布在500个不同的物理块上时，至少要执行500次I/O操作。<br>如果将同一系的学生元组集中存放，则每读一个物理块可得到多个满足查询条件的元组，从而显著地减少了访问磁盘的次数。</li><li>节省存储空间<br>聚簇以后，聚簇码相同的元组集中在一起了，因而聚簇码值不必在每个元组中重复存储，只要在一组中存一次就行了。</li></ol></li><li><p>聚簇的局限性</p><ul><li>聚簇只能提高某些特定应用的性能</li><li>建立与维护聚簇的开销相当大<ul><li>对已有关系建立聚簇，将导致关系中元组的物理存储位置移动，并使此关系上原有的索引无效，必须重建。</li><li>当一个元组的聚簇码改变时，该元组的存储位置也要做相应改变。</li></ul></li></ul></li><li><p>聚簇的适用范围</p><ul><li>既适用于单个关系独立聚簇，也适用于多个关系组合聚簇</li><li>当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的时，可以使用聚簇<ul><li>尤其当SQL语句中包含有与聚簇码有关的ORDER BY, GROUP BY, UNION, DISTINCT等子句或短语时，使用聚簇特别有利，可以省去或减化对结果集的排序操作</li></ul></li></ul></li><li><p>选择聚簇存取方法</p><ul><li>设计候选聚簇<br>（1）常在一起进行连接操作的关系可以建立组合聚簇<br>（2）如果一个关系的一组属性经常出现在相等比较条<br>件中，则该单个关系可建立聚簇；<br>（3）如果一个关系的一个（或一组）属性上的值重复<br>率很高，则此单个关系可建立聚簇。</li></ul></li><li><p>检查候选聚簇中的关系，取消其中不必要的关系<br>（1）从聚簇中删除经常进行全表扫描的关系<br>（2）从聚簇中删除更新操作远多于连接操作的关系<br>（3）从聚簇中删除重复出现的关系</p><p>当一个关系同时加入多个聚簇时，必须从这多个聚簇方案<br>（包括不建立聚簇）中选择一个较优的，即在这个聚簇上<br>运行各种事务的总代价最小。</p></li></ul><h3 id="确定数据库的存储结构">确定数据库的存储结构</h3><ul><li><p>确定数据库物理结构主要指确定数据的存放位置和存储结构，包括：确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等。</p></li><li><p>确定数据的存放位置和存储结构要综合考虑存取时间、存储空间利用率和维护代价3个方面的因素。</p></li><li><p>影响数据存放位置和存储结构的因素</p><ul><li>硬件环境</li><li>应用需求<ul><li>存取时间</li><li>存储空间利用率</li><li>维护代价</li></ul></li><li>这三个方面常常是相互矛盾的</li></ul></li><li><p>基本原则</p><ul><li>根据应用情况将<ul><li>易变部分与稳定部分分开存放</li><li>经常存取部分与存取频率较低部分分开存放</li></ul></li></ul></li><li><p>[例]</p><ul><li>可以将比较大的表分别放在两个磁盘上，以加快存取速度，这在多用户环境下特别有效。</li><li>可以将日志文件与数据库对象（表、索引等）放在不同的磁盘以改进系统的性能。</li></ul></li><li><p>数据库管理系统一般都提供了一些存储分配参数</p><ul><li>同时使用数据库的用户数</li><li>同时打开的数据库对象数</li><li>内存分配参数</li><li>缓冲区分配参数（使用的缓冲区长度、个数）</li><li>存储分配参数</li><li>物理块的大小</li><li>物理块装填因子</li><li>时间片大小</li><li>数据库的大小</li><li>锁的数目等</li></ul></li><li><p>系统都为这些变量赋予了合理的缺省值。在进行物理设计时需要根据应用环境确定这些参数值，以使系统性能最优。</p></li><li><p>在物理设计时对系统配置变量的调整只是初步的，要根据系统实际运行情况做进一步的调整，以切实改进系统性能。</p></li></ul><h3 id="评价物理结构">评价物理结构</h3><ul><li>对数据库物理设计过程中产生的多种方案进行评价，从中选择一个较优的方案作为数据库的物理结构。</li><li>评价方法<ul><li>定量估算各种方案<ul><li>存储空间</li><li>存取时间</li><li>维护代价</li></ul></li><li>对估算结果进行权衡、比较，选择出一个较优的合理的物理结构。</li></ul></li></ul><h2 id="数据库的实施和维护">数据库的实施和维护</h2><h3 id="数据的载入和应用程序的调试">数据的载入和应用程序的调试</h3><ul><li><p>数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。</p></li><li><p>数据装载方法</p><ul><li>人工方法</li><li>计算机辅助数据入库</li></ul></li><li><p>数据库应用程序的设计应该与数据设计并行进行</p></li><li><p>在组织数据入库的同时还要调试应用程序</p></li><li><p>应用程序的设计、编码和调试的方法、步骤在软件工程等课程中有详细讲解，这里就不赘述了</p></li></ul><h3 id="数据库的试运行">数据库的试运行</h3><ul><li><p>应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试，也称数据库的试运行。</p></li><li><p>主要工作包括：</p><ul><li>功能测试：实际运行应用程序，执行对数据库的各种操作，测试应用程序的各种功能。</li><li>性能测试：测量系统的性能指标，分析是否符合设计目标。</li></ul></li><li><p>数据库性能指标的测量</p><ul><li>数据库物理设计阶段在评价数据库结构估算时间、空间指标时，作了许多简化和假设，忽略了许多次要因素，因此结果必然很粗糙。</li><li>数据库试运行则是要实际测量系统的各种性能指标（不仅是时间、空间指标），如果结果不符合设计目标，则需要返回物理设计阶段，调整物理结构，修改参数；有时甚至需要返回逻辑设计阶段，调整逻辑结构。</li></ul></li><li><p>数据的分期入库</p><ul><li>重新设计物理结构甚至逻辑结构，会导致数据重新入库</li><li>由于数据入库工作量实在太大，所以可以采用分期输入数据的方法<ul><li>先输入小批量数据供先期联合调试使用</li><li>待试运行基本合格后再输入大批量数据</li><li>逐步增加数据量，逐步完成运行评价</li></ul></li></ul></li><li><p>数据库的转储和恢复</p><ul><li>在数据库试运行阶段，系统还不稳定，硬、软件故障随时都可能发生</li><li>系统的操作人员对新系统还不熟悉，误操作也不可避免</li><li>因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏</li></ul></li></ul><h3 id="数据库的运行和维护">数据库的运行和维护</h3><ul><li><p>在数据库运行阶段，对数据库经常性的维护工作主要是由数据库管理员完成的，包括：</p><ol><li><p>数据库的转储和恢复<br>数据库管理员要针对不同的应用要求制定不同的转储计划，定期对数据库和日志文件进行备份。<br>一旦发生介质故障，即利用数据库备份及日志文件备份，尽快将数据库恢复到某种一致性状态。</p></li><li><p>数据库的安全性、完整性控制</p><ul><li>初始定义<br>数据库管理员根据用户的实际需要授予不同的操作权限<br>根据应用环境定义不同的完整性约束条件</li><li>修改定义<br>当应用环境发生变化，对安全性的要求也会发生变化，数据库管理员需要根据实际情况修改原有的安全性控制<br>由于应用环境发生变化，数据库的完整性约束条件也会变化，也需要数据库管理员不断修正，以满足用户要求</li></ul></li><li><p>数据库性能的监督、分析和改进</p><ul><li>在数据库运行过程中，数据库管理员必须监督系统运行，对监测数据进行分析，找出改进系统性能的方法。<ul><li>利用监测工具获取系统运行过程中一系列性能参数的值</li><li>通过仔细分析这些数据，判断当前系统是否处于最佳运行状态</li><li>如果不是，则需要通过调整某些参数来进一步改进数据库性能</li></ul></li></ul></li><li><p>数据库的重组织与重构造<br>（1）数据库的重组织<br>为什么要重组织数据库<br>数据库运行一段时间后，由于记录的不断增、删、改，会使数据库的物理存储变坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降。</p><ul><li><p>重组织的形式</p><ul><li>全部重组织</li><li>部分重组织</li><li>只对频繁增、删的表进行重组织</li></ul></li><li><p>重组织的目标</p><p>提高系统性能</p></li><li><p>重组织的工作</p><ul><li>按原设计要求<br>重新安排存储位置<br>回收垃圾<br>减少指针链</li><li>数据库的重组织不会改变原设计的数据逻辑结构和物理结构</li></ul></li><li><p>数据库管理系统一般都提供了供重组织数据库使用的实用程序，帮助数据库管理员重新组织数据库。</p></li></ul><p>（2）数据库的重构造</p><ul><li>为什么要进行数据库的重构造<ul><li>数据库应用环境发生变化，会导致实体及实体间的联系也发生相应的变化，使原有的数据库设计不能很好地满足新的需求<ul><li>增加新的应用或新的实体</li><li>取消某些已有应用</li><li>改变某些已有应用</li></ul></li></ul></li></ul></li></ol></li><li><p>数据库重构造的主要工作</p><ul><li>根据新环境调整数据库的模式和内模式<ul><li>增加或删除某些数据项</li><li>改变数据项的类型</li><li>增加或删除某个表</li><li>改变数据库的容量</li><li>增加或删除某些索引</li></ul></li></ul></li><li><p>重构造数据库的程度是有限的</p><ul><li>若应用变化太大，已无法通过重构数据库来满足新的需求，或重构数据库的代价太大，则表明现有数据库应用系统的生命周期已经结束，应该重新设计新的数据库应用系统了。</li></ul></li></ul><h2 id="小结">小结</h2><ul><li><p>数据库的设计过程</p><ul><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行维护</li><li>设计过程中往往还会有许多反复</li></ul></li><li><p>数据库各级模式的形成</p><ul><li>需求分析阶段：综合各个用户的应用需求（现实世界的需求）。</li><li>概念设计阶段：概念模式（信息世界模型），用E-R图来描述。</li><li>逻辑设计阶段：逻辑模式、外模式。</li><li>物理设计阶段：内模式。</li></ul></li><li><p>概念结构设计</p><ul><li>E-R模型的基本概念和图示方法</li><li>E-R模型的设计</li><li>把E-R模型转换为关系模型的方法</li></ul></li><li><p>在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型如关系模型，形成数据库逻辑模式。</p></li><li><p>然后根据用户处理的要求，安全性的考虑，在基本表的基础上再建立必要的视图，形成数据的外模式</p></li><li><p>在物理设计阶段根据DBMS特点和处理的需要，进行物理存储安排，设计索引，形成数据库内模式</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重点和难点&quot;&gt;重点和难点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重点：&lt;/p&gt;
&lt;p&gt;掌握数据库设计步骤和数据库设计过程中的各级模式设计方法。特别是数据库概念结构的设计和逻辑结构的设计，这是数据库设计过程中最重要的两个环节。牢固掌握用E-R图来表示概念模型的方法，掌</summary>
      
    
    
    
    <category term="数据库" scheme="https://lebronchao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库" scheme="https://lebronchao.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="SQL" scheme="https://lebronchao.com/tags/SQL/"/>
    
    <category term="后端" scheme="https://lebronchao.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统 | 第六章 关系数据理论</title>
    <link href="https://lebronchao.com/2021/01/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
    <id>https://lebronchao.com/2021/01/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</id>
    <published>2021-01-19T02:31:24.000Z</published>
    <updated>2021-01-19T06:54:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题的提出">问题的提出</h2><ul><li><p>关系数据库逻辑设计</p><ul><li>针对具体问题，如何构造一个适合于它的数据模式</li><li>数据库逻辑设计的工具──关系数据库的规范化理论</li></ul></li><li><p>关系模式由五部分组成，是一个五元组：</p><p>R(U, D, DOM, F)</p><ul><li>关系名R是符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U中的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为属性组U上的一组数据依赖</li></ul></li><li><p>由于D、DOM与模式设计关系不大，因此在本章中把关系模式看作一个三元组：R&lt;U,F&gt;</p></li><li><p>当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系</p></li><li><p>作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于第一范式（1NF）</p></li><li><p>数据依赖</p><ul><li>是一个关系内部属性与属性之间的一种约束关系</li><li>通过属性间值的相等与否体现出来的数据间相互联系</li><li>是现实世界属性间相互联系的抽象</li><li>是数据内在的性质</li><li>是语义的体现</li></ul></li><li><p>数据依赖的主要类型</p><ul><li>函数依赖（Functional Dependency，简记为FD）</li><li>多值依赖（Multi-Valued Dependency，简记为MVD）</li></ul></li><li><p>函数依赖普遍存在于现实生活中</p><ul><li>描述一个学生关系，可以有学号、姓名、系名等属性。</li><li>一个学号只对应一个学生，一个学生只在一个系中学习</li><li>“学号”值确定后，学生的姓名及所在系的值就被唯一确定。</li><li>Sname=f(Sno)，Sdept=f(Sno)<ul><li>即Sno函数决定Sname</li><li>Sno函数决定Sdept</li><li>记作Sno→Sname，Sno→Sdept</li></ul></li></ul></li><li><p>[例6.1] 建立一个描述学校教务的数据库。涉及的对象包括：</p><ul><li>学生的学号（Sno）</li><li>所在系（Sdept）</li><li>系主任姓名（Mname）</li><li>课程号（Cno）</li><li>成绩（Grade）</li></ul></li><li><p>假设学校教务的数据库模式用一个单一的关系模式Student来表示，则该关系模式的属性集合为：U ＝{Sno, Sdept, Mname, Cno, Grade}</p><ul><li>现实世界的已知事实（语义）：<ul><li>一个系有若干学生， 但一个学生只属于一个系；</li><li>一个系只有一名（正职）负责人；</li><li>一个学生可以选修多门课程，每门课程有若干学生选修；</li><li>每个学生学习每一门课程有一个成绩。</li></ul></li></ul></li><li><p>由此可得到属性组U上的一组函数依赖F：<br>F={Sno→Sdept, Sdept→ Mname, (Sno, Cno)→ Grade}</p></li><li><p>关系模式Student&lt;U, F&gt;中存在的问题：<br>（1）数据冗余</p><ul><li>浪费大量的存储空间<ul><li>每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。</li></ul></li></ul><p>（2）更新异常（Update Anomalies）</p><ul><li>数据冗余 ，更新数据时，维护数据完整性代价大。<ul><li>某系更换系主任后，必须修改与该系学生有关的每一个元组。</li></ul></li></ul><p>（3）插入异常（Insertion Anomalies）</p><ul><li>如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。</li></ul><p>（4）删除异常（Deletion Anomalies）</p><ul><li>如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。</li></ul></li><li><p>结论</p><ul><li>Student关系模式不是一个好的模式。</li><li>一个“好”的模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。</li></ul></li><li><p>原因<br>由存在于模式中的某些数据依赖引起的。</p></li><li><p>解决方法<br>用规范化理论改造关系模式来消除其中不合适的数据依赖</p></li><li><p>把这个单一的模式分成三个关系模式：</p><ul><li>S(Sno,Sdept,Sno → Sdept);</li><li>SC(Sno,Cno,Grade,(Sno,Cno) → Grade);</li><li>DEPT(Sdept,Mname,Sdept → Mname);</li></ul></li><li><p>这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。</p></li></ul><h2 id="规范化">规范化</h2><h3 id="函数依赖">函数依赖</h3><ul><li><p>定义6.1</p><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。</p></li><li><p>[例] Student(Sno, Sname, Ssex, Sage, Sdept),<br>假设不允许重名，则有:<br>Sno → Ssex，      Sno → Sage<br>Sno → Sdept，    Sno ←→ Sname<br>Sname → Ssex， Sname → Sage<br>Sname → Sdept<br>但Ssex →Sage, Ssex→ Sdept</p><p>若X→Y，并且Y→X, 则记为X←→Y。<br>若Y不函数依赖于X, 则记为X→Y。</p></li><li><p>X→Y，但Y⊈X则称X→Y是非平凡的函数依赖。</p></li><li><p>X→Y，但Y⊆X 则称X→Y是平凡的函数依赖。</p></li><li><p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。<br>若不特别声明， 我们总是讨论非平凡函数依赖。</p></li><li><p>若X→Y，则X称为这个函数依赖的决定因素（Determinant）。<br>若X→Y，Y→X，则记作X←→Y。<br>若Y不函数依赖于X，则记作X↛Y。</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/1610897081703.jpg" alt=""></p><ul><li>定义6.3  在R(U)中，如果X→Y(Y⊈X)，Y↛X，Y→Z，Z⊈Y, 则称Z对X传递函数依赖(transitive functional dependency)。记为：X → Z。<br>注: 如果Y→X, 即X←→Y，则Z直接依赖于X，而不是传递函数依赖。<br>[例] 在关系Std(Sno, Sdept, Mname)中，有：<br>Sno → Sdept，Sdept → Mname，<br>Mname传递函数依赖于Sno</li></ul><h3 id="码">码</h3><ul><li><p>定义6.4</p><p>设K为R&lt;U,F&gt;中的属性或属性组合。若K → U，则K称为R的一个候选码(Candidate Key)。唯一标识实体的属性或属性组合称为码<br>如果U部分函数依赖于K，即K → U,则K称为超码      （Surpkey）。候选码是最小的超码，即K的任意一个真子集都不是候选码。</p></li><li><p>若关系模式R有多个候选码，则选定其中的一个做为主码(Primary key)。</p></li><li><p>主属性与非主属性<br>包含在任何一个候选码中的属性 ，称为主属性          （Prime attribute）<br>不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）</p></li><li><p>全码：整个属性组是码，称为全码（All-key）</p></li><li><p>主码=主键=主关键字，<br>关键字=候选码<br>候选关键字=候选码中除去主码的其他候选码</p></li><li><p>[例6.2]S(Sno, Sdept, Sage)，单个属性Sno是码<br>SC(Sno, Cno, Grade)中，(Sno, Cno)是码</p></li><li><p>[例6.3] R(P,W,A) P：演奏者     W：作品    A：听众<br>一个演奏者可以演奏多个作品<br>某一作品可被多个演奏者演奏<br>听众可以欣赏不同演奏者的不同作品<br>码为(P,W,A)，即All-Key</p></li><li><p>定义6.5  关系模式 R中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码。</p><ul><li>SC(Sno,Cno,Grade)中，Sno不是码</li><li>Sno是 S(Sno,Sdept,Sage)的码，则Sno是SC的外码</li></ul></li><li><p>主码与外部码一起提供了表示关系间联系的手段</p></li></ul><h3 id="范式">范式</h3><ul><li><p>范式是符合某一种级别的关系模式的集合。</p></li><li><p>作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于第一范式（1NF）</p></li><li><p>关系数据库中的关系必须满足一定的要求。满足   不同程度要求的为不同范式。</p></li><li><p>范式的种类</p><ul><li>第一范式（1NF）</li><li>第二范式（2NF）</li><li>第三范式（3NF）</li><li>BC范式（BCNF）</li><li>第四范式（4NF）</li><li>第五范式（5NF）</li></ul></li><li><p>各种范式之间存在联系：<br>某一关系模式R为第n范式，可简记为R∈nNF。</p></li><li><p>一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization）。</p></li></ul><h3 id="2NF">2NF</h3><ul><li><p>定义6.6  若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则R∈2NF</p></li><li><p>[例6.4]  S-L-C(Sno,Sdept,Sloc,Cno,Grade)， Sloc为学生的住处，并且每个系的学生住在同一个地方。S-L-C的码为(Sno,Cno)。<br>函数依赖有</p><ul><li>(Sno,Cno)→Grade</li><li>Sno→Sdept, (Sno,Cno)→Sdept</li><li>Sno→Sloc, (Sno,Cno)→Sloc</li><li>Sdept→Sloc</li></ul></li><li><p>一个关系模式不属于2NF，会产生以下问题：</p><ul><li>插入异常<br>如果插入一个新学生，但该生未选课，即该生无Cno，由于插入元组时，必须给定码值，因此插入失败。</li><li>删除异常<br>如果S4只选了一门课C3，现在他不再选这门课，则删除C3后，整个元组的其他信息也被删除了。</li><li>修改复杂<br>如果一个学生选了多门课，则Sdept，Sloc被存储了多次。如果该生转系，则需要修改所有相关的Sdept和Sloc，造成修改的复杂化。</li></ul></li><li><p>出现这种问题的原因</p><ul><li>例子中有两类非主属性：<ul><li>一类如Grade，它对码完全函数依赖</li><li>另一类如Sdept、Sloc，它们对码不是完全函数依赖</li></ul></li></ul></li><li><p>解决方法：</p><ul><li>用投影分解把关系模式S-L-C分解成两个关系模式<ul><li>SC(Sno,Cno,Grade)</li><li>S-L(Sno,Sdept,Sloc)</li></ul></li></ul></li><li><p>SC的码为(Sno,Cno),SL的码为Sno，这样使得非主属性对候选码都是完全函数依赖了，单关键字的数据库表都符合第二范式</p></li></ul><h3 id="3NF">3NF</h3><ul><li><p>定义6.7（无传递函数依赖即3NF）</p><p>设关系模式R&lt;U,F&gt;∈1NF,若R中不存在这样的码X、属性组Y(非码)及非主属性Z（Z ⊈ Y）, 使得X→Y(Y⊈X，Y ↛ X)，Y→Z成立，则称R&lt;U,F&gt; ∈ 3NF。</p><ul><li>SC没有传递依赖，因此SC ∈ 3NF</li><li>S-L中Sno →Sdept( Sdept ↛ Sno), Sdept→Sloc，可得Sno  →  Sloc。</li><li>解决的办法是将S-L分解成<ul><li>S-D(Sno,Sdept)∈ 3NF</li><li>D-L(Sdept,Sloc)∈ 3NF</li></ul></li></ul></li><li><p>基于2NF，非主属性不能函数依赖于非码。此外，非主属性只能存在一个表中，不应该存在多个表中；</p></li></ul><h3 id="BCNF">BCNF</h3><ul><li><p>BCNF（Boyce Codd Normal Form）由Boyce和Codd提出，比3NF更进了一步。通常认为BCNF是修正的第三范式，有时也称为扩充的第三范式。</p></li><li><p>定义6.8</p><p>设关系模式R&lt;U,F&gt;∈1NF，若X →Y且Y ⊆ X时X必含有码，则R&lt;U,F&gt;∈BCNF。</p></li><li><p>换言之，在关系模式R&lt;U,F&gt;中，如果每一个决定属性集都包含候选码，则R∈BCNF。</p></li><li><p>BCNF的关系模式所具有的性质</p><ul><li>所有非主属性都完全函数依赖于每个候选码(2NF)</li><li>所有主属性都完全函数依赖于每个不包含它的候选码(BCNF)</li><li>没有任何属性完全函数依赖于非码的任何一组属性(3NF+)</li></ul></li><li><p>如果一个关系数据库中的所有关系模式都属于BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常。</p></li><li><p>[例6.5]考察关系模式C(Cno,Cname,Pcno)</p></li><li><p>[例6.6] 关系模式S(Sno,Sname,Sdept,Sage)，</p><ul><li>假定Sname也具有唯一性，那么S就有两个码，这两个码都由单个属性组成，彼此不相交。</li><li>其他属性不存在对码的传递依赖与部分依赖，所以S∈3NF。</li><li>同时S中除Sno，Sname外没有其他决定因素，所以S也属于BCNF。</li></ul></li><li><p>[例6.7] 关系模式SJP(S,J,P)中，S是学生，J表示<br>课程，P表示名次。每一个学生选修每门课程的成绩有一定的名次，每门课程中每一名次只有一个学生（即没有并列名次）。</p><ul><li><p>由语义可得到函数依赖： (S,J)→P；(J,P)→S(S,J)与(J,P)都可以作为候选码。</p></li><li><p>关系模式中没有属性对码传递依赖或部分依赖，所以   SJP∈3NF。</p></li><li><p>除(S,J)与(J,P)以外没有其他决定因素，所以SJP∈BCNF。</p></li></ul></li><li><p>[例6.8] 关系模式STJ(S,T,J)中，S表示学生，T表示教师，J表示课程。每一教师只教一门课。每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。</p><ul><li>由语义可得到函数依赖：(S,J)→T；(S,T)→J；T→J</li><li>因为没有任何非主属性对码传递依赖或部分依赖，STJ ∈ 3NF。</li><li>因为T是决定因素，而T不包含码，所以STJ ∈ BCNF关系。BCNF每个属性均完全依赖于每个候选码(不含它)</li></ul></li><li><p>对于不是BCNF的关系模式，仍然存在不合适的地方。</p></li><li><p>非BCNF的关系模式也可以通过分解成为BCNF。例如STJ可分解为ST(S,T)与TJ(T,J)，它们都是BCNF。</p></li><li><p>3NF和BCNF是在函数依赖的条件下对模式分解所能达到的分离程度的测度。</p><ul><li>一个模式中的关系模式如果都属于BCNF，那么在函数依赖范畴内，它已实现了彻底的分离，已消除了插入和删除的异常。</li><li>3NF的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。</li></ul></li></ul><h3 id="规范化小结">规范化小结</h3><ul><li><p>在关系数据库中，对关系模式的基本要求是满足第一范式。</p></li><li><p>规范化程度过低的关系不一定能够很好地描述现实世界</p><ul><li>可能存在插入异常、删除异常、修改复杂、数据冗余等问题</li><li>解决方法就是对其进行规范化，转换成高级范式。</li></ul></li><li><p>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化。</p></li><li><p>关系数据库的规范化理论是数据库逻辑设计的工具。</p></li><li><p>规范化的基本思想</p><ul><li>是逐步消除数据依赖中不合适的部分，使模式中的各关系模式达到某种程度的“分离”。</li><li>即采用“一事一地”的模式设计原则<ul><li>让一个关系描述一个概念、一个实体或者实体间的一种联系。</li><li>若多于一个概念就把它“分离”出去。</li></ul></li><li>因此 规范化实质上是概念的单一化。</li></ul></li></ul><h2 id="数据依赖的公理系统">数据依赖的公理系统</h2><ul><li><p>一套推理规则，是模式分解算法的理论基础</p></li><li><p>用途</p><ul><li>求给定关系模式的码</li><li>从一组函数依赖求得蕴涵的函数依赖</li></ul></li><li><p>Armstrong公理系统  设U为属性集总体，F是U上的一组函数依赖， 于是有关系模式R &lt;U,F &gt;。对R &lt;U,F&gt; 来说有以下的推理规则：</p><ul><li>A1 自反律（reflexivity rule）：若Y  X  U，则X →Y 为F所蕴涵。</li><li>A2 增广律（augmentation rule）：若X→Y为F所蕴涵，且Z  U，则XZ→YZ 为F所蕴涵。</li><li>A3 传递律（transitivity rule）：若X→Y及Y→Z为F所蕴涵，则X→Z 为F所蕴涵。</li></ul></li><li><p>根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：</p><ul><li>合并规则（union rule）：<br>由X→Y，X→Z，有X→YZ。</li><li>伪传递规则（pseudo transitivity rule）：<br>由X→Y，WY→Z，有XW→Z。</li><li>分解规则（decomposition rule）：<br>由X→Y及ZY，有X→Z。</li></ul></li><li><p>定义6.12</p><p>在关系模式R&lt;U,F&gt;中为F所逻辑蕴涵的函数依赖的全体叫作F的闭包，记为F +。</p></li><li><p>定义6.13</p><p>设F为属性集U上的一组函数依赖，X、Y U， XF+={ A|X→A能由F根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F的闭包。</p></li><li><p>有效性与完备性的含义</p><ul><li>有效性：由F 出发根据Armstrong公理推导出来的每一个函数依赖一定在F +中</li><li>完备性：F +中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来</li></ul></li></ul><h2 id="小结">小结</h2><ul><li>若要求分解具有无损连接性，那么模式分解一定能够达到4NF。</li><li>若要求分解保持函数依赖，那么模式分解一定能够达到3NF，但不一定能够达到BCNF。</li><li>若分解既具有无损连接性，又保持函数依赖，则模式分解一定能够达到3NF，但不一定能够达到BCNF。</li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题的提出&quot;&gt;问题的提出&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关系数据库逻辑设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对具体问题，如何构造一个适合于它的数据模式&lt;/li&gt;
&lt;li&gt;数据库逻辑设计的工具──关系数据库的规范化理论&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
</summary>
      
    
    
    
    <category term="数据库" scheme="https://lebronchao.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="学习笔记" scheme="https://lebronchao.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数据库" scheme="https://lebronchao.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="SQL" scheme="https://lebronchao.com/tags/SQL/"/>
    
    <category term="后端" scheme="https://lebronchao.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
</feed>
