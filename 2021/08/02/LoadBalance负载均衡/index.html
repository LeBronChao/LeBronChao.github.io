<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>[深入浅出LB]手把手带你实现一个负载均衡器 | LeBronChao's Blog</title><meta name="keywords" content="计算机网络,负载均衡,Node,进程,线程,进程间通信"><meta name="author" content="LeBronChao-"><meta name="copyright" content="LeBronChao-"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Load Balance负载均衡 🌡   简介  负载均衡，含义就是根据一定算法将负载（工作任务）进行平衡，分摊到多个操作单元上运行、执行，常见的为Web服务器、企业核心应用服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡在原有的网络结构上提供了一种透明且有效的的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性，同时承受住更大的并发量级。">
<meta property="og:type" content="article">
<meta property="og:title" content="[深入浅出LB]手把手带你实现一个负载均衡器">
<meta property="og:url" content="https://lebronchao.com/2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/index.html">
<meta property="og:site_name" content="LeBronChao&#39;s Blog">
<meta property="og:description" content="Load Balance负载均衡 🌡   简介  负载均衡，含义就是根据一定算法将负载（工作任务）进行平衡，分摊到多个操作单元上运行、执行，常见的为Web服务器、企业核心应用服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡在原有的网络结构上提供了一种透明且有效的的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性，同时承受住更大的并发量级。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bloginfo.lebronchao.com/doc-image/LoadBalance.jpeg">
<meta property="article:published_time" content="2021-08-01T16:11:46.000Z">
<meta property="article:modified_time" content="2021-08-01T16:11:46.000Z">
<meta property="article:author" content="LeBronChao-">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="负载均衡">
<meta property="article:tag" content="Node">
<meta property="article:tag" content="进程">
<meta property="article:tag" content="线程">
<meta property="article:tag" content="进程间通信">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bloginfo.lebronchao.com/doc-image/LoadBalance.jpeg"><link rel="shortcut icon" href="https://bloginfo.lebronchao.com/doc-image/bitbug_favicon%20(1).ico"><link rel="canonical" href="https://lebronchao.com/2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0f958a253362f27db5bafcef151a46ab";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: LeBronChao-","link":"链接: ","source":"来源: LeBronChao's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-02 00:11:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="LeBronChao's Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://bloginfo.lebronchao.com/personal-info/IMG_8050.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-video"></i><span> 摄影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/Front-End/"><i class="fa-fw fas fa-laptop"></i><span> Front End</span></a></li><li><a class="site-page" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa-fw fas fa-wifi"></i><span> 计算机网络</span></a></li><li><a class="site-page" href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"><i class="fa-fw fab fa-git-square"></i><span> 开发技能</span></a></li><li><a class="site-page" href="/categories/Back-End/"><i class="fa-fw fas fa-database"></i><span> Back End</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bloginfo.lebronchao.com/doc-image/LoadBalance.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LeBronChao's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-video"></i><span> 摄影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/Front-End/"><i class="fa-fw fas fa-laptop"></i><span> Front End</span></a></li><li><a class="site-page" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa-fw fas fa-wifi"></i><span> 计算机网络</span></a></li><li><a class="site-page" href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"><i class="fa-fw fab fa-git-square"></i><span> 开发技能</span></a></li><li><a class="site-page" href="/categories/Back-End/"><i class="fa-fw fas fa-database"></i><span> Back End</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">[深入浅出LB]手把手带你实现一个负载均衡器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-01T16:11:46.000Z" title="发表于 2021-08-02 00:11:46">2021-08-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-01T16:11:46.000Z" title="更新于 2021-08-02 00:11:46">2021-08-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Load Balance负载均衡 🌡</h1>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622002849831.(null)" alt="img"></p>
<blockquote>
<p>简介</p>
</blockquote>
<p>负载均衡，含义就是根据一定算法将负载（工作任务）进行平衡，分摊到多个操作单元上运行、执行，常见的为Web服务器、企业核心应用服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡在原有的网络结构上提供了一种透明且有效的的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性，同时承受住更大的并发量级。</p>
<blockquote>
<p>简单来说就是将大量的并发请求处理转发给多个后端节点处理，减少工作响应时间。</p>
</blockquote>
<ul>
<li>
<p>避免资源浪费</p>
</li>
<li>
<p>避免服务不可用</p>
</li>
</ul>
<h1>一、分类</h1>
<h2 id="四层（传输层）">四层（传输层）</h2>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622002908874.png" alt="image-20210622002908874"></p>
<p>四层即OSI七层模型中的传输层，有TCP、UDP协议，这两种协议中包含源IP、目标IP以外，还包含源端口号及目标端口号。四层负载均衡在接收到客户端请求后，通过修改报文的地址信息（IP + PORT）将流量转发到应用服务器。</p>
<h2 id="七层（应用层）">七层（应用层）</h2>
<blockquote>
<p>代理负载均衡</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622002927473.png" alt="image-20210622002927473"></p>
<p>七层即OSI七层模型中的应用层，应用层协议较多，常用的为HTTP/HTTPS。七层负载均衡可以给予这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP + PORT进行负载均衡，还可以根据七层的URL、Cookie、浏览器类别、语言、请求类型来决定。</p>
<blockquote>
<p>四层负载均衡的本质是转发，七层负载均衡的本质是内容交换和代理。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th><strong>四层负载均衡</strong></th>
<th><strong>七层负载均衡</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>基于</strong></td>
<td>IP + PORT</td>
<td>URL 或 主机IP</td>
</tr>
<tr>
<td><strong>类似</strong></td>
<td>路由器</td>
<td>代理服务器</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高，无需解析内容</td>
<td>中，需算法识别URL Header、Cookie等</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>低，无法识别DDoS攻击</td>
<td>高，可防御SYN Flood攻击</td>
</tr>
<tr>
<td><strong>扩展功能</strong></td>
<td>无</td>
<td>内容缓存、图片防盗链等</td>
</tr>
</tbody>
</table>
<h1>二、常见算法</h1>
<blockquote>
<p>前置数据结构</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> urlObj&#123;</span><br><span class="line">  url:<span class="built_in">string</span>,</span><br><span class="line">  weight:<span class="built_in">number</span> <span class="comment">// 仅在权重轮询时生效</span></span><br><span class="line">&#125;</span><br><span class="line">urlDesc: urlObj[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> urlCollectObj&#123;</span><br><span class="line">  count: <span class="built_in">number</span>, <span class="comment">// 连接数</span></span><br><span class="line">  costTime: <span class="built_in">number</span>, <span class="comment">// 响应时间</span></span><br><span class="line">  connection: <span class="built_in">number</span>, <span class="comment">// 实时连接数</span></span><br><span class="line">&#125;</span><br><span class="line">urlCollect: urlCollectObj[]</span><br></pre></td></tr></table></figure>
<h2 id="Random">Random</h2>
<blockquote>
<p>随机</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622002949591.png" alt="image-20210622002949591"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Random = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  收集url</span></span><br><span class="line">  urlDesc.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    urlCollect.push(val.url);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  生成随机数下标返回相应URL</span></span><br><span class="line">    <span class="keyword">const</span> pos = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * urlCollect.length);</span><br><span class="line">    <span class="keyword">return</span> urlCollect[pos];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Random;</span><br></pre></td></tr></table></figure>
<h2 id="Weighted-Round-Robin">Weighted Round Robin</h2>
<blockquote>
<p>权重轮询算法</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003000250.png" alt="image-20210622003000250"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WeiRoundRobin = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span>,</span><br><span class="line">    urlCollect = [],</span><br><span class="line">    copyUrlDesc = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(urlDesc));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据权重收集url</span></span><br><span class="line">  <span class="keyword">while</span> (copyUrlDesc.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copyUrlDesc.length; i++) &#123;</span><br><span class="line">      urlCollect.push(copyUrlDesc[i].url);</span><br><span class="line">      copyUrlDesc[i].weight--;</span><br><span class="line">      <span class="keyword">if</span> (copyUrlDesc[i].weight === <span class="number">0</span>) &#123;</span><br><span class="line">        copyUrlDesc.splice(i, <span class="number">1</span>);</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 轮询获取URL函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = urlCollect[pos++];</span><br><span class="line">    <span class="keyword">if</span> (pos === urlCollect.length) &#123;</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WeiRoundRobin;</span><br></pre></td></tr></table></figure>
<h2 id="IP-Hash-URL-Hash">IP Hash &amp; URL Hash</h2>
<blockquote>
<p>源IP / URL Hash</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003030857.png" alt="image-20210622003030857"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Hash &#125; = <span class="built_in">require</span>(<span class="string">&quot;../util&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IpHash = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlDesc) &#123;</span><br><span class="line">    <span class="comment">// 收集url</span></span><br><span class="line">    urlCollect.push(urlDesc[key].url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">sourceInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 生成Hash十进制数值</span></span><br><span class="line">    <span class="keyword">const</span> hashInfo = Hash(sourceInfo);</span><br><span class="line">    <span class="comment">// 取余为下标</span></span><br><span class="line">    <span class="keyword">const</span> urlPos = <span class="built_in">Math</span>.abs(hashInfo) % urlCollect.length;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> urlCollect[urlPos];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = IpHash;</span><br></pre></td></tr></table></figure>
<h2 id="Consistent-Hash">Consistent Hash</h2>
<blockquote>
<p>一致性Hash</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003051914.png" alt="image-20210622003051914"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Hash &#125; = <span class="built_in">require</span>(<span class="string">&quot;../util&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ConsistentHash = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlHashMap = &#123;&#125;,</span><br><span class="line">    hashCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlDesc) &#123;</span><br><span class="line">    <span class="comment">// 收集urlHash进数组和生成HashMap</span></span><br><span class="line">    <span class="keyword">const</span> &#123; url &#125; = urlDesc[key];</span><br><span class="line">    <span class="keyword">const</span> hash = Hash(url);</span><br><span class="line">    urlHashMap[hash] = url;</span><br><span class="line">    hashCollect.push(hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将hash数组从小到大排序</span></span><br><span class="line">  hashCollect = hashCollect.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">sourceInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 生成Hash十进制数值</span></span><br><span class="line">    <span class="keyword">const</span> hashInfo = Hash(sourceInfo);</span><br><span class="line">    <span class="comment">// 遍历hash数组找到第一个比源信息hash值大的，并通过hashMap返回url</span></span><br><span class="line">    hashCollect.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &gt;= hashInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> urlHashMap[val];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 没找大则返回最大的</span></span><br><span class="line">    <span class="keyword">return</span> urlHashMap[hashCollect[hashCollect.length - <span class="number">1</span>]];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ConsistentHash;</span><br></pre></td></tr></table></figure>
<h2 id="Least-Connections">Least Connections</h2>
<blockquote>
<p>最小连接数</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003136462.png" alt="image-20210622003136462"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> leastConnections = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">urlCollect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.POSITIVE_INFINITY,</span><br><span class="line">      url = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历对象找到最少连接数的地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> urlCollect) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = urlCollect[key].connection;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; min) &#123;</span><br><span class="line">        min = val;</span><br><span class="line">        url = key;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = leastConnections;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：urlCollect为负载均属数据统计对象，有以下属性</p>
</blockquote>
<ul>
<li>
<p>connection实时连接数</p>
</li>
<li>
<p>count处理请求次数</p>
</li>
<li>
<p>costTime响应时间。</p>
</li>
</ul>
<h2 id="FAIR">FAIR</h2>
<blockquote>
<p>最小响应时间</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003155965.png" alt="image-20210622003155965"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Fair = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">urlCollect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.POSITIVE_INFINITY,</span><br><span class="line">      url = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 找到耗时最少的url </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlCollect) &#123;</span><br><span class="line">      <span class="keyword">const</span> urlObj = urlCollect[key];</span><br><span class="line">      <span class="keyword">if</span> (urlObj.costTime &lt; min) &#123;</span><br><span class="line">        min = urlObj.costTime;</span><br><span class="line">        url = key;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Fair;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看到这里是不是感觉算法都挺简单的 🥱</p>
</blockquote>
<blockquote>
<p>期待一下模块四的实现吧😏</p>
</blockquote>
<h1>三、健康监测</h1>
<blockquote>
<p>健康监测即对应用服务器的健康监测，为防止把请求转发到异常的应用服务器上，应使用健康监测策略。应对不同的业务敏感程度，可相应调整策略和频率。</p>
</blockquote>
<h2 id="HTTP-HTTPS-健康监测步骤（七层）">HTTP / HTTPS 健康监测步骤（七层）</h2>
<ol>
<li>负载均衡节点向应用服务器发送HEAD请求。</li>
<li>应用服务器接收到HEAD请求后根据情况返回相应状态码。</li>
<li>若在超时时间内未收到返回的状态码，则判断为超时，健康检查失败。</li>
<li>若在超时时间内收到返回的状态码，负载均衡节点进行比对，判断健康检查是否成功。</li>
</ol>
<h2 id="TCP健康检查步骤（四层）">TCP健康检查步骤（四层）</h2>
<ol>
<li>负载均衡节点向内网应用服务器IP + PORT 发TCP SYN请求数据包。</li>
<li>内网应用服务器收到请求后，若在正常监听，则返回SYN + ACK数据包。</li>
<li>若在超时时间内未收到返回的数据包，则判断服务无响应、健康检查失败，并向内网应用服务器发送RST数据包中断TCP连接。</li>
<li>若在超时时间内收到返回的数据包，则判定服务健康运行，发起RST数据包中断TCP连接。</li>
</ol>
<h2 id="UDP健康检查步骤（四层）">UDP健康检查步骤（四层）</h2>
<ol>
<li>负载均衡节点向内网应用服务器IP + PORT发送UDP报文。</li>
<li>若内网应用服务器未正常监听，则返回<code>PORT XX unreachable</code>的ICMP报错信息，反之为正常。</li>
<li>若在超时时间内收到了报错信息，则判断服务异常，健康检查失败。</li>
<li>若在超时时间内未收到报错信息，则判断服务健康运行。</li>
</ol>
<h1>四、VIP技术</h1>
<blockquote>
<p>Vrtual IP</p>
</blockquote>
<h2 id="虚拟IP">虚拟IP</h2>
<ul>
<li>在TCP / IP架构下，所有想上网的电脑，不论以何种形式连上网络，都不需要有一个唯一的IP地址。事实上IP地址是主机硬件物理地址的一种抽象。</li>
<li>简单来说地址分为两种
<ul>
<li>MAC物理地址</li>
<li>IP逻辑地址</li>
</ul>
</li>
<li>虚拟IP是一个未分配给真实主机的IP，也就是说对外提供的服务器的主机除了有一个真实IP还有一个虚IP，这两个IP中的任意一个都可以连接到这台主机。
<ul>
<li>通过虚拟IP对应真实主机的MAC地址实现</li>
</ul>
</li>
<li>虚拟IP一般用作达到高可用的目的，比如让所有项目中的数据库链接配置都是这个虚拟IP，当主服务器发生故障无法对外提供服务时，动态将这个虚IP切换到备用服务器。</li>
</ul>
<h2 id="虚拟IP原理">虚拟IP原理</h2>
<ol>
<li>ARP是地址解析协议，作用为将一个IP地址转换为MAC地址。</li>
<li>每台主机都有ARP高速缓存，存储同一个网络内IP地址与MAC地址的映射关系，主机发送数据会先从这个缓存中查询目标IP对应MAC地址，向这个MAC地址发送数据。操作系统自动维护这个缓存。</li>
<li>Linux下可用ARP命令操作ARP高速缓存</li>
</ol>
<ul>
<li>
<p>比如存在主机A（192.168.1.6）和主机B（192.168.1.8）。A作为对外服务的主服务器，B作为备份机器，两台服务器之间通过HeartBeat通信。</p>
</li>
<li>
<p>即主服务器会定时给备份服务器发送数据包，告知主服务器正常，当备份服务器在规定时间内没有收到主服务器的HeartBeat，会认为主服务器宕机。</p>
</li>
<li>
<p>此时备份服务器就升级为主服务器。</p>
<ul>
<li>服务器B将自己的ARP缓存发送出去，告知路由器修改路由表，告知虚拟IP地址应该指向192.168.1.8.</li>
<li>这时外接再次访问虚拟IP的时候，机器B就会变成主服务器，而A降级为备份服务器。</li>
<li>这样就完成了主从机器的切换，这一切对外都是无感知、透明的。</li>
</ul>
</li>
</ul>
<h1>五、基于 nodejs 实现一个简单的负载均衡</h1>
<h2 id="预期效果">预期效果</h2>
<blockquote>
<p>编辑config.js后<code>npm run start</code>即可启动均衡器和后端服务节点</p>
</blockquote>
<ul>
<li>
<p>urlDesc：后端服务节点配置对象，weight仅在WeightRoundRobin算法时起作用</p>
</li>
<li>
<p>port：均衡器监听端口</p>
</li>
<li>
<p>algorithm：算法名称（模块二中的算法均已实现）</p>
</li>
<li>
<p>workerNum：后端服务端口开启进程数，提供并发能力。</p>
</li>
<li>
<p>balancerNum：均衡器端口开启进程数，提供并发能力。</p>
</li>
<li>
<p>workerFilePath：后端服务节点执行文件，推荐使用绝对路径。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ALGORITHM, BASE_URL&#125; = <span class="built_in">require</span>(<span class="string">&quot;./constant&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    urlDesc: [</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16666</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">6</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16667</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16668</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16669</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16670</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16671</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16672</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    algorithm: ALGORITHM.RANDOM,</span><br><span class="line">    workerNum: <span class="number">5</span>，</span><br><span class="line">    balancerNum: <span class="number">5</span>，</span><br><span class="line">    workerFilePath:path.resolve(__dirname, <span class="string">&quot;./worker.js&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="架构设计图">架构设计图</h2>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003323078.png" alt="image-20210622003323078"></p>
<h2 id="先来看看主流程-main-js">先来看看主流程 main.js</h2>
<ol>
<li>
<p>初始化负载均衡统计对象balanceDataBase</p>
<ul>
<li>balanceDataBase是一个DataBase类实例，用于统计负载均衡数据（后续会讲到）.</li>
</ul>
</li>
<li>
<p>运行均衡器</p>
<ul>
<li>多进程模型，提供并发能力。</li>
</ul>
</li>
<li>
<p>运行后端服务节点</p>
<ul>
<li>多线程+多进程模型，运行多个服务节点并提供并发能力。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;urlDesc, balancerNum&#125; = <span class="built_in">require</span>(<span class="string">&quot;./config&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> &#123;DataBase&#125; = <span class="built_in">require</span>(<span class="string">&quot;./util&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;Worker&#125; = <span class="built_in">require</span>(<span class="string">&#x27;worker_threads&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runWorker = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 防止监听端口数 &gt; CPU核数</span></span><br><span class="line">    <span class="keyword">const</span> urlObjArr = urlDesc.slice(<span class="number">0</span>, cpusLen);</span><br><span class="line">    <span class="comment">// 初始化创建子线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; urlObjArr.length; i++) &#123;</span><br><span class="line">        createWorkerThread(urlObjArr[i].url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runBalancer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置子进程执行文件</span></span><br><span class="line">    cluster.setupMaster(&#123;<span class="attr">exec</span>: path.resolve(__dirname, <span class="string">&quot;./balancer.js&quot;</span>)&#125;);</span><br><span class="line">    <span class="comment">// 初始化创建子进程</span></span><br><span class="line">    <span class="keyword">let</span> max</span><br><span class="line">    <span class="keyword">if</span> (balancerNum) &#123;</span><br><span class="line">        max = balancerNum &gt; cpusLen ? cpusLen : balancerNum</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        createBalancer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化负载均衡数据统计对象</span></span><br><span class="line"><span class="keyword">const</span> balanceDataBase = <span class="keyword">new</span> DataBase(urlDesc);</span><br><span class="line"><span class="comment">// 运行均衡器</span></span><br><span class="line">runBalancer();</span><br><span class="line"><span class="comment">// 运行后端服务节点</span></span><br><span class="line">runWorker();</span><br></pre></td></tr></table></figure>
<h3 id="创建均衡器（createBalancer函数）">创建均衡器（createBalancer函数）</h3>
<ol>
<li>创建进程</li>
<li>监听进程通信消息
<ul>
<li>监听更新响应时间事件并执行更新函数
<ul>
<li>用于FAIR算法（最小响应时间）。</li>
</ul>
</li>
<li>监听获取统计对象事件并返回</li>
</ul>
</li>
<li>监听异常退出并重新创建，进程守护。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createBalancer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">    worker.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 监听更新响应时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&quot;updateCostTime&quot;</span>) &#123;</span><br><span class="line">            balanceDataBase.updateCostTime(msg.URL, msg.costTime)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 监听获取url统计对象事件并返回</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&quot;getUrlCollect&quot;</span>) &#123;</span><br><span class="line">            worker.send(&#123;<span class="attr">type</span>: <span class="string">&quot;getUrlCollect&quot;</span>, <span class="attr">urlCollect</span>: balanceDataBase.urlCollect&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 监听异常退出事件并重新创建进程</span></span><br><span class="line">    worker.on(<span class="string">&quot;exit&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        createBalancer();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建后端服务节点（createWorkerThread函数）">创建后端服务节点（createWorkerThread函数）</h3>
<ol>
<li>
<p>创建线程</p>
</li>
<li>
<p>解析需要监听的端口</p>
</li>
<li>
<p>向子线程通信，发送需要监听的端口</p>
</li>
<li>
<p>通过线程通信，监听子线程事件</p>
<ul>
<li>
<p>监听连接事件，并触发处理函数。</p>
</li>
<li>
<p>监听断开连接事件并触发处理函数。</p>
</li>
<li>
<p>用于统计负载均衡分布和实时连接数。</p>
</li>
</ul>
</li>
<li>
<p>监听异常退出并重新创建，线程守护。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createWorkerThread = <span class="function">(<span class="params">listenUrl</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(path.resolve(__dirname, <span class="string">&quot;./workerThread.js&quot;</span>));</span><br><span class="line">    <span class="comment">// 获取监听端口</span></span><br><span class="line">    <span class="keyword">const</span> listenPort = listenUrl.split(<span class="string">&quot;:&quot;</span>)[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 向子线程发送要监听的端口号</span></span><br><span class="line">    worker.postMessage(&#123;<span class="attr">type</span>: <span class="string">&quot;port&quot;</span>, <span class="attr">port</span>: listenPort&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收子线程消息统计进程被访问次数</span></span><br><span class="line">    worker.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 监听连接事件并触发计数事件</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&quot;connect&quot;</span>) &#123;</span><br><span class="line">            balanceDataBase.add(msg.port);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 监听断开连接事件并触发计数事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (msg.type === <span class="string">&quot;disconnect&quot;</span>) &#123;</span><br><span class="line">            balanceDataBase.sub(msg.port);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 监听异常退出事件并重新创建进程</span></span><br><span class="line">    worker.on(<span class="string">&quot;exit&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        createWorkerThread(listenUrl);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="再来看看均衡器工作流程-balancer-js">再来看看均衡器工作流程 balancer.js</h2>
<ol>
<li>获取getURL工具函数</li>
<li>监听请求并代理
<ol>
<li>获取需要传入getURL工具函数的参数。</li>
<li>通过getURL工具函数获取均衡代理目的地址URL</li>
<li>记录请求开始时间</li>
<li>处理跨域</li>
<li>返回响应</li>
<li>通过进程通信，触发响应时间更新事件。</li>
</ol>
</li>
</ol>
<blockquote>
<p>注1：LoadBalance函数即通过算法名称返回不同的getURL工具函数，各算法实现见模块二：常见算法</p>
</blockquote>
<blockquote>
<p>注2：getSource函数即处理参数并返回，getURL为上面讲到的获取URL工具函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> LoadBalance = <span class="built_in">require</span>(<span class="string">&quot;./algorithm&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&quot;axios&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> &#123;urlFormat, ipFormat&#125; = <span class="built_in">require</span>(<span class="string">&quot;./util&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;ALGORITHM, BASE_URL&#125; = <span class="built_in">require</span>(<span class="string">&quot;./constant&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;urlDesc, algorithm, port&#125; = <span class="built_in">require</span>(<span class="string">&quot;./config&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取转发URL工具函数</span></span><br><span class="line">    <span class="keyword">const</span> getURL = LoadBalance(urlDesc.slice(<span class="number">0</span>, cpusLen), algorithm);</span><br><span class="line">    <span class="comment">// 监听请求并均衡代理</span></span><br><span class="line">    app.get(<span class="string">&quot;/&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取需要传入的参数</span></span><br><span class="line">        <span class="keyword">const</span> source = <span class="keyword">await</span> getSource(req);</span><br><span class="line">        <span class="comment">// 获取URL</span></span><br><span class="line">        <span class="keyword">const</span> URL = getURL(source);</span><br><span class="line">        <span class="comment">// res.redirect(301, URL) 重定向负载均衡</span></span><br><span class="line">        <span class="comment">// 记录请求开始时间</span></span><br><span class="line">        <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="comment">// 代理请求</span></span><br><span class="line">        axios.get(URL).then(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取负载均衡统计对象并返回</span></span><br><span class="line">            <span class="keyword">const</span> urlCollect = <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">            <span class="comment">// 处理跨域</span></span><br><span class="line">            res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            response.data.urlCollect = urlCollect;</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            res.send(response.data);</span><br><span class="line">            <span class="comment">// 记录相应时间并更新</span></span><br><span class="line">            <span class="keyword">const</span> costTime = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">            process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;updateCostTime&quot;</span>, costTime, URL&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 负载均衡服务器开始监听请求</span></span><br><span class="line">    app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Load Balance Server Running at <span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getSource = <span class="keyword">async</span> (req) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (algorithm) &#123;</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.IP_HASH:</span><br><span class="line">            <span class="keyword">return</span> ipFormat(req);</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.URL_HASH:</span><br><span class="line">            <span class="keyword">return</span> urlFormat(req);</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.CONSISTENT_HASH:</span><br><span class="line">            <span class="keyword">return</span> urlFormat(req);</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.LEAST_CONNECTIONS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.FAIR:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="如何在均衡器中获取负载均衡统计对象-getUrlCollect">如何在均衡器中获取负载均衡统计对象 getUrlCollect</h3>
<ol>
<li>通过进程通信，向父进程发送获取消息。</li>
<li>同时开始监听父进程通信消息，接收后使用Promise resovle返回。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取负载均衡统计对象</span></span><br><span class="line"><span class="keyword">const</span> getUrlCollect = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;getUrlCollect&quot;</span>&#125;)</span><br><span class="line">            process.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.type === <span class="string">&quot;getUrlCollect&quot;</span>) &#123;</span><br><span class="line">                    resolve(msg.urlCollect)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何实现服务节点并发-workerThread-js">如何实现服务节点并发 workerThread.js</h2>
<blockquote>
<p>使用多线程+多进程模型，为每个服务节点提供并发能力。</p>
</blockquote>
<h3 id="主进程流程">主进程流程</h3>
<ol>
<li>根据配置文件，创建相应数量服务节点。
<ol>
<li>创建进程</li>
<li>监听父线程消息（服务节点监听端口），并转发给子进程。</li>
<li>监听子进程消息，并转发给父线程（建立连接、断开连接事件）。</li>
<li>监听异常退出并重新建立。</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> &#123;parentPort&#125; = <span class="built_in">require</span>(<span class="string">&#x27;worker_threads&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;workerNum, workerFilePath&#125; = <span class="built_in">require</span>(<span class="string">&quot;./config&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    <span class="comment">// 创建工作进程函数</span></span><br><span class="line">    <span class="keyword">const</span> createWorker = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 创建进程</span></span><br><span class="line">        <span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">        <span class="comment">// 监听父线程消息，并转发给子进程。</span></span><br><span class="line">        parentPort.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.type === <span class="string">&quot;port&quot;</span>) &#123;</span><br><span class="line">                worker.send(&#123;<span class="attr">type</span>: <span class="string">&quot;port&quot;</span>, <span class="attr">port</span>: msg.port&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 监听子进程消息并转发给父线程</span></span><br><span class="line">        worker.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">            parentPort.postMessage(msg);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 监听进程异常退出并重新创建</span></span><br><span class="line">        worker.on(<span class="string">&quot;exit&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            createWorker();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按配置创建进程，但不可大于CPU核数</span></span><br><span class="line">    <span class="keyword">let</span> max</span><br><span class="line">    <span class="keyword">if</span> (workerNum) &#123;</span><br><span class="line">        max = workerNum &gt; cpusLen ? cpusLen : workerNum</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        createWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 后端服务执行文件</span></span><br><span class="line">    <span class="built_in">require</span>(workerFilePath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="子进程流程-worker-js（config-workerFilePath）">子进程流程 worker.js（config.workerFilePath）</h3>
<ol>
<li>通过进程间通信，向父进程发送消息，触发建立连接事件。</li>
<li>返回相应。</li>
<li>通过进程间通信，向父进程发送消息，触发断开连接事件。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">let</span> port = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发连接事件</span></span><br><span class="line">    process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;connect&quot;</span>, port&#125;);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;HTTP Version: &quot;</span> + req.httpVersion);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Connection PORT Is &quot;</span> + port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&quot;Hello My PORT is &quot;</span> + port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回响应</span></span><br><span class="line">    res.send(&#123;msg&#125;);</span><br><span class="line">    <span class="comment">// 触发断开连接事件</span></span><br><span class="line">    process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;disconnect&quot;</span>, port&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收主进通信消息中的端口口并监听</span></span><br><span class="line">process.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.type === <span class="string">&quot;port&quot;</span>) &#123;</span><br><span class="line">        port = msg.port;</span><br><span class="line">        app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Worker Listening &quot;</span> + port);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="最后来看看DataBase类">最后来看看DataBase类</h2>
<ul>
<li>成员：</li>
</ul>
<ol>
<li>status：任务队列状态</li>
<li>urlCollect：数据统计对象（提供给各算法使用 / 展示数据）
<ol>
<li>count：处理请求数</li>
<li>costTime：响应时间</li>
<li>connection：实时连接数</li>
</ol>
</li>
<li>add方法
<ol>
<li>增加连接数和实时连接数</li>
</ol>
</li>
<li>sub方法
<ol>
<li>减少实时连接数</li>
</ol>
</li>
<li>updateCostTime方法
<ol>
<li>更新响应时间</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBase</span> </span>&#123;</span><br><span class="line">    urlCollect = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="title">constructor</span> (<span class="params">urlObj</span>) &#123;</span><br><span class="line">        urlObj.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.urlCollect[val.url] = &#123;</span><br><span class="line">                count: <span class="number">0</span>,</span><br><span class="line">                costTime: <span class="number">0</span>,</span><br><span class="line">                connection: <span class="number">0</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加连接数和实时连接数</span></span><br><span class="line">    add (port) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].count++;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].connection++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少实时连接数</span></span><br><span class="line">    sub (port) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].connection--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新响应时间</span></span><br><span class="line">    updateCostTime (url, time) &#123;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].costTime = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最终效果">最终效果</h2>
<blockquote>
<p>做了个可视化图表来看均衡效果(Random)✔️</p>
</blockquote>
<blockquote>
<p>看起来均衡效果还不错🧐</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622003557369.(null)" alt="img"></p>
<h1>小作业</h1>
<blockquote>
<p>想手动实现一下负载均衡器 / 看看源码的同学都可以看看 👉🏻   <a target="_blank" rel="noopener" href="https://github.com/LeBronChao/LoadBalancer">代码仓库</a></p>
</blockquote>
<h1>六、知识扩展</h1>
<h2 id="cluster多进程为什么可以监听一个端口">cluster多进程为什么可以监听一个端口?</h2>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003752283.png" alt="image-20210622003752283"></p>
<ol>
<li>通过cluster.isMaster判断是否为主进程，主进程不负责任务处理，只负责管理和调度工作子进程。</li>
<li>master主进程启动了一个TCP服务器，真正监听端口的只有这个TCP服务器。请求触发了这个TCP服务器的<code>connection</code>事件后，通过句柄转发（IPC）给工作进程处理。
<ol>
<li>句柄转发可转发TCP服务器、TCP套接字、UDP套接字、IPC管道</li>
<li>IPC只支持传输字符串，不支持传输对象（可序列化）。</li>
<li>转发流程：父进程发送 -&gt; stringfy &amp;&amp; send(fd) -&gt; IPC -&gt; get(fd) &amp;&amp; parse -&gt; 子进程接收</li>
<li>fd为句柄文件描述符。</li>
</ol>
</li>
<li>如何选择工作进程?
<ol>
<li>cluster模块内置了RoundRobin算法，轮询选择工作进程。</li>
</ol>
</li>
<li>为什么不直接用cluster进行负载均衡?
<ol>
<li>手动实现可根据不同场景选择不同的负载均衡算法。</li>
</ol>
</li>
</ol>
<h2 id="Node怎么实现进程间通信的？">Node怎么实现进程间通信的？</h2>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622003758932.(null)" alt="img"></p>
<ol>
<li>常见的进程间通信方式
<ol>
<li>管道通信
<ol>
<li>匿名管道</li>
<li>命名管道</li>
</ol>
</li>
<li>信号量</li>
<li>共享内存</li>
<li>Socket</li>
<li>消息队列</li>
</ol>
</li>
<li>Node中实现IPC通道是依赖于libuv。Windows下由命名管道实现，*nix系统则采用Domain Socket实现。</li>
<li>表现在应用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。</li>
<li>IPC管道是如何建立的？
<ol>
<li>父进程先通过环境变量告知子进程管道的文件描述符</li>
<li>父进程创建子进程</li>
<li>子进程启动，通过文件描述符连接已存在的IPC管道，与父进程建立连接。</li>
</ol>
</li>
</ol>
<h2 id="多进程-VS-多线程">多进程 VS 多线程</h2>
<h3 id="多进程">多进程</h3>
<ol>
<li>数据共享复杂，需要IPC。数据是分开的，同步简单。</li>
<li>占用内存多，CPU利用率低。</li>
<li>创建销毁复杂，速度慢</li>
<li>进程独立运行，不会相互影响</li>
<li>可用于多机多核分布式，易于扩展</li>
</ol>
<h3 id="多线程">多线程</h3>
<ol>
<li>共享进程数据，数据共享简单，同步复杂。</li>
<li>占用内存少，CPU利用率高。</li>
<li>创建销毁简单，速度快。</li>
<li>线程同呼吸共命运。</li>
<li>只能用于多核分布式。</li>
</ol>
<h1>七、由本次分享产生的一些想法</h1>
<blockquote>
<p>欢迎留言讨论</p>
</blockquote>
<ol>
<li>Node.js非阻塞异步I/O速度快，前端扩展服务端业务？</li>
<li>企业实践，说明Node还是可靠的？
<ol>
<li>阿里Node中台架构</li>
<li>腾讯CloudBase云开发Node</li>
<li>大量Node.js全栈工程师岗位</li>
</ol>
</li>
<li>Node计算密集型不友好？
<ol>
<li>Serverless盛行，计算密集型用C++/Go/Java编写，以Faas的方式调用。</li>
</ol>
</li>
<li>Node生态不如其他成熟的语言
<ol>
<li>阿里输出了Java生态</li>
<li>是不是可以看准趋势，打造Node生态以增强团队影响力。</li>
</ol>
</li>
<li>未雨绸缪，将Node &amp; 服务端业务知识加入学习计划 / 规划专题分享？</li>
<li>讨论</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/357717742/answer/926367671"> Node.js 做 Web 后端优势为什么这么大？ - 知乎 (zhihu.com)</a></li>
</ul>
<h1>八、参考资料</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/85958.html">健康检查概述 - 负载均衡</a></li>
<li>《深入浅出Node.js》</li>
<li><a target="_blank" rel="noopener" href="http://nodejs.cn/">Node.js (nodejs.cn)</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903908385488903#heading-17">深入理解Node.js 中的进程与线程 </a></li>
</ol>
<p>掘金：<a target="_blank" rel="noopener" href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p>
<p>知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p>
<p>持续分享技术博文，关注微信公众号👇🏻</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LeBronChao-</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lebronchao.com/2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">https://lebronchao.com/2021/08/02/LoadBalance负载均衡/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lebronchao.com" target="_blank">LeBronChao's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a><a class="post-meta__tags" href="/tags/Node/">Node</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">进程间通信</a></div><div class="post_share"><div class="social-share" data-image="https://bloginfo.lebronchao.com/doc-image/LoadBalance.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/05/ORM/"><img class="prev-cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/ORM.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">如何优雅地操作数据库？ORM了解一下</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/07/Vue3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/"><img class="next-cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/Vue.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">[建议收藏]你想知道的Vue3核心源码这里都有</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/20/浅析HTTP缓存/" title="浅析HTTP缓存"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/http.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-20</div><div class="title">浅析HTTP缓存</div></div></a></div><div><a href="/2020/12/20/计算机网络-第一章-概述/" title="计算机网络 | 第一章 概述"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-20</div><div class="title">计算机网络 | 第一章 概述</div></div></a></div><div><a href="/2020/12/27/计算机网络-第二章-物理层/" title="计算机网络 | 第二章 物理层"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-27</div><div class="title">计算机网络 | 第二章 物理层</div></div></a></div><div><a href="/2021/01/03/计算机网络-第五章-传输层/" title="计算机网络 | 第五章 传输层"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-03</div><div class="title">计算机网络 | 第五章 传输层</div></div></a></div><div><a href="/2021/01/03/计算机网络-第六章-应用层/" title="计算机网络 | 第六章 应用层"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-03</div><div class="title">计算机网络 | 第六章 应用层</div></div></a></div><div><a href="/2020/12/28/计算机网络-第三章-数据链路层/" title="计算机网络 | 第三章 数据链路层"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-28</div><div class="title">计算机网络 | 第三章 数据链路层</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://bloginfo.lebronchao.com/personal-info/IMG_8050.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">LeBronChao-</div><div class="author-info__description">深圳大学(SZTU)物联网工程大四<br/>前端开发工程师一枚<br/>业余摄影师，交流/约拍可私戳。<br/>字节跳动内推码:4FCV6BV<br/>Email：LeBronChao@foxmail.com</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LeBronChao"><i class="fab fa-github"></i><span>Follow My Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LeBronChao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lebronchao@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://bloginfo.lebronchao.com/personal-info/IMG_8268-20210326002121490.jpg" target="_blank" title="微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1531229587&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">掘金：<a target="_blank" rel="noopener" href="https://juejin.cn/user/3913917127467805">前端LeBron</a><br/>知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/lebronchao">前端LeBron</a><br/>持续分享技术博文，关注wx公众号👇🏻<br/><img src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" /></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Load Balance负载均衡 🌡</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">一、分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%B1%82%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">四层（传输层）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E5%B1%82%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">七层（应用层）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">二、常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Random"><span class="toc-number">3.1.</span> <span class="toc-text">Random</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Weighted-Round-Robin"><span class="toc-number">3.2.</span> <span class="toc-text">Weighted Round Robin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP-Hash-URL-Hash"><span class="toc-number">3.3.</span> <span class="toc-text">IP Hash &amp; URL Hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Consistent-Hash"><span class="toc-number">3.4.</span> <span class="toc-text">Consistent Hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Least-Connections"><span class="toc-number">3.5.</span> <span class="toc-text">Least Connections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FAIR"><span class="toc-number">3.6.</span> <span class="toc-text">FAIR</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">三、健康监测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-HTTPS-%E5%81%A5%E5%BA%B7%E7%9B%91%E6%B5%8B%E6%AD%A5%E9%AA%A4%EF%BC%88%E4%B8%83%E5%B1%82%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">HTTP &#x2F; HTTPS 健康监测步骤（七层）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%9B%9B%E5%B1%82%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">TCP健康检查步骤（四层）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%9B%9B%E5%B1%82%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">UDP健康检查步骤（四层）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">四、VIP技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FIP"><span class="toc-number">5.1.</span> <span class="toc-text">虚拟IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FIP%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">虚拟IP原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">五、基于 nodejs 实现一个简单的负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%9C%9F%E6%95%88%E6%9E%9C"><span class="toc-number">6.1.</span> <span class="toc-text">预期效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%9B%BE"><span class="toc-number">6.2.</span> <span class="toc-text">架构设计图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E7%9C%8B%E7%9C%8B%E4%B8%BB%E6%B5%81%E7%A8%8B-main-js"><span class="toc-number">6.3.</span> <span class="toc-text">先来看看主流程 main.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9D%87%E8%A1%A1%E5%99%A8%EF%BC%88createBalancer%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">创建均衡器（createBalancer函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%EF%BC%88createWorkerThread%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">创建后端服务节点（createWorkerThread函数）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E6%9D%A5%E7%9C%8B%E7%9C%8B%E5%9D%87%E8%A1%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-balancer-js"><span class="toc-number">6.4.</span> <span class="toc-text">再来看看均衡器工作流程 balancer.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%9D%87%E8%A1%A1%E5%99%A8%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%9F%E8%AE%A1%E5%AF%B9%E8%B1%A1-getUrlCollect"><span class="toc-number">6.4.1.</span> <span class="toc-text">如何在均衡器中获取负载均衡统计对象 getUrlCollect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E5%B9%B6%E5%8F%91-workerThread-js"><span class="toc-number">6.5.</span> <span class="toc-text">如何实现服务节点并发 workerThread.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%BF%9B%E7%A8%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">6.5.1.</span> <span class="toc-text">主进程流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%B5%81%E7%A8%8B-worker-js%EF%BC%88config-workerFilePath%EF%BC%89"><span class="toc-number">6.5.2.</span> <span class="toc-text">子进程流程 worker.js（config.workerFilePath）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E6%9D%A5%E7%9C%8B%E7%9C%8BDataBase%E7%B1%BB"><span class="toc-number">6.6.</span> <span class="toc-text">最后来看看DataBase类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C"><span class="toc-number">6.7.</span> <span class="toc-text">最终效果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">小作业</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">六、知识扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cluster%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3"><span class="toc-number">8.1.</span> <span class="toc-text">cluster多进程为什么可以监听一个端口?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">Node怎么实现进程间通信的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B-VS-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.3.</span> <span class="toc-text">多进程 VS 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">8.3.1.</span> <span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.3.2.</span> <span class="toc-text">多线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">七、由本次分享产生的一些想法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">八、参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/02/%E7%A7%8B%E6%8B%9B%E5%88%86%E4%BA%AB/" title="[面经分享] 收获多家大厂offer | 分享我的2022秋招经历"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E5%AD%97%E8%8A%82.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[面经分享] 收获多家大厂offer | 分享我的2022秋招经历"/></a><div class="content"><a class="title" href="/2021/11/02/%E7%A7%8B%E6%8B%9B%E5%88%86%E4%BA%AB/" title="[面经分享] 收获多家大厂offer | 分享我的2022秋招经历">[面经分享] 收获多家大厂offer | 分享我的2022秋招经历</a><time datetime="2021-11-02T15:06:11.000Z" title="发表于 2021-11-02 23:06:11">2021-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/05/Vuex4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="[源码解读]一文读懂Vuex4源码"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[源码解读]一文读懂Vuex4源码"/></a><div class="content"><a class="title" href="/2021/09/05/Vuex4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="[源码解读]一文读懂Vuex4源码">[源码解读]一文读懂Vuex4源码</a><time datetime="2021-09-05T02:25:04.000Z" title="发表于 2021-09-05 10:25:04">2021-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/05/ORM/" title="如何优雅地操作数据库？ORM了解一下"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/ORM.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何优雅地操作数据库？ORM了解一下"/></a><div class="content"><a class="title" href="/2021/09/05/ORM/" title="如何优雅地操作数据库？ORM了解一下">如何优雅地操作数据库？ORM了解一下</a><time datetime="2021-09-05T02:24:50.000Z" title="发表于 2021-09-05 10:24:50">2021-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="[深入浅出LB]手把手带你实现一个负载均衡器"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/LoadBalance.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[深入浅出LB]手把手带你实现一个负载均衡器"/></a><div class="content"><a class="title" href="/2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="[深入浅出LB]手把手带你实现一个负载均衡器">[深入浅出LB]手把手带你实现一个负载均衡器</a><time datetime="2021-08-01T16:11:46.000Z" title="发表于 2021-08-02 00:11:46">2021-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/07/Vue3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/" title="[建议收藏]你想知道的Vue3核心源码这里都有"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/Vue.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[建议收藏]你想知道的Vue3核心源码这里都有"/></a><div class="content"><a class="title" href="/2021/07/07/Vue3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/" title="[建议收藏]你想知道的Vue3核心源码这里都有">[建议收藏]你想知道的Vue3核心源码这里都有</a><time datetime="2021-07-06T17:09:08.000Z" title="发表于 2021-07-07 01:09:08">2021-07-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By LeBronChao-</div><div class="footer_custom_text">@ 2021 LeBronChao- CopyRight | 粤ICP备2021025161号</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'TKAoSdRXJ5zxwsjdGTP0Hrfh-9Nh9j0Va',
      appKey: 'lI3CGg5rpWkxsfvsKTRkVszT',
      placeholder: '留下你的足迹吧，記得留下你的昵称和邮箱....可以快速收到回复',
      avatar: 'https://bloginfo.lebronchao.com/doc-image/touxiang.jpeg',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-cn',
      recordIP: true,
      serverURLs: 'https://tkaosdrx.lc-cn-e1-shared.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (true) {
      const otherData = {"master":["64951ad612e26b51f6cc37788be7c200","b467dec92be8eb17c36ca900ef5d8dc1"],"friends":["30932c612db8dca9f08b98d6c1818ba2","898f30c9b8971d165a03abe4deba1ac6","741b327a5a0afbafd674ac782ddb0835","8dc27dfae152eb47084d3d0ae48c33d5","49fa154bbe0132bb66cb50c473f7f3ab","1f1338f1eff80cd7184516e788f9cbca","316d73187eea974f9f29c9fe4dc84a63","d4964055fcfa2b76c06d8cb038b0954e"],"metaPlaceholder":{"nick":"昵称(必填)","mail":"邮箱(必填,QQ邮箱可显示头像)","link":"主页(https://)"}}
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>