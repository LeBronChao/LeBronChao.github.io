<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>NodeJS加解密之Crypto | LeBronChao's Blog</title><meta name="keywords" content="JavaScript,Node,服务端"><meta name="author" content="LeBronChao-"><meta name="copyright" content="LeBronChao-"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="互联网时代，网络上的数据量每天都在以惊人的速度增长。同时，各类网络安全问题层出不穷。在信息安全重要性日益凸显的今天，作为一名开发者，需要加强对安全的认识，并通过技术手段增强服务的安全性。crypto 模块的目的是为了提供通用的加密和哈希算法。用纯 JavaScript 代码实现这些功能不是不可能，但速度会非常慢。Nodejs 用 C&#x2F;C++实现这些算法后，通过 cypto 这个模块暴露为 Jav">
<meta property="og:type" content="article">
<meta property="og:title" content="NodeJS加解密之Crypto">
<meta property="og:url" content="https://lebronchao.com/2021/12/22/NodeJS%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BCrypto/index.html">
<meta property="og:site_name" content="LeBronChao&#39;s Blog">
<meta property="og:description" content="互联网时代，网络上的数据量每天都在以惊人的速度增长。同时，各类网络安全问题层出不穷。在信息安全重要性日益凸显的今天，作为一名开发者，需要加强对安全的认识，并通过技术手段增强服务的安全性。crypto 模块的目的是为了提供通用的加密和哈希算法。用纯 JavaScript 代码实现这些功能不是不可能，但速度会非常慢。Nodejs 用 C&#x2F;C++实现这些算法后，通过 cypto 这个模块暴露为 Jav">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/node.png">
<meta property="article:published_time" content="2021-12-22T15:50:51.000Z">
<meta property="article:modified_time" content="2021-12-22T15:50:51.000Z">
<meta property="article:author" content="LeBronChao-">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="Node">
<meta property="article:tag" content="服务端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/node.png"><link rel="shortcut icon" href="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/bitbug_favicon%20(1).ico"><link rel="canonical" href="https://lebronchao.com/2021/12/22/NodeJS%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BCrypto/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0f958a253362f27db5bafcef151a46ab";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: LeBronChao-","link":"链接: ","source":"来源: LeBronChao's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-22 23:50:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="LeBronChao's Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/personal-info/IMG_8050.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">88</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-video"></i><span> 摄影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/Front-End/"><i class="fa-fw fas fa-laptop"></i><span> Front End</span></a></li><li><a class="site-page" href="/categories/Back-End/"><i class="fa-fw fas fa-database"></i><span> Back End</span></a></li><li><a class="site-page" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa-fw fas fa-wifi"></i><span> 计算机网络</span></a></li><li><a class="site-page" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fa fa-cubes"></i><span> 设计模式</span></a></li><li><a class="site-page" href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"><i class="fa-fw fab fa-git-square"></i><span> 开发技能</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/node.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LeBronChao's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-video"></i><span> 摄影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/Front-End/"><i class="fa-fw fas fa-laptop"></i><span> Front End</span></a></li><li><a class="site-page" href="/categories/Back-End/"><i class="fa-fw fas fa-database"></i><span> Back End</span></a></li><li><a class="site-page" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa-fw fas fa-wifi"></i><span> 计算机网络</span></a></li><li><a class="site-page" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fa fa-cubes"></i><span> 设计模式</span></a></li><li><a class="site-page" href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"><i class="fa-fw fab fa-git-square"></i><span> 开发技能</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NodeJS加解密之Crypto</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-22T15:50:51.000Z" title="发表于 2021-12-22 23:50:51">2021-12-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-22T15:50:51.000Z" title="更新于 2021-12-22 23:50:51">2021-12-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Back-End/">Back End</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>互联网时代，网络上的数据量每天都在以惊人的速度增长。同时，各类网络安全问题层出不穷。在信息安全重要性日益凸显的今天，作为一名开发者，需要加强对安全的认识，并通过技术手段增强服务的安全性。crypto 模块的目的是为了提供通用的加密和哈希算法。用纯 JavaScript 代码实现这些功能不是不可能，但速度会非常慢。Nodejs 用 C/C++实现这些算法后，通过 cypto 这个模块暴露为 JavaScript 接口，这样用起来方便，运行速度也快。</p>
</blockquote>
<h1>编码方式</h1>
<blockquote>
<p>为什么信息传输需要编码？</p>
<p>在开发加密解密数据的时候碰到需要把加密好的字节数组转换成 String 对象用于网络传输的需求，如果把字节数组直接转换成 UTF-8 等编码方式的话肯定会存在某些编码没有对应的字符(8bit 只能表示 128 个字符)，在编码和解析过程中会出错，不能正确地表达信息。这时就可以通过常用的二进制数据编码方式 Base64 编码或者 Hex 编码来实现。</p>
</blockquote>
<h2 id="hex-编码"><strong>hex 编码</strong></h2>
<ul>
<li>编码原理</li>
</ul>
<p>将一个 8 位的字节数据用两个 16 进制数表示出来</p>
<ol>
<li>将 8 位二进制码重新分组成两个 4 位的字节</li>
<li>其中一个字节的低 4 位是原字节的高 4 位，另一个字节的低 4 位是原数据的低 4 位</li>
<li>高 4 位都补 0，然后输出这两个字节对应的十六进制数字作为编码</li>
</ol>
<ul>
<li>例子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ASCII码：A(<span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">二进制码:<span class="number">0100</span> <span class="number">0001</span></span><br><span class="line"></span><br><span class="line">重新分组: <span class="number">00000100</span>  <span class="number">00000001</span></span><br><span class="line"></span><br><span class="line">十六进制: <span class="number">4</span>         <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Hex编码：<span class="number">41</span></span><br></pre></td></tr></table></figure>
<p>就算原文件是纯英文内容，编码后内容也和原文完全不一样，普通人难以阅读但由于只有 16 个字符，听说一些程序员大牛能够记下他们的映射关系，从而达到读 hex 编码和读原文一样的效果。另外，数据在经过 hex 编码后，空间占用变成了原来的 2 倍。</p>
<h2 id="base64-编码"><strong>base64 编码</strong></h2>
<ul>
<li>编码原理</li>
</ul>
<p>Base64 编码是通过 64 个字符来表示二进制数据，64 个字符表示二进制数据只能表示 6 位，所以它可以通过 4 个 Base64 字符来表示 3 个字节，如下是 Base64 的字符编码表</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202230237552.(null)" alt="img"></p>
<ul>
<li>举个 Base64 编码的例子，图就很浅显易懂了</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202230244003.(null)" alt="img"></p>
<ul>
<li>字符串长度不是 3 的倍数时补 0，也就是“=”</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202230248378.(null)" alt="img"></p>
<p>由 64 个字符组成，比 hex 编码更难阅读，但由于每 3 个字节会被编码为 4 个字符。</p>
<p>所以，空间占用会是原来的 4/3，比 hex 要节省空间。另外要注意的是，虽然 Base64 编码后的数据难以阅读，但不能将其作为加密算法使用，因为它解码都不需要你提供密钥啊</p>
<h2 id="urlencode-编码"><strong>urlencode 编码</strong></h2>
<ul>
<li>编码原理</li>
</ul>
<p>urlencode 编码，看名字就就知道是设计给 url 编码的对于<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，<code>.</code>，<code>-</code>和<code>_</code> ，urlencode 都不会做任何处理原样输出，而其它字节会被编码为<code>%xx</code>(16 进制)的形式，其中<code>xx</code>就是这个字节对应的 hex 编码。 由于英文字符原样保留，对于以英文为主的内容，可读性最好，空间占用几乎不变，而对于非英文内容，每个字节会被编码为%xx 的 3 个字符，空间占用是原来的 3 倍，所以 urlencode 是一个对英文友好的编码方案。</p>
<h1><strong>Hash</strong></h1>
<blockquote>
<p>摘要：将不固定长度的消息作为输入 Hash 函数，生成固定长度的输出，这段输出称之为摘要</p>
<p>适用场景：敏感信息的校验和存储、验证消息完整 &amp; 未被篡改</p>
</blockquote>
<h2 id="特点"><strong>特点</strong></h2>
<ol>
<li>输出长度固定：输入长度不固定，输出长度固定（因算法而异，常见的有 MD5、SHA 系列）。</li>
<li>运算不可逆：已知运算结果的情况下，无法通过通过逆运算得到原始字符串。</li>
<li>高度离散：输入的微小变化，可导致运算结果差异巨大。</li>
<li>弱碰撞性：不同输入的散列值可能相同。</li>
</ol>
<h2 id="以-MD5-为例">以 MD5 为例</h2>
<blockquote>
<p>MD5（Message-Digest Algorithm）是计算机安全领域广泛使用的散列函数（又称哈希算法、摘要算法），主要用来确保消息的完整和一致性。</p>
<p>常见的应用场景：密码保护、下载文件校验等。</p>
</blockquote>
<h2 id="应用场景"><strong>应用场景</strong></h2>
<ol>
<li>文件完整性校验：比如从网上下载一个软件，一般网站都会将软件的 md5 值附在网页上，用户下载完软件后，可对下载到本地的软件进行 md5 运算，然后跟网站上的 md5 值进行对比，确保软件的完整性</li>
<li>密码保护：将 md5 后的密码保存到数据库，而不是保存明文密码，避免拖库等事件发生后，明文密码泄漏。</li>
<li>防篡改：比如数字证书的防篡改，就用到了摘要算法。（当然还要结合数字签名等手段）</li>
</ol>
<h2 id="简单的-md5-运算">简单的 md5 运算</h2>
<ul>
<li>hash.digest([encoding])</li>
</ul>
<p>计算摘要。encoding 可以是<code>hex</code>、<code>base64</code>或其他。如果声明了 encoding，那么返回字符串。否则，返回 Buffer 实例。注意，调用 hash.digest()后，hash 对象就作废了，再次调用就会报错。</p>
<ul>
<li>hash.update(data[, input_encoding])</li>
</ul>
<p>input_encoding 可以是<code>utf8</code>、<code>ascii</code>或者其他。如果 data 是字符串，且没有指定 input_encoding，则默认是<code>utf8</code>。注意，hash.update()方法可以调用多次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FILE_PATH = <span class="string">&#x27;./index.txt&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ENCODING = <span class="string">&#x27;hex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(FILE_PATH);</span><br><span class="line"><span class="keyword">const</span> result = md5.update(content).digest(ENCODING);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// f62091d58876a322864f5a522eb05052</span></span><br></pre></td></tr></table></figure>
<h2 id="密码保护">密码保护</h2>
<blockquote>
<p>前面提到，将明文密码保存到数据库是很不安全的</p>
<p>最不济也要进行 md5 后进行保存</p>
<p>比如用户密码是<code>123456</code>，md5 运行后，得到<code>输出：e10adc3949ba59abbe56e057f20f883e</code></p>
</blockquote>
<p>这样至少有两个好处：</p>
<ol>
<li>防内部攻击：网站开发者也不知道用户的明文密码，避免开发者拿着用户明文密码干坏事，以这种形式来保护用户的隐私</li>
<li>防外部攻击：如网站被黑客入侵，黑客也只能拿到 md5 后的密码，而不是用户的明文密码，保证了密码的安全性</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cryptPwd = <span class="function">(<span class="params">password</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> md5.update(password).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> cryptPassword = cryptPwd(password);</span><br><span class="line"><span class="built_in">console</span>.log(cryptPassword);</span><br><span class="line"></span><br><span class="line"><span class="comment">// e10adc3949ba59abbe56e057f20f883e</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前面提到，通过对用户密码进行 md5 运算来提高安全性。
<ul>
<li>但实际上，这样的安全性是很差的，为什么呢？</li>
<li>稍微修改下上面的例子，可能你就明白了。相同的明文密码，md5 值也是相同的。</li>
</ul>
</li>
<li>也就是说当攻击者知道算法是 md5，且数据库里存储的密码值为<code>e10adc3949ba59abbe56e057f20f883e</code>时，理论上可以可以猜到，用户的明文密码就是<code>123456</code>。</li>
<li>事实上，彩虹表就是这么进行暴力破解的：事先将常见明文密码的 md5 值运算好存起来，然后跟网站数据库里存储的密码进行匹配，就能够快速找到用户的明文密码。</li>
</ul>
<blockquote>
<p>那么有什么办法可以进一步提升安全性呢？</p>
<p>答案是：密码加盐。</p>
</blockquote>
<h2 id="密码加盐"><strong>密码加盐</strong></h2>
<blockquote>
<p>“加盐”这个词看上去很玄乎，其实原理很简单</p>
<p>就是在密码特定位置插入特定字符串后，再对修改后的字符串进行 md5 运算。</p>
</blockquote>
<p>同样的密码，当“盐”值不一样时，md5 值的差异非常大</p>
<p>通过密码加盐，可以防止最初级的暴力破解，如果攻击者事先不知道”盐“值，破解的难度就会非常大</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cryptPwd = <span class="function">(<span class="params">password, salt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> saltPassword = <span class="string">`<span class="subst">$&#123;password&#125;</span>:<span class="subst">$&#123;salt&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`原始密码：<span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码：<span class="subst">$&#123;saltPassword&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = md5.update(password).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码的MD5值：<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> salt = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">cryptPwd(password, salt);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始密码：123456</span></span><br><span class="line"><span class="comment">加盐密码：123456:abc</span></span><br><span class="line"><span class="comment">加盐密码的MD5值：e10adc3949ba59abbe56e057f20f883e</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="密码加盐：随机盐值"><strong>密码加盐：随机盐值</strong></h2>
<blockquote>
<p>通过密码加盐，密码的安全性已经提高了不少</p>
<p>但其实上面的例子存在不少问题</p>
</blockquote>
<ul>
<li>假设字符串拼接算法、盐值已外泄，上面的代码至少存在下面问题：</li>
</ul>
<ol>
<li>短盐值：需要穷举的可能性较少，容易暴力破解，一般采用长盐值来解决。</li>
<li>盐值固定：类似的，攻击者只需要把常用密码+盐值的 hash 值表算出来。</li>
</ol>
<ul>
<li>短盐值自不必说，应该避免
<ul>
<li>对于为什么不应该使用固定盐值，这里需要多解释一下。很多时候，我们的盐值是硬编码到我们的代码里的（比如配置文件），一旦攻击者通过某种手段获知了盐值，那么，只需要针对这串固定的盐值进行暴力穷举就行了</li>
</ul>
</li>
<li>比如上面的代码，当你知道盐值是<code>abc</code>时，立刻就能猜到<code>51011af1892f59e74baf61f3d4389092</code>对应的明文密码是<code>123456</code>。</li>
</ul>
<blockquote>
<p>那么，该怎么优化呢？答案是：随机盐值。</p>
</blockquote>
<p>可以看到，密码同样是 123456，由于采用了随机盐值，前后运算得出的结果是不同的</p>
<p>这样带来的好处是，多个用户，同样的密码，攻击者需要进行多次运算才能够完全破解</p>
<p>同样是纯数字 3 位短盐值，随机盐值破解所需的运算量 &gt;&gt; 固定盐值</p>
<blockquote>
<p>示例代码如下</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getRandomSalt = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random().toString().slice(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cryptPwd = <span class="function">(<span class="params">password, salt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> saltPassword = <span class="string">`<span class="subst">$&#123;password&#125;</span>:<span class="subst">$&#123;salt&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`原始密码：<span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码：<span class="subst">$&#123;saltPassword&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = md5.update(saltPassword).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码的MD5值：<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cryptPwd(password, getRandomSalt());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始密码：123456</span></span><br><span class="line"><span class="comment">加盐密码：123456:126</span></span><br><span class="line"><span class="comment">加盐密码的MD5值：3aeb1848ff63aa32b262bc3f8dd5bd82</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">cryptPwd(password, getRandomSalt());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始密码：123456</span></span><br><span class="line"><span class="comment">加盐密码：123456:232</span></span><br><span class="line"><span class="comment">加盐密码的MD5值：21a427268a5094322146e18e47b135fb</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="HMAC-功能"><strong>HMAC 功能</strong></h2>
<blockquote>
<p>HMAC 的全称是 Hash-based Message Authentication Code，也即在 hash 的加盐运算。</p>
<p>具体到使用的话，跟 hash 模块差不多，选定 hash 算法，指定“盐”即可。</p>
<p>和上面的例子的区别是一个是手动拼盐值，一个是利用 HMAC 模块</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FILE_PATH = <span class="string">&quot;./index.txt&quot;</span></span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">&#x27;secret&#x27;</span></span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(FILE_PATH,&#123;<span class="attr">encoding</span>:<span class="string">&#x27;utf8&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> hmac = crypto.createHmac(<span class="string">&#x27;sha256&#x27;</span>, SECRET);</span><br><span class="line"></span><br><span class="line">hmac.update(content)</span><br><span class="line"><span class="keyword">const</span> output = hmac.digest(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hmac: <span class="subst">$&#123;output&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hmac: 6f438ef66d3806ae14d6692d9610e55c41ebb4eb3ee73911a4d512bd1cade976</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：大文件可流式处理</p>
</blockquote>
<h1>加密 / 解密</h1>
<blockquote>
<p>加解密主要用到下面两组方法：</p>
</blockquote>
<ul>
<li>
<p>加密：</p>
<ul>
<li>crypto.createCipher(algorithm, password)</li>
</ul>
</li>
<li>
<p>crypto.createCipheriv(algorithm, key, iv)</p>
</li>
<li>
<p>解密：</p>
<ul>
<li>crypto.createDecipher(algorithm, password)</li>
</ul>
</li>
<li>
<p>crypto.createDecipheriv(algorithm, key, iv)</p>
</li>
</ul>
<h2 id="crypto-createCipher-crypto-createDecipher"><strong>crypto.createCipher / crypto.createDecipher</strong></h2>
<blockquote>
<p>先来看下 crypto.createCipher(algorithm, password)，两个参数分别是加密算法、密码</p>
</blockquote>
<ul>
<li>
<p>algorithm：加密算法，比如<code>aes192</code></p>
<ul>
<li>具体有哪些可选的算法，依赖于本地<code>openssl</code>的版本</li>
</ul>
</li>
<li>
<p>可以通过<code>openssl list-cipher-algorithms</code>命令查看支持哪些算法</p>
</li>
<li>
<p>password：用来生成密钥(key)、初始化向量(IV)</p>
</li>
</ul>
<blockquote>
<p>crypto.createDecipher(algorithm, password)可以看作 crypto.createCipher(algorithm, password) 逆向操作</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">&#x27;secret&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ALGORITHM = <span class="string">&#x27;aes192&#x27;</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;Hello Node.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">const</span> cipher = crypto.createCipher(ALGORITHM, SECRET)</span><br><span class="line">cipher.update(content)</span><br><span class="line"><span class="keyword">const</span> output = cipher.final(encoding)</span><br><span class="line"><span class="built_in">console</span>.log(output)</span><br><span class="line"><span class="comment">// 944e6e3c21d6eb8568bd6a9716631e、e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">const</span> decipher = crypto.createDecipher(ALGORITHM, SECRET)</span><br><span class="line">decipher.update(output, encoding)</span><br><span class="line"><span class="keyword">const</span> input = decipher.final(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(input)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello Node.js</span></span><br></pre></td></tr></table></figure>
<h2 id="crypto-createCipheriv-crypto-createDecipheriv"><strong>crypto.createCipheriv / crypto.createDecipheriv</strong></h2>
<blockquote>
<p>相对于 crypto.createCipher() 来说，crypto.createCipheriv() 需要提供<code>key</code>和<code>iv</code>，而 crypto.createCipher() 是根据用户提供的 password 算出来的</p>
<p>key、iv 可以是 Buffer，也可以是 utf8 编码的字符串，这里需要关注的是它们的长度：</p>
</blockquote>
<ul>
<li>
<p>key：根据选择的算法有关</p>
<ul>
<li>比如 aes128、aes192、aes256，长度分别是 128、192、256 位（16、24、32 字节）</li>
</ul>
</li>
<li>
<p>iv：初始化向量，都是 128 位（16 字节），也可以理解为密码盐的一种</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> key = crypto.randomBytes(<span class="number">192</span> / <span class="number">8</span>)</span><br><span class="line"><span class="keyword">const</span> iv = crypto.randomBytes(<span class="number">128</span> / <span class="number">8</span>)</span><br><span class="line"><span class="keyword">const</span> algorithm = <span class="string">&#x27;aes192&#x27;</span></span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encrypt = <span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cipher = crypto.createCipheriv(algorithm, key, iv)</span><br><span class="line">    cipher.update(text)</span><br><span class="line">    <span class="keyword">return</span> cipher.final(encoding)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrypt = <span class="function">(<span class="params">encrypted</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.createDecipheriv(algorithm, key, iv)</span><br><span class="line">    decipher.update(encrypted, encoding)</span><br><span class="line">    <span class="keyword">return</span> decipher.final(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;Hello Node.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> crypted = encrypt(content)</span><br><span class="line"><span class="built_in">console</span>.log(crypted)</span><br><span class="line"></span><br><span class="line"><span class="comment">// db75f3e9e78fba0401ca82527a0bbd62</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrypted = decrypt(crypted)</span><br><span class="line"><span class="built_in">console</span>.log(decrypted)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello Node.js</span></span><br></pre></td></tr></table></figure>
<h2 id="数字签名-签名校验"><strong>数字签名</strong> <strong>/ 签名校验</strong></h2>
<ul>
<li>假设：
<ul>
<li>服务端原始信息为 M，摘要算法为 Hash，Hash(M)得出的摘要是 H</li>
<li>公钥为 Pub，私钥为 Piv，非对称加密算法为 Encrypt，非对称解密算法为 Decrypt</li>
<li>Encrypt(H)得到的结果是 S</li>
<li>客户端拿到的信息为 M1，利用 Hash(M1)得出的结果是 H1</li>
</ul>
</li>
<li>数字签名的产生、校验步骤分别如下：
<ul>
<li>数字签名的产生步骤：
<ul>
<li>利用摘要算法 Hash 算出 M 的摘要，即 Hash(M) == H</li>
<li>利用非对称加密算法对摘要进行加密 Encrypt( H, Piv )，得到数字签名 S</li>
</ul>
</li>
<li>数字签名的校验步骤：
<ul>
<li>利用解密算法 D 对数字签名进行解密，即 Decrypt(S) == H</li>
<li>计算 M1 的摘要 Hash(M1) == H1，对比 H、H1，如果两者相同，则通过校验</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>私钥如何生成不是这里的重点，这里采用网上的服务来生成。</p>
<p>了解了数字签名产生、校验的原理后，相信下面的代码很容易理解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> privateKey = fs.readFileSync(<span class="string">&#x27;./private-key.pem&#x27;</span>);  <span class="comment">// 私钥</span></span><br><span class="line"><span class="keyword">const</span> publicKey = fs.readFileSync(<span class="string">&#x27;./public-key.pem&#x27;</span>);  <span class="comment">// 公钥</span></span><br><span class="line"><span class="keyword">const</span> algorithm = <span class="string">&#x27;RSA-SHA256&#x27;</span>;  <span class="comment">// 加密算法 vs 摘要算法</span></span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字签名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sign</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sign = crypto.createSign(algorithm);</span><br><span class="line">    sign.update(text);</span><br><span class="line">    <span class="keyword">return</span> sign.sign(privateKey, encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验签名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">oriContent, signature</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> verifier = crypto.createVerify(algorithm);</span><br><span class="line">    verifier.update(oriContent);</span><br><span class="line">    <span class="keyword">return</span> verifier.verify(publicKey, signature, encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对内容进行签名</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> signature = sign(content);</span><br><span class="line"><span class="built_in">console</span>.log(signature);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验签名，如果通过，返回true</span></span><br><span class="line"><span class="keyword">const</span> verified = verify(content, signature);</span><br><span class="line"><span class="built_in">console</span>.log(verified);</span><br></pre></td></tr></table></figure>
<h2 id="DH-DiffieHellman">DH(DiffieHellman)</h2>
<blockquote>
<p>DiffieHellman：Diffie–Hellman key exchange，缩写为 D-H，是一种安全协议，常用于密钥交换，让通信双方在预先没有对方信息的情况下，通过不安全通信信道，创建一个密钥。这个密钥可以在后续的通信中，作为对称加密的密钥加密传递的信息。</p>
</blockquote>
<ul>
<li>原理解析</li>
</ul>
<p>假设客户端、服务端挑选两个素数 a、p（都公开），然后</p>
<ul>
<li>
<p>客户端：选择自然数 Xa，Ya = a^Xa mod p，并将 Ya 发送给服务端；</p>
</li>
<li>
<p>服务端：选择自然数 Xb，Yb = a^Xb mod p，并将 Yb 发送给客户端；</p>
</li>
<li>
<p>客户端：计算 Ka = Yb^Xa mod p</p>
</li>
<li>
<p>服务端：计算 Kb = Ya^Xb mod p</p>
</li>
</ul>
<blockquote>
<p>Ka = Yb^Xa mod p</p>
<p>= (a^Xb mod p)^Xa mod p</p>
<p>= a^(Xb * Xa) mod p</p>
<p>= (a^Xa mod p)^Xb mod p</p>
<p>= Ya^Xb mod p</p>
<p>= Kb</p>
<p>可以看到，尽管客户端、服务端彼此不知道对方的 Xa、Xb，但算出了相等的 secret</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> primeLength = <span class="number">1024</span>;  <span class="comment">// 素数p的长度</span></span><br><span class="line"><span class="keyword">const</span> generator = <span class="number">5</span>;  <span class="comment">// 素数a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建客户端的DH实例</span></span><br><span class="line"><span class="keyword">const</span> client = crypto.createDiffieHellman(primeLength, generator);</span><br><span class="line"><span class="comment">// 产生公、私钥对，Ya = a^Xa mod p</span></span><br><span class="line"><span class="keyword">const</span> clientKey = client.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务端的DH实例，采用跟客户端相同的素数a、p</span></span><br><span class="line"><span class="keyword">const</span> server = crypto.createDiffieHellman(client.getPrime(), client.getGenerator());</span><br><span class="line"><span class="comment">// 产生公、私钥对，Yb = a^Xb mod p</span></span><br><span class="line"><span class="keyword">const</span> serverKey = server.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 Ka = Yb^Xa mod p</span></span><br><span class="line"><span class="keyword">const</span> clientSecret = client.computeSecret(server.getPublicKey());</span><br><span class="line"><span class="comment">// 计算 Kb = Ya^Xb mod p</span></span><br><span class="line"><span class="keyword">const</span> serverSecret = server.computeSecret(client.getPublicKey());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于素数p是动态生成的，所以每次打印都不一样</span></span><br><span class="line"><span class="comment">// 但是 clientSecret === serverSecret</span></span><br><span class="line"><span class="built_in">console</span>.log(clientSecret.toString(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(serverSecret.toString(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="comment">// 39edfedad4f1be731977436936ca844e50ebc90953ad208c71d7f2dc1772409962ec3eb90eaf99db5948f089e1d4951f148bd7ff76c18b53ff6be32f267fc54535928ce4acf15d923cfd0caec45db95b206e7636128210ea6813a20fb09cbfb06214b2f488716fea32788023d98cb4cb7fe39b68bd3563b3b34257e37f6b7fb7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 39edfedad4f1be731977436936ca844e50ebc90953ad208c71d7f2dc1772409962ec3eb90eaf99db5948f089e1d4951f148bd7ff76c18b53ff6be32f267fc54535928ce4acf15d923cfd0caec45db95b206e7636128210ea6813a20fb09cbfb06214b2f488716fea32788023d98cb4cb7fe39b68bd3563b3b34257e37f6b7fb7</span></span><br></pre></td></tr></table></figure>
<h2 id="ECDH-Elliptic-Curve-Diffie-Hellma">ECDH(Elliptic Curve Diffie-Hellma)</h2>
<blockquote>
<p>ECDH 和 DH 原理类似，都是安全密钥协商协议。</p>
<p>相对于 DH 协议，结合椭圆曲线密码学 ECC 加速，运算更节省 CPU 资源</p>
</blockquote>
<ul>
<li>ECDH（<strong>Elliptic Curve Diffie-Hellman</strong> ）原理如下</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/(null)-20211202230722255.(null)" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> G = <span class="string">&#x27;secp521r1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = crypto.createECDH(G);</span><br><span class="line"><span class="keyword">const</span> serverKey = server.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = crypto.createECDH(G);</span><br><span class="line"><span class="keyword">const</span> clientKey = client.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serverSecret = server.computeSecret(clientKey);</span><br><span class="line"><span class="keyword">const</span> clientSecret = client.computeSecret(serverKey);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(serverSecret.toString(encoding));</span><br><span class="line"><span class="built_in">console</span>.log(clientSecret.toString(encoding));</span><br><span class="line"><span class="comment">// 01c418be1b479f936397d4c1653ad77fa28fade67ff058dc18264a72bd1fc208ea6cac4dad996fda55bf271e84f0faef085173257b67bf21f95b09acee4d0a204517</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 01c418be1b479f936397d4c1653ad77fa28fade67ff058dc18264a72bd1fc208ea6cac4dad996fda55bf271e84f0faef085173257b67bf21f95b09acee4d0a204517</span></span><br></pre></td></tr></table></figure>
<h2 id="ECDHE-Elliptic-Curve-Diffie-Hellma-Ephemeral">ECDHE(Elliptic Curve Diffie-Hellma Ephemeral)</h2>
<blockquote>
<p>普通的 ECDH 算法也存在一定缺陷，比如密钥协商的时候有一方的私钥总是一样的，一般都是 Server 方固定，Client 方私钥随机生成。随着时间的延长，黑客可以截获到海量的密钥协商过程（有些数据是公开的），黑客就可以依据这些数据暴力破解出 Server 的私钥，然后就可以计算出会话密钥了，加密的数据也会随之被破解。固定一方的私钥会有被破解的风险，那么就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个算法就是 ECDH 的增强版：ECDHE， E 全称是 Ephemeral（临时性的）。</p>
</blockquote>
<h1>扩展</h1>
<blockquote>
<p>学习这块儿知识的同时也学习了很多密码学相关知识，发现越挖越深快陷进去了 😂，感兴趣的同学可以继续展开看看相关加密算法和他们之间的区别以及应用场景，例如：</p>
</blockquote>
<ul>
<li>非对称加密 DSA、RSA、DH、DHE、ECDHE</li>
<li>对称加密 AES、DES</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg">RSA 算法原理（二） - 阮一峰的网络日志</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/14318338.html">图解 ECDHE 密钥交换算法 - 小林 coding</a></p>
<p>资料加密标准(DES) - 维基百科](<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96">https://zh.wikipedia.org/wiki/資料加密標準</a>)</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">高级加密标准(AES) - 维基百科</a></p>
</blockquote>
<h1><strong>相关术语</strong></h1>
<p>SPKAC：Signed Public Key and Challenge</p>
<p>MD5：Message-Digest Algorithm 5，信息-摘要算法。</p>
<p>SHA：Secure Hash Algorithm，安全散列算法。</p>
<p>HMAC：Hash-based Message Authentication Code，密钥相关的哈希运算消息认证码。</p>
<p>对称加密：比如 AES、DES</p>
<p>非对称加密：比如 RSA、DSA</p>
<p>AES：Advanced Encryption Standard（高级加密标准），密钥长度可以是 128、192 和 256 位。</p>
<p>DES：Data Encryption Standard，数据加密标准，对称密钥加密算法（现在认为不安全）。</p>
<p>DiffieHellman：Diffie–Hellman key exchange，缩写为 D-H，是一种安全协议，让通信双方在预先没有对方信息的情况下，通过不安全通信信道，创建一个密钥。这个密钥可以在后续的通信中，作为对称加密的密钥加密传递的信息。（备注，是使用协议的发明者命名）</p>
<p><strong>密钥交换算法</strong></p>
<p>常见的密钥交换算法有 RSA，ECDHE，DH，DHE 等算法。它们的特性如下：</p>
<ul>
<li>
<p>RSA：算法实现简单，诞生于 1977 年，历史悠久，经过了长时间的破解测试，安全性高。缺点就是需要比较大的素数（目前常用的是 2048 位）来保证安全强度，很消耗 CPU 运算资源。RSA 是目前唯一一个既能用于密钥交换又能用于证书签名的算法。</p>
</li>
<li>
<p>DH：diffie-hellman 密钥交换算法，诞生时间比较早（1977 年），但是 1999 年才公开。缺点是比较消耗 CPU 性能。</p>
</li>
<li>
<p>ECDHE：使用椭圆曲线（ECC）的 DH 算法，优点是能用较小的素数（256 位）实现 RSA 相同的安全等级。缺点是算法实现复杂，用于密钥交换的历史不长，没有经过长时间的安全攻击测试。</p>
</li>
<li>
<p>ECDH：不支持 PFS，安全性低，同时无法实现 false start。</p>
</li>
<li>
<p>DHE：不支持 ECC。非常消耗 CPU 资源 。</p>
</li>
</ul>
<p>建议优先支持 RSA 和 ECDH_RSA 密钥交换算法。原因是：</p>
<ul>
<li>
<p>ECDHE 支持 ECC 加速，计算速度更快。支持 PFS，更加安全。支持 false start，用户访问速度更快。</p>
</li>
<li>
<p>目前还有至少 20% 以上的客户端不支持 ECDHE，我们推荐使用 RSA 而不是 DH 或者 DHE，因为 DH 系列算法非常消耗 CPU（相当于要做两次 RSA 计算）。</p>
</li>
</ul>
<p>掘金：<a target="_blank" rel="noopener" href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p>
<p>知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p>
<p>持续分享技术博文，关注微信公众号 👇🏻</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LeBronChao-</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lebronchao.com/2021/12/22/NodeJS%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BCrypto/">https://lebronchao.com/2021/12/22/NodeJS加解密之Crypto/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lebronchao.com" target="_blank">LeBronChao's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/Node/">Node</a><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/">服务端</a></div><div class="post_share"><div class="social-share" data-image="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/node.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/07/%E6%91%84%E5%BD%B1-%E5%8D%97%E5%B1%B1%E5%A4%9C%E6%99%AF/"><img class="prev-cover" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00174.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">摄影 | 南山夜景</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/11/%E6%91%84%E5%BD%B1-%E5%B9%BF%E5%B7%9E%E8%A1%8C/"><img class="next-cover" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/IMG_9300.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">摄影 | 广州行</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/11/带你重新认识Node/" title="带你重新认识Node"><img class="cover" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/node.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-11</div><div class="title">带你重新认识Node</div></div></a></div><div><a href="/2021/06/22/JavaScipt-GC/" title="[深入浅出]JavaScript GC 垃圾回收机制"><img class="cover" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/JavaScript.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-22</div><div class="title">[深入浅出]JavaScript GC 垃圾回收机制</div></div></a></div><div><a href="/2022/08/21/JavaScript设计模式-单例模式/" title="JavaScript 设计模式 —— 单例模式"><img class="cover" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/63460f4ae2fe44c7beb9201528f684b7~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-21</div><div class="title">JavaScript 设计模式 —— 单例模式</div></div></a></div><div><a href="/2022/08/21/JavaScript设计模式-策略模式/" title="JavaScript 设计模式 —— 策略模式"><img class="cover" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/f3248dbebc9f40769a83e9d148f3a880~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-21</div><div class="title">JavaScript 设计模式 —— 策略模式</div></div></a></div><div><a href="/2022/10/10/JavaScript设计模式-代理模式/" title="JavaScript设计模式-代理模式"><img class="cover" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/banner-20220908163707243.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-10</div><div class="title">JavaScript设计模式-代理模式</div></div></a></div><div><a href="/2022/10/12/JavaScript设计模式-发布订阅模式/" title="JavaScript设计模式-发布订阅模式"><img class="cover" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20221011174858741.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-12</div><div class="title">JavaScript设计模式-发布订阅模式</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/personal-info/IMG_8050.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">LeBronChao-</div><div class="author-info__description">深圳大学(SZTU) 22届 物联网工程<br/>前端开发工程师一枚<br/>业余摄影师，交流/约拍可私戳。<br/>字节跳动内推码:4FCV6BV<br/>Email：LeBronChao@foxmail.com</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">88</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LeBronChao"><i class="fab fa-github"></i><span>Follow My Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LeBronChao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lebronchao@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/personal-info/IMG_8268-20210326002121490.jpg" target="_blank" title="微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1531229587&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">掘金：<a target="_blank" rel="noopener" href="https://juejin.cn/user/3913917127467805">前端LeBron</a><br/>知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/lebronchao">前端LeBron</a><br/>持续分享技术博文，关注wx公众号👇🏻<br/><img src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" /></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">编码方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hex-%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">hex 编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#base64-%E7%BC%96%E7%A0%81"><span class="toc-number">1.2.</span> <span class="toc-text">base64 编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#urlencode-%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">urlencode 编码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5-MD5-%E4%B8%BA%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">以 MD5 为例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.3.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84-md5-%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.</span> <span class="toc-text">简单的 md5 运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.5.</span> <span class="toc-text">密码保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90"><span class="toc-number">2.6.</span> <span class="toc-text">密码加盐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90%EF%BC%9A%E9%9A%8F%E6%9C%BA%E7%9B%90%E5%80%BC"><span class="toc-number">2.7.</span> <span class="toc-text">密码加盐：随机盐值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HMAC-%E5%8A%9F%E8%83%BD"><span class="toc-number">2.8.</span> <span class="toc-text">HMAC 功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">加密 &#x2F; 解密</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#crypto-createCipher-crypto-createDecipher"><span class="toc-number">3.1.</span> <span class="toc-text">crypto.createCipher &#x2F; crypto.createDecipher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#crypto-createCipheriv-crypto-createDecipheriv"><span class="toc-number">3.2.</span> <span class="toc-text">crypto.createCipheriv &#x2F; crypto.createDecipheriv</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.3.</span> <span class="toc-text">数字签名 &#x2F; 签名校验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DH-DiffieHellman"><span class="toc-number">3.4.</span> <span class="toc-text">DH(DiffieHellman)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ECDH-Elliptic-Curve-Diffie-Hellma"><span class="toc-number">3.5.</span> <span class="toc-text">ECDH(Elliptic Curve Diffie-Hellma)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ECDHE-Elliptic-Curve-Diffie-Hellma-Ephemeral"><span class="toc-number">3.6.</span> <span class="toc-text">ECDHE(Elliptic Curve Diffie-Hellma Ephemeral)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">相关术语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/12/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" title="JavaScript设计模式-发布订阅模式"><img data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/image-20221011174858741.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript设计模式-发布订阅模式"/></a><div class="content"><a class="title" href="/2022/10/12/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" title="JavaScript设计模式-发布订阅模式">JavaScript设计模式-发布订阅模式</a><time datetime="2022-10-12T15:59:18.000Z" title="发表于 2022-10-12 23:59:18">2022-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="JavaScript设计模式-代理模式"><img data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/banner-20220908163707243.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript设计模式-代理模式"/></a><div class="content"><a class="title" href="/2022/10/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="JavaScript设计模式-代理模式">JavaScript设计模式-代理模式</a><time datetime="2022-10-09T16:24:29.000Z" title="发表于 2022-10-10 00:24:29">2022-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="JavaScript 设计模式 —— 策略模式"><img data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/f3248dbebc9f40769a83e9d148f3a880~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript 设计模式 —— 策略模式"/></a><div class="content"><a class="title" href="/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" title="JavaScript 设计模式 —— 策略模式">JavaScript 设计模式 —— 策略模式</a><time datetime="2022-08-21T13:11:23.000Z" title="发表于 2022-08-21 21:11:23">2022-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="JavaScript 设计模式 —— 单例模式"><img data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/63460f4ae2fe44c7beb9201528f684b7~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript 设计模式 —— 单例模式"/></a><div class="content"><a class="title" href="/2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="JavaScript 设计模式 —— 单例模式">JavaScript 设计模式 —— 单例模式</a><time datetime="2022-08-21T13:11:14.000Z" title="发表于 2022-08-21 21:11:14">2022-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/20/%E6%91%84%E5%BD%B1-%E6%A2%A7%E6%A1%90%E5%B1%B1/" title="摄影 | 梧桐山"><img data-lazy-src="https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/DSC00287.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="摄影 | 梧桐山"/></a><div class="content"><a class="title" href="/2022/02/20/%E6%91%84%E5%BD%B1-%E6%A2%A7%E6%A1%90%E5%B1%B1/" title="摄影 | 梧桐山">摄影 | 梧桐山</a><time datetime="2022-02-19T16:24:49.000Z" title="发表于 2022-02-20 00:24:49">2022-02-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By LeBronChao-</div><div class="footer_custom_text">@ 2022 LeBronChao- CopyRight | <a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备2021025161号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'TKAoSdRXJ5zxwsjdGTP0Hrfh-9Nh9j0Va',
      appKey: 'lI3CGg5rpWkxsfvsKTRkVszT',
      placeholder: '留下你的足迹吧，記得留下你的昵称和邮箱....可以快速收到回复',
      avatar: 'https://lebronchao-1304295623.cos.ap-guangzhou.myqcloud.com/doc-image/touxiang.jpeg',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-cn',
      recordIP: true,
      serverURLs: 'https://tkaosdrx.lc-cn-e1-shared.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (true) {
      const otherData = {"master":["64951ad612e26b51f6cc37788be7c200","b467dec92be8eb17c36ca900ef5d8dc1"],"friends":["30932c612db8dca9f08b98d6c1818ba2","898f30c9b8971d165a03abe4deba1ac6","741b327a5a0afbafd674ac782ddb0835","8dc27dfae152eb47084d3d0ae48c33d5","49fa154bbe0132bb66cb50c473f7f3ab","1f1338f1eff80cd7184516e788f9cbca","316d73187eea974f9f29c9fe4dc84a63","d4964055fcfa2b76c06d8cb038b0954e"],"metaPlaceholder":{"nick":"昵称(必填)","mail":"邮箱(必填,QQ邮箱可显示头像)","link":"主页(https://)"}}
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>