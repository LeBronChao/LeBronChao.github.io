<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>带你重新认识Node | LeBronChao's Blog</title><meta name="keywords" content="JavaScript,Node,服务端"><meta name="author" content="LeBronChao-"><meta name="copyright" content="LeBronChao-"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="最初做Node的目的是什么？  Node作者Ryan Dahl： 基于V8创建一个轻量级的高性能Web服务器并提供一套库  为什么是JavaScript？  Ryan Dahl是一名资深的C&#x2F;C++程序员，创造出Node之前主要工作是围绕Web高性能服务器进行的 他发现Web高性能服务器的两个要点：   事件驱动 非阻塞I &#x2F; O  Ryan Dahl也曾评估过使用C、Lua、Haskell、Ru">
<meta property="og:type" content="article">
<meta property="og:title" content="带你重新认识Node">
<meta property="og:url" content="https://lebronchao.com/2021/12/11/%E5%B8%A6%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Node/index.html">
<meta property="og:site_name" content="LeBronChao&#39;s Blog">
<meta property="og:description" content="最初做Node的目的是什么？  Node作者Ryan Dahl： 基于V8创建一个轻量级的高性能Web服务器并提供一套库  为什么是JavaScript？  Ryan Dahl是一名资深的C&#x2F;C++程序员，创造出Node之前主要工作是围绕Web高性能服务器进行的 他发现Web高性能服务器的两个要点：   事件驱动 非阻塞I &#x2F; O  Ryan Dahl也曾评估过使用C、Lua、Haskell、Ru">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bloginfo.lebronchao.com/doc-image/node.png">
<meta property="article:published_time" content="2021-12-11T07:38:45.000Z">
<meta property="article:modified_time" content="2021-12-11T07:38:45.000Z">
<meta property="article:author" content="LeBronChao-">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="Node">
<meta property="article:tag" content="服务端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bloginfo.lebronchao.com/doc-image/node.png"><link rel="shortcut icon" href="https://bloginfo.lebronchao.com/doc-image/bitbug_favicon%20(1).ico"><link rel="canonical" href="https://lebronchao.com/2021/12/11/%E5%B8%A6%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Node/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?0f958a253362f27db5bafcef151a46ab";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: LeBronChao-","link":"链接: ","source":"来源: LeBronChao's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-11 15:38:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="LeBronChao's Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://bloginfo.lebronchao.com/personal-info/IMG_8050.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-video"></i><span> 摄影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/Front-End/"><i class="fa-fw fas fa-laptop"></i><span> Front End</span></a></li><li><a class="site-page" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa-fw fas fa-wifi"></i><span> 计算机网络</span></a></li><li><a class="site-page" href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"><i class="fa-fw fab fa-git-square"></i><span> 开发技能</span></a></li><li><a class="site-page" href="/categories/Back-End/"><i class="fa-fw fas fa-database"></i><span> Back End</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bloginfo.lebronchao.com/doc-image/node.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LeBronChao's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-video"></i><span> 摄影</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 分类</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/Front-End/"><i class="fa-fw fas fa-laptop"></i><span> Front End</span></a></li><li><a class="site-page" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa-fw fas fa-wifi"></i><span> 计算机网络</span></a></li><li><a class="site-page" href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/"><i class="fa-fw fab fa-git-square"></i><span> 开发技能</span></a></li><li><a class="site-page" href="/categories/Back-End/"><i class="fa-fw fas fa-database"></i><span> Back End</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw far fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">带你重新认识Node</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-11T07:38:45.000Z" title="发表于 2021-12-11 15:38:45">2021-12-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-11T07:38:45.000Z" title="更新于 2021-12-11 15:38:45">2021-12-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Back-End/">Back End</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>最初做Node的目的是什么？</h1>
<blockquote>
<p>Node作者Ryan Dahl：</p>
<p>基于V8创建一个轻量级的高性能Web服务器并提供一套库</p>
</blockquote>
<h1>为什么是JavaScript？</h1>
<blockquote>
<p>Ryan Dahl是一名资深的C/C++程序员，创造出Node之前主要工作是围绕Web高性能服务器进行的</p>
<p>他发现Web高性能服务器的两个要点：</p>
</blockquote>
<ul>
<li>事件驱动</li>
<li>非阻塞I / O</li>
</ul>
<p>Ryan Dahl也曾评估过使用C、Lua、Haskell、Ruby等语言作为备选实现，得出以下结论：</p>
<ul>
<li>C的开发门槛高，可以预见不会有太多的开发者能将它用于业务开发</li>
<li>Ryan Dahl觉得自己还不足够玩转Haskell，所以舍弃它</li>
<li>Lua自身已经含有很多阻塞 I / O 库，为其构建非阻塞 I / O 库不能改变开发者使用习惯</li>
<li>Ruby的虚拟机性能不佳</li>
</ul>
<p>JavaScript的优势：</p>
<ul>
<li>开发门槛低</li>
<li>在后端领域没有历史包袱</li>
<li>第二次浏览器大战渐渐分出高下，Chrome浏览器的JavaScript引擎V8摘得性能第一的桂冠</li>
</ul>
<h1>Node给JavaScript带来的意义</h1>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225039105.(null)" alt="img"></p>
<blockquote>
<p>除了HTML、Webkit和显卡这些UI相关技术没有支持外，Node的结构与Chrome十分相似。他们都是基于事件驱动的异步架构：</p>
</blockquote>
<ul>
<li>浏览器通过事件驱动来服务界面上的交互</li>
<li>Node通过事件驱动来服务 I / O</li>
</ul>
<blockquote>
<p>在Node中，JavaScript还被赋予了新的能力：</p>
</blockquote>
<ul>
<li>随心所欲地访问本地文件</li>
<li>搭建WebSocket服务端</li>
<li>连接数据库，进行业务研发</li>
<li>像Web Worker一样玩转多进程</li>
</ul>
<blockquote>
<p>Node使JavaScript可以运行在不同的地方，不再限制在浏览器中、DOM树打交道。如果HTTP协议是水平面，Node就是浏览器在协议栈另一边的倒影。</p>
<p>Node不处理UI，但用与浏览器相同的机制和原理运行，打破了JavaScript只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低前后端转换所需要的上下文代价。</p>
</blockquote>
<h1>Node的特点</h1>
<h2 id="异步I-O">异步I / O</h2>
<ul>
<li>以读取文件为例</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225046783.(null)" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); </span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;/path&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件完成&#x27;</span>) </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;发起读取文件&#x27;</span>); </span><br></pre></td></tr></table></figure>
<blockquote>
<p>熟悉的用户必知道，“读取文件完成”是在“发起读取文件”之后输出的</p>
<p>fs.readFile后的代码是被立即执行的，而“读取文件完成”的执行时间是不被预期的</p>
<p>只知道它将在这个异步操作后执行，但并不知道具体的时间点</p>
<p>异步调用中对于结果值的捕获是符合“Don’t call me, I will call you”原则的</p>
<p>这也是注重结果，不关心过程的一种表现</p>
</blockquote>
<p>Node中，绝大多数操作都以异步的方式进行调用，Ryan Dahl排除万难，在底层构建了很多异步I / O的API，从文件读取到网络请求等。使开发者很已从语言层面很自然地进行并行I / O操作，在每个调用之间无需等待之前的I / O调用结束，在编程模型上可以极大提升效率</p>
<blockquote>
<p><strong>注：异步I / O机制将在下文中详细阐述</strong></p>
</blockquote>
<h2 id="事件与回调函数">事件与回调函数</h2>
<p><strong>事件</strong></p>
<p>随着Web2.0的到来，JavaScript在前端担任了更多的职责，时间也得到了广泛的应用。将前端浏览器中广泛应用且成熟的事件与回到函数引入后端，配合异步I / O ，可以很好地将事件发生的时间点暴露给业务逻辑。</p>
<ul>
<li>服务端例子</li>
</ul>
<blockquote>
<p>对于服务器绑定了request事件</p>
</blockquote>
<blockquote>
<p>对于请求对象，绑定了data和end事件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>); </span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 侦听服务器的request事件 </span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"> req.setEncoding(<span class="string">&#x27;utf8&#x27;</span>); </span><br><span class="line"> <span class="comment">// 侦听请求的data事件 </span></span><br><span class="line"> req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>) </span>&#123;</span><br><span class="line"> postData += trunk;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 侦听请求的end事件</span></span><br><span class="line"> req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line"> res.end(postData); </span><br><span class="line"> &#125;); </span><br><span class="line">&#125;).listen(<span class="number">8080</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动完成&#x27;</span>); </span><br></pre></td></tr></table></figure>
<ul>
<li>前端例子</li>
</ul>
<blockquote>
<p>发出请求后，只需关心请求成功时执行相应的业务逻辑即可</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request(&#123; </span><br><span class="line"> url: <span class="string">&#x27;/url&#x27;</span>, </span><br><span class="line"> method: <span class="string">&#x27;POST&#x27;</span>, </span><br><span class="line"> data: &#123;&#125;, </span><br><span class="line"> success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; </span><br><span class="line"> <span class="comment">// success事件 </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<blockquote>
<p>事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是一个问题，后续也出现了一系列异步编程解决方案:</p>
</blockquote>
<ul>
<li>事件发布/订阅模式</li>
<li>Promise、async / await</li>
<li>流程控制库</li>
</ul>
<p><strong>回调函数</strong></p>
<ul>
<li>Node除了异步和事件外，回调函数也是一大特色</li>
<li>纵观下来，回调函数也是最好的接收异步调用返回数据的方式
<ul>
<li>但是这种编程方式对于很多习惯同步思路编程的人来说，也许是十分不习惯的</li>
<li>代码的编写顺序与执行顺序并无关系，这对他们可能造成阅读上的障碍</li>
</ul>
</li>
<li>在流程控制方面，因为穿插了异步方法和回调函数，与常规的同步方式相比变得不那么一目了然了
<ul>
<li>转变为异步编程思维后，通过对业务的划分和对事件的提炼，在流程控制方面处理业务的复杂度是与同步方式实际上是一致的</li>
</ul>
</li>
</ul>
<h2 id="单线程">单线程</h2>
<blockquote>
<p>Node保持了JavaScript在浏览器中单线程的特点</p>
<p>JavaScript与其他线程是无法共享任何状态的，最大的好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销</p>
</blockquote>
<ul>
<li>单线程的缺点
<ul>
<li>无法利用多核CPU</li>
<li>错误会引起整个应用退出，健壮性较差</li>
<li>大量计算占用CPU导致无法继续调用异步I / O</li>
</ul>
</li>
<li>后续也推出了child_process和cluster模块较好地缓解了以上缺点</li>
</ul>
<h2 id="跨平台">跨平台</h2>
<blockquote>
<p>起初Node只能在Linux平台上运行，如果想在Windows平台上学习和使用Node，则必须通过Cygwin / MinGW，后微软投入通过基于libuv实现跨平台架构</p>
</blockquote>
<ul>
<li>libuv</li>
</ul>
<blockquote>
<p>在操作系统与Node上层模块系统之间构建了一层平台架构</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225633500.(null)" alt="img"></p>
<blockquote>
<p>通过良好的架构，Node的第三方C++模块也可以借助libuv实现跨平台</p>
</blockquote>
<h1>Node模块机制 - CommonJS</h1>
<blockquote>
<p>背景：</p>
<p>在其他高级语言中，Java有类文件，Python有import机制，Ruby有require，PHP有include和require。而JavaScript通过script标签引入代码的方式显得杂乱无章，。人们不得不用命名空间等方式人为地约束代码，以达到安全和易用的目的。</p>
<p>直到后来出现了CommonJS…</p>
</blockquote>
<h2 id="愿景">愿景</h2>
<blockquote>
<p>希望JavaScript能欧在任何地方运行</p>
</blockquote>
<h2 id="出发点">出发点</h2>
<p>对于JavaScript自身而言，它的规范依然是薄弱的，还有以下缺陷：</p>
<ul>
<li>没有模块系统</li>
<li>标准库较少
<ul>
<li>ECMAScript仅定义了部分核心库</li>
<li>对于文件系统 I / O流等常见需求没有标准API</li>
</ul>
</li>
<li>没有标准接口
<ul>
<li>在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口</li>
</ul>
</li>
<li>缺乏包管理系统
<ul>
<li>导致JavaScript应用中基本没有自动加载和安装以来的能力</li>
</ul>
</li>
</ul>
<p>CommonJS的提出，主要是为了弥补当前JavaScript没有标准的缺陷，以达到像Python、Ruby和Java具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段，希望可以利用JavaScript开发：</p>
<ul>
<li>服务端JavaScript程序</li>
<li>命令行工具</li>
<li>桌面图形界面应用程序</li>
<li>混合应用</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225637966.(null)" alt="img"></p>
<p>CommonJS规范涵盖了：</p>
<ul>
<li>模块</li>
<li>二进制</li>
<li>Buffer</li>
<li>字符集编码</li>
<li>I / O流</li>
<li>进程环境</li>
<li>文件系统</li>
<li>套接字</li>
<li>单元测试</li>
<li>Web服务器网关接口</li>
<li>包管理</li>
</ul>
<blockquote>
<p>Node与浏览器以及W3C组织、CommonJS组织、ECMAScript之间的关系，共同构成了一个繁荣的生态系统</p>
</blockquote>
<h2 id="模块规范">模块规范</h2>
<ul>
<li>模块定义</li>
</ul>
<blockquote>
<p>上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是导出的唯一出口</p>
<p>在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性</p>
<p>在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="built_in">exports</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>模块引用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = math.add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在CommonJS规范中，存在require方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中</p>
</blockquote>
<ul>
<li>模块标识</li>
</ul>
<p>模块标识就是传递给require方法的参数，可以是：</p>
<ul>
<li>如何小驼峰命名的字符串</li>
<li>以./ 、…/ 开头的相对路径 or 绝对路径</li>
<li>可以没有文件名后缀.js</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225641404.(null)" alt="img"></p>
<blockquote>
<p>模块的定义十分简单，接口也十分简洁</p>
</blockquote>
<blockquote>
<p>每个模块具有独立的空间，它们互不干扰，在引用时也显得干净利落</p>
</blockquote>
<ul>
<li>意义：</li>
</ul>
<blockquote>
<p>将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖</p>
</blockquote>
<h2 id="模块实现">模块实现</h2>
<blockquote>
<p>在Node引入模块，需要经历以下三个步骤</p>
</blockquote>
<ul>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ul>
<p>Node中模块分为两类：</p>
<ul>
<li>核心模块</li>
</ul>
<blockquote>
<p>编译过程中，编译进了二进制执行文件</p>
<p>在Node进程启动时，部分核心模块就直接被加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略，并且在路径分析中优先判断，所以它的加载速度是最快的。</p>
</blockquote>
<ul>
<li>用户编写的文件模块</li>
</ul>
<blockquote>
<p>运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢</p>
</blockquote>
<h3 id="优先从缓存加载">优先从缓存加载</h3>
<blockquote>
<p>与浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行二次缓存，以减少二次引入时的开销。不同点在于:</p>
</blockquote>
<ul>
<li>浏览器仅缓存文件</li>
<li>Node缓存的是编译和执行之后的对象</li>
</ul>
<blockquote>
<p>无论核心模块还是文件模块，require方法对相同模块的二次加载都一律采用缓存优先的方式</p>
</blockquote>
<h3 id="路径分析和文件定位">路径分析和文件定位</h3>
<p><strong>标识符分析（路径）</strong></p>
<p>前面说到过，require方法接受一个参数作为标识符，分为以下几类：</p>
<ul>
<li>核心模块</li>
</ul>
<blockquote>
<p>优先级仅次于缓存加载，在Node的源代码编译过程中已编译为二进制代码，加载过程最快</p>
<p><strong>注：加载一个与核心模块标识符相同的自定义模块是不会成功的，只能通过选择不同的标识符 / 换用路径的方式实现</strong></p>
</blockquote>
<ul>
<li>路径形式的文件模块</li>
</ul>
<blockquote>
<p>以 ./ 、…/ 开头的标识符都被当做文件模块处理</p>
<p>require方法会将路径转为真实路径，并以真实路径为索引，将编译执行后的结果存放到缓存中，以使二次加载更快</p>
<p>文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度仅慢于核心模块</p>
</blockquote>
<ul>
<li>自定义模块</li>
</ul>
<blockquote>
<p>是一种特殊的文件模块，是一个文件或者包的形式</p>
<p>这类模块的查找是最费时的，也是最慢的一种</p>
</blockquote>
<p>先介绍一下模块路径这个概念，也是定位文件模块时制定的查找策略，具体表现为一个路径组成的数组</p>
<ul>
<li><code>console.log(module.path)</code></li>
<li>你可以得到一个路径数组</li>
</ul>
<p>[‘/home/bytedance/reasearch/node_modules’,</p>
<p>‘/home/bytedance/node_modules’,</p>
<p>‘home/node_module’, /node_modules’]</p>
<p>可以看出规则如下：</p>
<ul>
<li>当前文件目录下的node_modules目录</li>
<li>父目录下的node_modules目录</li>
<li>父目录的父目录下的node_modules目录</li>
<li>沿路径向上逐级递归，直到根目录下的node_modules目录</li>
</ul>
<blockquote>
<p>它的生成方式与JavaScript原型链 / 作用域链的查找方式十分类似</p>
<p>在加载过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件</p>
<p>文件路径越深，模块查找耗时会越多，这是自定义模块的加载速度最慢的原因</p>
</blockquote>
<p><strong>文件定位</strong></p>
<ul>
<li>文件扩展名分析</li>
</ul>
<blockquote>
<p>require分析标识符会出现不包含文件扩展名的情况</p>
<p>会按.js、.json、.node的次序补足扩展名，一次尝试</p>
<p>过程中，需调用fs模块同步阻塞地判断文件是否存在，Node单线程因此会引起性能问题</p>
<p>如果是.node / .json文件带上扩展名能加快点速度，配合缓存机制，可大幅缓解Node单线程阻塞调用的缺陷</p>
</blockquote>
<ul>
<li>目录分析和包</li>
</ul>
<blockquote>
<p>分析标识符的过程中可能没有找到文件，却得到一个目录，则会将目录当做一个包来处理</p>
<p>通过解析package.json文件对应该包的main属性指定的文件名</p>
<p>如果main相应文件解析错误 / 没有package.json文件，node会将index作为文件名</p>
<p>一次查找index.js  index.json  index.node</p>
<p>该目录没有定位成功则进行下一个模块路径进行查找</p>
<p>直到模块路径数组都被遍历完依然没有查找到目标文件则抛出异常</p>
</blockquote>
<h3 id="模块编译">模块编译</h3>
<blockquote>
<p>在Node中，每个文件模块都是一个对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">this</span>.id = id; </span><br><span class="line"> <span class="built_in">this</span>.exports = &#123;&#125;; </span><br><span class="line"> <span class="built_in">this</span>.parent = parent; </span><br><span class="line"> <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123; </span><br><span class="line">     parent.children.push(<span class="built_in">this</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">this</span>.filename = <span class="literal">null</span>; </span><br><span class="line"> <span class="built_in">this</span>.loaded = <span class="literal">false</span>; </span><br><span class="line"> <span class="built_in">this</span>.children = []; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>js文件
<ul>
<li>通过fs模块同步读取文件后编译执行</li>
</ul>
</li>
<li>node文件
<ul>
<li>这是用C/C++编写的扩展文件，通过dlopen方法加在最后编译生成的文件</li>
</ul>
</li>
<li>json文件
<ul>
<li>通过fs模块同步读取文件后，JSON.parse解析返回的结果</li>
</ul>
</li>
<li>其他
<ul>
<li>都被当作js文件载入</li>
</ul>
</li>
</ul>
<blockquote>
<p>每一个编译成功的模块都会将其文件路径作为索引存在Module.cache对象上，以提高二次引入的性能</p>
</blockquote>
<h1>包与NPM</h1>
<blockquote>
<p>Node组织了自身核心模块，也使得第三方文件模块可以有序地编写和使用</p>
<p>但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用</p>
<p>而在模块之外，包和 NPM 则是将模块联系起来的一种机制</p>
<p>一定程度上解决了变量依赖、依赖关系等代码组织性问题</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225646448.(null)" alt="img"></p>
<h2 id="包结构">包结构</h2>
<blockquote>
<p>包实际上是一个存档文件，即一个目录直接打包为一个.zip/tar.gz格式的文件，安装后解压还原为目录</p>
</blockquote>
<ul>
<li>符合CommonJS规范的包目录应该包含如下文件
<ul>
<li>package.json 包描述文件</li>
<li>bin 用于存放可执行二进制文件</li>
<li>lib 用于存放JavaScript代码的目录</li>
<li>doc 用于存放文档的目录</li>
<li>test 用于存放单元测试用例的代码</li>
</ul>
</li>
</ul>
<h2 id="包描述文件">包描述文件</h2>
<blockquote>
<p>package.json</p>
</blockquote>
<p>CommonJS为package.json定义了如下一些必须的字段</p>
<ul>
<li>name 包名</li>
<li>description 包简介</li>
<li>version 版本号</li>
<li>keywords 关键词数组，用于做npm搜索</li>
<li>maintainers 包维护者列表</li>
<li>contributors 贡献者列表</li>
<li>bugs 一个可以反馈bug的网页地址 / 邮件地址</li>
<li>licenses 许可证列表</li>
<li>repositories 托管源代码的位置列表</li>
<li>dependencies 使用当前包所需要依赖的包</li>
<li>homepage 当前包的网站地址</li>
<li>os 操作系统支持列表
<ul>
<li>aix、freebsd、linux、macos、solaris、vxworks、windows</li>
</ul>
</li>
<li>cpu CPU架构的支持列表
<ul>
<li>arm、mips、ppc、sparc、x86、x86_64</li>
</ul>
</li>
<li>builtin 标志当前包是否是内建在底层系统的标准组件</li>
<li>implements 实现规范的列表</li>
<li>scripts 脚本说明对象</li>
</ul>
<blockquote>
<p>包规范的定义可以帮助Node解决依赖包安装的问题，而NPM正是基于该规范进行了实现</p>
</blockquote>
<h2 id="NPM-常用功能">NPM 常用功能</h2>
<blockquote>
<p>CommonJS包规范是理论，NPM是其中一种实践</p>
<p>NPM于Node，相当于gem于Ruby，pear于PHP</p>
<p>帮助完成了第三方模块的发布、安装和依赖等</p>
</blockquote>
<ol>
<li>查看帮助</li>
</ol>
<ul>
<li>查看版本 <code>npm -v</code></li>
<li>查看命令 <code>npm</code></li>
</ul>
<ol start="2">
<li>安装依赖包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &#123;packageName&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行该命令后，NPM会在当前目录下创建node_modules目录下创建包目录，接着将相应的包解压到这个目录下</p>
</blockquote>
<ul>
<li>全局安装模式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &#123;packageName&#125; -g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任何地方reuqire它</p>
<p>全局模式这个成为并不精确，-g 实际上是将一个包安装为全局可用的执行命令</p>
<p>它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同的路径下</p>
</blockquote>
<ul>
<li>从本地安装</li>
</ul>
<blockquote>
<p>对于一些没有发布到NPM上的包，或者因为网络原因无法直接安装的包</p>
<p>可以通过将包下按在到本地，然后本地安装</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &lt;tarball file&gt;</span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install folder&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>从非官方源安装</li>
</ul>
<blockquote>
<p>如果不能通过官方源安装，可以通过镜像源安装</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --registry=&#123;urlResource&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用过程中几乎全使用镜像源，可以指定默认源</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry &#123;urlResource&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>NPM 钩子命令</li>
</ol>
<blockquote>
<p>package.json中scripts字段的提出就是让包在安装或者卸载等过程中提供钩子机制</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;preinstall&quot;</span>: <span class="string">&quot;preinstall.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;install&quot;</span>: <span class="string">&quot;install.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uninstall&quot;</span>: <span class="string">&quot;uninstall.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;test.js&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Install
<ul>
<li>在以上字段执行<code>npm install &lt;package&gt;</code>时，preinstall指向的脚本会被加载执行，然后install指向的脚本会被执行</li>
</ul>
</li>
<li>Uninstall
<ul>
<li>执行<code>npm uninstall &lt;package&gt;</code>时，uninstall指向的脚本也许会做一些清理工作</li>
</ul>
</li>
<li>Test
<ul>
<li>执行<code>npm test</code>将会运行test指向的脚本，一个优秀的包应当包含测试用例，并在package.json文件正配置好运行测试的命令，方便用户运行测试用例，以便检验包是否稳定可靠</li>
</ul>
</li>
</ul>
<h2 id="局域-NPM">局域 NPM</h2>
<ul>
<li>背景</li>
</ul>
<p>企业的限制在于，一方面需要享受到模块开发带来的低耦合和项目组织上的好处，另一方面却要考虑模块保密性的问题。所以，通过NPM共享和发布存在潜在的风险。</p>
<ul>
<li>解决方案</li>
</ul>
<p>为了同时能够享受到NPM上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是企业搭建自己的NPM仓库，NPM无论是它的服务端和客户端都是开源的。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225651308.(null)" alt="img"></p>
<blockquote>
<p>局域NPM仓库的搭建方法与搭建镜像站的方式几乎一样，与镜像仓库不同的地方在于可以选择不同步官方源仓库中的包</p>
</blockquote>
<ul>
<li>作用
<ul>
<li>私有的可重用模块可以打包到局域NPM仓库中，这样可以保持更新的中心化，不至于让各个小项目维护相同功能的模块</li>
<li>杜绝通过复制粘贴实现代码共享的行为</li>
</ul>
</li>
</ul>
<h1>异步I / O</h1>
<h2 id="为什么需要异步-I-O-？">为什么需要异步 I / O ？</h2>
<ul>
<li>用户体验</li>
</ul>
<blockquote>
<p>浏览器中JavaScript在单线程上执行，还和UI渲染共用一个线程</p>
<p>《高性能JavaScript》曾总结过，如果脚本执行的时间超过100ms用户就会感到页面卡顿</p>
<p>如果网页临时需要获取一个网络资源，通过同步的方式获取，JS需要等资源完全从服务器获取后才能继续执行，这期间UI将停顿，不响应用户的交互行为。可以想象，这样的用户体验将会多差。</p>
<p>而采用异步请求，JavaScript和UI的执行都不会处于等待状态，给用户一个鲜活的页面</p>
<p>I / O是昂贵的，分布式I / O 是更昂贵的</p>
<p>只有后端能够快速响应资源，才能让前端体验变好</p>
</blockquote>
<ul>
<li>资源分配</li>
</ul>
<blockquote>
<p>计算机在发展过程中将组件进行了抽象，分为了I / O设备和计算设备</p>
<p>假设业务场景有一组互不相关的任务需要完成，主流方法有两种：</p>
</blockquote>
<ol>
<li>多线程并行完成</li>
</ol>
<p>多线程的代价在于创建线程和执行线程上下文切换的开销较大。</p>
<p>在复杂的业务中经常面临锁、状态同步等问题。但是多线程在多核CPU上能够有效提升CPU利用率</p>
<ol start="2">
<li>单线程串行依次执行</li>
</ol>
<p>单线程顺序执行任务比较符合编程人员按顺序思考的思维方式，依然是主流的编程方式</p>
<p>串行执行的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞</p>
<p>在计算机资源中，通常I / O与CPU计算是可以并行的，同步编程模型导致的问题是，I / O的进行会让后续任务等待，这造成资源不能更好地被利用</p>
<ol start="3">
<li>Node在两者之间给出了它的答案</li>
</ol>
<blockquote>
<p>利用单线程，远离多线程死锁、状态同步等问题；</p>
<p>利用异步I / O，让单线程可以远离阻塞，更好地使用CPU</p>
<p>为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I / O</p>
<p>异步I / O的提出是期望I / O的调用不再阻塞后续运算，将原有等待I / O完成的这段时间分配给其余需要的业务去执行</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225655015.(null)" alt="img"></p>
<h2 id="异步I-O现状">异步I / O现状</h2>
<h3 id="异步I-O与非阻塞I-O">异步I / O与非阻塞I / O</h3>
<blockquote>
<p>操作系统内核对于I / O方式只有两种：阻塞与非阻塞</p>
<p>在调用阻塞I / O时，应用程序需要等待I / O完成才返回结果</p>
<p>特点：调用之后一定要等到系统内核层面完成所有操作后调用才结束</p>
<p>例子：系统内核在完成磁盘寻道、读取数据、复制数据到内幕才能中之后，这个调用才结束》</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202224957133.(null)" alt="img"></p>
<blockquote>
<p>非阻塞I / O与阻塞I / O的差别为调用之后会立即返回</p>
<p>非阻塞I / O返回之后，CPU的时间片可以用来处理其他事务，此时的性能提升是明显的</p>
<p>存在的问题：</p>
</blockquote>
<ul>
<li>由于完整的I / O没有完成，立即返回的并不是业务层期望的数据而仅仅是当前调用的状态</li>
<li>为了获取完整的数据，应用程序需要重复调用I / O操作来确认是否完成，称之为“轮询”。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225703091.(null)" alt="img"></p>
<h3 id="主要的轮询技术">主要的轮询技术</h3>
<ul>
<li>read</li>
</ul>
<blockquote>
<p>它是最原始、性能最低的一种，通过重复调用检查I / O的状态来完成数据的完整读取</p>
<p>在得到最终数据前，CPU一直耗用在等待上</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225706724.(null)" alt="img"></p>
<ul>
<li>select</li>
</ul>
<blockquote>
<p>它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断</p>
<p>限制：它采用一个1024长度的数组来存储状态，最多可以同时检查1024个文件描述符</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225711576.(null)" alt="img"></p>
<ul>
<li>poll</li>
</ul>
<blockquote>
<p>较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查</p>
<p>文件描述符较多时，它的性能还是十分低下的</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225714602.(null)" alt="img"></p>
<ul>
<li>epoll</li>
</ul>
<blockquote>
<p>该方案是Linux下效率最高的I / O事件通知机制，在进入轮询的时候如果没有检查到I / O事件，将会进行休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225718042.(null)" alt="img"></p>
<h3 id="理想的非阻塞异步I-O">理想的非阻塞异步I / O</h3>
<blockquote>
<p>尽管epoll已经利用了时间来降低CPU的耗用，但是休眠期间CPU几乎是限制的，对于当前线程而言利用率不够</p>
</blockquote>
<p>完美的异步I / O应该是应用程序发起非阻塞调用，无需通过遍历或者时间唤醒等方式轮询</p>
<p>可以直接处理下一个任务，只需在I / O完成后通过信号或回调将数据传递给应用程序即可</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225721234.(null)" alt="img"></p>
<p>Linux下存在原生提供的一种异步I / O方式（AIO）就是通过信号或者回调来传递数据的</p>
<p>缺点：</p>
<ul>
<li>仅Linux下有</li>
<li>仅支持I / O中的O_DIRECT方式读取，导致无法利用系统缓存</li>
</ul>
<blockquote>
<p>注：<a target="_blank" rel="noopener" href="https://blog.csdn.net/AXW2013/article/details/70242228">关于O_DIRECT</a></p>
</blockquote>
<h3 id="现实的异步I-O">现实的异步I / O</h3>
<blockquote>
<p>通过让部分线程进行阻塞I / O或者非阻塞I / O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I / O得到的数据进行传递，这就轻松实现了异步I / O（尽管它是模拟的</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225724648.(null)" alt="img"></p>
<ul>
<li>libeio实质上是采用线程池与阻塞I / O模拟异步I / O</li>
<li>Node最初在*nix平台下采用libeio配合libev实现异步I / O，后通过自行实现线程池完成</li>
<li>Windows下的IOCP
<ul>
<li>调用异步方法，等待I / O完成之后的通知，执行回调，用户无需考虑轮询</li>
<li>内部其实仍是线程池的原理，不同之处在于这些线程池由系统内核接手管理</li>
<li>与Node异步调用模型十分近似</li>
</ul>
</li>
<li>由于Windows平台和*nix平台的差异，Node提供了libuv作为抽象封装层，做兼容性判断
<ul>
<li>保证上层Node与下层的自定义线程池和IOCP各自独立</li>
</ul>
</li>
<li>我们时常提到Node是单线程的
<ul>
<li>这里的单线程仅仅只是JavaScript执行在单线程中罢了</li>
<li>无论是*nix还是Windows平台，内部完成I / O任务的另有线程池</li>
</ul>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225728300.(null)" alt="img"></p>
<h2 id="Node的异步I-O">Node的异步I / O</h2>
<blockquote>
<p>Node完成整个异步I / O环节的有事件循环、观察者和请求对象等</p>
</blockquote>
<h3 id="事件循环">事件循环</h3>
<blockquote>
<p>着重强调一下Node自身的执行模型——事件循环</p>
</blockquote>
<p>Node进程启动时，会创建一个类似while(true)的循环</p>
<p>每次循环体的过程称之为Tick，每个Tick的过程就是查看是否有事件待处理</p>
<p>如果有就取出事件及其相关的回调函数，并执行它们</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225732500.(null)" alt="img"></p>
<h3 id="观察者">观察者</h3>
<blockquote>
<p>每个事件循环中有一个或多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件</p>
</blockquote>
<ul>
<li>浏览器采用了类似的机制
<ul>
<li>事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者</li>
</ul>
</li>
<li>Node中事件主要来源于网络请求、文件I / O等
<ul>
<li>这些时间对应的观察者有文件I / O观察者、网络I / O观察者等，将事件进行了分类</li>
</ul>
</li>
<li>事件循环是一个典型的生产者 / 消费者模型
<ul>
<li>异步I / O、网络请求等则是事件的生产者</li>
<li>这些事件被传递到对应的观察者，事件循环则从观察者那取出事件并处理</li>
</ul>
</li>
</ul>
<h3 id="小结">小结</h3>
<blockquote>
<p>事件循环、观察者、请求对象、I / O线程池这四者共同构成了NOde异步I / O模型的基本要素</p>
</blockquote>
<p>由于我们知道JavaScipt是单线程的，所以按尝试很容易理解它不能充分利用多核CPU</p>
<p>事实上在Node中，除了JavaScript是单线程外，Node自身其实是多喜爱昵称的，只是I / O线程使用的CPU较少</p>
<p>另一个需要注意的点是，除了用户代码无法并行执行以外，所有的I / O是可以并行执行的</p>
<blockquote>
<p>注：图为Node整个异步I / O过程</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225736774.(null)" alt="img"></p>
<h1>事件驱动与高性能服务器</h1>
<blockquote>
<p>前面对异步的讲解，也基本勾勒出了事件驱动的实质，即通过主循环加事件触发的方式来运行程序</p>
</blockquote>
<p>下面为几种经典的服务器模型：</p>
<ul>
<li>同步式
<ul>
<li>一次只能处理一个请求，并且其余请求都处于等待状态</li>
</ul>
</li>
<li>进程 / 请求
<ul>
<li>这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多</li>
</ul>
</li>
<li>线程 / 请求
<ul>
<li>尽管线程比进程要清凉，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢</li>
<li>比进程 / 请求要好，但对于大型站点而言依然不够</li>
</ul>
</li>
<li>总结
<ul>
<li>线程 / 请求的方式目前还被Apache所采用</li>
<li>Node通过事件驱动的方式处理请求，无需为每一个请求创建额外的线程，可以省掉创建线程和销毁线程的开销</li>
<li>同时操作系统在调度任务时因为线程较少，上下文的代价很低
<ul>
<li>这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受上下文切换开销的影响，这也是Node高性能的一个原因</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>事件驱动带来的高效已经渐渐开始为业界所重视</p>
<p>知名服务器Nginx也摒弃了多线程的方式，采用和Node相同的事件驱动</p>
<p>不同之处在于Nginx采用纯C写成，性能较高，但是它仅适合于做Web服务器，用于反向代理或者负载均衡服务，在业务处理方面较为欠缺</p>
<p>Node则是一套高性能平台，可以利用它构建与Nginx相同的功能，也可以处理各种具体业务</p>
<p>Node没有Nginx在Web服务器方面那么专业，但场景更大，自身性能也不错</p>
<p>在实际项目中可以结合它们各自的优点以达到应用的最优性能</p>
<p>JavaScript在服务器端近乎空白，使得Node没有任何历史包袱，而Node在性能优化上的表现使得它一下子就在社区中流行了起来~</p>
</blockquote>
<h1>写在最后</h1>
<p>本文介绍了Node被创造的目的、语言选型、特点、模块机制、包管理机制以及异步I / O等相关知识，希望能让你对Node有一个新的认识。最近一直也在计划学习Node和服务端相关知识，感兴趣的同学可以一起学习和交流~</p>
<p>掘金：<a target="_blank" rel="noopener" href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p>
<p>知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p>
<p>持续分享技术博文，关注微信公众号👇🏻</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LeBronChao-</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lebronchao.com/2021/12/11/%E5%B8%A6%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Node/">https://lebronchao.com/2021/12/11/带你重新认识Node/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lebronchao.com" target="_blank">LeBronChao's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/Node/">Node</a><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/">服务端</a></div><div class="post_share"><div class="social-share" data-image="https://bloginfo.lebronchao.com/doc-image/node.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/11/%E6%91%84%E5%BD%B1-%E5%B9%BF%E5%B7%9E%E8%A1%8C/"><img class="prev-cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9300.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">摄影 | 广州行</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/02/%E7%A7%8B%E6%8B%9B%E5%88%86%E4%BA%AB/"><img class="next-cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E5%AD%97%E8%8A%82.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">[面经分享] 收获多家大厂offer | 分享我的2022秋招经历</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/22/NodeJS加解密之Crypto/" title="NodeJS加解密之Crypto"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/node.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-22</div><div class="title">NodeJS加解密之Crypto</div></div></a></div><div><a href="/2021/06/22/JavaScipt-GC/" title="[深入浅出]JavaScript GC 垃圾回收机制"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/JavaScript.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-22</div><div class="title">[深入浅出]JavaScript GC 垃圾回收机制</div></div></a></div><div><a href="/2021/08/02/LoadBalance负载均衡/" title="[深入浅出LB]手把手带你实现一个负载均衡器"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/LoadBalance.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-02</div><div class="title">[深入浅出LB]手把手带你实现一个负载均衡器</div></div></a></div><div><a href="/2021/09/05/ORM/" title="如何优雅地操作数据库？ORM了解一下"><img class="cover" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/ORM.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-05</div><div class="title">如何优雅地操作数据库？ORM了解一下</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://bloginfo.lebronchao.com/personal-info/IMG_8050.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">LeBronChao-</div><div class="author-info__description">深圳大学(SZTU)物联网工程大四<br/>前端开发工程师一枚<br/>业余摄影师，交流/约拍可私戳。<br/>字节跳动内推码:4FCV6BV<br/>Email：LeBronChao@foxmail.com</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LeBronChao"><i class="fab fa-github"></i><span>Follow My Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LeBronChao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lebronchao@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://bloginfo.lebronchao.com/personal-info/IMG_8268-20210326002121490.jpg" target="_blank" title="微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1531229587&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">掘金：<a target="_blank" rel="noopener" href="https://juejin.cn/user/3913917127467805">前端LeBron</a><br/>知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/lebronchao">前端LeBron</a><br/>持续分享技术博文，关注wx公众号👇🏻<br/><img src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" /></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">最初做Node的目的是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">为什么是JavaScript？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Node给JavaScript带来的意义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Node的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5I-O"><span class="toc-number">4.1.</span> <span class="toc-text">异步I &#x2F; O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">事件与回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-number">4.4.</span> <span class="toc-text">跨平台</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Node模块机制 - CommonJS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%BF%E6%99%AF"><span class="toc-number">5.1.</span> <span class="toc-text">愿景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E5%8F%91%E7%82%B9"><span class="toc-number">5.2.</span> <span class="toc-text">出发点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83"><span class="toc-number">5.3.</span> <span class="toc-text">模块规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.</span> <span class="toc-text">模块实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E4%BB%8E%E7%BC%93%E5%AD%98%E5%8A%A0%E8%BD%BD"><span class="toc-number">5.4.1.</span> <span class="toc-text">优先从缓存加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90%E5%92%8C%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="toc-number">5.4.2.</span> <span class="toc-text">路径分析和文件定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91"><span class="toc-number">5.4.3.</span> <span class="toc-text">模块编译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">包与NPM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">包结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text">包描述文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NPM-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">6.3.</span> <span class="toc-text">NPM 常用功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F-NPM"><span class="toc-number">6.4.</span> <span class="toc-text">局域 NPM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">异步I &#x2F; O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%82%E6%AD%A5-I-O-%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">为什么需要异步 I &#x2F; O ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5I-O%E7%8E%B0%E7%8A%B6"><span class="toc-number">7.2.</span> <span class="toc-text">异步I &#x2F; O现状</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5I-O%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EI-O"><span class="toc-number">7.2.1.</span> <span class="toc-text">异步I &#x2F; O与非阻塞I &#x2F; O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%9A%84%E8%BD%AE%E8%AF%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">7.2.2.</span> <span class="toc-text">主要的轮询技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E6%83%B3%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5I-O"><span class="toc-number">7.2.3.</span> <span class="toc-text">理想的非阻塞异步I &#x2F; O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E5%AE%9E%E7%9A%84%E5%BC%82%E6%AD%A5I-O"><span class="toc-number">7.2.4.</span> <span class="toc-text">现实的异步I &#x2F; O</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node%E7%9A%84%E5%BC%82%E6%AD%A5I-O"><span class="toc-number">7.3.</span> <span class="toc-text">Node的异步I &#x2F; O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.3.1.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85"><span class="toc-number">7.3.2.</span> <span class="toc-text">观察者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.3.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">事件驱动与高性能服务器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">写在最后</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/22/NodeJS%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BCrypto/" title="NodeJS加解密之Crypto"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/node.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NodeJS加解密之Crypto"/></a><div class="content"><a class="title" href="/2021/12/22/NodeJS%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BCrypto/" title="NodeJS加解密之Crypto">NodeJS加解密之Crypto</a><time datetime="2021-12-22T15:50:51.000Z" title="发表于 2021-12-22 23:50:51">2021-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/11/%E6%91%84%E5%BD%B1-%E5%B9%BF%E5%B7%9E%E8%A1%8C/" title="摄影 | 广州行"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9300.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="摄影 | 广州行"/></a><div class="content"><a class="title" href="/2021/12/11/%E6%91%84%E5%BD%B1-%E5%B9%BF%E5%B7%9E%E8%A1%8C/" title="摄影 | 广州行">摄影 | 广州行</a><time datetime="2021-12-11T07:51:35.000Z" title="发表于 2021-12-11 15:51:35">2021-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/11/%E5%B8%A6%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Node/" title="带你重新认识Node"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/node.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="带你重新认识Node"/></a><div class="content"><a class="title" href="/2021/12/11/%E5%B8%A6%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Node/" title="带你重新认识Node">带你重新认识Node</a><time datetime="2021-12-11T07:38:45.000Z" title="发表于 2021-12-11 15:38:45">2021-12-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/02/%E7%A7%8B%E6%8B%9B%E5%88%86%E4%BA%AB/" title="[面经分享] 收获多家大厂offer | 分享我的2022秋招经历"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E5%AD%97%E8%8A%82.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[面经分享] 收获多家大厂offer | 分享我的2022秋招经历"/></a><div class="content"><a class="title" href="/2021/11/02/%E7%A7%8B%E6%8B%9B%E5%88%86%E4%BA%AB/" title="[面经分享] 收获多家大厂offer | 分享我的2022秋招经历">[面经分享] 收获多家大厂offer | 分享我的2022秋招经历</a><time datetime="2021-11-02T15:06:11.000Z" title="发表于 2021-11-02 23:06:11">2021-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/05/Vuex4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="[源码解读]一文读懂Vuex4源码"><img data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[源码解读]一文读懂Vuex4源码"/></a><div class="content"><a class="title" href="/2021/09/05/Vuex4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="[源码解读]一文读懂Vuex4源码">[源码解读]一文读懂Vuex4源码</a><time datetime="2021-09-05T02:25:04.000Z" title="发表于 2021-09-05 10:25:04">2021-09-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By LeBronChao-</div><div class="footer_custom_text">@ 2021 LeBronChao- CopyRight | 粤ICP备2021025161号</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'TKAoSdRXJ5zxwsjdGTP0Hrfh-9Nh9j0Va',
      appKey: 'lI3CGg5rpWkxsfvsKTRkVszT',
      placeholder: '留下你的足迹吧，記得留下你的昵称和邮箱....可以快速收到回复',
      avatar: 'https://bloginfo.lebronchao.com/doc-image/touxiang.jpeg',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-cn',
      recordIP: true,
      serverURLs: 'https://tkaosdrx.lc-cn-e1-shared.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (true) {
      const otherData = {"master":["64951ad612e26b51f6cc37788be7c200","b467dec92be8eb17c36ca900ef5d8dc1"],"friends":["30932c612db8dca9f08b98d6c1818ba2","898f30c9b8971d165a03abe4deba1ac6","741b327a5a0afbafd674ac782ddb0835","8dc27dfae152eb47084d3d0ae48c33d5","49fa154bbe0132bb66cb50c473f7f3ab","1f1338f1eff80cd7184516e788f9cbca","316d73187eea974f9f29c9fe4dc84a63","d4964055fcfa2b76c06d8cb038b0954e"],"metaPlaceholder":{"nick":"昵称(必填)","mail":"邮箱(必填,QQ邮箱可显示头像)","link":"主页(https://)"}}
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>