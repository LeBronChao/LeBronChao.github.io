<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript 设计模式 —— 策略模式</title>
      <link href="2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>很快，迎来了 JavaScript 设计模式系列的第二篇 —— 策略模式 …</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/eeef21c8afaf4d89857f31ba2644ad36~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1>什么是策略模式</h1><blockquote><p>策略模式定义：</p><p>定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换</p></blockquote><p>策略模式一般由两部分组成：</p><ol><li><p>封装不同策略的策略组（使得代码复用性、可扩展、可维护性提高，避免大量 CV 代码的情况）</p></li><li><p>Context（委托算法，执行策略）</p></li></ol><h1>什么时候使用策略模式 ？</h1><blockquote><p>策略模式广泛应用于程序研发中，当出现需要根据不同的前置条件执行不同的算法得到结果时，使用策略模式可以让你的代码更加优雅</p></blockquote><p>怎么？不信？ 那就上点代码让你感受一下 💩 山的力量！</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/5cab40c1005d40c6a578a60fb43e836a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>假设一个函数负责 Consul （服务发现）和 LB （负载均衡）</p><p>这里 Consul 函数就是 Context，各种 LB 算法就是策略组</p><p>传入服务唯一标识和负载均衡算法</p><p>返回服务器实例 IP 地址</p><p>如想了解 LB 相关知识，可以看看这篇文章 <a href="https://juejin.cn/post/6987196608161005581">[深入浅出 LB]手把手带你实现一个负载均衡器</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consul</span>(<span class="params">serviceId, algorithm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (algorithm === <span class="string">&#x27;random&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// random flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;weightedRoundRobin&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// weightedRoundRobin flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;ipHash&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ipHash flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;urlHash&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// urlHash flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;leastConnection&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// leastConnection flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (algorithm === <span class="string">&#x27;fair&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// fair flow</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这段代码存在着一些明显的问题</p><ol><li><p>Consul 函数过于庞大，不符合单一职责原则，难维护</p></li><li><p>堆砌了过多的 IF-ELSE 语句，代码看起来比较冗余</p></li><li><p>负载均衡算法复用性较差，如果其他地方需要用到…（你不会直接 CV 吧 🤓</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/6167b9b2dc57444cbbbbd660b86ae406~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><blockquote><p>针对以上问题，我们可以利用策略模式加以优化</p></blockquote><ol><li><p>首先将各 LB 算法封装成独立的函数，提高复用性</p></li><li><p>建立算法名称 -&gt; 算法执行函数映射，干掉冗余的 IF-ELSE（简直就是 IF-ELSE 的救世主</p></li><li><p>简化 Consul 函数，具体算法对于 Consul 来说是“隐形”的，单一职责</p></li><li><p>可拓展性提高，如需拓展更多算法，仅需引入算法和添加 Map 中的配置</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// random flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">weightedRoundRobin</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// weightedRoundRobin flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipHash</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// IPHash flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlHash</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// URL Hash flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leastConnection</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// leaseConnection flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fair</span>(<span class="params">serviceId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// fair flow</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALGORITHM = &#123;</span><br><span class="line">  RANDOM: <span class="string">&#x27;random&#x27;</span>,</span><br><span class="line">  WEIGHTED_ROUND_ROBIN: <span class="string">&#x27;weightedRoundRobin&#x27;</span>,</span><br><span class="line">  IP_HASH: <span class="string">&#x27;ipHash&#x27;</span>,</span><br><span class="line">  URL_HASH: <span class="string">&#x27;urlHash&#x27;</span>,</span><br><span class="line">  LEAST_CONNECTION: <span class="string">&#x27;leastConnection&#x27;</span>,</span><br><span class="line">  FAIR: <span class="string">&#x27;fair&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALGORITHM_MAP = &#123;</span><br><span class="line">  [ALGORITHM.RANDOM]: random,</span><br><span class="line">  [ALGORITHM.WEIGHTED_ROUND_ROBIN]: weightedRoundRobin,</span><br><span class="line">  [ALGORITHM.IP_HASH]: ipHash,</span><br><span class="line">  [ALGORITHM.URL_HASH]: urlHash,</span><br><span class="line">  [ALGORITHM.LEAST_CONNECTION]: leastConnection,</span><br><span class="line">  [ALGORITHM.FAIR]: fair,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consul</span>(<span class="params">serviceId, algorithm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ALGORITHM_MAP[algorithm](serviceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>策略模式应用场景之表单校验</h1><h2 id="粗糙的表单校验">粗糙的表单校验</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 粗糙的表单校验</span></span><br><span class="line"><span class="keyword">let</span> loginFrom = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;loginFrom&#x27;</span>);</span><br><span class="line">loginFrom.onsubmit = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> username = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> pwd = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;pwd&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> mobile = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;mobile&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (username === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;用户名不可为空&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pwd.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;密码长度不能少于6位&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="regexp">/^1(3\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|8\d|9[0-35-9])\d&#123;8&#125;$/</span>.test(mobile)</span><br><span class="line">  ) &#123;</span><br><span class="line">    alert(<span class="string">&#x27;手机号码格式不正确&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用策略模式优化后的表单校验">使用策略模式优化后的表单校验</h2><blockquote><p>Context：validate</p><p>策略组：strategy</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用策略模式优化</span></span><br><span class="line"><span class="keyword">const</span> strategy = &#123;</span><br><span class="line">  isEmpty: <span class="function"><span class="keyword">function</span> (<span class="params">&#123; value &#125;, errMsg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isMobile: <span class="function"><span class="keyword">function</span> (<span class="params">&#123; value &#125;, errMsg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !<span class="regexp">/^1(3\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|8\d|9[0-35-9])\d&#123;8&#125;$/</span>.test(value)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  isLongerThanMinLength: <span class="function"><span class="keyword">function</span> (<span class="params">&#123; value, len &#125;, errMsg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length &lt; len) &#123;</span><br><span class="line">      <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.validateItems = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">params, strategyKey, errMsg</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.validateItems.push(&#123; params, strategyKey, errMsg &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">this</span>.validateItems) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; params, strategyKey, errMsg &#125; = item;</span><br><span class="line">      <span class="keyword">const</span> msg = strategy[strategyKey](params, errMsg);</span><br><span class="line">      <span class="keyword">if</span> (msg) &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> username = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> pwd = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;pwd&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> mobile = <span class="built_in">document</span>.getElementId(<span class="string">&#x27;mobile&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> validator = <span class="keyword">new</span> Validator();</span><br><span class="line">  validator.add(&#123; <span class="attr">value</span>: username &#125;, <span class="string">&#x27;isEmpty&#x27;</span>, <span class="string">&#x27;用户名不可为空&#x27;</span>);</span><br><span class="line">  validator.add(</span><br><span class="line">    &#123; <span class="attr">value</span>: pwd, <span class="attr">len</span>: <span class="number">6</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;isLongerThanMinLength&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;密码长度不能少于6位&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  validator.add(&#123; <span class="attr">value</span>: mobile &#125;, <span class="string">&#x27;isMobile&#x27;</span>, <span class="string">&#x27;手机号码格式不正确&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> errMsg = validator.start();</span><br><span class="line">  <span class="keyword">if</span> (errMsg) &#123;</span><br><span class="line">    alert(errMsg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">&#x27;校验通过&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validate();</span><br></pre></td></tr></table></figure><h1>策略模式和多态的区别</h1><ul><li><p>策略模式定义了算法组，分别封装，它们之间可以相互替换，此模式的变化独立于使用算法的客户</p></li><li><p>多态常用继承、方法重写、父类引用指向子类对象等方法实现</p></li></ul><blockquote><p>策略模式强调的是做同一件事的不同且不重复的方法</p><p>多态是一种语言机制，有的不支持多态的语言也一样要实现策略模式</p><p>策略处于程序设计层次，多态处于语言语法层次</p></blockquote><h1>总结</h1><h2 id="策略模式的优点">策略模式的优点</h2><ul><li><p>策略模式利用组合、委托和多态等技术和思想，可以有效避免多重且冗余的 IF-ELSE</p></li><li><p>策略模式提供了对开放——封闭原则的完美支持，将算法封装在独立的策略中。可以在不修改原代码的情况下，灵活增加新算法。提高了它们的复用性、和可拓展性，也更容易切换和理解。</p></li><li><p>策略模式中的算法也可以复用在工程的其他地方，避免大量重复的 CV 工作</p></li><li><p>在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案</p></li></ul><h2 id="策略模式的缺点">策略模式的缺点</h2><ul><li><p>策略模式会在程序中增加许多策略函数、类、对象，但实际上比把它们堆砌在 Context 中要更好</p></li><li><p>使用策略模式必须了解所有的策略，必须了解它们的细节比较它们之间的不同点，才能选择一个合适的策略。此时需要向用户暴露它的所有实现，违反最少知识原则。</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/a16be28e58b54115b4bc17ebc45b7cd0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Front End </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 设计模式 —— 单例模式</title>
      <link href="2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2022/08/21/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案 —— 设计模式</p><p>设计模式原则：“找出程序中变化的地方，并将变化封装起来”</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/e424e745d4e545a8bb75e14a563dbe70~tplv-k3u1fbpfcp-watermark.image" alt="imagepng"></p><h1>为什么要学习设计模式?</h1><p>从事开发岗位也有一年多的时间了，见识过陈年老项目，也从零到一搭建过一个项目。随着项目和业务的不断扩张，写下的代码如果没有进行设计，就渐渐变成了 emm … x 山，怎么写都不对劲，过段时间就想着重构。</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/bf5f5a7bb5c440db89c525db7044a7ba~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>人之所以可以走到食物链的顶端，是因为会学习、总结，会使用“名字”和“工具”。而设计模式并不是凭空发明出来的，是经过了大量的项目实践总结出来的对某种业务场景下的程序编写最佳实践，总结出来的解决方案，并给它取了个名字，就变成了一个设计模式。就好比篮球场上的战术，组织后卫常喊出打几号战术，而不是一个人一个人地指挥，简洁的代号往往比冗杂的描述更优雅。有可能你经常写程序的一种方式，可以描述出来，但不知道它叫什么名字，有可能就是一种设计模式。所以我们在学习的过程中，经常会有这种感受： ooooo ！！这玩意儿我经常用，经常这么写，原来这个是 xx 模式！</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/eac8ed0ef6544b3489bff9d17ee7870b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>最后，为什么要学设计模式呢？虽然有时候设计模式会使代码复杂度升高，增加开发的成本，但极大地降低了维护成本。就好比图书馆中的书如果无序地散落在各个角落，找起来如同大海捞针；而如果标号且归类、有序地放在指定书架上，找起来就容易了许多。想象一个场景，某天，你指着一段代码开始骂，这谁写的 x 山！鼠标移了上去， git 修改记录显示，哦！我写的，那没事了。赶紧设计模式学起来，优雅地编写简洁、可复用、易维护的程序 ~</p><h1>单例模式</h1><blockquote><p>1、保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p>2、主要解决一个全局使用的类频繁地创建和销毁，占用内存</p></blockquote><h2 id="实现单例模式">实现单例模式</h2><blockquote><p>实现一个简洁的单例模式并不复杂，无非就是将实例对象保存起来，下一次获取/创建对象的时候，直接返回之前创建的实例</p></blockquote><h3 id="最简单例模式">最简单例模式</h3><blockquote><ul><li><p>闭包实现</p></li><li><p>ES6 实现</p></li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用闭包实现</span></span><br><span class="line"><span class="keyword">var</span> Singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Instance</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Instance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> single1 = Singleton();</span><br><span class="line"><span class="keyword">var</span> single2 = Singleton();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(single1 === single2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Singleton.instance) &#123;</span><br><span class="line">      Singleton.instance = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Singleton.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> single1 = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="keyword">const</span> single2 = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(single1 === single2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="惰性单例">惰性单例</h3><blockquote><p>惰性单例：初始化时不进行实例创建，到获取实例时才进行实例创建，类似前端的资源懒加载思想</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非惰性单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (!SingleTon.instance) &#123;</span><br><span class="line">      SingleTon.instance = <span class="keyword">new</span> Tool(args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 惰性单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.instance) &#123;</span><br><span class="line">      <span class="built_in">this</span>.instance = <span class="keyword">new</span> Tool(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透明单例和代理单例">透明单例和代理单例</h3><blockquote><ul><li><p>透明单例</p><ul><li>将实例的创建和方法的执行封装到了一个类中</li><li>不太符合“单一职责原则”，代码不易读、不易改</li></ul></li><li><p>代理单例</p><ul><li>代理模式：将实例创建和方法分离，委托出去</li><li>Person 作为普通类，可以创建对象实例</li><li>createPerson 作为单例创建代理，可以创建一个单例</li><li>符合“单一职责原则”，代码易读、易改</li></ul></li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 透明 单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createPerson</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (createPerson.instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> createPerson.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">    <span class="keyword">return</span> (createPerson.instance = <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;lebron&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;james&#x27;</span>);</span><br><span class="line">p1.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line">p2.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createPerson</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!createPerson.instance) &#123;</span><br><span class="line">      createPerson.instance = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createPerson.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;lebron&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;james&#x27;</span>);</span><br><span class="line">p1.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line">p2.init(); <span class="comment">// My name is  lebron</span></span><br></pre></td></tr></table></figure><h3 id="最终版本">最终版本</h3><blockquote><p>每次实现一个类的单例模式都去 CV 重复的模板代码，不太符合预期。</p><p>于是，我们可以根据设计模式的原则“找出程序变化的地方，并将变化封装起来”</p><p>可以做如下改造</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> singleInstance;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">singleConstructor</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 第一次实例化</span></span><br><span class="line">      <span class="keyword">if</span> (!singleInstance) &#123;</span><br><span class="line">        singleInstance = <span class="keyword">new</span> fn(...args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 多次实例化直接返回</span></span><br><span class="line">      <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    singleConstructor.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">return</span> singleConstructor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createPerson = <span class="keyword">new</span> SingleTon(Person);</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;lebron&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> createPerson(<span class="string">&#x27;james&#x27;</span>);</span><br><span class="line">p1.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line">p2.init(); <span class="comment">// My name is  lebron</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">number</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.number = number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;This is tool &#x27;</span>, <span class="built_in">this</span>.number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createTool = <span class="keyword">new</span> SingleTon(Tool);</span><br><span class="line"><span class="keyword">const</span> t1 = <span class="keyword">new</span> createTool(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> t2 = <span class="keyword">new</span> createTool(<span class="number">2</span>);</span><br><span class="line">t1.init(); <span class="comment">// This is tool  1</span></span><br><span class="line">t2.init(); <span class="comment">// This is tool  1</span></span><br><span class="line"><span class="built_in">console</span>.log(t1 === t2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="单例模式的应用场景">单例模式的应用场景</h2><h3 id="登录窗口">登录窗口</h3><blockquote><p>登录窗口在我们的软件中很常见，也很适合使用单例模式创建（全局唯一、频繁使用）</p><p>使用单例模式创建可以避免多次节点创建和销毁</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.element.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">           用户名 &lt;input name=&quot;username&quot;/&gt;</span></span><br><span class="line"><span class="string">           密码 &lt;input name=&quot;password&quot;/&gt;</span></span><br><span class="line"><span class="string">           &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;</span></span><br><span class="line"><span class="string">          `</span>;</span><br><span class="line">    <span class="built_in">this</span>.element.style.cssText = <span class="string">`width:100px;height:100px;position:absolute;left:50%;top:50%;margin-top:-50px;margin-left:-50px;display:none`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="built_in">this</span>.element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;show&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hide&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用上文最终版本创建单例代码</span></span><br><span class="line"><span class="keyword">const</span> createLogin = <span class="keyword">new</span> SingleTon(Login);</span><br><span class="line"><span class="keyword">const</span> loginInstance = createLogin();</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;show-btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  loginInstance.show();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;hide-btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  loginInstance.hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Store">Store</h3><blockquote><p>全局状态管理，全局唯一实例，例如 Vuex / Redux / Mobx</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已省略一些无关代码</span></span><br><span class="line"><span class="keyword">if</span> (!Vue &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  install(<span class="built_in">window</span>.Vue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">&#x27;[vuex] already installed. Vue.use(Vuex) should be called only once.&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Vue = _Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jquery">Jquery</h3><blockquote><p>Jquery 也是应用的单例模式，虽然它已经渐渐淡出了我们的视野 😂</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.jQuery != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.jQuery;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//init~~~~~~~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><h3 id="使用场景">使用场景</h3><ul><li>保证一个类仅有一个实例，并提供一个访问它的全局访问点</li></ul><h3 id="优点">优点</h3><ul><li><p>在内存里只有一个实例，减少了内存的开销，尤其是频繁地创建和销毁实例</p></li><li><p>避免对资源的多重占用</p></li></ul><h1>闲谈</h1><blockquote><p>上半年一直在忙毕业的事情，然后也休息了一段时间，已经大半年没写技术文章了。</p><p>近期正式入职了，开始逐步调整到一个比较好的学习和工作状态。制定一些学习计划，恢复更新文章（很久没写还是有点不太习惯哈哈</p><p>第一个系列《设计模式》第一篇墨迹了半天，但也终于产出了。后续会持续更新，更新频率和进度看空闲时间情况了哈哈，欢迎关注~</p><p>一个还在努力的前端开发工程师，继续加油！</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/cce8553a6ec8415690f43252e508eb09~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Front End </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 梧桐山</title>
      <link href="2022/02/20/%E6%91%84%E5%BD%B1-%E6%A2%A7%E6%A1%90%E5%B1%B1/"/>
      <url>2022/02/20/%E6%91%84%E5%BD%B1-%E6%A2%A7%E6%A1%90%E5%B1%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 24-70GM<br>出镜：无<br>地点：梧桐山</p></blockquote><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00244.JPG" alt="DSC00244"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00248.JPG" alt="DSC00248"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00249.JPG" alt="DSC00249"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00250.JPG" alt="DSC00250"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00251.JPG" alt="DSC00251"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00253.JPG" alt="DSC00253"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00260.JPG" alt="DSC00260"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00287.JPG" alt="DSC00287"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00302.JPG" alt="DSC00302"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00271.JPG" alt="DSC00271"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00278.JPG" alt="DSC00278"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_0086.JPG" alt="IMG_0086"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00266.JPG" alt="DSC00266"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00237.JPG" alt="DSC00237"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00242.JPG" alt="DSC00242"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00232.JPG" alt="DSC00232"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人文 </tag>
            
            <tag> 摄影 </tag>
            
            <tag> 风光 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 南山夜景</title>
      <link href="2022/02/07/%E6%91%84%E5%BD%B1-%E5%8D%97%E5%B1%B1%E5%A4%9C%E6%99%AF/"/>
      <url>2022/02/07/%E6%91%84%E5%BD%B1-%E5%8D%97%E5%B1%B1%E5%A4%9C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身： SONY A7M2<br>镜头： SONY 24-70 GM<br>出镜： 无<br>地点： 深圳大南山公园</p></blockquote><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00174.JPG" alt="DSC00174"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00175.JPG" alt="DSC00175"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00229.JPG" alt="DSC00229"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00230.JPG" alt="DSC00230"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/DSC00167.JPG" alt="DSC00167"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 风光 </tag>
            
            <tag> 城市夜景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS加解密之Crypto</title>
      <link href="2021/12/22/NodeJS%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BCrypto/"/>
      <url>2021/12/22/NodeJS%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B9%8BCrypto/</url>
      
        <content type="html"><![CDATA[<blockquote><p>互联网时代，网络上的数据量每天都在以惊人的速度增长。同时，各类网络安全问题层出不穷。在信息安全重要性日益凸显的今天，作为一名开发者，需要加强对安全的认识，并通过技术手段增强服务的安全性。crypto 模块的目的是为了提供通用的加密和哈希算法。用纯 JavaScript 代码实现这些功能不是不可能，但速度会非常慢。Nodejs 用 C/C++实现这些算法后，通过 cypto 这个模块暴露为 JavaScript 接口，这样用起来方便，运行速度也快。</p></blockquote><h1>编码方式</h1><blockquote><p>为什么信息传输需要编码？</p><p>在开发加密解密数据的时候碰到需要把加密好的字节数组转换成 String 对象用于网络传输的需求，如果把字节数组直接转换成 UTF-8 等编码方式的话肯定会存在某些编码没有对应的字符(8bit 只能表示 128 个字符)，在编码和解析过程中会出错，不能正确地表达信息。这时就可以通过常用的二进制数据编码方式 Base64 编码或者 Hex 编码来实现。</p></blockquote><h2 id="hex-编码"><strong>hex 编码</strong></h2><ul><li>编码原理</li></ul><p>将一个 8 位的字节数据用两个 16 进制数表示出来</p><ol><li>将 8 位二进制码重新分组成两个 4 位的字节</li><li>其中一个字节的低 4 位是原字节的高 4 位，另一个字节的低 4 位是原数据的低 4 位</li><li>高 4 位都补 0，然后输出这两个字节对应的十六进制数字作为编码</li></ol><ul><li>例子</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ASCII码：A(<span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">二进制码:<span class="number">0100</span> <span class="number">0001</span></span><br><span class="line"></span><br><span class="line">重新分组: <span class="number">00000100</span>  <span class="number">00000001</span></span><br><span class="line"></span><br><span class="line">十六进制: <span class="number">4</span>         <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Hex编码：<span class="number">41</span></span><br></pre></td></tr></table></figure><p>就算原文件是纯英文内容，编码后内容也和原文完全不一样，普通人难以阅读但由于只有 16 个字符，听说一些程序员大牛能够记下他们的映射关系，从而达到读 hex 编码和读原文一样的效果。另外，数据在经过 hex 编码后，空间占用变成了原来的 2 倍。</p><h2 id="base64-编码"><strong>base64 编码</strong></h2><ul><li>编码原理</li></ul><p>Base64 编码是通过 64 个字符来表示二进制数据，64 个字符表示二进制数据只能表示 6 位，所以它可以通过 4 个 Base64 字符来表示 3 个字节，如下是 Base64 的字符编码表</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202230237552.(null)" alt="img"></p><ul><li>举个 Base64 编码的例子，图就很浅显易懂了</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202230244003.(null)" alt="img"></p><ul><li>字符串长度不是 3 的倍数时补 0，也就是“=”</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202230248378.(null)" alt="img"></p><p>由 64 个字符组成，比 hex 编码更难阅读，但由于每 3 个字节会被编码为 4 个字符。</p><p>所以，空间占用会是原来的 4/3，比 hex 要节省空间。另外要注意的是，虽然 Base64 编码后的数据难以阅读，但不能将其作为加密算法使用，因为它解码都不需要你提供密钥啊</p><h2 id="urlencode-编码"><strong>urlencode 编码</strong></h2><ul><li>编码原理</li></ul><p>urlencode 编码，看名字就就知道是设计给 url 编码的对于<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，<code>.</code>，<code>-</code>和<code>_</code> ，urlencode 都不会做任何处理原样输出，而其它字节会被编码为<code>%xx</code>(16 进制)的形式，其中<code>xx</code>就是这个字节对应的 hex 编码。 由于英文字符原样保留，对于以英文为主的内容，可读性最好，空间占用几乎不变，而对于非英文内容，每个字节会被编码为%xx 的 3 个字符，空间占用是原来的 3 倍，所以 urlencode 是一个对英文友好的编码方案。</p><h1><strong>Hash</strong></h1><blockquote><p>摘要：将不固定长度的消息作为输入 Hash 函数，生成固定长度的输出，这段输出称之为摘要</p><p>适用场景：敏感信息的校验和存储、验证消息完整 &amp; 未被篡改</p></blockquote><h2 id="特点"><strong>特点</strong></h2><ol><li>输出长度固定：输入长度不固定，输出长度固定（因算法而异，常见的有 MD5、SHA 系列）。</li><li>运算不可逆：已知运算结果的情况下，无法通过通过逆运算得到原始字符串。</li><li>高度离散：输入的微小变化，可导致运算结果差异巨大。</li><li>弱碰撞性：不同输入的散列值可能相同。</li></ol><h2 id="以-MD5-为例">以 MD5 为例</h2><blockquote><p>MD5（Message-Digest Algorithm）是计算机安全领域广泛使用的散列函数（又称哈希算法、摘要算法），主要用来确保消息的完整和一致性。</p><p>常见的应用场景：密码保护、下载文件校验等。</p></blockquote><h2 id="应用场景"><strong>应用场景</strong></h2><ol><li>文件完整性校验：比如从网上下载一个软件，一般网站都会将软件的 md5 值附在网页上，用户下载完软件后，可对下载到本地的软件进行 md5 运算，然后跟网站上的 md5 值进行对比，确保软件的完整性</li><li>密码保护：将 md5 后的密码保存到数据库，而不是保存明文密码，避免拖库等事件发生后，明文密码泄漏。</li><li>防篡改：比如数字证书的防篡改，就用到了摘要算法。（当然还要结合数字签名等手段）</li></ol><h2 id="简单的-md5-运算">简单的 md5 运算</h2><ul><li>hash.digest([encoding])</li></ul><p>计算摘要。encoding 可以是<code>hex</code>、<code>base64</code>或其他。如果声明了 encoding，那么返回字符串。否则，返回 Buffer 实例。注意，调用 hash.digest()后，hash 对象就作废了，再次调用就会报错。</p><ul><li>hash.update(data[, input_encoding])</li></ul><p>input_encoding 可以是<code>utf8</code>、<code>ascii</code>或者其他。如果 data 是字符串，且没有指定 input_encoding，则默认是<code>utf8</code>。注意，hash.update()方法可以调用多次。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FILE_PATH = <span class="string">&#x27;./index.txt&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ENCODING = <span class="string">&#x27;hex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(FILE_PATH);</span><br><span class="line"><span class="keyword">const</span> result = md5.update(content).digest(ENCODING);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// f62091d58876a322864f5a522eb05052</span></span><br></pre></td></tr></table></figure><h2 id="密码保护">密码保护</h2><blockquote><p>前面提到，将明文密码保存到数据库是很不安全的</p><p>最不济也要进行 md5 后进行保存</p><p>比如用户密码是<code>123456</code>，md5 运行后，得到<code>输出：e10adc3949ba59abbe56e057f20f883e</code></p></blockquote><p>这样至少有两个好处：</p><ol><li>防内部攻击：网站开发者也不知道用户的明文密码，避免开发者拿着用户明文密码干坏事，以这种形式来保护用户的隐私</li><li>防外部攻击：如网站被黑客入侵，黑客也只能拿到 md5 后的密码，而不是用户的明文密码，保证了密码的安全性</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cryptPwd = <span class="function">(<span class="params">password</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> md5.update(password).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> cryptPassword = cryptPwd(password);</span><br><span class="line"><span class="built_in">console</span>.log(cryptPassword);</span><br><span class="line"></span><br><span class="line"><span class="comment">// e10adc3949ba59abbe56e057f20f883e</span></span><br></pre></td></tr></table></figure><ul><li>前面提到，通过对用户密码进行 md5 运算来提高安全性。<ul><li>但实际上，这样的安全性是很差的，为什么呢？</li><li>稍微修改下上面的例子，可能你就明白了。相同的明文密码，md5 值也是相同的。</li></ul></li><li>也就是说当攻击者知道算法是 md5，且数据库里存储的密码值为<code>e10adc3949ba59abbe56e057f20f883e</code>时，理论上可以可以猜到，用户的明文密码就是<code>123456</code>。</li><li>事实上，彩虹表就是这么进行暴力破解的：事先将常见明文密码的 md5 值运算好存起来，然后跟网站数据库里存储的密码进行匹配，就能够快速找到用户的明文密码。</li></ul><blockquote><p>那么有什么办法可以进一步提升安全性呢？</p><p>答案是：密码加盐。</p></blockquote><h2 id="密码加盐"><strong>密码加盐</strong></h2><blockquote><p>“加盐”这个词看上去很玄乎，其实原理很简单</p><p>就是在密码特定位置插入特定字符串后，再对修改后的字符串进行 md5 运算。</p></blockquote><p>同样的密码，当“盐”值不一样时，md5 值的差异非常大</p><p>通过密码加盐，可以防止最初级的暴力破解，如果攻击者事先不知道”盐“值，破解的难度就会非常大</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cryptPwd = <span class="function">(<span class="params">password, salt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> saltPassword = <span class="string">`<span class="subst">$&#123;password&#125;</span>:<span class="subst">$&#123;salt&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`原始密码：<span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码：<span class="subst">$&#123;saltPassword&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = md5.update(password).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码的MD5值：<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> salt = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">cryptPwd(password, salt);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始密码：123456</span></span><br><span class="line"><span class="comment">加盐密码：123456:abc</span></span><br><span class="line"><span class="comment">加盐密码的MD5值：e10adc3949ba59abbe56e057f20f883e</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="密码加盐：随机盐值"><strong>密码加盐：随机盐值</strong></h2><blockquote><p>通过密码加盐，密码的安全性已经提高了不少</p><p>但其实上面的例子存在不少问题</p></blockquote><ul><li>假设字符串拼接算法、盐值已外泄，上面的代码至少存在下面问题：</li></ul><ol><li>短盐值：需要穷举的可能性较少，容易暴力破解，一般采用长盐值来解决。</li><li>盐值固定：类似的，攻击者只需要把常用密码+盐值的 hash 值表算出来。</li></ol><ul><li>短盐值自不必说，应该避免<ul><li>对于为什么不应该使用固定盐值，这里需要多解释一下。很多时候，我们的盐值是硬编码到我们的代码里的（比如配置文件），一旦攻击者通过某种手段获知了盐值，那么，只需要针对这串固定的盐值进行暴力穷举就行了</li></ul></li><li>比如上面的代码，当你知道盐值是<code>abc</code>时，立刻就能猜到<code>51011af1892f59e74baf61f3d4389092</code>对应的明文密码是<code>123456</code>。</li></ul><blockquote><p>那么，该怎么优化呢？答案是：随机盐值。</p></blockquote><p>可以看到，密码同样是 123456，由于采用了随机盐值，前后运算得出的结果是不同的</p><p>这样带来的好处是，多个用户，同样的密码，攻击者需要进行多次运算才能够完全破解</p><p>同样是纯数字 3 位短盐值，随机盐值破解所需的运算量 &gt;&gt; 固定盐值</p><blockquote><p>示例代码如下</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getRandomSalt = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random().toString().slice(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cryptPwd = <span class="function">(<span class="params">password, salt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> saltPassword = <span class="string">`<span class="subst">$&#123;password&#125;</span>:<span class="subst">$&#123;salt&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`原始密码：<span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码：<span class="subst">$&#123;saltPassword&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = md5.update(saltPassword).digest(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加盐密码的MD5值：<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> password = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cryptPwd(password, getRandomSalt());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始密码：123456</span></span><br><span class="line"><span class="comment">加盐密码：123456:126</span></span><br><span class="line"><span class="comment">加盐密码的MD5值：3aeb1848ff63aa32b262bc3f8dd5bd82</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">cryptPwd(password, getRandomSalt());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原始密码：123456</span></span><br><span class="line"><span class="comment">加盐密码：123456:232</span></span><br><span class="line"><span class="comment">加盐密码的MD5值：21a427268a5094322146e18e47b135fb</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="HMAC-功能"><strong>HMAC 功能</strong></h2><blockquote><p>HMAC 的全称是 Hash-based Message Authentication Code，也即在 hash 的加盐运算。</p><p>具体到使用的话，跟 hash 模块差不多，选定 hash 算法，指定“盐”即可。</p><p>和上面的例子的区别是一个是手动拼盐值，一个是利用 HMAC 模块</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FILE_PATH = <span class="string">&quot;./index.txt&quot;</span></span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">&#x27;secret&#x27;</span></span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(FILE_PATH,&#123;<span class="attr">encoding</span>:<span class="string">&#x27;utf8&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> hmac = crypto.createHmac(<span class="string">&#x27;sha256&#x27;</span>, SECRET);</span><br><span class="line"></span><br><span class="line">hmac.update(content)</span><br><span class="line"><span class="keyword">const</span> output = hmac.digest(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hmac: <span class="subst">$&#123;output&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hmac: 6f438ef66d3806ae14d6692d9610e55c41ebb4eb3ee73911a4d512bd1cade976</span></span><br></pre></td></tr></table></figure><blockquote><p>注：大文件可流式处理</p></blockquote><h1>加密 / 解密</h1><blockquote><p>加解密主要用到下面两组方法：</p></blockquote><ul><li><p>加密：</p><ul><li>crypto.createCipher(algorithm, password)</li></ul></li><li><p>crypto.createCipheriv(algorithm, key, iv)</p></li><li><p>解密：</p><ul><li>crypto.createDecipher(algorithm, password)</li></ul></li><li><p>crypto.createDecipheriv(algorithm, key, iv)</p></li></ul><h2 id="crypto-createCipher-crypto-createDecipher"><strong>crypto.createCipher / crypto.createDecipher</strong></h2><blockquote><p>先来看下 crypto.createCipher(algorithm, password)，两个参数分别是加密算法、密码</p></blockquote><ul><li><p>algorithm：加密算法，比如<code>aes192</code></p><ul><li>具体有哪些可选的算法，依赖于本地<code>openssl</code>的版本</li></ul></li><li><p>可以通过<code>openssl list-cipher-algorithms</code>命令查看支持哪些算法</p></li><li><p>password：用来生成密钥(key)、初始化向量(IV)</p></li></ul><blockquote><p>crypto.createDecipher(algorithm, password)可以看作 crypto.createCipher(algorithm, password) 逆向操作</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">&#x27;secret&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ALGORITHM = <span class="string">&#x27;aes192&#x27;</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;Hello Node.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">const</span> cipher = crypto.createCipher(ALGORITHM, SECRET)</span><br><span class="line">cipher.update(content)</span><br><span class="line"><span class="keyword">const</span> output = cipher.final(encoding)</span><br><span class="line"><span class="built_in">console</span>.log(output)</span><br><span class="line"><span class="comment">// 944e6e3c21d6eb8568bd6a9716631e、e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">const</span> decipher = crypto.createDecipher(ALGORITHM, SECRET)</span><br><span class="line">decipher.update(output, encoding)</span><br><span class="line"><span class="keyword">const</span> input = decipher.final(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(input)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello Node.js</span></span><br></pre></td></tr></table></figure><h2 id="crypto-createCipheriv-crypto-createDecipheriv"><strong>crypto.createCipheriv / crypto.createDecipheriv</strong></h2><blockquote><p>相对于 crypto.createCipher() 来说，crypto.createCipheriv() 需要提供<code>key</code>和<code>iv</code>，而 crypto.createCipher() 是根据用户提供的 password 算出来的</p><p>key、iv 可以是 Buffer，也可以是 utf8 编码的字符串，这里需要关注的是它们的长度：</p></blockquote><ul><li><p>key：根据选择的算法有关</p><ul><li>比如 aes128、aes192、aes256，长度分别是 128、192、256 位（16、24、32 字节）</li></ul></li><li><p>iv：初始化向量，都是 128 位（16 字节），也可以理解为密码盐的一种</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> key = crypto.randomBytes(<span class="number">192</span> / <span class="number">8</span>)</span><br><span class="line"><span class="keyword">const</span> iv = crypto.randomBytes(<span class="number">128</span> / <span class="number">8</span>)</span><br><span class="line"><span class="keyword">const</span> algorithm = <span class="string">&#x27;aes192&#x27;</span></span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encrypt = <span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cipher = crypto.createCipheriv(algorithm, key, iv)</span><br><span class="line">    cipher.update(text)</span><br><span class="line">    <span class="keyword">return</span> cipher.final(encoding)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrypt = <span class="function">(<span class="params">encrypted</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.createDecipheriv(algorithm, key, iv)</span><br><span class="line">    decipher.update(encrypted, encoding)</span><br><span class="line">    <span class="keyword">return</span> decipher.final(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;Hello Node.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> crypted = encrypt(content)</span><br><span class="line"><span class="built_in">console</span>.log(crypted)</span><br><span class="line"></span><br><span class="line"><span class="comment">// db75f3e9e78fba0401ca82527a0bbd62</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decrypted = decrypt(crypted)</span><br><span class="line"><span class="built_in">console</span>.log(decrypted)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello Node.js</span></span><br></pre></td></tr></table></figure><h2 id="数字签名-签名校验"><strong>数字签名</strong> <strong>/ 签名校验</strong></h2><ul><li>假设：<ul><li>服务端原始信息为 M，摘要算法为 Hash，Hash(M)得出的摘要是 H</li><li>公钥为 Pub，私钥为 Piv，非对称加密算法为 Encrypt，非对称解密算法为 Decrypt</li><li>Encrypt(H)得到的结果是 S</li><li>客户端拿到的信息为 M1，利用 Hash(M1)得出的结果是 H1</li></ul></li><li>数字签名的产生、校验步骤分别如下：<ul><li>数字签名的产生步骤：<ul><li>利用摘要算法 Hash 算出 M 的摘要，即 Hash(M) == H</li><li>利用非对称加密算法对摘要进行加密 Encrypt( H, Piv )，得到数字签名 S</li></ul></li><li>数字签名的校验步骤：<ul><li>利用解密算法 D 对数字签名进行解密，即 Decrypt(S) == H</li><li>计算 M1 的摘要 Hash(M1) == H1，对比 H、H1，如果两者相同，则通过校验</li></ul></li></ul></li></ul><p>私钥如何生成不是这里的重点，这里采用网上的服务来生成。</p><p>了解了数字签名产生、校验的原理后，相信下面的代码很容易理解：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> privateKey = fs.readFileSync(<span class="string">&#x27;./private-key.pem&#x27;</span>);  <span class="comment">// 私钥</span></span><br><span class="line"><span class="keyword">const</span> publicKey = fs.readFileSync(<span class="string">&#x27;./public-key.pem&#x27;</span>);  <span class="comment">// 公钥</span></span><br><span class="line"><span class="keyword">const</span> algorithm = <span class="string">&#x27;RSA-SHA256&#x27;</span>;  <span class="comment">// 加密算法 vs 摘要算法</span></span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字签名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sign</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sign = crypto.createSign(algorithm);</span><br><span class="line">    sign.update(text);</span><br><span class="line">    <span class="keyword">return</span> sign.sign(privateKey, encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验签名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">verify</span>(<span class="params">oriContent, signature</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> verifier = crypto.createVerify(algorithm);</span><br><span class="line">    verifier.update(oriContent);</span><br><span class="line">    <span class="keyword">return</span> verifier.verify(publicKey, signature, encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对内容进行签名</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> signature = sign(content);</span><br><span class="line"><span class="built_in">console</span>.log(signature);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验签名，如果通过，返回true</span></span><br><span class="line"><span class="keyword">const</span> verified = verify(content, signature);</span><br><span class="line"><span class="built_in">console</span>.log(verified);</span><br></pre></td></tr></table></figure><h2 id="DH-DiffieHellman">DH(DiffieHellman)</h2><blockquote><p>DiffieHellman：Diffie–Hellman key exchange，缩写为 D-H，是一种安全协议，常用于密钥交换，让通信双方在预先没有对方信息的情况下，通过不安全通信信道，创建一个密钥。这个密钥可以在后续的通信中，作为对称加密的密钥加密传递的信息。</p></blockquote><ul><li>原理解析</li></ul><p>假设客户端、服务端挑选两个素数 a、p（都公开），然后</p><ul><li><p>客户端：选择自然数 Xa，Ya = a^Xa mod p，并将 Ya 发送给服务端；</p></li><li><p>服务端：选择自然数 Xb，Yb = a^Xb mod p，并将 Yb 发送给客户端；</p></li><li><p>客户端：计算 Ka = Yb^Xa mod p</p></li><li><p>服务端：计算 Kb = Ya^Xb mod p</p></li></ul><blockquote><p>Ka = Yb^Xa mod p</p><p>= (a^Xb mod p)^Xa mod p</p><p>= a^(Xb * Xa) mod p</p><p>= (a^Xa mod p)^Xb mod p</p><p>= Ya^Xb mod p</p><p>= Kb</p><p>可以看到，尽管客户端、服务端彼此不知道对方的 Xa、Xb，但算出了相等的 secret</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> primeLength = <span class="number">1024</span>;  <span class="comment">// 素数p的长度</span></span><br><span class="line"><span class="keyword">const</span> generator = <span class="number">5</span>;  <span class="comment">// 素数a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建客户端的DH实例</span></span><br><span class="line"><span class="keyword">const</span> client = crypto.createDiffieHellman(primeLength, generator);</span><br><span class="line"><span class="comment">// 产生公、私钥对，Ya = a^Xa mod p</span></span><br><span class="line"><span class="keyword">const</span> clientKey = client.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务端的DH实例，采用跟客户端相同的素数a、p</span></span><br><span class="line"><span class="keyword">const</span> server = crypto.createDiffieHellman(client.getPrime(), client.getGenerator());</span><br><span class="line"><span class="comment">// 产生公、私钥对，Yb = a^Xb mod p</span></span><br><span class="line"><span class="keyword">const</span> serverKey = server.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 Ka = Yb^Xa mod p</span></span><br><span class="line"><span class="keyword">const</span> clientSecret = client.computeSecret(server.getPublicKey());</span><br><span class="line"><span class="comment">// 计算 Kb = Ya^Xb mod p</span></span><br><span class="line"><span class="keyword">const</span> serverSecret = server.computeSecret(client.getPublicKey());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于素数p是动态生成的，所以每次打印都不一样</span></span><br><span class="line"><span class="comment">// 但是 clientSecret === serverSecret</span></span><br><span class="line"><span class="built_in">console</span>.log(clientSecret.toString(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(serverSecret.toString(<span class="string">&#x27;hex&#x27;</span>));</span><br><span class="line"><span class="comment">// 39edfedad4f1be731977436936ca844e50ebc90953ad208c71d7f2dc1772409962ec3eb90eaf99db5948f089e1d4951f148bd7ff76c18b53ff6be32f267fc54535928ce4acf15d923cfd0caec45db95b206e7636128210ea6813a20fb09cbfb06214b2f488716fea32788023d98cb4cb7fe39b68bd3563b3b34257e37f6b7fb7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 39edfedad4f1be731977436936ca844e50ebc90953ad208c71d7f2dc1772409962ec3eb90eaf99db5948f089e1d4951f148bd7ff76c18b53ff6be32f267fc54535928ce4acf15d923cfd0caec45db95b206e7636128210ea6813a20fb09cbfb06214b2f488716fea32788023d98cb4cb7fe39b68bd3563b3b34257e37f6b7fb7</span></span><br></pre></td></tr></table></figure><h2 id="ECDH-Elliptic-Curve-Diffie-Hellma">ECDH(Elliptic Curve Diffie-Hellma)</h2><blockquote><p>ECDH 和 DH 原理类似，都是安全密钥协商协议。</p><p>相对于 DH 协议，结合椭圆曲线密码学 ECC 加速，运算更节省 CPU 资源</p></blockquote><ul><li>ECDH（<strong>Elliptic Curve Diffie-Hellman</strong> ）原理如下</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202230722255.(null)" alt="img"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> G = <span class="string">&#x27;secp521r1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> encoding = <span class="string">&#x27;hex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = crypto.createECDH(G);</span><br><span class="line"><span class="keyword">const</span> serverKey = server.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = crypto.createECDH(G);</span><br><span class="line"><span class="keyword">const</span> clientKey = client.generateKeys();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serverSecret = server.computeSecret(clientKey);</span><br><span class="line"><span class="keyword">const</span> clientSecret = client.computeSecret(serverKey);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(serverSecret.toString(encoding));</span><br><span class="line"><span class="built_in">console</span>.log(clientSecret.toString(encoding));</span><br><span class="line"><span class="comment">// 01c418be1b479f936397d4c1653ad77fa28fade67ff058dc18264a72bd1fc208ea6cac4dad996fda55bf271e84f0faef085173257b67bf21f95b09acee4d0a204517</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 01c418be1b479f936397d4c1653ad77fa28fade67ff058dc18264a72bd1fc208ea6cac4dad996fda55bf271e84f0faef085173257b67bf21f95b09acee4d0a204517</span></span><br></pre></td></tr></table></figure><h2 id="ECDHE-Elliptic-Curve-Diffie-Hellma-Ephemeral">ECDHE(Elliptic Curve Diffie-Hellma Ephemeral)</h2><blockquote><p>普通的 ECDH 算法也存在一定缺陷，比如密钥协商的时候有一方的私钥总是一样的，一般都是 Server 方固定，Client 方私钥随机生成。随着时间的延长，黑客可以截获到海量的密钥协商过程（有些数据是公开的），黑客就可以依据这些数据暴力破解出 Server 的私钥，然后就可以计算出会话密钥了，加密的数据也会随之被破解。固定一方的私钥会有被破解的风险，那么就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个算法就是 ECDH 的增强版：ECDHE， E 全称是 Ephemeral（临时性的）。</p></blockquote><h1>扩展</h1><blockquote><p>学习这块儿知识的同时也学习了很多密码学相关知识，发现越挖越深快陷进去了 😂，感兴趣的同学可以继续展开看看相关加密算法和他们之间的区别以及应用场景，例如：</p></blockquote><ul><li>非对称加密 DSA、RSA、DH、DHE、ECDHE</li><li>对称加密 AES、DES</li></ul><blockquote><p><a href="https://mp.weixin.qq.com/s/U9SRLE7jZTB6lUZ6c8gTKg">RSA 算法原理（二） - 阮一峰的网络日志</a></p><p><a href="https://www.cnblogs.com/xiaolincoding/p/14318338.html">图解 ECDHE 密钥交换算法 - 小林 coding</a></p><p>资料加密标准(DES) - 维基百科](<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96">https://zh.wikipedia.org/wiki/資料加密標準</a>)</p><p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">高级加密标准(AES) - 维基百科</a></p></blockquote><h1><strong>相关术语</strong></h1><p>SPKAC：Signed Public Key and Challenge</p><p>MD5：Message-Digest Algorithm 5，信息-摘要算法。</p><p>SHA：Secure Hash Algorithm，安全散列算法。</p><p>HMAC：Hash-based Message Authentication Code，密钥相关的哈希运算消息认证码。</p><p>对称加密：比如 AES、DES</p><p>非对称加密：比如 RSA、DSA</p><p>AES：Advanced Encryption Standard（高级加密标准），密钥长度可以是 128、192 和 256 位。</p><p>DES：Data Encryption Standard，数据加密标准，对称密钥加密算法（现在认为不安全）。</p><p>DiffieHellman：Diffie–Hellman key exchange，缩写为 D-H，是一种安全协议，让通信双方在预先没有对方信息的情况下，通过不安全通信信道，创建一个密钥。这个密钥可以在后续的通信中，作为对称加密的密钥加密传递的信息。（备注，是使用协议的发明者命名）</p><p><strong>密钥交换算法</strong></p><p>常见的密钥交换算法有 RSA，ECDHE，DH，DHE 等算法。它们的特性如下：</p><ul><li><p>RSA：算法实现简单，诞生于 1977 年，历史悠久，经过了长时间的破解测试，安全性高。缺点就是需要比较大的素数（目前常用的是 2048 位）来保证安全强度，很消耗 CPU 运算资源。RSA 是目前唯一一个既能用于密钥交换又能用于证书签名的算法。</p></li><li><p>DH：diffie-hellman 密钥交换算法，诞生时间比较早（1977 年），但是 1999 年才公开。缺点是比较消耗 CPU 性能。</p></li><li><p>ECDHE：使用椭圆曲线（ECC）的 DH 算法，优点是能用较小的素数（256 位）实现 RSA 相同的安全等级。缺点是算法实现复杂，用于密钥交换的历史不长，没有经过长时间的安全攻击测试。</p></li><li><p>ECDH：不支持 PFS，安全性低，同时无法实现 false start。</p></li><li><p>DHE：不支持 ECC。非常消耗 CPU 资源 。</p></li></ul><p>建议优先支持 RSA 和 ECDH_RSA 密钥交换算法。原因是：</p><ul><li><p>ECDHE 支持 ECC 加速，计算速度更快。支持 PFS，更加安全。支持 false start，用户访问速度更快。</p></li><li><p>目前还有至少 20% 以上的客户端不支持 ECDHE，我们推荐使用 RSA 而不是 DH 或者 DHE，因为 DH 系列算法非常消耗 CPU（相当于要做两次 RSA 计算）。</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端 LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端 LeBron</a></p><p>持续分享技术博文，关注微信公众号 👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node </tag>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 广州行</title>
      <link href="2021/12/11/%E6%91%84%E5%BD%B1-%E5%B9%BF%E5%B7%9E%E8%A1%8C/"/>
      <url>2021/12/11/%E6%91%84%E5%BD%B1-%E5%B9%BF%E5%B7%9E%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：IPhone 13 Pro Max<br>镜头：IPhone 13 Pro Max<br>出镜：无<br>地点：广州</p></blockquote><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9240.JPG" alt="IMG_9240"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9244.JPG" alt="IMG_9244"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9246.JPG" alt="IMG_9246"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9257.JPG" alt="IMG_9257"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9265.JPG" alt="IMG_9265"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9271.JPG" alt="IMG_9271"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9290.JPG" alt="IMG_9290"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9296.JPG" alt="IMG_9296"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9306.JPG" alt="IMG_9306"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9300.JPG" alt="IMG_9300"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_9305.JPG" alt="IMG_9305"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 风光 </tag>
            
            <tag> 广州 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带你重新认识Node</title>
      <link href="2021/12/11/%E5%B8%A6%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Node/"/>
      <url>2021/12/11/%E5%B8%A6%E4%BD%A0%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Node/</url>
      
        <content type="html"><![CDATA[<h1>最初做Node的目的是什么？</h1><blockquote><p>Node作者Ryan Dahl：</p><p>基于V8创建一个轻量级的高性能Web服务器并提供一套库</p></blockquote><h1>为什么是JavaScript？</h1><blockquote><p>Ryan Dahl是一名资深的C/C++程序员，创造出Node之前主要工作是围绕Web高性能服务器进行的</p><p>他发现Web高性能服务器的两个要点：</p></blockquote><ul><li>事件驱动</li><li>非阻塞I / O</li></ul><p>Ryan Dahl也曾评估过使用C、Lua、Haskell、Ruby等语言作为备选实现，得出以下结论：</p><ul><li>C的开发门槛高，可以预见不会有太多的开发者能将它用于业务开发</li><li>Ryan Dahl觉得自己还不足够玩转Haskell，所以舍弃它</li><li>Lua自身已经含有很多阻塞 I / O 库，为其构建非阻塞 I / O 库不能改变开发者使用习惯</li><li>Ruby的虚拟机性能不佳</li></ul><p>JavaScript的优势：</p><ul><li>开发门槛低</li><li>在后端领域没有历史包袱</li><li>第二次浏览器大战渐渐分出高下，Chrome浏览器的JavaScript引擎V8摘得性能第一的桂冠</li></ul><h1>Node给JavaScript带来的意义</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225039105.(null)" alt="img"></p><blockquote><p>除了HTML、Webkit和显卡这些UI相关技术没有支持外，Node的结构与Chrome十分相似。他们都是基于事件驱动的异步架构：</p></blockquote><ul><li>浏览器通过事件驱动来服务界面上的交互</li><li>Node通过事件驱动来服务 I / O</li></ul><blockquote><p>在Node中，JavaScript还被赋予了新的能力：</p></blockquote><ul><li>随心所欲地访问本地文件</li><li>搭建WebSocket服务端</li><li>连接数据库，进行业务研发</li><li>像Web Worker一样玩转多进程</li></ul><blockquote><p>Node使JavaScript可以运行在不同的地方，不再限制在浏览器中、DOM树打交道。如果HTTP协议是水平面，Node就是浏览器在协议栈另一边的倒影。</p><p>Node不处理UI，但用与浏览器相同的机制和原理运行，打破了JavaScript只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低前后端转换所需要的上下文代价。</p></blockquote><h1>Node的特点</h1><h2 id="异步I-O">异步I / O</h2><ul><li>以读取文件为例</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225046783.(null)" alt="img"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>); </span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;/path&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件完成&#x27;</span>) </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;发起读取文件&#x27;</span>); </span><br></pre></td></tr></table></figure><blockquote><p>熟悉的用户必知道，“读取文件完成”是在“发起读取文件”之后输出的</p><p>fs.readFile后的代码是被立即执行的，而“读取文件完成”的执行时间是不被预期的</p><p>只知道它将在这个异步操作后执行，但并不知道具体的时间点</p><p>异步调用中对于结果值的捕获是符合“Don’t call me, I will call you”原则的</p><p>这也是注重结果，不关心过程的一种表现</p></blockquote><p>Node中，绝大多数操作都以异步的方式进行调用，Ryan Dahl排除万难，在底层构建了很多异步I / O的API，从文件读取到网络请求等。使开发者很已从语言层面很自然地进行并行I / O操作，在每个调用之间无需等待之前的I / O调用结束，在编程模型上可以极大提升效率</p><blockquote><p><strong>注：异步I / O机制将在下文中详细阐述</strong></p></blockquote><h2 id="事件与回调函数">事件与回调函数</h2><p><strong>事件</strong></p><p>随着Web2.0的到来，JavaScript在前端担任了更多的职责，时间也得到了广泛的应用。将前端浏览器中广泛应用且成熟的事件与回到函数引入后端，配合异步I / O ，可以很好地将事件发生的时间点暴露给业务逻辑。</p><ul><li>服务端例子</li></ul><blockquote><p>对于服务器绑定了request事件</p></blockquote><blockquote><p>对于请求对象，绑定了data和end事件</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>); </span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 侦听服务器的request事件 </span></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"> req.setEncoding(<span class="string">&#x27;utf8&#x27;</span>); </span><br><span class="line"> <span class="comment">// 侦听请求的data事件 </span></span><br><span class="line"> req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>) </span>&#123;</span><br><span class="line"> postData += trunk;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 侦听请求的end事件</span></span><br><span class="line"> req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line"> res.end(postData); </span><br><span class="line"> &#125;); </span><br><span class="line">&#125;).listen(<span class="number">8080</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;服务器启动完成&#x27;</span>); </span><br></pre></td></tr></table></figure><ul><li>前端例子</li></ul><blockquote><p>发出请求后，只需关心请求成功时执行相应的业务逻辑即可</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request(&#123; </span><br><span class="line"> url: <span class="string">&#x27;/url&#x27;</span>, </span><br><span class="line"> method: <span class="string">&#x27;POST&#x27;</span>, </span><br><span class="line"> data: &#123;&#125;, </span><br><span class="line"> success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; </span><br><span class="line"> <span class="comment">// success事件 </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><blockquote><p>事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是一个问题，后续也出现了一系列异步编程解决方案:</p></blockquote><ul><li>事件发布/订阅模式</li><li>Promise、async / await</li><li>流程控制库</li></ul><p><strong>回调函数</strong></p><ul><li>Node除了异步和事件外，回调函数也是一大特色</li><li>纵观下来，回调函数也是最好的接收异步调用返回数据的方式<ul><li>但是这种编程方式对于很多习惯同步思路编程的人来说，也许是十分不习惯的</li><li>代码的编写顺序与执行顺序并无关系，这对他们可能造成阅读上的障碍</li></ul></li><li>在流程控制方面，因为穿插了异步方法和回调函数，与常规的同步方式相比变得不那么一目了然了<ul><li>转变为异步编程思维后，通过对业务的划分和对事件的提炼，在流程控制方面处理业务的复杂度是与同步方式实际上是一致的</li></ul></li></ul><h2 id="单线程">单线程</h2><blockquote><p>Node保持了JavaScript在浏览器中单线程的特点</p><p>JavaScript与其他线程是无法共享任何状态的，最大的好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销</p></blockquote><ul><li>单线程的缺点<ul><li>无法利用多核CPU</li><li>错误会引起整个应用退出，健壮性较差</li><li>大量计算占用CPU导致无法继续调用异步I / O</li></ul></li><li>后续也推出了child_process和cluster模块较好地缓解了以上缺点</li></ul><h2 id="跨平台">跨平台</h2><blockquote><p>起初Node只能在Linux平台上运行，如果想在Windows平台上学习和使用Node，则必须通过Cygwin / MinGW，后微软投入通过基于libuv实现跨平台架构</p></blockquote><ul><li>libuv</li></ul><blockquote><p>在操作系统与Node上层模块系统之间构建了一层平台架构</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225633500.(null)" alt="img"></p><blockquote><p>通过良好的架构，Node的第三方C++模块也可以借助libuv实现跨平台</p></blockquote><h1>Node模块机制 - CommonJS</h1><blockquote><p>背景：</p><p>在其他高级语言中，Java有类文件，Python有import机制，Ruby有require，PHP有include和require。而JavaScript通过script标签引入代码的方式显得杂乱无章，。人们不得不用命名空间等方式人为地约束代码，以达到安全和易用的目的。</p><p>直到后来出现了CommonJS…</p></blockquote><h2 id="愿景">愿景</h2><blockquote><p>希望JavaScript能欧在任何地方运行</p></blockquote><h2 id="出发点">出发点</h2><p>对于JavaScript自身而言，它的规范依然是薄弱的，还有以下缺陷：</p><ul><li>没有模块系统</li><li>标准库较少<ul><li>ECMAScript仅定义了部分核心库</li><li>对于文件系统 I / O流等常见需求没有标准API</li></ul></li><li>没有标准接口<ul><li>在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口</li></ul></li><li>缺乏包管理系统<ul><li>导致JavaScript应用中基本没有自动加载和安装以来的能力</li></ul></li></ul><p>CommonJS的提出，主要是为了弥补当前JavaScript没有标准的缺陷，以达到像Python、Ruby和Java具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段，希望可以利用JavaScript开发：</p><ul><li>服务端JavaScript程序</li><li>命令行工具</li><li>桌面图形界面应用程序</li><li>混合应用</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225637966.(null)" alt="img"></p><p>CommonJS规范涵盖了：</p><ul><li>模块</li><li>二进制</li><li>Buffer</li><li>字符集编码</li><li>I / O流</li><li>进程环境</li><li>文件系统</li><li>套接字</li><li>单元测试</li><li>Web服务器网关接口</li><li>包管理</li></ul><blockquote><p>Node与浏览器以及W3C组织、CommonJS组织、ECMAScript之间的关系，共同构成了一个繁荣的生态系统</p></blockquote><h2 id="模块规范">模块规范</h2><ul><li>模块定义</li></ul><blockquote><p>上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是导出的唯一出口</p><p>在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性</p><p>在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="built_in">exports</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模块引用</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = math.add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><p>在CommonJS规范中，存在require方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中</p></blockquote><ul><li>模块标识</li></ul><p>模块标识就是传递给require方法的参数，可以是：</p><ul><li>如何小驼峰命名的字符串</li><li>以./ 、…/ 开头的相对路径 or 绝对路径</li><li>可以没有文件名后缀.js</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225641404.(null)" alt="img"></p><blockquote><p>模块的定义十分简单，接口也十分简洁</p></blockquote><blockquote><p>每个模块具有独立的空间，它们互不干扰，在引用时也显得干净利落</p></blockquote><ul><li>意义：</li></ul><blockquote><p>将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖</p></blockquote><h2 id="模块实现">模块实现</h2><blockquote><p>在Node引入模块，需要经历以下三个步骤</p></blockquote><ul><li>路径分析</li><li>文件定位</li><li>编译执行</li></ul><p>Node中模块分为两类：</p><ul><li>核心模块</li></ul><blockquote><p>编译过程中，编译进了二进制执行文件</p><p>在Node进程启动时，部分核心模块就直接被加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略，并且在路径分析中优先判断，所以它的加载速度是最快的。</p></blockquote><ul><li>用户编写的文件模块</li></ul><blockquote><p>运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢</p></blockquote><h3 id="优先从缓存加载">优先从缓存加载</h3><blockquote><p>与浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行二次缓存，以减少二次引入时的开销。不同点在于:</p></blockquote><ul><li>浏览器仅缓存文件</li><li>Node缓存的是编译和执行之后的对象</li></ul><blockquote><p>无论核心模块还是文件模块，require方法对相同模块的二次加载都一律采用缓存优先的方式</p></blockquote><h3 id="路径分析和文件定位">路径分析和文件定位</h3><p><strong>标识符分析（路径）</strong></p><p>前面说到过，require方法接受一个参数作为标识符，分为以下几类：</p><ul><li>核心模块</li></ul><blockquote><p>优先级仅次于缓存加载，在Node的源代码编译过程中已编译为二进制代码，加载过程最快</p><p><strong>注：加载一个与核心模块标识符相同的自定义模块是不会成功的，只能通过选择不同的标识符 / 换用路径的方式实现</strong></p></blockquote><ul><li>路径形式的文件模块</li></ul><blockquote><p>以 ./ 、…/ 开头的标识符都被当做文件模块处理</p><p>require方法会将路径转为真实路径，并以真实路径为索引，将编译执行后的结果存放到缓存中，以使二次加载更快</p><p>文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度仅慢于核心模块</p></blockquote><ul><li>自定义模块</li></ul><blockquote><p>是一种特殊的文件模块，是一个文件或者包的形式</p><p>这类模块的查找是最费时的，也是最慢的一种</p></blockquote><p>先介绍一下模块路径这个概念，也是定位文件模块时制定的查找策略，具体表现为一个路径组成的数组</p><ul><li><code>console.log(module.path)</code></li><li>你可以得到一个路径数组</li></ul><p>[‘/home/bytedance/reasearch/node_modules’,</p><p>‘/home/bytedance/node_modules’,</p><p>‘home/node_module’, /node_modules’]</p><p>可以看出规则如下：</p><ul><li>当前文件目录下的node_modules目录</li><li>父目录下的node_modules目录</li><li>父目录的父目录下的node_modules目录</li><li>沿路径向上逐级递归，直到根目录下的node_modules目录</li></ul><blockquote><p>它的生成方式与JavaScript原型链 / 作用域链的查找方式十分类似</p><p>在加载过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件</p><p>文件路径越深，模块查找耗时会越多，这是自定义模块的加载速度最慢的原因</p></blockquote><p><strong>文件定位</strong></p><ul><li>文件扩展名分析</li></ul><blockquote><p>require分析标识符会出现不包含文件扩展名的情况</p><p>会按.js、.json、.node的次序补足扩展名，一次尝试</p><p>过程中，需调用fs模块同步阻塞地判断文件是否存在，Node单线程因此会引起性能问题</p><p>如果是.node / .json文件带上扩展名能加快点速度，配合缓存机制，可大幅缓解Node单线程阻塞调用的缺陷</p></blockquote><ul><li>目录分析和包</li></ul><blockquote><p>分析标识符的过程中可能没有找到文件，却得到一个目录，则会将目录当做一个包来处理</p><p>通过解析package.json文件对应该包的main属性指定的文件名</p><p>如果main相应文件解析错误 / 没有package.json文件，node会将index作为文件名</p><p>一次查找index.js  index.json  index.node</p><p>该目录没有定位成功则进行下一个模块路径进行查找</p><p>直到模块路径数组都被遍历完依然没有查找到目标文件则抛出异常</p></blockquote><h3 id="模块编译">模块编译</h3><blockquote><p>在Node中，每个文件模块都是一个对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123; </span><br><span class="line"> <span class="built_in">this</span>.id = id; </span><br><span class="line"> <span class="built_in">this</span>.exports = &#123;&#125;; </span><br><span class="line"> <span class="built_in">this</span>.parent = parent; </span><br><span class="line"> <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123; </span><br><span class="line">     parent.children.push(<span class="built_in">this</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">this</span>.filename = <span class="literal">null</span>; </span><br><span class="line"> <span class="built_in">this</span>.loaded = <span class="literal">false</span>; </span><br><span class="line"> <span class="built_in">this</span>.children = []; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>js文件<ul><li>通过fs模块同步读取文件后编译执行</li></ul></li><li>node文件<ul><li>这是用C/C++编写的扩展文件，通过dlopen方法加在最后编译生成的文件</li></ul></li><li>json文件<ul><li>通过fs模块同步读取文件后，JSON.parse解析返回的结果</li></ul></li><li>其他<ul><li>都被当作js文件载入</li></ul></li></ul><blockquote><p>每一个编译成功的模块都会将其文件路径作为索引存在Module.cache对象上，以提高二次引入的性能</p></blockquote><h1>包与NPM</h1><blockquote><p>Node组织了自身核心模块，也使得第三方文件模块可以有序地编写和使用</p><p>但是在第三方模块中，模块与模块之间仍然是散列在各地的，相互之间不能直接引用</p><p>而在模块之外，包和 NPM 则是将模块联系起来的一种机制</p><p>一定程度上解决了变量依赖、依赖关系等代码组织性问题</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225646448.(null)" alt="img"></p><h2 id="包结构">包结构</h2><blockquote><p>包实际上是一个存档文件，即一个目录直接打包为一个.zip/tar.gz格式的文件，安装后解压还原为目录</p></blockquote><ul><li>符合CommonJS规范的包目录应该包含如下文件<ul><li>package.json 包描述文件</li><li>bin 用于存放可执行二进制文件</li><li>lib 用于存放JavaScript代码的目录</li><li>doc 用于存放文档的目录</li><li>test 用于存放单元测试用例的代码</li></ul></li></ul><h2 id="包描述文件">包描述文件</h2><blockquote><p>package.json</p></blockquote><p>CommonJS为package.json定义了如下一些必须的字段</p><ul><li>name 包名</li><li>description 包简介</li><li>version 版本号</li><li>keywords 关键词数组，用于做npm搜索</li><li>maintainers 包维护者列表</li><li>contributors 贡献者列表</li><li>bugs 一个可以反馈bug的网页地址 / 邮件地址</li><li>licenses 许可证列表</li><li>repositories 托管源代码的位置列表</li><li>dependencies 使用当前包所需要依赖的包</li><li>homepage 当前包的网站地址</li><li>os 操作系统支持列表<ul><li>aix、freebsd、linux、macos、solaris、vxworks、windows</li></ul></li><li>cpu CPU架构的支持列表<ul><li>arm、mips、ppc、sparc、x86、x86_64</li></ul></li><li>builtin 标志当前包是否是内建在底层系统的标准组件</li><li>implements 实现规范的列表</li><li>scripts 脚本说明对象</li></ul><blockquote><p>包规范的定义可以帮助Node解决依赖包安装的问题，而NPM正是基于该规范进行了实现</p></blockquote><h2 id="NPM-常用功能">NPM 常用功能</h2><blockquote><p>CommonJS包规范是理论，NPM是其中一种实践</p><p>NPM于Node，相当于gem于Ruby，pear于PHP</p><p>帮助完成了第三方模块的发布、安装和依赖等</p></blockquote><ol><li>查看帮助</li></ol><ul><li>查看版本 <code>npm -v</code></li><li>查看命令 <code>npm</code></li></ul><ol start="2"><li>安装依赖包</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &#123;packageName&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行该命令后，NPM会在当前目录下创建node_modules目录下创建包目录，接着将相应的包解压到这个目录下</p></blockquote><ul><li>全局安装模式</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &#123;packageName&#125; -g</span><br></pre></td></tr></table></figure><blockquote><p>全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任何地方reuqire它</p><p>全局模式这个成为并不精确，-g 实际上是将一个包安装为全局可用的执行命令</p><p>它根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同的路径下</p></blockquote><ul><li>从本地安装</li></ul><blockquote><p>对于一些没有发布到NPM上的包，或者因为网络原因无法直接安装的包</p><p>可以通过将包下按在到本地，然后本地安装</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &lt;tarball file&gt;</span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install folder&gt;</span><br></pre></td></tr></table></figure><ul><li>从非官方源安装</li></ul><blockquote><p>如果不能通过官方源安装，可以通过镜像源安装</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --registry=&#123;urlResource&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果使用过程中几乎全使用镜像源，可以指定默认源</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry &#123;urlResource&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>NPM 钩子命令</li></ol><blockquote><p>package.json中scripts字段的提出就是让包在安装或者卸载等过程中提供钩子机制</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;preinstall&quot;</span>: <span class="string">&quot;preinstall.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;install&quot;</span>: <span class="string">&quot;install.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uninstall&quot;</span>: <span class="string">&quot;uninstall.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;test.js&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Install<ul><li>在以上字段执行<code>npm install &lt;package&gt;</code>时，preinstall指向的脚本会被加载执行，然后install指向的脚本会被执行</li></ul></li><li>Uninstall<ul><li>执行<code>npm uninstall &lt;package&gt;</code>时，uninstall指向的脚本也许会做一些清理工作</li></ul></li><li>Test<ul><li>执行<code>npm test</code>将会运行test指向的脚本，一个优秀的包应当包含测试用例，并在package.json文件正配置好运行测试的命令，方便用户运行测试用例，以便检验包是否稳定可靠</li></ul></li></ul><h2 id="局域-NPM">局域 NPM</h2><ul><li>背景</li></ul><p>企业的限制在于，一方面需要享受到模块开发带来的低耦合和项目组织上的好处，另一方面却要考虑模块保密性的问题。所以，通过NPM共享和发布存在潜在的风险。</p><ul><li>解决方案</li></ul><p>为了同时能够享受到NPM上众多的包，同时对自己的包进行保密和限制，现有的解决方案就是企业搭建自己的NPM仓库，NPM无论是它的服务端和客户端都是开源的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225651308.(null)" alt="img"></p><blockquote><p>局域NPM仓库的搭建方法与搭建镜像站的方式几乎一样，与镜像仓库不同的地方在于可以选择不同步官方源仓库中的包</p></blockquote><ul><li>作用<ul><li>私有的可重用模块可以打包到局域NPM仓库中，这样可以保持更新的中心化，不至于让各个小项目维护相同功能的模块</li><li>杜绝通过复制粘贴实现代码共享的行为</li></ul></li></ul><h1>异步I / O</h1><h2 id="为什么需要异步-I-O-？">为什么需要异步 I / O ？</h2><ul><li>用户体验</li></ul><blockquote><p>浏览器中JavaScript在单线程上执行，还和UI渲染共用一个线程</p><p>《高性能JavaScript》曾总结过，如果脚本执行的时间超过100ms用户就会感到页面卡顿</p><p>如果网页临时需要获取一个网络资源，通过同步的方式获取，JS需要等资源完全从服务器获取后才能继续执行，这期间UI将停顿，不响应用户的交互行为。可以想象，这样的用户体验将会多差。</p><p>而采用异步请求，JavaScript和UI的执行都不会处于等待状态，给用户一个鲜活的页面</p><p>I / O是昂贵的，分布式I / O 是更昂贵的</p><p>只有后端能够快速响应资源，才能让前端体验变好</p></blockquote><ul><li>资源分配</li></ul><blockquote><p>计算机在发展过程中将组件进行了抽象，分为了I / O设备和计算设备</p><p>假设业务场景有一组互不相关的任务需要完成，主流方法有两种：</p></blockquote><ol><li>多线程并行完成</li></ol><p>多线程的代价在于创建线程和执行线程上下文切换的开销较大。</p><p>在复杂的业务中经常面临锁、状态同步等问题。但是多线程在多核CPU上能够有效提升CPU利用率</p><ol start="2"><li>单线程串行依次执行</li></ol><p>单线程顺序执行任务比较符合编程人员按顺序思考的思维方式，依然是主流的编程方式</p><p>串行执行的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞</p><p>在计算机资源中，通常I / O与CPU计算是可以并行的，同步编程模型导致的问题是，I / O的进行会让后续任务等待，这造成资源不能更好地被利用</p><ol start="3"><li>Node在两者之间给出了它的答案</li></ol><blockquote><p>利用单线程，远离多线程死锁、状态同步等问题；</p><p>利用异步I / O，让单线程可以远离阻塞，更好地使用CPU</p><p>为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I / O</p><p>异步I / O的提出是期望I / O的调用不再阻塞后续运算，将原有等待I / O完成的这段时间分配给其余需要的业务去执行</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225655015.(null)" alt="img"></p><h2 id="异步I-O现状">异步I / O现状</h2><h3 id="异步I-O与非阻塞I-O">异步I / O与非阻塞I / O</h3><blockquote><p>操作系统内核对于I / O方式只有两种：阻塞与非阻塞</p><p>在调用阻塞I / O时，应用程序需要等待I / O完成才返回结果</p><p>特点：调用之后一定要等到系统内核层面完成所有操作后调用才结束</p><p>例子：系统内核在完成磁盘寻道、读取数据、复制数据到内幕才能中之后，这个调用才结束》</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202224957133.(null)" alt="img"></p><blockquote><p>非阻塞I / O与阻塞I / O的差别为调用之后会立即返回</p><p>非阻塞I / O返回之后，CPU的时间片可以用来处理其他事务，此时的性能提升是明显的</p><p>存在的问题：</p></blockquote><ul><li>由于完整的I / O没有完成，立即返回的并不是业务层期望的数据而仅仅是当前调用的状态</li><li>为了获取完整的数据，应用程序需要重复调用I / O操作来确认是否完成，称之为“轮询”。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225703091.(null)" alt="img"></p><h3 id="主要的轮询技术">主要的轮询技术</h3><ul><li>read</li></ul><blockquote><p>它是最原始、性能最低的一种，通过重复调用检查I / O的状态来完成数据的完整读取</p><p>在得到最终数据前，CPU一直耗用在等待上</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225706724.(null)" alt="img"></p><ul><li>select</li></ul><blockquote><p>它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断</p><p>限制：它采用一个1024长度的数组来存储状态，最多可以同时检查1024个文件描述符</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225711576.(null)" alt="img"></p><ul><li>poll</li></ul><blockquote><p>较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查</p><p>文件描述符较多时，它的性能还是十分低下的</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225714602.(null)" alt="img"></p><ul><li>epoll</li></ul><blockquote><p>该方案是Linux下效率最高的I / O事件通知机制，在进入轮询的时候如果没有检查到I / O事件，将会进行休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225718042.(null)" alt="img"></p><h3 id="理想的非阻塞异步I-O">理想的非阻塞异步I / O</h3><blockquote><p>尽管epoll已经利用了时间来降低CPU的耗用，但是休眠期间CPU几乎是限制的，对于当前线程而言利用率不够</p></blockquote><p>完美的异步I / O应该是应用程序发起非阻塞调用，无需通过遍历或者时间唤醒等方式轮询</p><p>可以直接处理下一个任务，只需在I / O完成后通过信号或回调将数据传递给应用程序即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225721234.(null)" alt="img"></p><p>Linux下存在原生提供的一种异步I / O方式（AIO）就是通过信号或者回调来传递数据的</p><p>缺点：</p><ul><li>仅Linux下有</li><li>仅支持I / O中的O_DIRECT方式读取，导致无法利用系统缓存</li></ul><blockquote><p>注：<a href="https://blog.csdn.net/AXW2013/article/details/70242228">关于O_DIRECT</a></p></blockquote><h3 id="现实的异步I-O">现实的异步I / O</h3><blockquote><p>通过让部分线程进行阻塞I / O或者非阻塞I / O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I / O得到的数据进行传递，这就轻松实现了异步I / O（尽管它是模拟的</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225724648.(null)" alt="img"></p><ul><li>libeio实质上是采用线程池与阻塞I / O模拟异步I / O</li><li>Node最初在*nix平台下采用libeio配合libev实现异步I / O，后通过自行实现线程池完成</li><li>Windows下的IOCP<ul><li>调用异步方法，等待I / O完成之后的通知，执行回调，用户无需考虑轮询</li><li>内部其实仍是线程池的原理，不同之处在于这些线程池由系统内核接手管理</li><li>与Node异步调用模型十分近似</li></ul></li><li>由于Windows平台和*nix平台的差异，Node提供了libuv作为抽象封装层，做兼容性判断<ul><li>保证上层Node与下层的自定义线程池和IOCP各自独立</li></ul></li><li>我们时常提到Node是单线程的<ul><li>这里的单线程仅仅只是JavaScript执行在单线程中罢了</li><li>无论是*nix还是Windows平台，内部完成I / O任务的另有线程池</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225728300.(null)" alt="img"></p><h2 id="Node的异步I-O">Node的异步I / O</h2><blockquote><p>Node完成整个异步I / O环节的有事件循环、观察者和请求对象等</p></blockquote><h3 id="事件循环">事件循环</h3><blockquote><p>着重强调一下Node自身的执行模型——事件循环</p></blockquote><p>Node进程启动时，会创建一个类似while(true)的循环</p><p>每次循环体的过程称之为Tick，每个Tick的过程就是查看是否有事件待处理</p><p>如果有就取出事件及其相关的回调函数，并执行它们</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225732500.(null)" alt="img"></p><h3 id="观察者">观察者</h3><blockquote><p>每个事件循环中有一个或多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件</p></blockquote><ul><li>浏览器采用了类似的机制<ul><li>事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者</li></ul></li><li>Node中事件主要来源于网络请求、文件I / O等<ul><li>这些时间对应的观察者有文件I / O观察者、网络I / O观察者等，将事件进行了分类</li></ul></li><li>事件循环是一个典型的生产者 / 消费者模型<ul><li>异步I / O、网络请求等则是事件的生产者</li><li>这些事件被传递到对应的观察者，事件循环则从观察者那取出事件并处理</li></ul></li></ul><h3 id="小结">小结</h3><blockquote><p>事件循环、观察者、请求对象、I / O线程池这四者共同构成了NOde异步I / O模型的基本要素</p></blockquote><p>由于我们知道JavaScipt是单线程的，所以按尝试很容易理解它不能充分利用多核CPU</p><p>事实上在Node中，除了JavaScript是单线程外，Node自身其实是多喜爱昵称的，只是I / O线程使用的CPU较少</p><p>另一个需要注意的点是，除了用户代码无法并行执行以外，所有的I / O是可以并行执行的</p><blockquote><p>注：图为Node整个异步I / O过程</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20211202225736774.(null)" alt="img"></p><h1>事件驱动与高性能服务器</h1><blockquote><p>前面对异步的讲解，也基本勾勒出了事件驱动的实质，即通过主循环加事件触发的方式来运行程序</p></blockquote><p>下面为几种经典的服务器模型：</p><ul><li>同步式<ul><li>一次只能处理一个请求，并且其余请求都处于等待状态</li></ul></li><li>进程 / 请求<ul><li>这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多</li></ul></li><li>线程 / 请求<ul><li>尽管线程比进程要清凉，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢</li><li>比进程 / 请求要好，但对于大型站点而言依然不够</li></ul></li><li>总结<ul><li>线程 / 请求的方式目前还被Apache所采用</li><li>Node通过事件驱动的方式处理请求，无需为每一个请求创建额外的线程，可以省掉创建线程和销毁线程的开销</li><li>同时操作系统在调度任务时因为线程较少，上下文的代价很低<ul><li>这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受上下文切换开销的影响，这也是Node高性能的一个原因</li></ul></li></ul></li></ul><blockquote><p>事件驱动带来的高效已经渐渐开始为业界所重视</p><p>知名服务器Nginx也摒弃了多线程的方式，采用和Node相同的事件驱动</p><p>不同之处在于Nginx采用纯C写成，性能较高，但是它仅适合于做Web服务器，用于反向代理或者负载均衡服务，在业务处理方面较为欠缺</p><p>Node则是一套高性能平台，可以利用它构建与Nginx相同的功能，也可以处理各种具体业务</p><p>Node没有Nginx在Web服务器方面那么专业，但场景更大，自身性能也不错</p><p>在实际项目中可以结合它们各自的优点以达到应用的最优性能</p><p>JavaScript在服务器端近乎空白，使得Node没有任何历史包袱，而Node在性能优化上的表现使得它一下子就在社区中流行了起来~</p></blockquote><h1>写在最后</h1><p>本文介绍了Node被创造的目的、语言选型、特点、模块机制、包管理机制以及异步I / O等相关知识，希望能让你对Node有一个新的认识。最近一直也在计划学习Node和服务端相关知识，感兴趣的同学可以一起学习和交流~</p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node </tag>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[面经分享] 收获多家大厂offer | 分享我的2022秋招经历</title>
      <link href="2021/11/02/%E7%A7%8B%E6%8B%9B%E5%88%86%E4%BA%AB/"/>
      <url>2021/11/02/%E7%A7%8B%E6%8B%9B%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>好久不见，我是LeBron，有段时间没写博客了。最近几个月的大部分精力都放在秋招上了，边实习边秋招还是挺吃力的，总算结果还是不错。</p><p>先介绍一下个人情况：2022届双非本科应届生，项目经验和经历还算丰富，在字节实习至今也快8个月了，详细情况可以来我的博客看看哈 : <a href="https://www.lebronchao.com/about/">LeBronChao’s Blog</a></p><p>秋招从7.19 ~ 10.24历时三个多月，腾讯、阿里、字节、百度、大疆、华为、Shopee、滴滴、美团、拼多多10家公司，将近40场笔试 / 面试（自我介绍都快念麻了)，基本全部通过收到offer，借此机会做个总结和大家分享一下面经。</p><h1>面试前的准备</h1><h2 id="简历">简历</h2><blockquote><p>可以参考<a href="https://juejin.cn/post/6952679000422498318">前端 Offer 提速：如何写出有亮点的简历</a></p><p>这个其实不用讲太多了，尽量地写出亮点，比如</p></blockquote><ul><li>开源项目经验</li><li>实习经历 &amp; 重点产出</li><li>技术深度展现 / 知名开源框架PR</li><li>技术热情 / 影响力</li><li>知识产权 / 论文</li><li>校园项目经验 / 亮点经历</li><li>等等…</li><li>重点：Word格式容易出问题 尽量用PDF格式</li></ul><h2 id="相应岗位知识">相应岗位知识</h2><blockquote><p>这个其实靠平时积累会比较多一点，面试前可以通过面经做个自测，我面试的大部分是前端岗位主要分为以下几个方面</p></blockquote><ul><li><p>计算机网络</p><ul><li>TCP / UDP</li><li>HTTP / HTTPS / WebSocket</li><li>LB / CDN / DNS / IP</li><li>网络安全</li><li>…</li></ul></li><li><p>操作系统</p></li><li><p>开发技能 &amp; 原理</p><ul><li>HTML / CSS(LESS) / JS / TS</li><li>Vue、React、Node、Webpack等</li><li>浏览器 / 小程序 / 跨端</li><li>性能优化 / 安全策略</li><li>这个根据自己的实际情况来定，<strong>不熟悉的不要写到简历里</strong></li></ul></li><li><p>算法题 / 智力题</p><ul><li><p>系统学习数据结构和算法</p></li><li><p>然后就是刷题了，Hot100和常见题刷起来吧，主要刷easy和middle，hard没必要</p></li><li><p>培养举一反三的能力</p></li><li><p>题库</p><ul><li><a href="https://leetcode-cn.com/">力扣</a></li><li><a href="https://codetop.cc/home">CodeTop企业题库</a></li></ul></li></ul></li><li><p>相应的技术广度扩展和深度探索</p></li><li><p>新的技术动态关注程度，比如</p><ul><li>ES新特性</li><li>Vue3的更新和对比</li><li>字节的Modern.js</li><li>阿里的Kraken</li><li>…</li></ul></li><li><p>提前想好常见问题的答案和对面试的公司做初步的了解，比如</p><ul><li>你的项目有什么亮点和难点</li><li>你会从哪些角度去考虑选择毕业后的第一家公司</li><li>你觉得XXX是一家怎么样的公司</li><li>你有什么优点和缺点</li><li>为什么想做全栈工程师</li><li>你的职业规划是怎么样的</li><li>…</li></ul></li></ul><blockquote><p>感兴趣的话可以看看这篇文章：<a href="https://juejin.cn/post/6953116014678638629">[建议收藏] 初中级前端应该掌握的基础知识</a></p><p>我的公众号、博客里也有挺多相关知识的讲解，感兴趣可以看看：<a href="">前端LeBron</a></p><p>欢迎关注我的微信公众号：</p><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62cfe8552fa3405b9370000ec256ef8a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p></blockquote><h2 id="自我介绍">自我介绍</h2><p>你和面试官一般都是初次见面，他只能通过你的简历和自我介绍来了解你。<strong>所以说不是特别熟悉的东西不要写到简历里，自我介绍也不要说</strong>。面试官一般也基本不会逐字逐句地看你的简历，可能没法发现你的亮点，自我介绍这不是把机会给你了吗（开始装逼哈哈哈。自我介绍可以由你的基本信息、项目经验、技术亮点和解决哪些比较复杂的问题、个人经历的亮点和未来的规划简述组成。也可以尝试引导面试官问你问题，一般面试官都会从简历 / 自我介绍中开始发问。自我介绍要简明干练，一般1min左右就好了。</p><h1>总结</h1><p>三个多月的秋招生活告一段落，最终选择了留在字节工作。新时期的工作带来了新的挑战，没有躺赢的命那就站起来奔跑吧！努力是会有结果的！</p><p>我是一个即将毕业的22届双非本科应届生，在字节游戏中台做前端开发工作。希望我的秋招面试经验可以给予正在找工作的你一点帮助，特别是正在奋战秋招/实习的同学、学弟和学妹们。字节游戏中台前端部门求贤若渴，持续招人中。感兴趣的同学可以通过内推链接投递，有问题也可以加微信沟通。Vx:LeBronChao-</p><p>游戏中台内推：</p><ul><li><p>深圳</p><ul><li>社招：<a href="https://job.toutiao.com/s/R6gm31s">前端开发（高级）工程师-游戏中台</a></li><li>校招 &amp; 实习：<a href="https://job.toutiao.com/s/R6gBGHA">前端开发实习生 — 有转正机会</a></li></ul></li><li><p>上海</p><ul><li>社招：<a href="https://job.toutiao.com/s/R6gVo9r">前端开发（高级）工程师-游戏中台</a></li><li>校招 &amp; 实习：<a href="https://job.toutiao.com/s/R6gmupU">前端开发实习生-独立闭环业务（可转正）</a></li></ul></li><li><p>【社招总内推链接】</p><ul><li><a href="https://job.toutiao.com/s/R6qQccL">https://job.toutiao.com/s/R6qQccL</a></li></ul></li><li><p>【内推码】</p><ul><li>4FCV6BV</li></ul></li><li><p>【我的邮箱】</p><ul><li><a href="mailto:chaoweiwen@bytedance.com">chaoweiwen@bytedance.com</a></li></ul></li></ul><h1>废话不多说，直接上面经↓</h1><h1>字节</h1><h2 id="10-9-实习转正答辩-通过">10.9 实习转正答辩 通过</h2><h1>腾讯</h1><h2 id="8-17-WXG游戏一面-60min-通过">8.17 WXG游戏一面 60min 通过</h2><ol start="0"><li>实习工作主要负责什么</li><li>小程序开发中遇到过什么问题？怎么解决的</li><li>实习项目的难点、亮点</li><li>字节小程序和微信小程序有什么区别</li><li>Uni-app框架做了什么工作、处理？</li><li>用Uni-app开发的过程中遇到过什么问题？怎么解决的？</li><li>从输入网址到整个渲染过程描述</li><li>除了HTTP缓存还有什么缓存方式？</li><li>HTTP缓存、localstorge、sessionstorge、cookie、indexDB这些方式实现缓存有什么区别、特点</li><li>做过CDN相关的工作吗？</li><li>CDN有什么好处呢？</li><li>聊参与的开源项目技术栈、云开发</li><li>进程和线程的区别？</li><li>进程间通信方式有哪些？</li><li>有用过Mysql？讲解一下什么是事务？</li><li>二叉树有哪些遍历方式？哪些属于DFS?</li><li>有用过预处理器吗？有什么特点？</li><li>有考虑过多主题样式吗？怎么实现？</li><li>Node用过吗？用过哪些相关框架？做过哪些东西？</li><li>手撕jsonStringfy</li><li>实现JSON.parse的思路？除了eval和new Function（AST、编译原理）</li><li>跨端方式有哪几种解决方案？</li></ol><h2 id="8-18-WXG游戏二面-40min-通过">8.18 WXG游戏二面 40min 通过</h2><ol start="0"><li>为什么选择做前端？</li><li>前端和其他方向相比，比如机器学习，有什么区别和特点</li><li>怎么样才算前端做得比较好？</li><li>有做过性能优化吗？怎么做得？</li><li>小程序是怎么跑在客户端的?</li><li>双线程架构有什么好处呢？</li><li>如果不使用双线程架构会怎么样？在技术指标上会有什么变化?</li><li>体验卡顿问题？一帧大概多少毫秒？</li><li>JS和渲染，你觉得一帧各占多少毫秒比较合适？</li><li>说一说各种跨端的方式？JSB是怎么进行桥接的？</li><li>除了JSB还有什么连接方式吗？</li><li>做过性能优化，有哪些操作？首屏渲染优化了多少秒？达到目标了吗？达到你自己的目标了吗？</li><li>各个操作分别优化了多少毫秒？</li><li>CDN的原理？为什么资源加载快？</li><li>如果你是一个CDN服务商，你会怎么设计你的CDN来吸引开发者。</li><li>什么情况下会存在跨域问题？</li><li>你在字节感受怎么样？为什么会选择来微信？</li><li>你觉得首屏渲染多少秒是一个合格的标准？</li><li>之前有投递过腾讯吗？为什么没有来？</li><li>后面可以过来实习吗？实习多久？后续在哪个城市发展？</li><li>反问环节、业务介绍</li></ol><h2 id="8-30-WXG游戏三面-30min-通过">8.30 WXG游戏三面 30min 通过</h2><ol start="0"><li>实习多久了？为什么投递腾讯？</li><li>聊实习业务、技术难点、亮点，实习对个人的提升</li><li>小程序怎么调用客户端能力？JSBridge初始化需要多少时间？</li><li>Faas和普通的后端工程服务有什么区别和特点？</li><li>原子服务之间的调用会有什么问题吗？</li><li>你自己起一个Node后端项目？需要做什么操作能让它更好更稳定地运行呢？</li><li>算法题 LeetCode middle 122 买卖股票的最佳时机II</li><li>反问环节、新人培养、业务了解</li></ol><h2 id="9-7-WXG游戏-hc不足流程结束">9.7 WXG游戏 hc不足流程结束</h2><h2 id="9-14-TEG腾讯大数据（数平）一面-40min">9.14 TEG腾讯大数据（数平）一面 40min</h2><ol start="0"><li>字节实习项目介绍、难点、亮点、挑战</li><li>企业项目性能如何？FCP、FMP如何?是否进行了分包加载？包体积大小如何？</li><li>Vue路由模式有几种？有什么区别？</li><li>Vue最大的优点和缺点是什么？</li><li>有实战过React吗？和Vue对比有什么区别和优缺点？</li><li>Class组件和函数组件有什么区别？</li><li>React组件间数据传递方式</li><li>用过打包工具吗？介绍一下Webpack</li><li>用过哪些Loader和Plugin？</li><li>Plugin的原理和编写思路是怎么样的？</li><li>前端异常和性能监控怎么做？让你设计一个异常和性能监控平台你会怎么设计？</li><li>LocalStorge和cookie有什么区别？</li><li>ES6实现排序有哪几种方式？</li><li>了解Set吗？介绍一下</li><li>解决跨域的方式有哪几种？分别是什么原理和实现形式？</li><li>有用过代理工具/抓包吗？</li><li>个人职业规划</li><li>用过Node吗？有哪些应用场景？</li><li>字节转正了吗？会因为什么选择一家公司？考虑哪些因素？</li><li>反问环节、业务介绍</li></ol><h2 id="9-15-TEG腾讯大数据（数平）二面-60min-通过">9.15 TEG腾讯大数据（数平）二面 60min 通过</h2><ol start="0"><li><p>物联网工程和计算机是什么关系？</p></li><li><p>大学学习了哪些课程？计算机系列课程学过吗？</p></li><li><p>简历上各个项目挨个聊</p></li><li><p>数组和链表有什么区别和特点</p></li><li><p>链表有多少种类型？</p></li><li><p>双向链表的应用场景有哪些?</p></li><li><p>一道贪心算法题</p><p>有1、5、10、50、100面值硬币，输入一个长度为5的数组，表示有多少枚对应面值的硬币，再输入一个需要凑齐的数值，输出最少需要多少枚</p></li><li><p>常见的排序算法有哪些？</p></li><li><p>快排的实现思路是？时间复杂度是？冒泡呢？</p></li><li><p>有用过哪些设计模式？介绍一下</p></li><li><p>常用Vue的哪个版本？nextTick是怎么实现的？什么原理？知道process.nextTick吗？</p></li><li><p>Vue异步更新介绍一下</p></li><li><p>聊浏览器执行机制、事件循环、多线程架构</p></li><li><p>Vue怎么实现数据双向绑定和视图更新</p></li><li><p>有用过ts吗？有什么好处和特点？</p></li><li><p>聊字节实习项目</p></li><li><p>聊小程序WebView预加载、热更新机制</p></li><li><p>反问环节、业务介绍</p></li></ol><h2 id="9-23-TEG腾讯大数据（数平）GM三面-20min-通过">9.23 TEG腾讯大数据（数平）GM三面 20min 通过</h2><ol start="0"><li>本科期间产出了很多论文和知识产权？是很早就开始做了吗？</li><li>你是一个学霸吗？还是实践能力比较强？</li><li>聊字节实习项目和工作</li><li>聊职业规划、个人发展</li><li>为什么想转全栈？</li><li>去字节实习的目的是什么？</li><li>字节如何评估你的实习工作？</li><li>你如何做你的述职答辩？</li><li>你如何考虑你的校招去向，会因为哪些因素选择一家公司？目前更倾向哪家公司？说说你的想法</li><li>你觉得腾讯和字节有什么不同？</li><li>反问环节</li></ol><h2 id="9-26-TEG腾讯大数据（数平）-HR面-20min-通过">9.26 TEG腾讯大数据（数平） HR面 20min 通过</h2><ol start="0"><li>为什么不考虑考研？</li><li>介绍一下获得国一等奖的项目和发明专利</li><li>介绍一下开源项目</li><li>你觉得字节是一家什么样的公司？</li><li>你觉得腾讯是一家什么样的公司？</li><li>你觉得TEG（技术工程事业群）的价值怎么体现？</li><li>你觉得加入腾讯TEG工作有什么挑战</li><li>为什么想转全栈？</li><li>手里还有其他offer吗？怎么考虑和选择</li><li>哪里人？后续在哪个城市发展？</li><li>有无亲属在腾讯</li><li>反问环节</li></ol><h1>阿里</h1><h2 id="8-13-淘系一面-60min-通过">8.13 淘系一面 60min 通过</h2><blockquote><p>一面老板直接上了我是没想到的</p></blockquote><ol start="0"><li><p>为什么想来阿里？</p></li><li><p>聊一下你觉得做得比较好的项目，有什么难点和亮点？</p></li><li><p>聊负载均衡器项目</p><ol start="0"><li>Node进程间通信方式是怎么实现的?</li><li>Node多进程架构是怎么样的？怎么监听同一个端口</li><li>一致性哈希算法的实现原理是？</li><li>最小连接数算法的实现方式是？</li><li>介绍一下ARP协议的作用</li><li>你的负载均衡器有用到ARP应用吗？怎么应用？</li></ol></li><li><p>聊企业项目亮点</p></li><li><p>讲讲Faas的理解，优缺点</p></li><li><p>小程序的技术架构原理是怎么样的？</p></li><li><p>小程序为什么要使用双线程+JSB的架构？</p></li><li><p>Vue3的hooks原理？</p></li><li><p>Vue3有哪些hooks API？</p></li><li><p>讲一讲Webpack的原理</p></li><li><p>反问环节</p></li></ol><h2 id="9-7-淘系-拖了一个月告知hc不足…">9.7 淘系 拖了一个月告知hc不足…</h2><h1>华为</h1><h2 id="10-16-一面-60min-通过">10.16 一面 60min 通过</h2><ol start="0"><li><p>算法题</p><p>碰撞检测算法，给定一个数组表示一系列行星。对于数组的每一个元素，其绝对值表示行星的大小，正负表示行星移动的方向（正表示向右移动，负表示向左移动）找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星永远不会发生碰撞</p><p>用例：</p><p>[5, 10, -5] =&gt; [5,10]</p><p>[8, -8] =&gt; []</p><p>[10, 2, -5] =&gt; [10]</p><p>[-2, -1, 1, 2] =&gt; [-2, -1, 1, 2]</p></li><li><p>Vue声明周期有哪些</p></li><li><p>讲一讲什么是MVC</p></li><li><p>Vue和React有什么区别</p></li><li><p>Vuex有哪些使用场景？为什么使用？Vuex的实现原理是？</p></li><li><p>Vue的路由模式有哪些？区别和实现原理是？</p></li><li><p>物联网场景Web和常规Web场景有什么区别？</p></li><li><p>HTTPS加密原理是？</p></li><li><p>讲讲你做的负载均衡器</p></li><li><p>小程序和h5有啥区别？</p></li><li><p>Uni-app的转译原理介绍一下</p></li><li><p>反问环节、业务介绍</p></li></ol><h2 id="10-16-二面-45min-通过">10.16 二面 45min 通过</h2><ol start="0"><li><p>算法题</p><p>给定一个数组，里面有6个整数，求这个数组能够表示的最大24进制的时间是多少，输出这个时间，无法表示输出invalid。</p><p>输入描述:</p><p>输入为一个整数数组，数组内有六个整数。输入数组长度为6，不需要考虑其它长度，元素值为0或者正整数，6个数字每个数字只能使用一次。</p><p>输出描述:</p><p>输出为一个24进制格式的时间，或者字符串&quot;invalid&quot;。</p><p>备注:输出时间格式为xx:xx:xx格式。</p><p>示例1 输入[0,2,3,0,5,6]</p><p>输出 23:56:00</p><p>示例2 输入[9,9,9,9,9,9]</p><p>输出invalid</p></li><li><p>介绍知识产权（发明专利、实用新型专利、软件著作权），如何产出，团队构成和个人角色。</p></li><li><p>介绍个人国奖项目</p></li><li><p>大学四年的规划、经历和职业规划</p></li><li><p>实习过程中遇到的技术难点、亮点</p></li><li><p>反问环节、业务介绍</p></li></ol><h2 id="10-24-三面-40min-通过">10.24 三面 40min 通过</h2><ol start="0"><li>考虑留在字节吗？从哪些方面考虑选择一家公司？</li><li>讲一讲你是怎么学习前端开发的？遇到过哪些难点？怎么解决？学习周期多久？</li><li>聊字节实习项目、工作、产出</li><li>实习工作合作过程中有遇到什么问题吗？怎么解决这些问题？</li><li>合作过程中的沟通时间占比多少？</li><li>实习和学业怎么平衡的？</li><li>职业规划是怎么样的？</li><li>意向城市</li><li>反问环节</li></ol><h1>大疆</h1><h2 id="8-1-笔试-90min（60min完成）通过">8.1 笔试 90min（60min完成）通过</h2><p>3单选</p><ol><li>以下判断单链表有环方法错误的是 暴力穷举、找相同尾结点、哈希缓存、快慢指针找交点</li><li>根据前序和中序选后续遍历的结果</li><li>JavaScript解释器运行到什么阶段可以判断出不需要运行func2 语法解析、词法解析、语义分析、生成字节码</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;已知</span><br><span class="line">&#x2F;&#x2F;b.js包含如下代码</span><br><span class="line">import &#123; func1 &#125; from &#39;.&#x2F;a&#39;</span><br><span class="line">&#x2F;&#x2F;a.js包含如下代码</span><br><span class="line">export function func1()&#123;&#125;</span><br><span class="line">export function func2()&#123;&#125;</span><br></pre></td></tr></table></figure><p>6多选</p><ol><li><p>空间复杂度为O（1）的算法有 归并排序、堆排序、冒泡排序、快速排序</p></li><li><p>关于HTTP 1.0/1.1/2.0说法正确的事</p><ol><li>HTTP1.0每次请求需要建立一个TCP连接</li><li>HTTP/1.1支持多路复用</li><li>HTTP/2.0支持二进制解析</li><li>HTTP/2.0支持服务端推送</li></ol></li><li><p>Chrome采用了多进程架构，创建少量tab时会启动独立的工作进程，以下关于线程、进程对比描述正确的是</p><ol><li>进程安全性更高，tab崩溃不会互相影响</li><li>进程启动成本更低，可以快速创建tab</li><li>进程间通信效率更高，更容易支持插件化</li><li>进程管理更容易，tab独立渲染更快。</li></ol></li><li><p>对于JS原型链描述正确的是</p><ol><li>任何一个函数都有prototype属性</li><li>任何一个非null对象都有<strong><strong>proto</strong></strong>属性，等同于prototype</li><li>原型链属性查找优先级为：实例****proto___ &gt; 实例本身</li><li>严格模式中，全局作用域this为undefined</li></ol></li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; 2;</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a &#x3D; 1;</span><br><span class="line">  return (b) &#x3D;&gt; &#123;</span><br><span class="line">    return (c) &#x3D;&gt; &#123;</span><br><span class="line">      const ret &#x3D; a + b + c;</span><br><span class="line">      a *&#x3D; 2;</span><br><span class="line">      return ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">let f1 &#x3D; func();</span><br><span class="line">let f2 &#x3D; func();</span><br><span class="line"></span><br><span class="line">console.log(func()(1)(2), func()(1)(2)); &#x2F;&#x2F; 4 4</span><br><span class="line"></span><br><span class="line">console.log(f1(1)(2), f2(1)(2)); &#x2F;&#x2F; 4 4</span><br><span class="line"></span><br><span class="line">console.log(f1(1)(2),f1(1)(2)); &#x2F;&#x2F; 4 4</span><br><span class="line"></span><br><span class="line">console.log(func()(1)(2), func()(1)(2)); &#x2F;&#x2F; 4 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>对于Promise、async、await 描述正确的是</p><ol><li>Promise用于解决回调嵌套过深的问题</li><li>await可以以”同步“的方式实现异步的逻辑</li><li>Promise rejected状态可以变为pending状态</li><li>Promise执行过程中可以取消</li></ol></li></ol><p>5问答</p><ol><li>EventLoop看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br><span class="line">console.log(4);</span><br><span class="line">​</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(5);</span><br><span class="line">&#125;, 0);</span><br><span class="line">​</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(6);</span><br><span class="line">&#125;, 1);</span><br></pre></td></tr></table></figure><ol start="2"><li>简述浏览器的垃圾回收机制</li><li>介绍Vue的双向绑定实现原理及流程</li><li></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum WidgetType &#123;</span><br><span class="line">  Button,</span><br><span class="line">  Text,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class Widget &#123;</span><br><span class="line">  draw() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class WButton extends Widget &#123;</span><br><span class="line">  type: WidgetType &#x3D; WidgetType.Button;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    console.log(&quot;draw Button&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class WText extends Widget &#123;</span><br><span class="line">  type: WidgetType &#x3D; WidgetType.Text;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    console.log(&quot;draw Text&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class WButtonText&#123;</span><br><span class="line">  button: WButton</span><br><span class="line">  text: WText</span><br><span class="line">  constructor(button: WButton, text: WText) &#123;</span><br><span class="line">    this.button &#x3D; button;</span><br><span class="line">    this.text &#x3D; text;</span><br><span class="line">  &#125;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    this.button.draw();</span><br><span class="line">    this.text.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">function render() &#123;</span><br><span class="line">  let btext &#x3D; new WButtonText(new WButton(), new WText());</span><br><span class="line">  btext.draw();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">&#x2F;*</span><br><span class="line">请尝试使用设计模式改写代码，使得render中可以用如下方式调用，得到相同的输出</span><br><span class="line">*&#x2F;</span><br><span class="line">​</span><br><span class="line">function render() &#123;</span><br><span class="line">  let btext &#x3D; new WText(new WButton());</span><br><span class="line">  btext.draw();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br></pre></td></tr></table></figure><ol start="2"><li>实现一个搜索器，输入一个二叉树的根节点，调用搜索器的next()方法，将返回二叉树中下一个最小的数；调用搜索器的hasNext方法，将返回是否存在下一个数。二叉树节点是无需整数</li></ol><p>附加题：</p><blockquote><p>能不能给非可视化方向的同学一点机会…</p></blockquote><ol><li>（可视化方向附加题）简述WebGL渲染管线</li><li>（可视化方向附加题）简述你了解的3D场景管理数据结构及其实现原理</li><li>（可视化方向附加题）在WebGL 3D场景中，要实现物体阴影效果，请简述实现原理。假设场景区域很大，要如何优化阴影效果。</li></ol><h2 id="8-19-一面-60min-通过">8.19 一面 60min 通过</h2><ol><li>为什么选择来大疆？不留在字节吗？</li><li>你会因为什么因素选择一家公司？</li><li>有其他公司的offer吗？</li><li>介绍一下V8垃圾回收机制？</li><li>知道V8垃圾回收机制对比编码有什么好处？</li><li>什么情况会出现内存泄漏？</li><li>你编码有出现过内存泄漏或者有排查过吗？</li><li>怎么防止内存泄漏？排查解决治标不治本</li><li>用的什么技术栈？有用过TS吗？</li><li>介绍一下你的实习项目业务</li><li>项目有什么难点？亮点？</li><li>多主题的实现你有调研过其他的解决方案吗？这个需求的背景是什么？为什么不调研别的方案？为什么不和组内同时讨论？为什么没去看antd的源码实现？</li><li>你的项目里面有涉及到权限等级系统的设计吗？</li><li>让你设计一个省市区的级联选择器你会考虑哪些点？</li><li>说说你的开源项目？</li><li>有用过哪些ES6新特性，都说一说</li><li>箭头函数this指向哪里？在不同的地方执行this执行会指向不同吗？</li><li>const和let带来了什好处？</li><li>除了块级作用域还有什么作用域？</li><li>过渡使用闭包会出现什么问题？</li><li>promise出现以前是怎么处理异步编程的？promise有什么好处？编程思路发生了什么转变？会出现什么问题？</li><li>从哪里看到的大疆招聘信息？了解大疆是怎么样的一个企业？</li><li>你觉得来大疆做前端你会做哪些工作？</li><li>↑你觉得你的描述能够吸引人吗？</li><li>业务介绍、反问环节</li></ol><h2 id="8-26-二面-30min-通过">8.26 二面 30min 通过</h2><ol><li>讲一讲你觉得最能体现你技术水平的项目</li><li>聊字节实习工作、项目、负载均衡器项目</li><li>通过这些项目 / 字节实习，你学到了什么？</li><li>个人的职业规划是怎么样的？</li><li>场景设计，单人 / 多人了解，如何做加解密可以做到服务器被攻陷也不会泄漏聊天记录，加解密的流程是怎么样的？</li><li>为什么想来大疆？有用过大疆的产品吗？</li><li>你能总结一下你个人的优缺点吗？</li><li>你的缺点有给你带来困扰和影响吗？</li><li>你实习的同事对你评价怎么样？</li><li>不考虑在字节留用吗？</li><li>你的产品思维怎么样？通过什么事情能够体现？</li><li>你平时有什么爱好？水平如何？</li><li>反问环节、业务介绍</li></ol><h2 id="8-29-三面-50min-通过">8.29 三面 50min 通过</h2><ol><li>了解企业实习工作和业务</li><li>最近国家约谈互联网大厂和做出整改你怎么看？动机是什么？面对整改你们做了什么工作?</li><li>为什么是国家整改而不是企业主动去做？</li><li>你对未来的职业规划包括选择是怎么样的？</li><li>你会因为什么去选择一家公司？为什么选择大疆？</li><li>你自己做的最满意的一个项目是什么？有什么特点和难点？</li><li>自己做的项目和企业项目的区别是什么？实习有什么收获？</li><li>你怎么看待大疆？和互联网企业不太一样，有什么特别的想法吗？</li><li>你也有提到有用过大疆的产品，感觉体验怎么样？有什么功能建议点？…讨论大疆产品和爱好</li><li>如果发了offer让你来？你觉得你需要提前做什么准备？</li><li>你有遇到过比较大的挫折和困难吗，是怎么面对的？</li><li>你的人生目标是什么？最大的优缺点是什么?</li><li>有过让自己后悔的决策吗?</li><li>字节和大疆都给你offer了你会怎么选择呢？</li><li>反问环节、企业文化价值观交流</li></ol><h1>Shopee</h1><h2 id="7-19-提前批笔试-120min-通过">7.19 提前批笔试 120min 通过</h2><ol start="0"><li><p>Symbol相关</p></li><li><p>Proxy相关</p></li><li><p>instance of相关</p></li><li><p>%、rem、vh、px相关</p></li><li><p>liunx建立新进程的命令</p></li><li><p>状态码504的含义</p></li><li><p>前端安全，SQL注入、XSS攻击、CSRF攻击、HTTPS、CA相关</p></li><li><p>IP、子网掩码算广播地址</p></li><li><p>正则相关，选一个正则不能进行的操作</p></li><li><p>选一个会触发重绘、回流的情景</p></li><li><p>不给cookie设置有效时间，它的生命周期是？</p></li><li><p>visualbility：hidden、display：none 是否触发重绘回流</p></li><li><p>使用虚拟DOM的好处</p></li><li><p>CSRF防御方案</p></li><li><p>可能被XSS注入的标签</p></li><li><p>position定位类型</p></li><li><p>CORS解决跨域请求头设置 带cookie</p></li><li><p>算法：</p><ol start="0"><li>找出最后一个只出现一个的字符</li><li>ACM的一道题 仓库拣货，二维数组标记几个点为货物，经过货物四周即为拣货成功。从入口开始，需要转向几次才能拣完所有的货。</li><li>相交数组，找出两个数组重复的项</li></ol></li></ol><h2 id="7-25-提前批一面-50min-通过">7.25 提前批一面 50min 通过</h2><ol start="0"><li>重绘重排及优化点</li><li>CSS 定位方式有哪几种 分别有什么区别</li><li>虚拟DOM的优缺点</li><li>TCP连接可靠性</li><li>TCP是否有数据校验</li><li>TCP流量控制、拥塞控制</li><li>Vue data为什么是个函数</li><li>深拷贝、浅拷贝 为什么会有这种概念</li><li>JS基本类型、引用类型</li><li>V8垃圾回收描述</li><li>事件委托、事件代理</li><li>算法：括号匹配、二叉树后续遍历</li><li>反问环节</li></ol><h2 id="8-1-提前批二面-54min-通过">8.1 提前批二面 54min 通过</h2><ol start="0"><li>EventLoop，写输出和思路</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;start&quot;);</span><br><span class="line">​</span><br><span class="line">  Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;Promise1&quot;);</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;setTimeout2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">​</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;setTimeout1&quot;);</span><br><span class="line">    Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&quot;promise2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">​</span><br><span class="line">console.log(&quot;end&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li>闭包、块级作用域，写输出和思路</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result &#x3D; [],</span><br><span class="line">  a &#x3D; 3;</span><br><span class="line">var total &#x3D; 0;</span><br><span class="line">function foo(a) &#123;</span><br><span class="line">  var i &#x3D; 0;</span><br><span class="line">  for (; i &lt; 3; i++) &#123;</span><br><span class="line">    result[i] &#x3D; function () &#123;</span><br><span class="line">      total +&#x3D; i * a;</span><br><span class="line">      console.log(total);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">foo(1);</span><br><span class="line">result[0]();</span><br><span class="line">result[1]();</span><br><span class="line">result[2]();</span><br></pre></td></tr></table></figure><ol start="3"><li>手撕防抖，支持立即执行</li><li>前端性能优化，聊了静态资源上cdn，HTTP缓存，接口聚合，骨架屏/loading，DNS预解析，preload，prefetch，webpack优化：Compress、Tenser、HMR、多线程打包、开启缓存、DLL</li><li>实现一个组件，无限滚动，要求刷新性能尽可能地好，聊了虚拟列表固定大小和不固定大小分别怎么实现</li><li>聊实习项目、亮点、遇到问题、怎么解决</li><li>ES6 - 最新版本有什么新特性</li><li>Vite了解吗，聊一聊，和webpack有什么区别，为什么比webpack快</li><li>反问环节</li></ol><h2 id="8-4-提前批HR面-20min-通过">8.4 提前批HR面 20min 通过</h2><ol start="0"><li>自我介绍</li><li>字节实习工作内容</li><li>做项目遇到什么问题，怎么解决的？</li><li>会因为什么选择一个公司？业务？薪酬？大厂背景？</li><li>对什么业务比较感兴趣呢？</li><li>用三个词形容自己</li><li>职业规划，有考虑考研吗？</li><li>自身有什么优缺点？</li><li>手头还有什么offer？</li><li>有什么兴趣、爱好？</li></ol><h1>百度</h1><h2 id="8-19-提前批一面-80min-通过">8.19 提前批一面 80min 通过</h2><ol><li><p>介绍企业实习项目</p></li><li><p>项目并发量级这么大，是怎么承受高并发的？怎么更新版本？</p></li><li><p>前端层面怎么设计可以减轻服务端压力，承受高并发？</p></li><li><p>介绍一下HTTP缓存</p></li><li><p>CDN有什么好处？原理呢？</p></li><li><p>离线包有了解过吗？</p></li><li><p>你的safeRouter是怎么封装的？怎么做的？</p></li><li><p>VueRouter的原理是什么？</p></li><li><p>个人项目的权限系统是怎么设计的？如果更复杂的权限系统你会怎么设计？</p></li><li><p>封装一个通用的根据权限渲染不同内容的组件你会怎么设计？</p></li><li><p>浏览器的时间循环机制描述一下？</p></li><li><p>Node事件循环和浏览器有什么区别？</p></li><li><p>遍历一个对象有什么形式？</p></li><li><p>for in有什么缺陷？怎么避免？</p></li><li><p>for of可以遍历对象吗？怎么让它能遍历</p></li><li><p>v-model的原理</p></li><li><p>怎么实现多个位置绑定同一个v-model？</p></li><li><p>vue组件传值有哪些方式？尽可能多地说</p></li><li><p>工程化了解过吗？Webpack的Loader和Plugin有什么区别？</p></li><li><p>Plugin可以实现Loader的功能吗？</p></li><li><p>拆包有了解过吗？路由懒加载有了解过吗？讲一讲</p></li><li><p>讲一讲你了解的数据结构</p></li><li><p>链表的头插法、查询、有序插入时间复杂度是多少？</p></li><li><p>二叉树的查询复杂度是多少？</p></li><li><p>快排的时间复杂度是多少？</p></li><li><p>算法</p><ol><li><p>数组去重</p><ol><li>set</li><li>手动</li></ol></li><li><p>爬楼梯</p><ol><li>迭代</li><li>递归</li><li>缓存 + 递归</li></ol></li></ol></li><li><p>反问环节、业务介绍</p></li></ol><h2 id="8-21-提前批二面-80min-通过">8.21 提前批二面 80min 通过</h2><ol><li><p>聊开源项目</p></li><li><p>聊企业实习项目</p></li><li><p>项目有什么难点？亮点？</p></li><li><p>实习有什么收获？</p></li><li><p>实现一个repeat函数，第一个参数是字符串，第二个参数是字符串重复多少次后返回，例如repeat(‘str’,2)返回strstr</p><ol><li>实现这个函数你要考虑什么问题？</li><li>一个字符串的最大长度是多少？</li><li>除了问人，可以查文档等各种方式去查、写代码去验证，你会怎么做？（第二个问题）</li><li>MDN文档中文版和英文版有什么不一样吗？可以看一看</li><li>你现在写的是迭代的方式，你可以改成递归的方式吗？</li><li>你一般怎么对代码进行debug？</li><li>你现在的时间复杂度是多少？可以优化吗？</li><li>ok，优化到logn了，logn的迭代形式要怎么改呢？</li></ol></li><li><p>反问环节、业务了解</p></li></ol><h2 id="8-24-提前批三面-30min-通过">8.24 提前批三面 30min 通过</h2><ol><li><p>在字节转正了吗？</p></li><li><p>后续职业规划是怎么样的？考虑考研吗？</p></li><li><p>聊字节实习项目</p></li><li><p>实习有哪些成长？</p></li><li><p>我看你学的是物联网，还获得了不少奖项和知识产权，为什么选择做前端呢？</p></li><li><p>你会因为哪些因素选择一家公司？</p></li><li><p>后续考虑在深圳发展吗？</p></li><li><p>算法设计</p><p>1000支疫苗，有一支变质了，可以通过试纸检测，反应时间需要一小时，如何在一小时用尽可能少的试纸找到变质的疫苗。一张试纸可以滴多支疫苗，一支疫苗也可以滴在多张试纸。</p><ol><li>将疫苗变成m * n矩阵，m * n = 1000， m + n 尽量小，需 m + n 张（mn对应行列）</li><li>将疫苗进行二进制编号，使用10张试纸，对应位为1则滴，不为1则不滴，通过变红的试纸反推编号。</li></ol></li><li><p>反问环节</p></li></ol><h1>滴滴</h1><h2 id="7-31-提前批一面-70min-通过">7.31 提前批一面 70min 通过</h2><ol><li>聊负载均衡器 实现、算法（个人项目）</li><li>Node进程间通信实现，其他进程间通信方式</li><li>实习项目介绍，业务理解，亮点</li><li>Express和Koa的区别，中间件的实现方式 compose</li><li>实现一个compose</li><li>compose函数看代码写输出 带try catch和抛错</li><li>讲讲对webpack的理解</li><li>vue2和vue3的区别</li><li>vue组件传值$attr</li><li>Vue的插槽有哪几种类型，分别有什么区别</li><li>手撕最长公共子串 LeetCode 1143 middle</li><li>手撕深拷贝</li><li>判断数据类型的方法</li><li>手撕发布订阅模式</li><li>反问环节</li></ol><h2 id="7-31-提前批二面-70min-通过">7.31 提前批二面 70min 通过</h2><ol><li>尽可能多的写出div中img垂直水平居中的方法。要求至少有一种方法是使用flex布局。其中div宽高300px，img宽高100px</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;img &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>画一条0.5px的线</li><li>宏任务、微任务、EventLoop</li><li>看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(100)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(200)</span><br><span class="line">Promise.resolve().then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(300)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>尽可能多的写出数组去重的方法</li><li>写一个每隔一秒输出0、1、2、3、4、5的方法</li><li><strong>var const let</strong> 块级作用域</li><li>写出console的结果</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f &#x3D; (function() &#123;</span><br><span class="line">  var c &#x3D; &quot;c&quot;;</span><br><span class="line">  return &#123;</span><br><span class="line">    a: function() &#123;</span><br><span class="line">      return c;</span><br><span class="line">    &#125;,</span><br><span class="line">    b: function(d) &#123;</span><br><span class="line">      c &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">console.warn(f.a())</span><br><span class="line">console.warn(f.c)</span><br><span class="line">console.warn(f.b(&quot;d&quot;))</span><br><span class="line">console.warn(f.a())</span><br></pre></td></tr></table></figure><ol start="7"><li>闭包</li><li>任选一种排序方法进行实现</li><li>浏览器url从输入到显示出页面的流程（带缓存）</li><li>强缓存、协商缓存</li><li>link标签引入css会阻塞dom渲染嘛</li><li>async和defer的区别</li><li>node EventLoop和浏览器有什么区别</li><li>进程间通信domain socket具体实现流程</li><li>箭头函数和普通函数有什么区别</li><li>小程序的运行机制（双线程、JSB相关）</li><li>redis怎么实现分布式锁</li><li>你认为自己的定位是怎么样的 有什么优缺点</li><li>你认为别人眼中的你是怎么样的</li><li>反问环节</li></ol><h2 id="7-31-提前批三面-70min-通过">7.31 提前批三面 70min 通过</h2><ol><li>自我介绍爱好、特长、特点、亮点、个人定位</li><li>大学中的成长历程、怎么接触技术、学习和发展历程</li><li>实习项目和做的事情</li><li>未来个人职业规划</li><li>聊负载均衡器项目（个人项目）</li><li>为什么会去做技术分享、目的、怎么选题（字节部门技术分享）</li><li>再让你做技术分享你会选什么题目</li><li>大学里最有成就感的事情，为什么？</li><li>简历上六个项目挨个聊</li><li>物联网工程专业和计算机的关系和区别</li><li>除了前端还有没有学过别的方向的技术</li><li>最擅长的专业课是什么</li><li>你怎么给一个非专业的人介绍计算机网络</li><li>计算机网络为什么要分层</li><li>你的数据结构和算法怎么样 有没有刷题</li><li>dp了解吗 讲一讲</li><li>写道题吧 对象的key全部驼峰转下划线 要求递归 可限制深度 dfs和bfs分别怎么实现</li><li>反问环节</li></ol><h1>美团</h1><h2 id="8-16-一面-70min-通过">8.16 一面 70min 通过</h2><ol><li>看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;windowsName&quot;;</span><br><span class="line">var a &#x3D; &#123;</span><br><span class="line">  name:&quot;Cherry&quot;,</span><br><span class="line">  </span><br><span class="line">  func1:function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func2:function()&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      this.func1();</span><br><span class="line">    &#125;, 100)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.func2();</span><br></pre></td></tr></table></figure><ol start="2"><li>说说对闭包的理解，有哪些应用场景</li><li>实现一个方法</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(a) -&gt; [a]</span><br><span class="line">f(b) -&gt; [a, b]</span><br><span class="line">f(c) -&gt; [a, b, c]</span><br></pre></td></tr></table></figure><ol start="4"><li>看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const list &#x3D; [1, 2, 3];</span><br><span class="line">const square &#x3D; num &#x3D;&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(num * num);</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">function test()&#123;</span><br><span class="line">  list.forEach(async x&#x3D;&gt;&#123;</span><br><span class="line">    const res &#x3D; await square(x);</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><ol start="5"><li>new的过程中发生了什么</li><li>说一下Promise的应用</li><li>async await是什么的语法糖</li><li>Promise有哪些状态，可逆吗？</li><li>讲讲Vue的双向绑定原理</li><li>数组的双向绑定相关，Vue2直接更新数组某项会进行视图更新吗？</li><li>了解跨域吗？讲一讲有哪几种方式</li><li>TCP三次握手四次挥手，为什么三次和四次，如何保障可靠性</li><li>手写快排</li><li>跨端方式交流</li><li>反问环节</li></ol><h2 id="8-24-二面-45min-通过">8.24 二面 45min 通过</h2><ol><li><p>可以提前过来实习吗？</p></li><li><p>字节留用情况？</p></li><li><p>更看重公司的哪些因素？</p></li><li><p>有考虑考研吗？</p></li><li><p>聊字节实习项目</p></li><li><p>介绍一下你的HTTP缓存文章写了哪些内容</p></li><li><p>ETag是什么？常见的算法有哪些？</p></li><li><p>负载均衡器项目是怎么实现的？</p></li><li><p>一致性哈希算法原理是？</p></li><li><p>最有成就感的项目是哪一个？</p></li><li><p>介绍一下虚拟DOM，有什么优缺点？</p></li><li><p>虚拟DOM的底层patch、diff有了解过吗？</p></li><li><p>Vue的diff算法，Vue2和Vue3分别是怎么样的？有什么区别？</p></li><li><p>Vue的双向绑定原理是怎么实现的？</p></li><li><p>算法</p><ol><li>计算一个数组最长连续自然数个数，要求值连续，位置没有要求</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入 &#123;100,4,200,1,3,2&#125;</span><br><span class="line">输出 4</span><br><span class="line">示例2 输入 &#123;200,201,202,100,4,200,1,3,2,204,203&#125;</span><br><span class="line">输出 5</span><br></pre></td></tr></table></figure><ol start="2"><li>看代码说输出，会报错吗</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let A &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  this.a &#x3D; 100;</span><br><span class="line">  return &#123;a: 200&#125;</span><br><span class="line">&#125;</span><br><span class="line">A.a &#x3D; 300</span><br><span class="line">A.__proto__.a &#x3D; 500</span><br><span class="line">A.prototype &#x3D; &#123; a: 600 &#125;</span><br><span class="line">a &#x3D; new A()</span><br><span class="line">console.log(a.a)</span><br></pre></td></tr></table></figure></li><li><p>箭头函数和普通函数有什么区别？</p></li><li><p>prototype和<strong><strong>proto</strong></strong> 有什么区别？</p></li><li><p>能说一下HTTPS握手、加解密流程吗？</p></li><li><p>让你最有收获的专业课是什么？</p></li><li><p>你觉得自己有什么优点和缺点？</p></li><li><p>除了前端还学习过什么别的技术吗？</p></li><li><p>你的知识产权（发明专利、实用新型专利、软件著作权）是怎么产生的？</p></li><li><p>反问环节</p></li></ol><h2 id="9-1-HR面-20min-通过">9.1 HR面 20min 通过</h2><ol><li>你的专利和软件著作权是通过什么机会去产出的？第几作者呢？</li><li>看你项目经验很丰富</li><li>你在字节的工作感受如何？压力大吗？</li><li>字节是否会给你留用offer？</li><li>你还有投递其他那些公司？</li><li>你会因为什么选择一家公司？</li><li>你觉得你做的最有成就感的项目是哪个？</li><li>你觉得你做的最难的项目是哪一个？难点在哪里？</li><li>你的职业规划是怎么样的？</li><li>你有哪些优点和优势？</li><li>反问环节</li></ol><h1>拼多多</h1><h2 id="7-25-提前批笔试-90min（30min完成）-通过">7.25 提前批笔试 90min（30min完成） 通过</h2><ol start="0"><li>递归实现和非递归实现哪个更快</li><li>TCP和UDP的区别是</li><li>实操HTML CSS</li><li>实现一个异步加载js函数返回一个promise，成功resolve，失败/5s超时reject</li><li>手写Promise.resolve和Promise.reject</li></ol><h2 id="8-3-提前批一面-55min-通过">8.3 提前批一面 55min 通过</h2><ol start="0"><li><p>手撕括号匹配</p></li><li><p>实现一个promiseTimeout方法，接收两个参数，第一个参数为promise，第二个参数为number类型；该方法的作用为</p><ol start="0"><li>若promise在第二个参数给定的时间内处于pending状态，则返回一个rejected的promise，其reason为new Error（‘promise timeout’）</li><li>若promise在第二个参数给定的时间内处于非pending状态，则返回该promise</li></ol></li><li><p>浏览器任务循环，看代码写输出</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">​</span><br><span class="line">async1();</span><br><span class="line">​</span><br><span class="line">new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;promise1&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;promise2&quot;);</span><br><span class="line">    return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((result) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;promise3&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">​</span><br><span class="line">console.log(&quot;script end&quot;);</span><br></pre></td></tr></table></figure><ol start="4"><li>看代码写输出</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">console.log(&#39;a finish&#39;);</span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">console.log(&#39;b finish&#39;);</span><br><span class="line">​</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;a.js&quot; defer&#x3D;&quot;defer&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;b.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      console.log(&quot;event begin&quot;);</span><br><span class="line">      document.addEventListener(&quot;DOMContentLoaded&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;DOMContentLoaded finish&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">      window.addEventListener(&quot;load&quot;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&quot;load finish&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;main&quot; class&#x3D;&quot;bg&quot;&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">        let i &#x3D; 0;</span><br><span class="line">        while (i &lt; 1000000) &#123;</span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;compute finished&quot;);</span><br><span class="line">      &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><ol start="5"><li>Vue双向绑定实现原理</li><li>Vue.$nextTick实现原理，是宏任务还是微任务</li><li>Vue scoped实现原理</li><li>跨域的实现方式</li><li>简单请求复杂请求 Option预请求</li><li>从url到页面渲染间发生了什么</li><li>重绘、回流，优化方式</li><li>HTTP缓存 强缓存、协商缓存</li><li>手写Reac Hookst计数器（自增），闭包陷阱</li><li>无限滚动场景，虚拟列表设计</li><li>单点登录</li><li>前端安全CSRF</li></ol><h2 id="8-7-提前批二面-50min-通过">8.7 提前批二面 50min 通过</h2><ol start="0"><li>你觉得Vue是个怎么样的框架</li><li>Vue DSL是个什么样的模式</li><li>什么是MVVM？</li><li>MVVM三层分别做了什么事情</li><li>Vue中组件是什么概念？什么场景你会去封装一个组件</li><li>Vue组件数据通信有什么方式？分别有什么区别</li><li>Vuex异步和同步操作分别用什么，区别在哪里？</li><li>算法题：给出一个数组中有多个对象，对象的属性有用户的id和操作的时间，给出了时间的起止，输出一个数组，数组中的对象为操作次数和相同操作次数的用户数，按操作次数从大到小排列</li><li>for in和for of的区别</li><li>const、let和var的区别</li><li>什么是块级作用域</li><li>垃圾回收做了什么事情</li><li>如何让函数作用域外的访问函数内的变量</li><li>什么是闭包，手写个闭包</li><li>this在JS中是什么</li><li>箭头函数和普通函数有什么区别</li><li>怎么改变函数的this指向</li><li>说一下flex布局，有哪些常见属性，分别用来干吗</li><li>简单写个flex布局</li><li>CSS有哪些单位 有什么区别</li><li>rem有什么使用场景</li><li>浏览器拿到document后浏览器的渲染流程</li><li>什么情况会阻塞渲染，怎么优化</li><li>async和defer有什么区别</li><li>怎么手动测量渲染时间</li></ol><h2 id="8-16-提前批三面-70min-通过">8.16 提前批三面 70min 通过</h2><ol start="0"><li>算法</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">请将第二排天上数组，使得第二排每一位数字是对应的第一排数字的次数</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">- - - - - - - - - -</span><br><span class="line">​</span><br><span class="line">例如</span><br><span class="line">0 1 2 3</span><br><span class="line">1 2 1 0</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现一个HardMan</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HardMan(&quot;jack&quot;)输出</span><br><span class="line">i am jack</span><br><span class="line">HardMan(&quot;jack&quot;).learn(&quot;computer&quot;)输出：</span><br><span class="line">i am jack</span><br><span class="line">Learning computer</span><br><span class="line">HardMan(&quot;jack&quot;).rest(10).learn(&quot;computer&quot;)输出</span><br><span class="line">i am jack 等待10s</span><br><span class="line">Start learning after 10 seconds</span><br><span class="line">Learning computer</span><br><span class="line">HardMan(&quot;jack&quot;).restFirst(5).learn(&quot;computer&quot;)输出</span><br><span class="line">等待5s</span><br><span class="line">Start learning after 5 seconds</span><br><span class="line">i am jack</span><br><span class="line">Learning chinese</span><br></pre></td></tr></table></figure><ol start="3"><li>介绍项目，难点、亮点、问题、怎么解决</li><li>HTTP 强缓存、协商缓存</li><li>localstorge和HTTP缓存有啥区别，你会怎么选择缓存方案</li><li>缓存位置在哪儿？策略？</li><li>反问环节</li></ol><h2 id="8-23-HR面-20min-通过">8.23 HR面 20min 通过</h2><ol start="0"><li>自我介绍</li><li>职业规划</li><li>后续在哪个城市发展</li><li>爸妈同意吗？有没有女朋友</li><li>会因为什么因素选择一家公司</li><li>有什么感兴趣的业务方向</li><li>期望薪资是什么水平？</li><li>为什么选择做前端开发？</li><li>可以过来实习嘛？</li><li>工作强度是否了解过？是否能接受？</li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 秋招 </tag>
            
            <tag> 应届生 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[源码解读]一文读懂Vuex4源码</title>
      <link href="2021/09/05/Vuex4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>2021/09/05/Vuex4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Vuex4源码解析</p><blockquote><p>Vuex是在Vue中常用的状态管理库，在Vue3发布后，这个状态管理库也随之发出了适配Vue3的Vuex4</p></blockquote><h1>快速过Vuex3.x原理</h1><ul><li>为什么每个组件都可以通过<code>this.$store</code>访问到store数据？<ul><li>在beforeCreate时，通过mixin的方式注入了store</li></ul></li><li>为什么Vuex中的数据都是响应式的<ul><li>创建store的时候调用的是<code>new Vue</code>,创建了一个Vue实例，相当于借用了Vue的响应式。</li></ul></li><li>mapXxxx是怎么获取到store中的数据和方法的<ul><li>mapXxxx只是一个语法糖，底层实现也是从$store中获取然后返回到computed / methods中。</li></ul></li></ul><h1>Vuex4使用</h1><h2 id="Vue-useStore">Vue.useStore</h2><ul><li>在Vue3 Composition API中使用Vuex</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> store = useStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Vuex4原理探究</h1><blockquote><p>去除冗余代码看本质</p></blockquote><h2 id="Vuex4是怎么注入Vue的">Vuex4是怎么注入Vue的</h2><h3 id="install">install</h3><ul><li>Vuex是以插件的形式在Vue中使用的，在createApp时调用install安装<ul><li>也就是我们常用的Vue.use函数<ul><li>插件列表中加入plugin</li><li>执行plugin的安装函数</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3源码 app.use</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>&lt;<span class="title">HostElement</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  render: RootRenderFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate?: RootHydrateFunction</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CreateAppFunction</span>&lt;<span class="title">HostElement</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略部分代码....</span></span><br><span class="line">    <span class="keyword">const</span> app: App = (context.app = &#123;</span><br><span class="line">      _uid: uid++,</span><br><span class="line">      _component: rootComponent <span class="keyword">as</span> ConcreteComponent,</span><br><span class="line">      _props: rootProps,</span><br><span class="line">      _container: <span class="literal">null</span>,</span><br><span class="line">      _context: context,</span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 省略部分代码....</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">use</span>(<span class="params">plugin: Plugin, ...options: <span class="built_in">any</span>[]</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (installedPlugins.has(plugin)) &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warn(<span class="string">`Plugin has already been applied to target app.`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plugin &amp;&amp; isFunction(plugin.install)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin.install(app, ...options)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(plugin)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin(app, ...options)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`A plugin must either be a function or an object with an &quot;install&quot; `</span> +</span><br><span class="line">              <span class="string">`function.`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 省略部分代码 ....</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Store 类的install，两种实现分别为挂载到全局和组件内访问<ul><li>实现通过inject获取<ul><li>详情见下文app.provide讲解</li></ul></li><li>实现this.$store获取<ul><li>将store挂载到全局properties</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex4实现插件install</span></span><br><span class="line">install (app, injectKey) &#123;</span><br><span class="line">  <span class="comment">// 实现通过inject获取</span></span><br><span class="line">  app.provide(injectKey || storeKey, <span class="built_in">this</span>)</span><br><span class="line">  <span class="comment">// 实现this.$store获取</span></span><br><span class="line">  app.config.globalProperties.$store = <span class="built_in">this</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Provide / Inject架构示意图</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)" alt="img"></p><blockquote><p>下面接着看provide实现</p></blockquote><h3 id="app-provide实现">app.provide实现</h3><ul><li>每个Vue组件都有一个context上下文对象</li><li>对context上下文中的provides对象进行赋值</li><li>createAppContext是一个创建App上下文函数<ul><li>返回体中是一个具有一些常见的Option（mixins、components等）</li><li>Vue的插件实现最主要的为其中一项provides，具体实现方式为：<ul><li>将插件通过key / value的形式挂载到app上下文的provides对象上</li><li>inject时，通过存入的key进行取出</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3 app.provide实现</span></span><br><span class="line"><span class="function"><span class="title">provide</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 已存在则警告</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; (key <span class="keyword">as</span> <span class="built_in">string</span> | symbol) <span class="keyword">in</span> context.provides) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`App already provides property with key &quot;<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>&quot;. `</span> +</span><br><span class="line">        <span class="string">`It will be overwritten with the new value.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将store放入context的provide中</span></span><br><span class="line">  context.provides[key <span class="keyword">as</span> <span class="built_in">string</span>] = value</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// context相关   context为上下文对象</span></span><br><span class="line"><span class="keyword">const</span> context = createAppContext()</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppContext</span>(<span class="params"></span>): <span class="title">AppContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app: <span class="literal">null</span> <span class="keyword">as</span> <span class="built_in">any</span>,</span><br><span class="line">    config: &#123;</span><br><span class="line">      isNativeTag: NO,</span><br><span class="line">      performance: <span class="literal">false</span>,</span><br><span class="line">      globalProperties: &#123;&#125;,</span><br><span class="line">      optionMergeStrategies: &#123;&#125;,</span><br><span class="line">      errorHandler: <span class="literal">undefined</span>,</span><br><span class="line">      warnHandler: <span class="literal">undefined</span>,</span><br><span class="line">      compilerOptions: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mixins: [],</span><br><span class="line">    components: &#123;&#125;,</span><br><span class="line">    directives: &#123;&#125;,</span><br><span class="line">    provides: <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useStore的实现">useStore的实现</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useStore</span> (<span class="params">key = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> inject(key !== <span class="literal">null</span> ? key : storeKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-provide">Vue.provide</h3><ul><li>Vue的provide API也比较简单，相当于直接通过key/value赋值</li><li>当前实例provides和父级实例provides相同时，通过原型链建立连接</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3 provide实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">provide</span>&lt;<span class="title">T</span>&gt;(<span class="params">key: InjectionKey&lt;T&gt; | <span class="built_in">string</span> | <span class="built_in">number</span>, value: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!currentInstance) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      warn(<span class="string">`provide() can only be used inside setup().`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> provides = currentInstance.provides</span><br><span class="line">    <span class="keyword">const</span> parentProvides =</span><br><span class="line">      currentInstance.parent &amp;&amp; currentInstance.parent.provides</span><br><span class="line">    <span class="keyword">if</span> (parentProvides === provides) &#123;</span><br><span class="line">      provides = currentInstance.provides = <span class="built_in">Object</span>.create(parentProvides)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TS doesn&#x27;t allow symbol as index type</span></span><br><span class="line">    provides[key <span class="keyword">as</span> <span class="built_in">string</span>] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-inject">Vue.inject</h3><ul><li>通过provide时存入的key取出store</li><li>有父级实例则取父级实例的provides，没有则取根实例的provides</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3 inject实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inject</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  key: InjectionKey&lt;<span class="built_in">any</span>&gt; | <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  defaultValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  treatDefaultAsFactory = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instance = currentInstance || currentRenderingInstance</span><br><span class="line">  <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">    <span class="comment">// 有父级实例则取父级实例的provides，没有则取根实例的provides</span></span><br><span class="line">    <span class="keyword">const</span> provides =</span><br><span class="line">      instance.parent == <span class="literal">null</span></span><br><span class="line">        ? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides</span><br><span class="line">        : instance.parent.provides</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过provide时存入的key取出store</span></span><br><span class="line">    <span class="keyword">if</span> (provides &amp;&amp; (key <span class="keyword">as</span> <span class="built_in">string</span> | symbol) <span class="keyword">in</span> provides) &#123;</span><br><span class="line">      <span class="keyword">return</span> provides[key <span class="keyword">as</span> <span class="built_in">string</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略一部分代码......</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注入">注入</h3><ul><li>为什么每个组件实例都有Store对象了?<ul><li>在创建组件实例的时候注入了provides<ul><li>优先注入父级provides</li><li>兜底为注入app上下文的provides</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponentInstance</span>(<span class="params">vnode, parent, suspense</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">type</span> = vnode.type;</span><br><span class="line">    <span class="keyword">const</span> appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;</span><br><span class="line">    <span class="keyword">const</span> instance = &#123;</span><br><span class="line">        parent,</span><br><span class="line">        appContext,</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        provides: parent ? parent.provides : <span class="built_in">Object</span>.create(appContext.provides),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可从vue中引入provide、inject、getCurrentInstance等API进行库开发 / 高阶用法，这里不过多赘述。</p></blockquote><h2 id="Vuex4执行机制">Vuex4执行机制</h2><h3 id="createStore">createStore</h3><ul><li>从createStore开始看起<ul><li>可以发现Vuex4中的state是通过reactive API去创建的响应式数据，Vuex3中是通过new Vue实例</li><li>dispatch、commit的实现基本是封装了一层执行，底层也是通过store去执行，不用过于关心</li><li>而Vuex4的响应式实现，同样是借用了Vue3的响应式API reactive</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex4源码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Store(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span></span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">options = &#123;&#125;</span>)&#123;</span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">        <span class="built_in">this</span>._committing = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>._actionSubscribers = []</span><br><span class="line">        <span class="built_in">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br><span class="line">        <span class="built_in">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>._subscribers = []</span><br><span class="line">        <span class="built_in">this</span>._makeLocalGettersCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// bind commit and dispatch to self</span></span><br><span class="line">        <span class="keyword">const</span> store = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="built_in">this</span></span><br><span class="line">        <span class="built_in">this</span>.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">boundDispatch</span> (<span class="params"><span class="keyword">type</span>, payload</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> dispatch.call(store, <span class="keyword">type</span>, payload)</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">this</span>.commit = <span class="function"><span class="keyword">function</span> <span class="title">boundCommit</span> (<span class="params"><span class="keyword">type</span>, payload, options</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> commit.call(store, <span class="keyword">type</span>, payload, options)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> state = <span class="built_in">this</span>._modules.root.state</span><br><span class="line">        installModule(<span class="built_in">this</span>, state, [], <span class="built_in">this</span>._modules.root);</span><br><span class="line">        resetStoreState(<span class="built_in">this</span>, state)</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 省略若干代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreState</span> (<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">    store._state = reactive(&#123;</span><br><span class="line">        data: state</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 省略若干代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="installModule">installModule</h3><blockquote><p>installModule主要为按序初始化各模块，主要功能代码已高亮</p></blockquote><ol><li><blockquote><p>Mutation</p></blockquote></li><li><blockquote><p>Action</p></blockquote></li><li><blockquote><p>Getter</p></blockquote></li><li><blockquote><p>Child（install）</p></blockquote></li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span> (<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isRoot = !path.length</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">namespace</span> = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">    // register in <span class="keyword">namespace</span> map</span><br><span class="line">    if (module.namespaced) &#123;</span><br><span class="line">        <span class="keyword">if</span> (store._modulesNamespaceMap[<span class="keyword">namespace</span>] &amp;&amp; __DEV__) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">`[vuex] duplicate namespace <span class="subst">$&#123;<span class="keyword">namespace</span>&#125;</span> for the namespaced module <span class="subst">$&#123;path.join(<span class="string">&#x27;/&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        store._modulesNamespaceMap[<span class="keyword">namespace</span>] = module</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // set state</span><br><span class="line">    if (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">        <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">        store._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">                <span class="keyword">if</span> (moduleName <span class="keyword">in</span> parentState) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(</span><br><span class="line">                        <span class="string">`[vuex] state field &quot;<span class="subst">$&#123;moduleName&#125;</span>&quot; was overridden by a module with the same name at &quot;<span class="subst">$&#123;path.join(<span class="string">&#x27;.&#x27;</span>)&#125;</span>&quot;`</span></span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            parentState[moduleName] = <span class="built_in">module</span>.state</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> local = <span class="built_in">module</span>.context = makeLocalContext(store, <span class="keyword">namespace</span>, path)</span><br><span class="line"></span><br><span class="line">    module.forEachMutation((mutation, key) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> namespacedType = <span class="keyword">namespace</span> + key</span><br><span class="line">        registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    module.forEachAction((action, key) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">type</span> = action.root ? key : <span class="keyword">namespace</span> + key</span><br><span class="line">        const handler = action.handler || action</span><br><span class="line">        registerAction(store, type, handler, local)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    module.forEachGetter((getter, key) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> namespacedType = <span class="keyword">namespace</span> + key</span><br><span class="line">        registerGetter(store, namespacedType, getter, local)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    module.forEachChild((child, key) =&gt; &#123;</span><br><span class="line">        installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="订阅机制">订阅机制</h3><blockquote><p>看完了Vuex4是如何安装和注入的，最后来看看Vuex的订阅机制是如何实现的</p></blockquote><ul><li>和订阅机制有关的方法主要有<ul><li>订阅：subscribe、subscribeAction，分别用于订阅Mutation和Action</li><li>执行：commit、dispatch，分别用于执行</li></ul></li><li>数据项有：_actionSubscribers、_subscribers</li></ul><h4 id="subscribe">subscribe</h4><blockquote><p>订阅 store 的 mutation。<code>handler</code> 会在每个 mutation 完成后调用，接收 mutation 和经过 mutation 后的状态作为参数</p></blockquote><blockquote><p>所有的订阅callback都会被放入<code>this._subscribers</code>，可通过prepend选项选择放入队头 / 队尾。</p></blockquote><ol><li>将callback推入订阅数组</li><li>返回一个取消订阅的函数</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法   该方法会返回一个取消订阅的函数</span></span><br><span class="line">store.subscribe(<span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(action.type)</span><br><span class="line">    <span class="built_in">console</span>.log(action.payload)</span><br><span class="line">&#125;, &#123; <span class="attr">prepend</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe  Vuex4源码实现</span></span><br><span class="line">subscribe (fn, options) &#123;</span><br><span class="line">    <span class="keyword">return</span> genericSubscribe(fn, <span class="built_in">this</span>._subscribers, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genericSubscribe</span> (<span class="params">fn, subs, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subs.indexOf(fn) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        options &amp;&amp; options.prepend</span><br><span class="line">            ? subs.unshift(fn)</span><br><span class="line">            : subs.push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> i = subs.indexOf(fn)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            subs.splice(i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接着看看commit执行时如何触发这些订阅的callback</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210905101036157.png" alt="image-20210905101036157"></p><ol><li>执行需commit的函数</li><li>依次执行<code>this._subscribers</code>中的订阅callback</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commit实现</span></span><br><span class="line">commit (_type, _payload, _options) &#123;</span><br><span class="line">    <span class="comment">// check object-style commit</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        payload,</span><br><span class="line">        options</span><br><span class="line">    &#125; = unifyObjectStyle(_type, _payload, _options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> mutation = &#123; <span class="keyword">type</span>, payload &#125;</span><br><span class="line">    <span class="keyword">const</span> entry = <span class="built_in">this</span>._mutations[<span class="keyword">type</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行需commit的函数</span></span><br><span class="line">    <span class="built_in">this</span>._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">            handler(payload)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)x</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行订阅函数</span></span><br><span class="line">    <span class="built_in">this</span>._subscribers</span><br><span class="line">        .slice() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">        .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub(mutation, <span class="built_in">this</span>.state))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略若干代码....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="subscribeAction">subscribeAction</h4><blockquote><p>订阅 store 的 action。<code>handler</code> 会在每个 action 分发的时候调用并接收 action 描述和当前的 store 的 state 这两个参数</p></blockquote><blockquote><p>可订阅：执行前、执行后和错误</p></blockquote><ol><li>将订阅对象推入<code>this._actionSubscribers</code></li><li>返回一个取消订阅函数</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line">store.subscribeAction(&#123;</span><br><span class="line">    before: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`before action <span class="subst">$&#123;action.<span class="keyword">type</span>&#125;</span>`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    after: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`after action <span class="subst">$&#123;action.<span class="keyword">type</span>&#125;</span>`</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function">(<span class="params">action, state, error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`error action <span class="subst">$&#123;action.<span class="keyword">type</span>&#125;</span>`</span>)</span><br><span class="line">        <span class="built_in">console</span>.error(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">prepend</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vuex4源码实现</span></span><br><span class="line">subscribeAction (fn, options) &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> ? &#123; <span class="attr">before</span>: fn &#125; : fn</span><br><span class="line">    <span class="keyword">return</span> genericSubscribe(subs, <span class="built_in">this</span>._actionSubscribers, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genericSubscribe</span> (<span class="params">fn, subs, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subs.indexOf(fn) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        options &amp;&amp; options.prepend</span><br><span class="line">            ? subs.unshift(fn)</span><br><span class="line">            : subs.push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> i = subs.indexOf(fn)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            subs.splice(i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>dispatch执行时如何触发这些订阅函数？</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210905101145134.png" alt="image-20210905101145134"></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vuex4源码实现</span></span><br><span class="line">dispatch (_type, _payload) &#123;</span><br><span class="line">  <span class="comment">// check object-style dispatch</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    payload</span><br><span class="line">  &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> action = &#123; <span class="keyword">type</span>, payload &#125;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="built_in">this</span>._actions[<span class="keyword">type</span>]</span><br><span class="line">  <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] unknown action type: <span class="subst">$&#123;<span class="keyword">type</span>&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// before订阅执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._actionSubscribers</span><br><span class="line">      .slice() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">      .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.before)</span><br><span class="line">      .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.before(action, <span class="built_in">this</span>.state))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in before action subscribers: `</span>)</span><br><span class="line">      <span class="built_in">console</span>.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// action执行</span></span><br><span class="line">  <span class="keyword">const</span> result = entry.length &gt; <span class="number">1</span></span><br><span class="line">    ? <span class="built_in">Promise</span>.all(entry.map(<span class="function"><span class="params">handler</span> =&gt;</span> handler(payload)))</span><br><span class="line">    : entry[<span class="number">0</span>](payload)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// after订阅执行</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._actionSubscribers</span><br><span class="line">          .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after)</span><br><span class="line">          .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.after(action, <span class="built_in">this</span>.state))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in after action subscribers: `</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// error订阅执行</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._actionSubscribers</span><br><span class="line">          .filter(<span class="function"><span class="params">sub</span> =&gt;</span> sub.error)</span><br><span class="line">          .forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.error(action, <span class="built_in">this</span>.state, error))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">`[vuex] error in error action subscribers: `</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>一句话总结</h1><blockquote><p>Vuex3  -&gt; Vuex4，主要实现方式将mixin注入改为了provides / inject的方式注入。</p></blockquote><blockquote><p>Provide / Inject 不仅用于Vuex实现，同样可以用于深层组件的数据传递</p></blockquote><blockquote><p>提示：<code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p></blockquote><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Front End </tag>
            
            <tag> Vue </tag>
            
            <tag> SPA </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅地操作数据库？ORM了解一下</title>
      <link href="2021/09/05/ORM/"/>
      <url>2021/09/05/ORM/</url>
      
        <content type="html"><![CDATA[<h1>什么是ORM</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/orm.jpg" alt="img"></p><p>对象关系映射（Object Relational Mapping，简称ORM），是一种程序技术，实现面向对象编程语言中的内存对象与关系型数据库中的业务实体之间的关系映射。这样在我们操作数据库的时候，不再需要和复杂的SQL语句打交道，只需要简单地操作对象的属性和方法就可以直接实现对数据库中对应实体表的CRUD（增删改查）的操作。常见的ORM框架有Node.js的TypeOrm、Sequlize，Java的Hibernate、Mybatis和Go的Gorm、GoRose等。</p><ul><li>ORM的方法论基于三个核心原则<ul><li>简单：以最基本的形式建模数据</li><li>传达性：数据库结构被任何人都能理解的语言文档化</li><li>精确性：基于数据模型创建正确、标准化的结构</li></ul></li></ul><h1>为什么会出现ORM</h1><blockquote><p>面向对象编程语言和关系型数据库都是目前最流行的技术，但他们的模型是不一样的。</p></blockquote><ul><li>几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。</li><li>以 MVC 分层模式为例。Model 作为数据承载实体，在用户界面和业务逻辑层之间，数据以面向对象的形式传递；而当我们需要通过 Controller 分发请求把数据持久化的时候，我们就遇到了内存中的对象如何持久化成关系数据库中存储的一条实际数据记录的问题。</li><li>面向对象是从软件工程的基本原则，即封装，继承，多态的基础上发展起来的；而关系型数据库则是从数学理论的基础上发展起来的，两者之间是不匹配的。所有就出现了 ORM 以项目中间件的形式实现数据在不同场景下的数据关系映射。。而对象关系映射就是这样一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。在其基础上诞生很多对象和关系之间的映射框架，也即ORM技术。</li></ul><h1>ORM的使用  以Sequelize为例</h1><blockquote><p>仅示例，更多操作可参考</p></blockquote><ul><li><a href="https://www.sequelize.com.cn/">Sequelize 中文文档</a></li><li><a href="https://github.com/RobinBuschmann/sequelize-typescript">RobinBuschmann/sequelize-typescript</a></li></ul><p>Sequelize 是一个基于 Promise 的 Node.js <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a>, 目前支持 <a href="https://en.wikipedia.org/wiki/PostgreSQL">Postgres</a>, <a href="https://en.wikipedia.org/wiki/MySQL">MySQL</a>, <a href="https://en.wikipedia.org/wiki/MariaDB">MariaDB</a>, <a href="https://en.wikipedia.org/wiki/SQLite">SQLite</a> 以及 <a href="https://en.wikipedia.org/wiki/Microsoft_SQL_Server">Microsoft SQL Server</a>. 它具有强大的事务支持, 关联关系, 预读和延迟加载,读取复制等功能。</p><p>Sequelize 遵从 <a href="http://semver.org/">语义版本控制</a>。 支持 Node v10 及更高版本以便使用 ES6 功能。</p><h2 id="连接数据库">连接数据库</h2><ul><li>设置使用sequlize插件，并配置要连接的数据库</li></ul><h2 id="定义Model">定义Model</h2><blockquote><p>通过面向对象Class 和 关系型数据库的表建立连接</p><p>@Column 表示数据库的一列</p><p>@PrimaryKey 表示主键</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">tsimport &#123;</span><br><span class="line">  Column,</span><br><span class="line">  Model,</span><br><span class="line">  PrimaryKey,</span><br><span class="line">  Table,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@gulu/sequelize/typescript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> GameType &#123;</span><br><span class="line">  micro_game = <span class="string">&#x27;micro_game&#x27;</span>,</span><br><span class="line">  mobile_game = <span class="string">&#x27;mobile_game&#x27;</span>,</span><br><span class="line">  micro_app = <span class="string">&#x27;micro_app&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Table</span>(&#123; <span class="attr">modelName</span>: <span class="string">&#x27;game&#x27;</span>, <span class="attr">timestamps</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">GameModel</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="meta">@PrimaryKey</span></span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  gameId!: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  name!: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  description?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  <span class="keyword">type</span>!: GameType;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  icon?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="meta">@Column</span></span><br><span class="line">  isDelete!: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作数据库">操作数据库</h2><blockquote><p>通过Model的方法操作数据库</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> GameModel <span class="keyword">from</span> <span class="string">&#x27;../model/game&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏列表查询服务</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">query</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> GameModel.findAll(&#123;</span><br><span class="line">    <span class="comment">// 去除软删除字段</span></span><br><span class="line">    attributes: &#123;</span><br><span class="line">      exclude: [<span class="string">&#x27;isDelete&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 查询未被软删除的游戏</span></span><br><span class="line">    where: &#123;</span><br><span class="line">      isDelete: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相当于以下SQL语句</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> gameId, name, description, type, icon <span class="keyword">from</span> game <span class="keyword">where</span> isDelete <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><p>当然Sequlize也支持SQL语句查询</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> GameModel <span class="keyword">from</span> <span class="string">&#x27;../model/game&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏列表查询服务</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">query</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> GameModel.sequelize.query(</span><br><span class="line">      <span class="string">&#x27;select gameId, name, description, type, icon from game where isDelete = 0&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>ORM的优缺点</h1><blockquote><p>优点</p></blockquote><ol><li>隐藏了数据访问的细节，“封闭”的通用数据库交互是ORM的核心。他使得我们的通用数据库交互变得简单易行，并且完全不用考虑SQL语句。</li><li>开发效率更高，ORM使我们构造固化数据变得简单易行，在ORM诞生前，我们需要见过我们的对象模型转化为一条一条的SQL语句，通过直连或者是DB helper在关系数据库构造我们的数据库体系。而现在，基本上所有的ORM框架都提供了通过对象模型构造关系数据库结构的功能。</li><li>数据访问更抽象、轻便，支持面向对象封装。数据模型都在一个地方定义，更容易更新和维护，也利于重用代码</li><li>ORM有现成的工具，很多功能都可以自动完成，比如数据消毒、预处理、事务等等。</li><li>它迫使你使用MVC架构，ORM就是天然的Model，最终使代码更清晰。</li><li>基于ORM的业务代码比较简单，代码量少，语义性好，容易理解。</li><li>防范SQL注入攻击</li><li>不必编写性能不佳的SQL。</li></ol><blockquote><p>缺点</p></blockquote><ol><li>无可避免的，自动化意味着映射和关联管理，代价是牺牲性能。现在的各种ORM框架都在尝试使用各种方法来减轻性能上的损失，如懒加载技术、缓存技术等。</li><li>面向对象的查询语言作为一种数据库与对象之间的过渡，虽然隐藏了数据层面的业务抽象，但并不能完全屏蔽数据库层的设计。ORM库也不是轻量级的工具，需要花很多精力学习和设置，无疑将增加学习成本。</li><li>ORM难以实现过于复杂的查询。虽然可以实现，但是需要花费很大的代价（性能不如原生SQL）。</li><li>持久化层缺乏弹性，一旦出现业务需求变更，就必须修改持久化层的接口</li><li>持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化层相关程序代码，增加了软件的维护难度。</li></ol><blockquote><p>什么是“持久化” 层</p></blockquote><ul><li><p>持久（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。</p></li><li><p>总结：当下ORM的开发模式是主流，提高了代码的封装性和可读性，同时防范了SQL注入攻击。以较小量级的性能损失换来了明显的开发效率提升，明显的性能损失往往存在于复杂的查询，这种情况可以选择使用ORM提供的SQL语句接口进行查询以优化性能。</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> TypeScript </tag>
            
            <tag> Node </tag>
            
            <tag> ORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[深入浅出LB]手把手带你实现一个负载均衡器</title>
      <link href="2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>2021/08/02/LoadBalance%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1>Load Balance负载均衡 🌡</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622002849831.(null)" alt="img"></p><blockquote><p>简介</p></blockquote><p>负载均衡，含义就是根据一定算法将负载（工作任务）进行平衡，分摊到多个操作单元上运行、执行，常见的为Web服务器、企业核心应用服务器和其他主要任务服务器等，从而协同完成工作任务。负载均衡在原有的网络结构上提供了一种透明且有效的的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性，同时承受住更大的并发量级。</p><blockquote><p>简单来说就是将大量的并发请求处理转发给多个后端节点处理，减少工作响应时间。</p></blockquote><ul><li><p>避免资源浪费</p></li><li><p>避免服务不可用</p></li></ul><h1>一、分类</h1><h2 id="四层（传输层）">四层（传输层）</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622002908874.png" alt="image-20210622002908874"></p><p>四层即OSI七层模型中的传输层，有TCP、UDP协议，这两种协议中包含源IP、目标IP以外，还包含源端口号及目标端口号。四层负载均衡在接收到客户端请求后，通过修改报文的地址信息（IP + PORT）将流量转发到应用服务器。</p><h2 id="七层（应用层）">七层（应用层）</h2><blockquote><p>代理负载均衡</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622002927473.png" alt="image-20210622002927473"></p><p>七层即OSI七层模型中的应用层，应用层协议较多，常用的为HTTP/HTTPS。七层负载均衡可以给予这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP + PORT进行负载均衡，还可以根据七层的URL、Cookie、浏览器类别、语言、请求类型来决定。</p><blockquote><p>四层负载均衡的本质是转发，七层负载均衡的本质是内容交换和代理。</p></blockquote><table><thead><tr><th></th><th><strong>四层负载均衡</strong></th><th><strong>七层负载均衡</strong></th></tr></thead><tbody><tr><td><strong>基于</strong></td><td>IP + PORT</td><td>URL 或 主机IP</td></tr><tr><td><strong>类似</strong></td><td>路由器</td><td>代理服务器</td></tr><tr><td><strong>复杂度</strong></td><td>低</td><td>高</td></tr><tr><td><strong>性能</strong></td><td>高，无需解析内容</td><td>中，需算法识别URL Header、Cookie等</td></tr><tr><td><strong>安全性</strong></td><td>低，无法识别DDoS攻击</td><td>高，可防御SYN Flood攻击</td></tr><tr><td><strong>扩展功能</strong></td><td>无</td><td>内容缓存、图片防盗链等</td></tr></tbody></table><h1>二、常见算法</h1><blockquote><p>前置数据结构</p></blockquote><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> urlObj&#123;</span><br><span class="line">  url:<span class="built_in">string</span>,</span><br><span class="line">  weight:<span class="built_in">number</span> <span class="comment">// 仅在权重轮询时生效</span></span><br><span class="line">&#125;</span><br><span class="line">urlDesc: urlObj[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> urlCollectObj&#123;</span><br><span class="line">  count: <span class="built_in">number</span>, <span class="comment">// 连接数</span></span><br><span class="line">  costTime: <span class="built_in">number</span>, <span class="comment">// 响应时间</span></span><br><span class="line">  connection: <span class="built_in">number</span>, <span class="comment">// 实时连接数</span></span><br><span class="line">&#125;</span><br><span class="line">urlCollect: urlCollectObj[]</span><br></pre></td></tr></table></figure><h2 id="Random">Random</h2><blockquote><p>随机</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622002949591.png" alt="image-20210622002949591"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Random = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  收集url</span></span><br><span class="line">  urlDesc.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    urlCollect.push(val.url);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  生成随机数下标返回相应URL</span></span><br><span class="line">    <span class="keyword">const</span> pos = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * urlCollect.length);</span><br><span class="line">    <span class="keyword">return</span> urlCollect[pos];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Random;</span><br></pre></td></tr></table></figure><h2 id="Weighted-Round-Robin">Weighted Round Robin</h2><blockquote><p>权重轮询算法</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003000250.png" alt="image-20210622003000250"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WeiRoundRobin = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span>,</span><br><span class="line">    urlCollect = [],</span><br><span class="line">    copyUrlDesc = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(urlDesc));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据权重收集url</span></span><br><span class="line">  <span class="keyword">while</span> (copyUrlDesc.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copyUrlDesc.length; i++) &#123;</span><br><span class="line">      urlCollect.push(copyUrlDesc[i].url);</span><br><span class="line">      copyUrlDesc[i].weight--;</span><br><span class="line">      <span class="keyword">if</span> (copyUrlDesc[i].weight === <span class="number">0</span>) &#123;</span><br><span class="line">        copyUrlDesc.splice(i, <span class="number">1</span>);</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 轮询获取URL函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = urlCollect[pos++];</span><br><span class="line">    <span class="keyword">if</span> (pos === urlCollect.length) &#123;</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WeiRoundRobin;</span><br></pre></td></tr></table></figure><h2 id="IP-Hash-URL-Hash">IP Hash &amp; URL Hash</h2><blockquote><p>源IP / URL Hash</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003030857.png" alt="image-20210622003030857"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Hash &#125; = <span class="built_in">require</span>(<span class="string">&quot;../util&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IpHash = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlDesc) &#123;</span><br><span class="line">    <span class="comment">// 收集url</span></span><br><span class="line">    urlCollect.push(urlDesc[key].url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">sourceInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 生成Hash十进制数值</span></span><br><span class="line">    <span class="keyword">const</span> hashInfo = Hash(sourceInfo);</span><br><span class="line">    <span class="comment">// 取余为下标</span></span><br><span class="line">    <span class="keyword">const</span> urlPos = <span class="built_in">Math</span>.abs(hashInfo) % urlCollect.length;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> urlCollect[urlPos];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = IpHash;</span><br></pre></td></tr></table></figure><h2 id="Consistent-Hash">Consistent Hash</h2><blockquote><p>一致性Hash</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003051914.png" alt="image-20210622003051914"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Hash &#125; = <span class="built_in">require</span>(<span class="string">&quot;../util&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ConsistentHash = <span class="function">(<span class="params">urlDesc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> urlHashMap = &#123;&#125;,</span><br><span class="line">    hashCollect = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlDesc) &#123;</span><br><span class="line">    <span class="comment">// 收集urlHash进数组和生成HashMap</span></span><br><span class="line">    <span class="keyword">const</span> &#123; url &#125; = urlDesc[key];</span><br><span class="line">    <span class="keyword">const</span> hash = Hash(url);</span><br><span class="line">    urlHashMap[hash] = url;</span><br><span class="line">    hashCollect.push(hash);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将hash数组从小到大排序</span></span><br><span class="line">  hashCollect = hashCollect.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">sourceInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 生成Hash十进制数值</span></span><br><span class="line">    <span class="keyword">const</span> hashInfo = Hash(sourceInfo);</span><br><span class="line">    <span class="comment">// 遍历hash数组找到第一个比源信息hash值大的，并通过hashMap返回url</span></span><br><span class="line">    hashCollect.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &gt;= hashInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> urlHashMap[val];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 没找大则返回最大的</span></span><br><span class="line">    <span class="keyword">return</span> urlHashMap[hashCollect[hashCollect.length - <span class="number">1</span>]];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ConsistentHash;</span><br></pre></td></tr></table></figure><h2 id="Least-Connections">Least Connections</h2><blockquote><p>最小连接数</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003136462.png" alt="image-20210622003136462"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> leastConnections = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">urlCollect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.POSITIVE_INFINITY,</span><br><span class="line">      url = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历对象找到最少连接数的地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> urlCollect) &#123;</span><br><span class="line">      <span class="keyword">const</span> val = urlCollect[key].connection;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; min) &#123;</span><br><span class="line">        min = val;</span><br><span class="line">        url = key;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = leastConnections;</span><br></pre></td></tr></table></figure><blockquote><p>注：urlCollect为负载均属数据统计对象，有以下属性</p></blockquote><ul><li><p>connection实时连接数</p></li><li><p>count处理请求次数</p></li><li><p>costTime响应时间。</p></li></ul><h2 id="FAIR">FAIR</h2><blockquote><p>最小响应时间</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003155965.png" alt="image-20210622003155965"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Fair = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">urlCollect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.POSITIVE_INFINITY,</span><br><span class="line">      url = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 找到耗时最少的url </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> urlCollect) &#123;</span><br><span class="line">      <span class="keyword">const</span> urlObj = urlCollect[key];</span><br><span class="line">      <span class="keyword">if</span> (urlObj.costTime &lt; min) &#123;</span><br><span class="line">        min = urlObj.costTime;</span><br><span class="line">        url = key;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Fair;</span><br></pre></td></tr></table></figure><blockquote><p>看到这里是不是感觉算法都挺简单的 🥱</p></blockquote><blockquote><p>期待一下模块四的实现吧😏</p></blockquote><h1>三、健康监测</h1><blockquote><p>健康监测即对应用服务器的健康监测，为防止把请求转发到异常的应用服务器上，应使用健康监测策略。应对不同的业务敏感程度，可相应调整策略和频率。</p></blockquote><h2 id="HTTP-HTTPS-健康监测步骤（七层）">HTTP / HTTPS 健康监测步骤（七层）</h2><ol><li>负载均衡节点向应用服务器发送HEAD请求。</li><li>应用服务器接收到HEAD请求后根据情况返回相应状态码。</li><li>若在超时时间内未收到返回的状态码，则判断为超时，健康检查失败。</li><li>若在超时时间内收到返回的状态码，负载均衡节点进行比对，判断健康检查是否成功。</li></ol><h2 id="TCP健康检查步骤（四层）">TCP健康检查步骤（四层）</h2><ol><li>负载均衡节点向内网应用服务器IP + PORT 发TCP SYN请求数据包。</li><li>内网应用服务器收到请求后，若在正常监听，则返回SYN + ACK数据包。</li><li>若在超时时间内未收到返回的数据包，则判断服务无响应、健康检查失败，并向内网应用服务器发送RST数据包中断TCP连接。</li><li>若在超时时间内收到返回的数据包，则判定服务健康运行，发起RST数据包中断TCP连接。</li></ol><h2 id="UDP健康检查步骤（四层）">UDP健康检查步骤（四层）</h2><ol><li>负载均衡节点向内网应用服务器IP + PORT发送UDP报文。</li><li>若内网应用服务器未正常监听，则返回<code>PORT XX unreachable</code>的ICMP报错信息，反之为正常。</li><li>若在超时时间内收到了报错信息，则判断服务异常，健康检查失败。</li><li>若在超时时间内未收到报错信息，则判断服务健康运行。</li></ol><h1>四、VIP技术</h1><blockquote><p>Vrtual IP</p></blockquote><h2 id="虚拟IP">虚拟IP</h2><ul><li>在TCP / IP架构下，所有想上网的电脑，不论以何种形式连上网络，都不需要有一个唯一的IP地址。事实上IP地址是主机硬件物理地址的一种抽象。</li><li>简单来说地址分为两种<ul><li>MAC物理地址</li><li>IP逻辑地址</li></ul></li><li>虚拟IP是一个未分配给真实主机的IP，也就是说对外提供的服务器的主机除了有一个真实IP还有一个虚IP，这两个IP中的任意一个都可以连接到这台主机。<ul><li>通过虚拟IP对应真实主机的MAC地址实现</li></ul></li><li>虚拟IP一般用作达到高可用的目的，比如让所有项目中的数据库链接配置都是这个虚拟IP，当主服务器发生故障无法对外提供服务时，动态将这个虚IP切换到备用服务器。</li></ul><h2 id="虚拟IP原理">虚拟IP原理</h2><ol><li>ARP是地址解析协议，作用为将一个IP地址转换为MAC地址。</li><li>每台主机都有ARP高速缓存，存储同一个网络内IP地址与MAC地址的映射关系，主机发送数据会先从这个缓存中查询目标IP对应MAC地址，向这个MAC地址发送数据。操作系统自动维护这个缓存。</li><li>Linux下可用ARP命令操作ARP高速缓存</li></ol><ul><li><p>比如存在主机A（192.168.1.6）和主机B（192.168.1.8）。A作为对外服务的主服务器，B作为备份机器，两台服务器之间通过HeartBeat通信。</p></li><li><p>即主服务器会定时给备份服务器发送数据包，告知主服务器正常，当备份服务器在规定时间内没有收到主服务器的HeartBeat，会认为主服务器宕机。</p></li><li><p>此时备份服务器就升级为主服务器。</p><ul><li>服务器B将自己的ARP缓存发送出去，告知路由器修改路由表，告知虚拟IP地址应该指向192.168.1.8.</li><li>这时外接再次访问虚拟IP的时候，机器B就会变成主服务器，而A降级为备份服务器。</li><li>这样就完成了主从机器的切换，这一切对外都是无感知、透明的。</li></ul></li></ul><h1>五、基于 nodejs 实现一个简单的负载均衡</h1><h2 id="预期效果">预期效果</h2><blockquote><p>编辑config.js后<code>npm run start</code>即可启动均衡器和后端服务节点</p></blockquote><ul><li><p>urlDesc：后端服务节点配置对象，weight仅在WeightRoundRobin算法时起作用</p></li><li><p>port：均衡器监听端口</p></li><li><p>algorithm：算法名称（模块二中的算法均已实现）</p></li><li><p>workerNum：后端服务端口开启进程数，提供并发能力。</p></li><li><p>balancerNum：均衡器端口开启进程数，提供并发能力。</p></li><li><p>workerFilePath：后端服务节点执行文件，推荐使用绝对路径。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ALGORITHM, BASE_URL&#125; = <span class="built_in">require</span>(<span class="string">&quot;./constant&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    urlDesc: [</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16666</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">6</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16667</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16668</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16669</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16670</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16671</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;<span class="number">16672</span>&#125;</span>`</span>,</span><br><span class="line">            weight: <span class="number">4</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    algorithm: ALGORITHM.RANDOM,</span><br><span class="line">    workerNum: <span class="number">5</span>，</span><br><span class="line">    balancerNum: <span class="number">5</span>，</span><br><span class="line">    workerFilePath:path.resolve(__dirname, <span class="string">&quot;./worker.js&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="架构设计图">架构设计图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003323078.png" alt="image-20210622003323078"></p><h2 id="先来看看主流程-main-js">先来看看主流程 main.js</h2><ol><li><p>初始化负载均衡统计对象balanceDataBase</p><ul><li>balanceDataBase是一个DataBase类实例，用于统计负载均衡数据（后续会讲到）.</li></ul></li><li><p>运行均衡器</p><ul><li>多进程模型，提供并发能力。</li></ul></li><li><p>运行后端服务节点</p><ul><li>多线程+多进程模型，运行多个服务节点并提供并发能力。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;urlDesc, balancerNum&#125; = <span class="built_in">require</span>(<span class="string">&quot;./config&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> &#123;DataBase&#125; = <span class="built_in">require</span>(<span class="string">&quot;./util&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;Worker&#125; = <span class="built_in">require</span>(<span class="string">&#x27;worker_threads&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runWorker = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 防止监听端口数 &gt; CPU核数</span></span><br><span class="line">    <span class="keyword">const</span> urlObjArr = urlDesc.slice(<span class="number">0</span>, cpusLen);</span><br><span class="line">    <span class="comment">// 初始化创建子线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; urlObjArr.length; i++) &#123;</span><br><span class="line">        createWorkerThread(urlObjArr[i].url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runBalancer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置子进程执行文件</span></span><br><span class="line">    cluster.setupMaster(&#123;<span class="attr">exec</span>: path.resolve(__dirname, <span class="string">&quot;./balancer.js&quot;</span>)&#125;);</span><br><span class="line">    <span class="comment">// 初始化创建子进程</span></span><br><span class="line">    <span class="keyword">let</span> max</span><br><span class="line">    <span class="keyword">if</span> (balancerNum) &#123;</span><br><span class="line">        max = balancerNum &gt; cpusLen ? cpusLen : balancerNum</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        createBalancer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化负载均衡数据统计对象</span></span><br><span class="line"><span class="keyword">const</span> balanceDataBase = <span class="keyword">new</span> DataBase(urlDesc);</span><br><span class="line"><span class="comment">// 运行均衡器</span></span><br><span class="line">runBalancer();</span><br><span class="line"><span class="comment">// 运行后端服务节点</span></span><br><span class="line">runWorker();</span><br></pre></td></tr></table></figure><h3 id="创建均衡器（createBalancer函数）">创建均衡器（createBalancer函数）</h3><ol><li>创建进程</li><li>监听进程通信消息<ul><li>监听更新响应时间事件并执行更新函数<ul><li>用于FAIR算法（最小响应时间）。</li></ul></li><li>监听获取统计对象事件并返回</li></ul></li><li>监听异常退出并重新创建，进程守护。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createBalancer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建进程</span></span><br><span class="line">    <span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">    worker.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 监听更新响应时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&quot;updateCostTime&quot;</span>) &#123;</span><br><span class="line">            balanceDataBase.updateCostTime(msg.URL, msg.costTime)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 监听获取url统计对象事件并返回</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&quot;getUrlCollect&quot;</span>) &#123;</span><br><span class="line">            worker.send(&#123;<span class="attr">type</span>: <span class="string">&quot;getUrlCollect&quot;</span>, <span class="attr">urlCollect</span>: balanceDataBase.urlCollect&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 监听异常退出事件并重新创建进程</span></span><br><span class="line">    worker.on(<span class="string">&quot;exit&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        createBalancer();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建后端服务节点（createWorkerThread函数）">创建后端服务节点（createWorkerThread函数）</h3><ol><li><p>创建线程</p></li><li><p>解析需要监听的端口</p></li><li><p>向子线程通信，发送需要监听的端口</p></li><li><p>通过线程通信，监听子线程事件</p><ul><li><p>监听连接事件，并触发处理函数。</p></li><li><p>监听断开连接事件并触发处理函数。</p></li><li><p>用于统计负载均衡分布和实时连接数。</p></li></ul></li><li><p>监听异常退出并重新创建，线程守护。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createWorkerThread = <span class="function">(<span class="params">listenUrl</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(path.resolve(__dirname, <span class="string">&quot;./workerThread.js&quot;</span>));</span><br><span class="line">    <span class="comment">// 获取监听端口</span></span><br><span class="line">    <span class="keyword">const</span> listenPort = listenUrl.split(<span class="string">&quot;:&quot;</span>)[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 向子线程发送要监听的端口号</span></span><br><span class="line">    worker.postMessage(&#123;<span class="attr">type</span>: <span class="string">&quot;port&quot;</span>, <span class="attr">port</span>: listenPort&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收子线程消息统计进程被访问次数</span></span><br><span class="line">    worker.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 监听连接事件并触发计数事件</span></span><br><span class="line">        <span class="keyword">if</span> (msg.type === <span class="string">&quot;connect&quot;</span>) &#123;</span><br><span class="line">            balanceDataBase.add(msg.port);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 监听断开连接事件并触发计数事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (msg.type === <span class="string">&quot;disconnect&quot;</span>) &#123;</span><br><span class="line">            balanceDataBase.sub(msg.port);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 监听异常退出事件并重新创建进程</span></span><br><span class="line">    worker.on(<span class="string">&quot;exit&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        createWorkerThread(listenUrl);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再来看看均衡器工作流程-balancer-js">再来看看均衡器工作流程 balancer.js</h2><ol><li>获取getURL工具函数</li><li>监听请求并代理<ol><li>获取需要传入getURL工具函数的参数。</li><li>通过getURL工具函数获取均衡代理目的地址URL</li><li>记录请求开始时间</li><li>处理跨域</li><li>返回响应</li><li>通过进程通信，触发响应时间更新事件。</li></ol></li></ol><blockquote><p>注1：LoadBalance函数即通过算法名称返回不同的getURL工具函数，各算法实现见模块二：常见算法</p></blockquote><blockquote><p>注2：getSource函数即处理参数并返回，getURL为上面讲到的获取URL工具函数。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> LoadBalance = <span class="built_in">require</span>(<span class="string">&quot;./algorithm&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&quot;axios&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> &#123;urlFormat, ipFormat&#125; = <span class="built_in">require</span>(<span class="string">&quot;./util&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;ALGORITHM, BASE_URL&#125; = <span class="built_in">require</span>(<span class="string">&quot;./constant&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;urlDesc, algorithm, port&#125; = <span class="built_in">require</span>(<span class="string">&quot;./config&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取转发URL工具函数</span></span><br><span class="line">    <span class="keyword">const</span> getURL = LoadBalance(urlDesc.slice(<span class="number">0</span>, cpusLen), algorithm);</span><br><span class="line">    <span class="comment">// 监听请求并均衡代理</span></span><br><span class="line">    app.get(<span class="string">&quot;/&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取需要传入的参数</span></span><br><span class="line">        <span class="keyword">const</span> source = <span class="keyword">await</span> getSource(req);</span><br><span class="line">        <span class="comment">// 获取URL</span></span><br><span class="line">        <span class="keyword">const</span> URL = getURL(source);</span><br><span class="line">        <span class="comment">// res.redirect(301, URL) 重定向负载均衡</span></span><br><span class="line">        <span class="comment">// 记录请求开始时间</span></span><br><span class="line">        <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="comment">// 代理请求</span></span><br><span class="line">        axios.get(URL).then(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取负载均衡统计对象并返回</span></span><br><span class="line">            <span class="keyword">const</span> urlCollect = <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">            <span class="comment">// 处理跨域</span></span><br><span class="line">            res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            response.data.urlCollect = urlCollect;</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            res.send(response.data);</span><br><span class="line">            <span class="comment">// 记录相应时间并更新</span></span><br><span class="line">            <span class="keyword">const</span> costTime = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">            process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;updateCostTime&quot;</span>, costTime, URL&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 负载均衡服务器开始监听请求</span></span><br><span class="line">    app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Load Balance Server Running at <span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getSource = <span class="keyword">async</span> (req) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (algorithm) &#123;</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.IP_HASH:</span><br><span class="line">            <span class="keyword">return</span> ipFormat(req);</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.URL_HASH:</span><br><span class="line">            <span class="keyword">return</span> urlFormat(req);</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.CONSISTENT_HASH:</span><br><span class="line">            <span class="keyword">return</span> urlFormat(req);</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.LEAST_CONNECTIONS:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">        <span class="keyword">case</span> ALGORITHM.FAIR:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> getUrlCollect();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="如何在均衡器中获取负载均衡统计对象-getUrlCollect">如何在均衡器中获取负载均衡统计对象 getUrlCollect</h3><ol><li>通过进程通信，向父进程发送获取消息。</li><li>同时开始监听父进程通信消息，接收后使用Promise resovle返回。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取负载均衡统计对象</span></span><br><span class="line"><span class="keyword">const</span> getUrlCollect = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;getUrlCollect&quot;</span>&#125;)</span><br><span class="line">            process.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.type === <span class="string">&quot;getUrlCollect&quot;</span>) &#123;</span><br><span class="line">                    resolve(msg.urlCollect)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现服务节点并发-workerThread-js">如何实现服务节点并发 workerThread.js</h2><blockquote><p>使用多线程+多进程模型，为每个服务节点提供并发能力。</p></blockquote><h3 id="主进程流程">主进程流程</h3><ol><li>根据配置文件，创建相应数量服务节点。<ol><li>创建进程</li><li>监听父线程消息（服务节点监听端口），并转发给子进程。</li><li>监听子进程消息，并转发给父线程（建立连接、断开连接事件）。</li><li>监听异常退出并重新建立。</li></ol></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> cpusLen = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).cpus().length;</span><br><span class="line"><span class="keyword">const</span> &#123;parentPort&#125; = <span class="built_in">require</span>(<span class="string">&#x27;worker_threads&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;workerNum, workerFilePath&#125; = <span class="built_in">require</span>(<span class="string">&quot;./config&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">    <span class="comment">// 创建工作进程函数</span></span><br><span class="line">    <span class="keyword">const</span> createWorker = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 创建进程</span></span><br><span class="line">        <span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">        <span class="comment">// 监听父线程消息，并转发给子进程。</span></span><br><span class="line">        parentPort.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.type === <span class="string">&quot;port&quot;</span>) &#123;</span><br><span class="line">                worker.send(&#123;<span class="attr">type</span>: <span class="string">&quot;port&quot;</span>, <span class="attr">port</span>: msg.port&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 监听子进程消息并转发给父线程</span></span><br><span class="line">        worker.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">            parentPort.postMessage(msg);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 监听进程异常退出并重新创建</span></span><br><span class="line">        worker.on(<span class="string">&quot;exit&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            createWorker();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按配置创建进程，但不可大于CPU核数</span></span><br><span class="line">    <span class="keyword">let</span> max</span><br><span class="line">    <span class="keyword">if</span> (workerNum) &#123;</span><br><span class="line">        max = workerNum &gt; cpusLen ? cpusLen : workerNum</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        createWorker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 后端服务执行文件</span></span><br><span class="line">    <span class="built_in">require</span>(workerFilePath)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="子进程流程-worker-js（config-workerFilePath）">子进程流程 worker.js（config.workerFilePath）</h3><ol><li>通过进程间通信，向父进程发送消息，触发建立连接事件。</li><li>返回相应。</li><li>通过进程间通信，向父进程发送消息，触发断开连接事件。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">let</span> port = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发连接事件</span></span><br><span class="line">    process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;connect&quot;</span>, port&#125;);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;HTTP Version: &quot;</span> + req.httpVersion);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Connection PORT Is &quot;</span> + port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> msg = <span class="string">&quot;Hello My PORT is &quot;</span> + port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回响应</span></span><br><span class="line">    res.send(&#123;msg&#125;);</span><br><span class="line">    <span class="comment">// 触发断开连接事件</span></span><br><span class="line">    process.send(&#123;<span class="attr">type</span>: <span class="string">&quot;disconnect&quot;</span>, port&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收主进通信消息中的端口口并监听</span></span><br><span class="line">process.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.type === <span class="string">&quot;port&quot;</span>) &#123;</span><br><span class="line">        port = msg.port;</span><br><span class="line">        app.listen(port, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;Worker Listening &quot;</span> + port);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="最后来看看DataBase类">最后来看看DataBase类</h2><ul><li>成员：</li></ul><ol><li>status：任务队列状态</li><li>urlCollect：数据统计对象（提供给各算法使用 / 展示数据）<ol><li>count：处理请求数</li><li>costTime：响应时间</li><li>connection：实时连接数</li></ol></li><li>add方法<ol><li>增加连接数和实时连接数</li></ol></li><li>sub方法<ol><li>减少实时连接数</li></ol></li><li>updateCostTime方法<ol><li>更新响应时间</li></ol></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBase</span> </span>&#123;</span><br><span class="line">    urlCollect = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="title">constructor</span> (<span class="params">urlObj</span>) &#123;</span><br><span class="line">        urlObj.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.urlCollect[val.url] = &#123;</span><br><span class="line">                count: <span class="number">0</span>,</span><br><span class="line">                costTime: <span class="number">0</span>,</span><br><span class="line">                connection: <span class="number">0</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加连接数和实时连接数</span></span><br><span class="line">    add (port) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].count++;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].connection++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少实时连接数</span></span><br><span class="line">    sub (port) &#123;</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].connection--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新响应时间</span></span><br><span class="line">    updateCostTime (url, time) &#123;</span><br><span class="line">        <span class="built_in">this</span>.urlCollect[url].costTime = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><blockquote><p>做了个可视化图表来看均衡效果(Random)✔️</p></blockquote><blockquote><p>看起来均衡效果还不错🧐</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622003557369.(null)" alt="img"></p><h1>小作业</h1><blockquote><p>想手动实现一下负载均衡器 / 看看源码的同学都可以看看 👉🏻   <a href="https://github.com/LeBronChao/LoadBalancer">代码仓库</a></p></blockquote><h1>六、知识扩展</h1><h2 id="cluster多进程为什么可以监听一个端口">cluster多进程为什么可以监听一个端口?</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210622003752283.png" alt="image-20210622003752283"></p><ol><li>通过cluster.isMaster判断是否为主进程，主进程不负责任务处理，只负责管理和调度工作子进程。</li><li>master主进程启动了一个TCP服务器，真正监听端口的只有这个TCP服务器。请求触发了这个TCP服务器的<code>connection</code>事件后，通过句柄转发（IPC）给工作进程处理。<ol><li>句柄转发可转发TCP服务器、TCP套接字、UDP套接字、IPC管道</li><li>IPC只支持传输字符串，不支持传输对象（可序列化）。</li><li>转发流程：父进程发送 -&gt; stringfy &amp;&amp; send(fd) -&gt; IPC -&gt; get(fd) &amp;&amp; parse -&gt; 子进程接收</li><li>fd为句柄文件描述符。</li></ol></li><li>如何选择工作进程?<ol><li>cluster模块内置了RoundRobin算法，轮询选择工作进程。</li></ol></li><li>为什么不直接用cluster进行负载均衡?<ol><li>手动实现可根据不同场景选择不同的负载均衡算法。</li></ol></li></ol><h2 id="Node怎么实现进程间通信的？">Node怎么实现进程间通信的？</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622003758932.(null)" alt="img"></p><ol><li>常见的进程间通信方式<ol><li>管道通信<ol><li>匿名管道</li><li>命名管道</li></ol></li><li>信号量</li><li>共享内存</li><li>Socket</li><li>消息队列</li></ol></li><li>Node中实现IPC通道是依赖于libuv。Windows下由命名管道实现，*nix系统则采用Domain Socket实现。</li><li>表现在应用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。</li><li>IPC管道是如何建立的？<ol><li>父进程先通过环境变量告知子进程管道的文件描述符</li><li>父进程创建子进程</li><li>子进程启动，通过文件描述符连接已存在的IPC管道，与父进程建立连接。</li></ol></li></ol><h2 id="多进程-VS-多线程">多进程 VS 多线程</h2><h3 id="多进程">多进程</h3><ol><li>数据共享复杂，需要IPC。数据是分开的，同步简单。</li><li>占用内存多，CPU利用率低。</li><li>创建销毁复杂，速度慢</li><li>进程独立运行，不会相互影响</li><li>可用于多机多核分布式，易于扩展</li></ol><h3 id="多线程">多线程</h3><ol><li>共享进程数据，数据共享简单，同步复杂。</li><li>占用内存少，CPU利用率高。</li><li>创建销毁简单，速度快。</li><li>线程同呼吸共命运。</li><li>只能用于多核分布式。</li></ol><h1>七、由本次分享产生的一些想法</h1><blockquote><p>欢迎留言讨论</p></blockquote><ol><li>Node.js非阻塞异步I/O速度快，前端扩展服务端业务？</li><li>企业实践，说明Node还是可靠的？<ol><li>阿里Node中台架构</li><li>腾讯CloudBase云开发Node</li><li>大量Node.js全栈工程师岗位</li></ol></li><li>Node计算密集型不友好？<ol><li>Serverless盛行，计算密集型用C++/Go/Java编写，以Faas的方式调用。</li></ol></li><li>Node生态不如其他成熟的语言<ol><li>阿里输出了Java生态</li><li>是不是可以看准趋势，打造Node生态以增强团队影响力。</li></ol></li><li>未雨绸缪，将Node &amp; 服务端业务知识加入学习计划 / 规划专题分享？</li><li>讨论</li></ol><ul><li><a href="https://www.zhihu.com/question/357717742/answer/926367671"> Node.js 做 Web 后端优势为什么这么大？ - 知乎 (zhihu.com)</a></li></ul><h1>八、参考资料</h1><ol><li><a href="https://help.aliyun.com/document_detail/85958.html">健康检查概述 - 负载均衡</a></li><li>《深入浅出Node.js》</li><li><a href="http://nodejs.cn/">Node.js (nodejs.cn)</a></li><li><a href="https://juejin.cn/post/6844903908385488903#heading-17">深入理解Node.js 中的进程与线程 </a></li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 负载均衡 </tag>
            
            <tag> Node </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 进程间通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[建议收藏]你想知道的Vue3核心源码这里都有</title>
      <link href="2021/07/07/Vue3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/"/>
      <url>2021/07/07/Vue3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>Effect和Reactive</h1><blockquote><p>effect作为Vue响应式原理中的核心，在Computed、Watch、Reactive中都有出现</p><p>主要和Reactive(Proxy)、track、trigger等函数配合实现收集依赖，触发依赖更新</p></blockquote><ul><li>Effect<ul><li>副作用依赖函数</li></ul></li><li>Track<ul><li>依赖收集</li></ul></li><li>Trigger<ul><li>依赖触发</li></ul></li></ul><h2 id="Effect">Effect</h2><blockquote><p>effect可以被理解为一个副作用函数，被当做依赖收集，在响应式数据更新后被触发。</p><p>Vue的响应式API例如Computed、Watch都有用到effect来实现</p></blockquote><ul><li>先来看看入口函数<ul><li>入口函数主要是一些逻辑处理，核心逻辑位于createReactiveEffect</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions = EMPTY_OBJ</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 如果已经是effect，则重置</span></span><br><span class="line">  <span class="keyword">if</span> (isEffect(fn)) &#123;</span><br><span class="line">    fn = fn.raw</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建effect</span></span><br><span class="line">  <span class="keyword">const</span> effect = createReactiveEffect(fn, options)</span><br><span class="line">  <span class="comment">// 如果不是惰性执行，先执行一次</span></span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createReactiveEffect</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> effectStack: ReactiveEffect[] = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveEffect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ReactiveEffectOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params"></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有激活，说明调用了effect stop函数</span></span><br><span class="line">    <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">      <span class="comment">// 无调度者则直接返回，否则执行fn</span></span><br><span class="line">      <span class="keyword">return</span> options.scheduler ? <span class="literal">undefined</span> : fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断EffectStack中有没有effect，有则不处理</span></span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(effect)) &#123;</span><br><span class="line">      <span class="comment">// 清除effect</span></span><br><span class="line">      cleanup(effect)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 开始重新收集依赖</span></span><br><span class="line"><span class="comment">        * 压入stack</span></span><br><span class="line"><span class="comment">        * 将effect设置为activeEffect</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        enableTracking()</span><br><span class="line">        effectStack.push(effect)</span><br><span class="line">        activeEffect = effect</span><br><span class="line">        <span class="keyword">return</span> fn()</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 完成后将effect弹出</span></span><br><span class="line"><span class="comment">        * 重置依赖</span></span><br><span class="line"><span class="comment">        * 重置activeEffect</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        effectStack.pop()</span><br><span class="line">        resetTracking()</span><br><span class="line">        activeEffect = effectStack[effectStack.length - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> ReactiveEffect</span><br><span class="line">  effect.id = uid++ <span class="comment">// 自增id，effect唯一标识</span></span><br><span class="line">  effect.allowRecurse = !!options.allowRecurse</span><br><span class="line">  effect._isEffect = <span class="literal">true</span> <span class="comment">// 是否是effect</span></span><br><span class="line">  effect.active = <span class="literal">true</span>  <span class="comment">// 是否激活</span></span><br><span class="line">  effect.raw = fn   <span class="comment">// 挂载原始对象</span></span><br><span class="line">  effect.deps = []  <span class="comment">// 当前effect的dep数组</span></span><br><span class="line">  effect.options = options  <span class="comment">// 传入的options</span></span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次effect运行都会重新收集依赖，deps是effect的依赖数组，需要全部清空</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params">effect: ReactiveEffect</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deps &#125; = effect</span><br><span class="line">  <span class="keyword">if</span> (deps.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.length; i++) &#123;</span><br><span class="line">      deps[i].delete(effect)</span><br><span class="line">    &#125;</span><br><span class="line">    deps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Track">Track</h2><blockquote><p>Track这个函数常出现在reactive的getter函数中，用于依赖收集</p><p>源码详解见注释</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target: <span class="built_in">object</span>, <span class="keyword">type</span>: TrackOpTypes, key: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// activeEffect为空表示没有依赖</span></span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// targetMap依赖管理Map，用于收集依赖</span></span><br><span class="line">  <span class="comment">// 检查targetMap中有没有target，没有则新建</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dep用来收集依赖函数，当监听的key值发生变化，触发dep中的依赖函数更新</span></span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">    <span class="comment">// 开发环境会触发onTrack，仅用于调试</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        effect: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trigger">Trigger</h2><blockquote><p>Trigger常出现在reactive中的setter函数中，用于触发依赖更新</p><p>源码详解见注释</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  newValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;unknown, unknown&gt; | <span class="built_in">Set</span>&lt;unknown&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取依赖Map，如果没有则不需要触发</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// never been tracked</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用Set保存需要触发的effect，避免重复</span></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="comment">// 定义依赖添加函数</span></span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd: <span class="built_in">Set</span>&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect || effect.allowRecurse) &#123;</span><br><span class="line">          effects.add(effect)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将depsMap中的依赖添加到effects中</span></span><br><span class="line">  <span class="comment">// 只为了理解和原理的话   各个分支不用细看</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    depsMap.forEach(add)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    depsMap.forEach(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;</span><br><span class="line">        add(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.ADD:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          add(depsMap.get(ITERATE_KEY))</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isIntegerKey(key)) &#123;</span><br><span class="line">          <span class="comment">// new index added to array -&gt; length changes</span></span><br><span class="line">          add(depsMap.get(<span class="string">&#x27;length&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.DELETE:</span><br><span class="line">        <span class="keyword">if</span> (!isArray(target)) &#123;</span><br><span class="line">          add(depsMap.get(ITERATE_KEY))</span><br><span class="line">          <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">            add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TriggerOpTypes.SET:</span><br><span class="line">        <span class="keyword">if</span> (isMap(target)) &#123;</span><br><span class="line">          add(depsMap.get(ITERATE_KEY))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装effects执行函数</span></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect: ReactiveEffect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.options.onTrigger) &#123;</span><br><span class="line">      effect.options.onTrigger(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在scheduler则调用</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发effects中的所有依赖函数</span></span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reactive">Reactive</h2><blockquote><p>了解了Track用于依赖收集，Trigger用于依赖触发，那么他们的调用时机是什么时候呢?来看看Reactive的源码就清楚了，源码详解见注释。</p><p>注：源码结构较为复杂（封装），为便于理解原理，以下为简化源码。</p></blockquote><ul><li>总结来说<ul><li>在getter时进行依赖收集</li><li>在setter时触发依赖更新</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target:<span class="built_in">object</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | symbol, receiver: <span class="built_in">object</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">            track(target, TrackOpTypes.GET, key)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target: <span class="built_in">object</span>, key: <span class="built_in">string</span> | symbol, value: unknown, receiver: <span class="built_in">object</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key]</span><br><span class="line">            <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">            <span class="comment">// trigger(target, TriggerOpTypes.ADD, key, value)</span></span><br><span class="line">            trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Computed</h1><blockquote><p>Computed是Vue中常用且好用的一个属性，这个属性的值在依赖改变后同步进行改变，在依赖未改变时使用缓存的值。</p></blockquote><ul><li>Vue2<ul><li>在Vue2中Computed的实现通过嵌套watcher，实现响应式数据的依赖收集，间接链式触发依赖更新。</li></ul></li><li>Vue3中出现了effect，重新实现了Computed属性<ul><li>effect可以被理解为副作用函数，被当做依赖收集，在响应式数据更新后被触发。</li></ul></li></ul><blockquote><p>Show me the Code</p></blockquote><ul><li>读完这段computed函数会发现，这里只是做了简要的getter和setter的赋值处理<ul><li>computed支持两种写法<ul><li>函数</li><li>getter、setter</li></ul></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computed</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> getter: ComputedGetter&lt;T&gt;</span><br><span class="line">  <span class="keyword">let</span> setter: ComputedSetter&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOptions)) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">&#x27;Write operation failed: computed value is readonly&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ComputedRefImpl(</span><br><span class="line">    getter,</span><br><span class="line">    setter,</span><br><span class="line">    isFunction(getterOrOptions) || !getterOrOptions.set</span><br><span class="line">  ) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心逻辑都在ComputedRefImpl中，我们接着往下看<ul><li>通过dirty变量标记数据是否为旧数据</li><li>在响应式数据更新后将dirty赋值为true</li><li>在下一次get时，dirty为true时进行重新计算，并将dirty赋值为false</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputedRefImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _value!: T</span><br><span class="line">  <span class="keyword">private</span> _dirty = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> effect: ReactiveEffect&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> __v_isRef = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">readonly</span> [ReactiveFlags.IS_READONLY]: <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    getter: ComputedGetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> <span class="keyword">readonly</span> _setter: ComputedSetter&lt;T&gt;,</span></span><br><span class="line"><span class="params">    isReadonly: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.effect = effect(getter, &#123;</span><br><span class="line">      lazy: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 响应式数据更新后将dirty赋值为true</span></span><br><span class="line">      <span class="comment">// 下次执行getter判断dirty为true即重新计算computed值</span></span><br><span class="line">      scheduler: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>._dirty) &#123;</span><br><span class="line">          <span class="built_in">this</span>._dirty = <span class="literal">true</span></span><br><span class="line">          <span class="comment">// 派发所有引用当前计算属性的副作用函数effect </span></span><br><span class="line">          trigger(toRaw(<span class="built_in">this</span>), TriggerOpTypes.SET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>[ReactiveFlags.IS_READONLY] = isReadonly</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="comment">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span></span><br><span class="line">    <span class="keyword">const</span> self = toRaw(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// 当响应式数据更新后dirty为true</span></span><br><span class="line">    <span class="comment">// 重新计算数据后，将dirty赋值为false</span></span><br><span class="line">    <span class="keyword">if</span> (self._dirty) &#123;</span><br><span class="line">      self._value = <span class="built_in">this</span>.effect()</span><br><span class="line">      self._dirty = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    track(self, TrackOpTypes.GET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回计算后的值</span></span><br><span class="line">    <span class="keyword">return</span> self._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._setter(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Watch</h1><blockquote><p>Watch主要用于对某个变量的监听，并做相应的处理</p><p>Vue3中不仅重构了watch，还多了一个WatchEffect API</p></blockquote><ul><li>Watch</li></ul><blockquote><p>用于对某个变量的监听，同时可以通过callBack拿到新值和旧值</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">watch(state, <span class="function">(<span class="params">state, prevState</span>)=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>WatchEffect</li></ul><blockquote><p>每次更新都会执行，自动收集使用到的依赖</p></blockquote><blockquote><p>无法获取到新值和旧值，可手动停止监听</p></blockquote><blockquote><p><code>onInvalidate(fn)</code>传入的回调会在 <code>watchEffect</code> 重新运行或者 <code>watchEffect</code> 停止的时候执行</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watchEffect(<span class="function">(<span class="params">onInvalidate</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    onInvalidate(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)    </span><br><span class="line"><span class="comment">// 手动停止监听</span></span><br><span class="line">stop()</span><br></pre></td></tr></table></figure><h2 id="watch和watchEffect的不同点">watch和watchEffect的不同点</h2><ul><li>watch惰性执行，watchEffect每次代码加载都会执行</li><li>watch可指定监听变量，watchEffect自动依赖收集</li><li>watch可获取新旧值，watchEffect不行</li><li>watchEffect有onInvalidate功能，watch没有</li><li>watch只可监听ref、reactive等对象，watchEffect只可监听具体属性</li></ul><h2 id="Source-Code">Source Code</h2><blockquote><p>Show me the Code</p></blockquote><ul><li>这里可以看到watch和watchEffet的核心逻辑都封装到了doWatch中</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// watch</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watch</span>&lt;<span class="title">T</span> = <span class="title">any</span>, <span class="title">Immediate</span> <span class="title">extends</span> <span class="title">Readonly</span>&lt;<span class="title">boolean</span>&gt; = <span class="title">false</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: T | WatchSource&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptions&lt;Immediate&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !isFunction(cb)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`\`watch(fn, options?)\` signature has been moved to a separate API. `</span> +</span><br><span class="line">        <span class="string">`Use \`watchEffect(fn, options?)\` instead. \`watch\` now only `</span> +</span><br><span class="line">        <span class="string">`supports \`watch(source, cb, options?) signature.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doWatch(source <span class="keyword">as</span> <span class="built_in">any</span>, cb, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptionsBase</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doWatch(effect, <span class="literal">null</span>, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doWatch</li></ul><blockquote><p>以下为删减版源码，理解核心原理即可</p><p>详情见注释</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: WatchSource | WatchSource[] | WatchEffect | object,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: WatchCallback | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123; immediate, deep, flush, onTrack, onTrigger &#125;: WatchOptions = EMPTY_OBJ,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance = currentInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> getter: <span class="function">() =&gt;</span> any</span><br><span class="line">  <span class="keyword">let</span> forceTrigger = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> isMultiSource = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对不同的情况做getter赋值</span></span><br><span class="line">  <span class="keyword">if</span> (isRef(source)) &#123;</span><br><span class="line">    <span class="comment">// ref通过.value获取</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> (source <span class="keyword">as</span> Ref).value</span><br><span class="line">    forceTrigger = !!(source <span class="keyword">as</span> Ref)._shallow</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(source)) &#123;</span><br><span class="line">    <span class="comment">// reactive直接获取</span></span><br><span class="line">    getter = <span class="function">() =&gt;</span> source</span><br><span class="line">    deep = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(source)) &#123;</span><br><span class="line">    <span class="comment">// 如果是数组，做遍历处理</span></span><br><span class="line">    isMultiSource = <span class="literal">true</span></span><br><span class="line">    forceTrigger = source.some(isReactive)</span><br><span class="line">    getter = <span class="function">() =&gt;</span></span><br><span class="line">      source.map(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRef(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> s.value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReactive(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> traverse(s)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(s)) &#123;</span><br><span class="line">          <span class="keyword">return</span> callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER, [</span><br><span class="line">            instance &amp;&amp; (instance.proxy <span class="keyword">as</span> any)</span><br><span class="line">          ])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warnInvalidSource(s)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(source)) &#123;</span><br><span class="line">    <span class="comment">// 如果是函数的情况</span></span><br><span class="line">    <span class="comment">// 有cb则为watch，没有则为watchEffect</span></span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// getter with cb</span></span><br><span class="line">      getter = <span class="function">() =&gt;</span></span><br><span class="line">        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER, [</span><br><span class="line">          instance &amp;&amp; (instance.proxy <span class="keyword">as</span> any)</span><br><span class="line">        ])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// no cb -&gt; simple effect</span></span><br><span class="line">      getter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance &amp;&amp; instance.isUnmounted) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> callWithAsyncErrorHandling(</span><br><span class="line">          source,</span><br><span class="line">          instance,</span><br><span class="line">          ErrorCodes.WATCH_CALLBACK,</span><br><span class="line">          [onInvalidate]</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常情况</span></span><br><span class="line">    getter = NOOP</span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    __DEV__ &amp;&amp; warnInvalidSource(source)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 深度监听逻辑处理</span></span><br><span class="line">  <span class="keyword">if</span> (cb &amp;&amp; deep) &#123;</span><br><span class="line">    <span class="keyword">const</span> baseGetter = getter</span><br><span class="line">    getter = <span class="function">() =&gt;</span> traverse(baseGetter())</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> cleanup: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">let</span> onInvalidate: InvalidateCbRegistrator = <span class="function">(<span class="params">fn: () =&gt; <span class="keyword">void</span></span>) =&gt;</span> &#123;</span><br><span class="line">    cleanup = runner.options.onStop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录oldValue，并通过runner获取newValue</span></span><br><span class="line">  <span class="comment">// callback的封装处理为job</span></span><br><span class="line">  <span class="keyword">let</span> oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE</span><br><span class="line">  <span class="keyword">const</span> job: SchedulerJob = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!runner.active) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// watch(source, cb)</span></span><br><span class="line">      <span class="keyword">const</span> newValue = runner()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        deep ||</span><br><span class="line">        forceTrigger ||</span><br><span class="line">        (isMultiSource</span><br><span class="line">          ? (newValue <span class="keyword">as</span> any[]).some(<span class="function">(<span class="params">v, i</span>) =&gt;</span></span><br><span class="line">              hasChanged(v, (oldValue <span class="keyword">as</span> any[])[i])</span><br><span class="line">            )</span><br><span class="line">          : hasChanged(newValue, oldValue)) ||</span><br><span class="line">        (__COMPAT__ &amp;&amp;</span><br><span class="line">          isArray(newValue) &amp;&amp;</span><br><span class="line">          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// cleanup before running cb again</span></span><br><span class="line">        <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">          cleanup()</span><br><span class="line">        &#125;</span><br><span class="line">        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [</span><br><span class="line">          newValue,</span><br><span class="line">          <span class="comment">// pass undefined as the old value when it&#x27;s changed for the first time</span></span><br><span class="line">          oldValue === INITIAL_WATCHER_VALUE ? <span class="literal">undefined</span> : oldValue,</span><br><span class="line">          onInvalidate</span><br><span class="line">        ])</span><br><span class="line">        oldValue = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// watchEffect</span></span><br><span class="line">      runner()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// important: mark the job as a watcher callback so that scheduler knows</span></span><br><span class="line">  <span class="comment">// it is allowed to self-trigger (#1727)</span></span><br><span class="line">  job.allowRecurse = !!cb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过读取配置，处理job的触发时机</span></span><br><span class="line">  <span class="comment">// 并再次将job的执行封装到scheduler中</span></span><br><span class="line">  <span class="keyword">let</span> scheduler: ReactiveEffectOptions[<span class="string">&#x27;scheduler&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123; <span class="comment">// 同步执行</span></span><br><span class="line">    scheduler = job</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123; <span class="comment">// 更新后执行</span></span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">    <span class="comment">// 更新前执行</span></span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance || instance.isMounted) &#123;</span><br><span class="line">        queuePreFlushCb(job)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// with &#x27;pre&#x27; option, the first call must happen before</span></span><br><span class="line">        <span class="comment">// the component is mounted so it is called synchronously.</span></span><br><span class="line">        job()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用effect副作用处理依赖收集，在依赖更新后调用scheduler（其中封装了callback的执行）</span></span><br><span class="line">  <span class="keyword">const</span> runner = effect(getter, &#123;</span><br><span class="line">    lazy: <span class="literal">true</span>,</span><br><span class="line">    onTrack,</span><br><span class="line">    onTrigger,</span><br><span class="line">    scheduler</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收集依赖</span></span><br><span class="line">  recordInstanceBoundEffect(runner, instance)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取配置，进行watch初始化</span></span><br><span class="line">  <span class="comment">// 是否有cb</span></span><br><span class="line">  <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">    <span class="comment">// 是否立刻执行</span></span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      job()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      oldValue = runner()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 是否更新后执行</span></span><br><span class="line">    queuePostRenderEffect(runner, instance &amp;&amp; instance.suspense)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    runner()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回手动停止函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    stop(runner)</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      remove(instance.effects!, runner)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Mixin</h1><blockquote><p>Mixin意为混合，是公共逻辑封装利器。</p><p>原理比较简单，那就是合并。</p></blockquote><ul><li>合并分为对象的合并和生命周期的合并<ul><li>对象，mergeOption<ul><li>类型Object.assign的合并，会出现覆盖现象</li></ul></li><li>生命周期，mergeHook<ul><li>合并会将两个生命周期放入一个队列，依次调用</li></ul></li></ul></li><li>mergeOptions</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  to: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">from</span>: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance?: ComponentInternalInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  strats = instance &amp;&amp; instance.appContext.config.optionMergeStrategies</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__COMPAT__ &amp;&amp; isFunction(<span class="keyword">from</span>)) &#123;</span><br><span class="line">    <span class="keyword">from</span> = <span class="keyword">from</span>.options</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; mixins, <span class="attr">extends</span>: extendsOptions &#125; = <span class="keyword">from</span></span><br><span class="line"></span><br><span class="line">  extendsOptions &amp;&amp; mergeOptions(to, extendsOptions, instance, strats)</span><br><span class="line">  mixins &amp;&amp;</span><br><span class="line">    mixins.forEach(<span class="function">(<span class="params">m: ComponentOptionsMixin</span>) =&gt;</span></span><br><span class="line">      mergeOptions(to, m, instance, strats)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 对mixin中的对象进行遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果存在则进行覆盖处理</span></span><br><span class="line">    <span class="keyword">if</span> (strats &amp;&amp; hasOwn(strats, key)) &#123;</span><br><span class="line">      to[key] = strats[key](to[key], <span class="keyword">from</span>[key], instance &amp;&amp; instance.proxy, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不存在则直接赋值</span></span><br><span class="line">      to[key] = <span class="keyword">from</span>[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mergeHook</li></ul><blockquote><p>简单粗暴放进Set，调用时依次调用</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  to: <span class="built_in">Function</span>[] | <span class="built_in">Function</span> | <span class="literal">undefined</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">from</span>: <span class="built_in">Function</span> | <span class="built_in">Function</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([...toArray(to), ...toArray(<span class="keyword">from</span>)]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Diff算法优化</h1><blockquote><p>了解Vue3的Diff算法优化前，可以先了解一下<a href="https://juejin.cn/post/6944887985531781133">Vue2的Diff算法</a></p><p>本部分注重把算法讲清楚，将不进行逐行源码分析</p></blockquote><ul><li>Vue3中的主要优化点为<ul><li>在updateChildren时双端比较 -&gt; 最长递增子序列</li><li>全量Diff -&gt; 静态标记 + 非全量Diff</li><li>静态提升</li></ul></li></ul><h2 id="updateChildren">updateChildren</h2><ul><li>Vue2<ul><li>头 - 头比较</li><li>尾 - 尾比较</li><li>头 - 尾比较</li><li>尾 - 头比较</li></ul></li><li>Vue3<ul><li>头 - 头比较</li><li>尾 - 尾比较</li><li>基于最长递增子序列进行移动 / 删除 / 新增</li></ul></li></ul><h3 id="举个🌰">举个🌰</h3><ul><li>oldChild [a,b,c,d,e,f,g]</li><li>newChild [a,b,f,c,d,e,h,g]</li></ul><ol><li>首先进行头 - 头比较,比较到不一样的节点时跳出循环<ul><li>得到[a,b]</li></ul></li><li>然后进行尾 - 尾比较，比较到不一样的节点时跳出循环<ul><li>得到[g]</li></ul></li><li>剩余[f,c,d,e,h]<ul><li>通过newIndexToOldIndexMap生成数组[5, 2, 3, 4, -1]</li><li>得出最长递增子序列[2, 3, 4]对应节点为[c, d, e]</li><li>剩余的节点基于[c, d, e]进行移动 / 新增 / 删除</li></ul></li></ol><blockquote><p><strong>最长递增子序列</strong> 减少Dom元素的移动，达到最少的 dom 操作以减小开销。</p><p>关于最长递增子序列算法可以看看<a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.md">最长递增子序列</a></p></blockquote><h2 id="静态标记">静态标记</h2><blockquote><p>Vue2中对vdom进行全量Diff，Vue3中增加了静态标记进行非全量Diff</p><p>对vnode打了像以下枚举内的静态标记</p></blockquote><ul><li>patchFlag</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="built_in">enum</span> PatchFlags&#123;</span><br><span class="line">  TEXT = <span class="number">1</span> ,  <span class="comment">//动态文本节点</span></span><br><span class="line">  CLASS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">//2   动态class</span></span><br><span class="line">  STYLE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">//4   动态style</span></span><br><span class="line">  PROPS = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">//8                动态属性，但不包含类名和样式</span></span><br><span class="line">  FULL_PROPS = <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">//16   具有动态key属性，当key改变时，需进行完整的diff比较</span></span><br><span class="line">  HYDRATE_EVENTS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,<span class="comment">//32  带有监听事件的节点</span></span><br><span class="line">  STABLE_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">//64  一个不会改变子节点顺序的fragment</span></span><br><span class="line">  KEYED_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,  <span class="comment">//128 带有key属性的fragment或部分子节点有key</span></span><br><span class="line">  UNKEYEN_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,   <span class="comment">//256  子节点没有key的fragment</span></span><br><span class="line">  NEED_PATCH = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">//512   一个节点只会进行非props比较</span></span><br><span class="line">  DYNAMIC_SLOTS = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,<span class="comment">//1024   动态slot</span></span><br><span class="line">  HOISTED = -<span class="number">1</span>,   <span class="comment">//静态节点 </span></span><br><span class="line">  <span class="comment">//指示在diff过程中要退出优化模式</span></span><br><span class="line">  BAIL = -<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="举个🌰-2">举个🌰</h3><ul><li>模板长这样</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>生成vdom源码</li></ul><blockquote><p>对msg变量进行了标记</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.msg), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><ul><li>对vnode进行标记，将需要动态更新和不需要动态更新的节点进行分类</li><li>静态节点仅需创建一次，渲染直接复用，不参与diff算法流程。</li></ul><h2 id="静态提升">静态提升</h2><ul><li><p>Vue2中无论是元素是否参与更新，每次都会重新创建</p></li><li><p>Vue3中对于不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停地复用</p></li><li><p>以后每次进行render的时候，就不会重复创建这些静态的内容，而是直接从一开始就创建好的常量中取就行了。</p></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 静态提升前</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>),</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>),</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>),</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.msg), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 静态提升后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span>_createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span>_createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span>_createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Xmo&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    _hoisted_2,</span><br><span class="line">    _hoisted_3,</span><br><span class="line">    _createVNode(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, _toDisplayString(_ctx.msg), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><h1>cacheHandlers 事件侦听器缓存</h1><ul><li><p>默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化</p></li><li><p>但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。</p></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button <span class="meta">@click</span>=<span class="string">&quot;onClick&quot;</span>&gt;btn&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用缓存前</span></span><br><span class="line"><span class="comment">// 这里我们还没有开启事件监听缓存，熟悉的静态标记 8 /* PROPS */ 出现了，</span></span><br><span class="line"><span class="comment">// 它将标签的 Props （属性） 标记动态属性。</span></span><br><span class="line"><span class="comment">// 如果我们存在属性不会改变，不希望这个属性被标记为动态，那么就需要 cacheHandler 的出场了。</span></span><br><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">onClick</span>: _ctx.onClick &#125;, <span class="string">&quot;btn&quot;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">&quot;onClick&quot;</span>])</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用缓存后</span></span><br><span class="line"><span class="keyword">import</span> &#123; createVNode <span class="keyword">as</span> _createVNode, openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    _createVNode(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      onClick: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.onClick(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;btn&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>它的意思很明显，onClick 方法被存入 cache。</p><p>在使用的时候，如果能在缓存中找到这个方法，那么它将直接被使用。</p><p>如果找不到，那么将这个方法注入缓存。</p><p>总之，就是把方法给缓存了。</p></blockquote><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Front End </tag>
            
            <tag> Vue </tag>
            
            <tag> SPA </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[深入浅出]JavaScript GC 垃圾回收机制</title>
      <link href="2021/06/22/JavaScipt-GC/"/>
      <url>2021/06/22/JavaScipt-GC/</url>
      
        <content type="html"><![CDATA[<h1>[科普]JavaScript GC</h1><h1>为什么需要垃圾回收</h1><ul><li>在C / C++中，跟踪内存的使用和管理内存对开发者来说是很大的负担<ul><li>JavaScript是使用垃圾回收机制的语言，也就是说执行环境负责在代码执行时管理内存，帮开发者卸下了这个负担</li><li>通过自动内存管理实现内存的分配和资源的回收</li><li>基本思路很简单，确定哪个变量不会再被使用了，把它的内存空间释放</li><li>这个过程是周期性的，意思是这个垃圾回收程序每隔一段时间就会运行一次</li></ul></li><li>像JS中的对象、字符串、对象的内存是不固定的，只有真正用到的时候才会动态分配内存<ul><li>这些内存需在不使用后进行释放以便再次使用，否则在计算机可用内存耗尽后造成崩溃</li></ul></li><li>浏览器发展史上的垃圾回收法主要有<ul><li>引用计数法</li><li>标记清除法</li></ul></li></ul><h1>引用计数法</h1><h2 id="思路">思路</h2><ul><li>变量只是对值进行引用</li><li>当变量引用该值时，引用次数+1</li><li>当该变量的引用被覆盖或者清除时，引用次数-1</li><li>当引用次数为0时，就可以安全地释放这块内存。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]   <span class="comment">// [1, 0, 1]这块内存被arr引用  引用次数为1</span></span><br><span class="line">arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]  <span class="comment">// [1, 0, 1]的内存引用次数为0被释放  </span></span><br><span class="line">                 <span class="comment">// [0, 1, 0]的内存被arr引用   引用次数为1</span></span><br><span class="line"><span class="keyword">const</span> tmp = arr  <span class="comment">// [0, 1, 0]的内存被tmp引用   引用次数为2</span></span><br></pre></td></tr></table></figure><h2 id=""></h2><h2 id="循环引用问题">循环引用问题</h2><blockquote><p>Netscape Navigator 3.0 采用</p></blockquote><ul><li>在这个例子中，ObjectA和ObjectB的属性分别相互引用</li><li>造成这个函数执行后，Object被引用的次数不会变成0，影响了正常的GC。</li><li>如果执行多次，将造成严重的内存泄漏。</li><li>而标记清除法则不会出现这个问题。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ObjectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">let</span> ObjectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    ObjectA.p = ObjectB;</span><br><span class="line">    ObjectB.p = ObjectA;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Example();</span><br></pre></td></tr></table></figure><ul><li>解决方法：在函数结束时将其指向null</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ObjectA = <span class="literal">null</span>;</span><br><span class="line">ObjectB = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h1>标记清除法</h1><blockquote><p>为了解决循环引用造成的内存泄漏问题，Netscape Navigator 4.0 开始采用标记清除法</p></blockquote><blockquote><p>到了 2008 年，IE、Firefox、Opera、Chrome 和 Safari 都在自己的 JavaScript 实现中采用标记清理(或 其变体)，只是在运行垃圾回收的频率上有所差异。</p></blockquote><h2 id="思路-2">思路</h2><ul><li>在变量进入执行上下文时打上“进入”标记</li><li>同时在变量离开执行上下文时也打上“离开”标记<ul><li>从此以后，无法访问这个变量</li><li>在下一次垃圾回收时进行内存的释放</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> n * a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标记Example进入执行上下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">1</span>;  <span class="comment">// 标记n进入执行上下文</span></span><br><span class="line">Example(n);   <span class="comment">// 标记a,b,c进入执行上下文</span></span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// 标记a, b, c离开执行上下文，等待垃圾回收</span></span><br></pre></td></tr></table></figure><h2 id="const和let声明提升性能">const和let声明提升性能</h2><ul><li>const和let不仅有助于改善代码风格，同时有利于垃圾回收性能的提升</li><li>const和let使JS有了块级作用域，当块级作用域比函数作用域更早结束时，垃圾回收程序更早介入</li><li>尽早回收该回收的内存，提升了垃圾回收的性能</li></ul><h1>V8引擎的垃圾回收</h1><blockquote><p>V8引擎的垃圾回收采用标记清除法与分代回收法</p></blockquote><blockquote><p>分为新生代和老生代</p></blockquote><h2 id="新生代">新生代</h2><blockquote><p>新生代垃圾回收采用<code>Scavenge</code> 算法</p></blockquote><blockquote><p>分配给常用内存和新分配的小量内存</p></blockquote><ul><li><p>内存大小</p><ul><li>32位系统16M内存</li><li>64位系统32M内存</li></ul></li><li><p>分区</p><ul><li>新生代内存分为以下两区，内存各占一半</li><li>From space</li><li>To space</li></ul></li><li><p>运行</p><ul><li>实际运行的只有From space</li><li>To space处于空闲状态</li></ul></li><li><p><code>Scavenge</code>算法</p><ul><li>当From space内存使用将要达到上限时开始垃圾回收，将From space中的不可达对象都打上标记</li><li>将From space的未标记对象复制到To space。<ul><li>解决了内存散落分块的问题（不连续的内存空间）</li><li>相当于用空间换时间。</li></ul></li><li>然后清空From space、将其闲置，也就是转变为To space，俗称反转。</li></ul></li><li><p>新生代 -&gt; 老生代</p><ul><li>新生代存放的是新分配的小量内存，如果达到以下条件中的一个，将被分配至老生代<ul><li>内存大小达到From space的25%</li><li>经历了From space &lt;-&gt; To space的一个轮回</li></ul></li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210607231001850.(null)" alt="img"></p><h2 id="老生代">老生代</h2><blockquote><p>老生代采用<code>mark-sweep</code>标记清除和<code>mark-compact</code>标记整理</p></blockquote><blockquote><p>通常存放较大的内存块和从新生代分配过来的内存块</p></blockquote><ul><li>内存大小<ul><li>32位系统700M左右</li><li>64位系统1.4G左右</li></ul></li><li>分区<ul><li>Old Object Space<ul><li>字面的老生代，存放的是新生代分配过来的内存。</li></ul></li><li>Large Object Space<ul><li>存放其他区域放不下的较大的内存，基本都超过1M</li></ul></li><li>Map Space<ul><li>存放存储对象的映射关系</li></ul></li><li>Code Space<ul><li>存储编译后的代码</li></ul></li></ul></li><li>回收流程<ul><li>标记分类（三色标记）<ul><li>未被扫描，可回收，下面简称<code>1类</code></li><li>扫描中，不可回收，下面简称<code>2类</code></li><li>扫描完成，不可回收，下面简称<code>3类</code></li></ul></li><li>遍历<ul><li>采用深度优先遍历，遍历每个对象。</li><li>首先将非根部对象全部标记为<code>1类</code>，然后进行深度优先遍历。</li><li>遍历过程中将对象压入栈，这个过程中对象被标记为<code>2类</code>。</li><li>遍历完成对象出栈，这个对象被标记为<code>3类</code>。</li><li>整个过程直至栈空</li></ul></li><li>Mark-sweep<ul><li>标记完成之后，将标记为<code>1类</code>的对象进行内存释放<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210607231013225-20210607231556621.(null)" alt="img"></li></ul></li><li>Mark-compact<ul><li>垃圾回收完成之后，内存空间是不连续的。</li><li>这样容易造成无法分配较大的内存空间的问题，从而触发垃圾回收。</li><li>所以，会有Mark-compact步骤将未被回收的内存块整理为连续地内存空间。</li><li>频繁触发垃圾回收会影响引擎的性能，内存空间不足时也会优先触发Mark-compact</li></ul></li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210607231009280.(null)" alt="img"></p><h2 id="垃圾回收优化">垃圾回收优化</h2><ul><li>增量标记<ul><li>如果用集中的一段时间进行垃圾回收，新生代倒还好，老生代如果遍历较大的对象，可能会造成卡顿。</li><li>增量标记：使垃圾回收程序和应用逻辑程序交替运行，思想类似Time Slicing</li></ul></li><li>并行回收<ul><li>在垃圾回收的过程中，开启若干辅助线程，提高垃圾回收效率。</li></ul></li><li>并发回收<ul><li>在逻辑程序执行的过程中，开启若干辅助线程进行垃圾回收，清理和主线程没有任何逻辑关系的内存。</li></ul></li></ul><h1>内存泄露场景</h1><h2 id="全局变量">全局变量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exm1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    exm = <span class="string">&#x27;LeBron&#x27;</span>   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exm2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.exm = <span class="string">&#x27;LeBron&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Example()</span><br></pre></td></tr></table></figure><h2 id="未清除的定时器">未清除的定时器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// clearInterval(timer)</span></span><br></pre></td></tr></table></figure><h2 id="闭包">闭包</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = debounce(handler, <span class="number">1000</span>); <span class="comment">// fn引用了timeout</span></span><br></pre></td></tr></table></figure><h2 id="未清除的DOM元素引用">未清除的DOM元素引用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// 此处引用了DOM元素</span></span><br><span class="line">    button:<span class="built_in">document</span>.getElementById(<span class="string">&#x27;LeBron&#x27;</span>),</span><br><span class="line">    select:<span class="built_in">document</span>.getElementById(<span class="string">&#x27;select&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;LeBron&#x27;</span>))</span><br></pre></td></tr></table></figure><h1>如何检测内存泄漏</h1><blockquote><p>这个其实不难，浏览器原带的开发者工具Performance就可以</p></blockquote><ul><li>步骤<ul><li>F12打开开发者工具</li><li>选择Performance工具栏</li><li>勾选屏幕截图和Memory</li><li>点击开始录制</li><li>一段时间之后结束录制</li></ul></li><li>结果<ul><li>堆内存会周期性地分配和释放</li><li>如果堆内存的min值在逐渐上升则存在内存泄漏</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210622234127287.(null)" alt="img"></p><h1>优化内存使用</h1><ol><li>尽量不在for循环中定义函数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exm</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">idx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> idx * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//const fn = (idx) =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//    return idx * 2;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">const</span> res = fn(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>尽量不在for循环中定义对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// const obj = &#123;</span></span><br><span class="line">    <span class="comment">//   a: i,</span></span><br><span class="line">    <span class="comment">//   b: i * 2,</span></span><br><span class="line">    <span class="comment">//   c: i * 3,</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    obj.a = i;</span><br><span class="line">    obj.b = i * <span class="number">2</span>;</span><br><span class="line">    obj.c = i * <span class="number">3</span>;</span><br><span class="line">    res += <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>清空数组</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.length = <span class="number">0</span>; <span class="comment">// 清空了数组，数组类型不变</span></span><br><span class="line"><span class="comment">// arr = []  // 重新申请了一块空数组对象内存</span></span><br></pre></td></tr></table></figure><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Front End </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[打包优化]Webpack体积压缩</title>
      <link href="2021/06/07/Webpack%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A9/"/>
      <url>2021/06/07/Webpack%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6969018138591494158">打包优化]Webpack体积压缩 (juejin.cn)</a></p></blockquote><h1>HTTP压缩</h1><ul><li><p>HTTP压缩是一种内置在 服务器 和 客户端 之间的，以改进传输速度和带宽利用率的方式;</p></li><li><p>HTTP压缩的流程什么呢?</p><ul><li>第一步:HTTP数据在服务器发送前就已经被压缩了;(可以在webpack中完成)</li><li>第二步:兼容的浏览器在向服务器发送请求时，会告知服务器自己支持哪些压缩格式;</li><li>第三步:服务器在浏览器支持的压缩格式下，直接返回对应的压缩后的文件，并且在响应头中告知浏览器;</li></ul></li></ul><h2 id="压缩格式">压缩格式</h2><ol><li><p>compress – UNIX的“compress”程序的方法(历史性原因，不推荐大多数应用使用，应该使用gzip或</p><p>deflate);</p></li><li><p>deflate – 基于deflate算法(定义于RFC 1951)的压缩，使用zlib数据格式封装;</p></li><li><p>gzip – GNU zip格式(定义于RFC 1952)，是目前使用比较广泛的压缩算法;</p></li><li><p>br – 一种新的开源压缩算法，专为HTTP内容的编码而设计;</p></li></ol><h2 id="Webpack对文件压缩">Webpack对文件压缩</h2><blockquote><p>使用CompressionPlugin对文件进行压缩</p></blockquote><ul><li><p>安装</p><ul><li><code>npm install compression-webpack-plugin</code></li></ul></li><li><p>webpack.prod.js</p><ul><li>threshold：x以上的文件才进行压缩</li><li>minRatio：最小压缩比，小于则不压缩</li><li>test：正则匹配的文件才压缩</li><li>alogorithm：压缩算法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span>  CompressionPlugin(&#123;</span><br><span class="line">        threshold: <span class="number">0</span>,</span><br><span class="line">        minRatio:<span class="number">0.6</span>,</span><br><span class="line">        test:<span class="regexp">/\.(css|js)/i</span>,</span><br><span class="line">        algorithm:<span class="string">&quot;gzip&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="HTML文件中代码的压缩">HTML文件中代码的压缩</h2><ul><li><p>之前使用了HtmlWebpackPlugin插件来生成HTML的模板，事实上它还有一些其他的配置:</p></li><li><p>inject:设置打包的资源插入的位置</p><ul><li>true、 false 、body、head</li></ul></li><li><p>cache:设置为true，只有当文件改变时，才会生成新的文件(默认值也是true)</p></li><li><p>minify:默认会使用一个插件html-minifier-terser</p></li><li><p>webpack.prod.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: <span class="string">&quot;LeBronChao Webpack&quot;</span>,</span><br><span class="line">        template: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">        inject:<span class="string">&quot;body&quot;</span>,</span><br><span class="line">        cache:<span class="literal">true</span>,</span><br><span class="line">        minify: isProduction ? &#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>, <span class="comment">// 是否删除注释</span></span><br><span class="line">            removeRedundantAttributes:<span class="literal">true</span>, <span class="comment">// 是否删除多余（默认）属性</span></span><br><span class="line">            removeEmptyAttributes:<span class="literal">true</span>,  <span class="comment">// 是否删除空属性</span></span><br><span class="line">            collapseWhitespace:<span class="literal">false</span>,  <span class="comment">// 折叠空格</span></span><br><span class="line">            removeStyleLinkTypeAttributes:<span class="literal">true</span>, <span class="comment">// 比如link中的type=&quot;text/css&quot;</span></span><br><span class="line">            minifyCSS:<span class="literal">true</span>, <span class="comment">// 是否压缩style标签内的css</span></span><br><span class="line">            minifyJS:&#123;  <span class="comment">// 压缩JS选项，可参考Terser配置</span></span><br><span class="line">                mangle:&#123;</span><br><span class="line">                    toplevel: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;: <span class="literal">false</span></span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="InlineChunkHtmlPlugin">InlineChunkHtmlPlugin</h2><ul><li><p>另外有一个插件，可以辅助将一些chunk出来的模块，内联到html中:</p><ul><li>比如runtime的代码，代码量不大，但是是必须加载的;</li><li>那么可以直接内联到html中;</li></ul></li><li><p>这个插件是在react-dev-utils中实现的，所以我们可以安装一下:</p><ul><li><code>npm i react-dev-utils </code></li></ul></li><li><p>在production的plugins中进行配置（内联runtime文件）:</p><ul><li>webpack.prod.js</li><li>参数一为HtmlWebpackPlugin</li><li>参数二为正则匹配表达式</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InlieChunkHtmlPlugin = <span class="built_in">require</span>(<span class="string">&quot;react-dev-utils/InlineChunkHtmlPlugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> InlieChunkHtmlPlugin(HtmlWebpackPlugin,[<span class="regexp">/runtime.+\.js/</span>])</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Terser">Terser</h2><ul><li><p>什么是Terser呢?</p><ul><li>Terser是一个JavaScript的解释(Parser)、Mangler(绞肉机)/Compressor(压缩机)的工具集;</li><li>早期会使用 uglify-js来压缩、丑化JavaScript代码，但是目前已经不再维护，并且不支持ES6+的 语法;</li><li>Terser是从 uglify-es fork 过来的，并且保留它原来的大部分API以及适配 uglify-es和uglify-js@3等; 也就是说，Terser可以帮助压缩、丑化代码，让我们的bundle变得更小。</li></ul></li><li><p>因为Terser是一个独立的工具，所以它可以单独安装:</p><ul><li><code>npm i terser -g</code></li></ul></li><li><p>可以在命令行中使用Terser</p><ul><li>因为他们的配置非常多Compress option和Mangle option</li><li>详情查看文档<ul><li><a href="https://github.com/terser/terser#compress-options">https://github.com/terser/terser#compress-options</a></li><li><a href="https://github.com/terser/terser#mangle-options">https://github.com/terser/terser#mangle-options</a></li></ul></li></ul></li></ul><h3 id="Webpack中配置Terser">Webpack中配置Terser</h3><ul><li><p>首先，需要打开minimize，让其对代码进行压缩(默认production模式下已经打开了)</p></li><li><p>其次，可以在minimizer创建一个TerserPlugin:</p><ul><li>extractComments:默认值为true，表示会将注释抽取到一个单独的文件中;<ul><li>在开发中，不希望保留这个注释时，可以设置为false;</li></ul></li><li>parallel:使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量: os.cpus().length - 1;<ul><li>也可以设置自己的个数，但是使用默认值即可;</li></ul></li><li>terserOptions:设置terser相关的配置<ul><li>compress:设置压缩相关的选项;</li><li>mangle:设置丑化相关的选项，可以直接设置为true;</li><li>toplevel:底层变量是否进行转换;</li><li>keep_classnames:保留类的名称;</li></ul></li></ul></li></ul><h2 id="CSS压缩">CSS压缩</h2><ul><li><p>另一个代码的压缩是CSS:</p><ul><li>CSS压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等;</li><li>CSS的压缩我们可以使用另外一个插件:css-minimizer-webpack-plugin;</li><li>css-minimizer-webpack-plugin是使用cssnano工具来优化、压缩CSS(也可以单独使用);</li></ul></li><li><p>安装 css-minimizer-webpack-plugin:</p><ul><li><code>npm i css-minimizer-webpack-plugin</code></li></ul></li><li><p>在optimization.minimizer中配置</p></li></ul><h2 id="配置示例">配置示例</h2><ul><li>webpack.prod.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProduction = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> CssMiniMizerPlugin = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        chunkIds: <span class="string">&quot;deterministic&quot;</span>,</span><br><span class="line">        minimize:<span class="literal">true</span>,</span><br><span class="line">        minimizer:[</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                extractComments:<span class="literal">true</span>,</span><br><span class="line">                parallel:<span class="literal">true</span>,</span><br><span class="line">                terserOptions:&#123;</span><br><span class="line">                    compress:<span class="literal">true</span>,</span><br><span class="line">                    mangle:<span class="literal">true</span>,</span><br><span class="line">                    toplevel:<span class="literal">false</span>,</span><br><span class="line">                    keep_classnames:<span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> CssMiniMizerPlugin(&#123;</span><br><span class="line">                parallel:<span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">            patterns: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">from</span>: <span class="string">&quot;public&quot;</span>,</span><br><span class="line">                    <span class="comment">// 可不写，默认到output</span></span><br><span class="line">                    to: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    globOptions: &#123;</span><br><span class="line">                        ignore: [<span class="string">&quot;**/index.html&quot;</span>, <span class="string">&quot;**/.DS_Store&quot;</span>, <span class="string">&quot;**/abc.txt&quot;</span>],</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<a href="https://juejin.cn/post/6969018138591494158">打包优化]Webpack体积压缩 (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Webpack </tag>
            
            <tag> 打包构建 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> Loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[分享]Webpack打包分析工具</title>
      <link href="2021/06/07/Webpack%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>2021/06/07/Webpack%E6%89%93%E5%8C%85%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6968275465572188191">分享]Webpack打包分析工具 (juejin.cn)</a></p></blockquote><h1>Webpack打包分析</h1><blockquote><p>分享时间和文件的分析工具，便于进行打包优化。</p></blockquote><h2 id="打包的时间分析">打包的时间分析</h2><ul><li><p>如果希望看到每一个Loader、每一个Plugin消耗的打包时间，可以借助于一个插件:speed-measure-webpack-plugin</p><ul><li>注意:该插件在最新的webpack版本中存在一些兼容性的问题(和部分Plugin不兼容)</li><li>截止2021-3-10日，但是目前该插件还在维护，所以可以等待后续是否更新;</li></ul></li><li><p>安装</p><ul><li><code>npm i speed-measure-webpack-plugin</code></li></ul></li><li><p>使用</p><ul><li>创建插件导出的对象 SpeedMeasurePlugin;</li><li>使用 smp.wrap 包裹我们导出的webpack配置;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SpeedMeasurePlugin = <span class="built_in">require</span>(<span class="string">&quot;speed-measure-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin()</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isProduction = env.production;</span><br><span class="line">    process.env.NODE_ENV = isProduction ? <span class="string">&quot;production&quot;</span> : <span class="string">&quot;development&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> config = isProduction ? prodConfig : devConfig</span><br><span class="line">    <span class="keyword">const</span> webpackConfig = merge(commonConfig(isProduction), config)</span><br><span class="line">    <span class="keyword">return</span> smp.wrap(webpackConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>效果</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/33dce190bd2344059ba35f5923d08985~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210502234038719"></p><h2 id="打包后的文件分析">打包后的文件分析</h2><h3 id="方案一：生成stats-json文件">方案一：生成stats.json文件</h3><ul><li>编辑npm script</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;stats&quot;: &quot;webpack --config ./config/webpack.common.js --env production --profile --json=stats.json&quot;, </span><br></pre></td></tr></table></figure><ul><li><p>运行npm run stats</p><ul><li>根目录下生成了一个stats.json</li></ul></li><li><p>json文件内容较复杂，可以将文件上传至https://webpack.github.io/analyse/ 进行分析</p></li><li><p>效果</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e4274bbeb174029a66c2476e471d03e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h3 id="方案二：使用webpack-bundle-analyzer">方案二：使用webpack-bundle-analyzer</h3><ul><li><p>安装</p><ul><li><code>npm install webpack-bundle-analyzer</code></li></ul></li><li><p>webpack.common.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;BundleAnalyzerPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><p>在打包webpack的时候，这个工具打开一个8888端口上的服务，我们可以直观的看到每个包的大小。</p><ul><li>比如有一个包是通过一个Vue组件打包的，但是非常的大，那么我们可以考虑是否可以拆分出多个组件，并且对其进行懒加载;</li><li>比如一个图片或者字体文件特别大，是否可以对其进行压缩或者其他的优化处理;</li></ul></li><li><p>效果</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/7736de9810554f7fb63fcc2dce63b65f~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210502234139506"></p><p>[<a href="https://juejin.cn/post/6968275465572188191">分享]Webpack打包分析工具 (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Webpack </tag>
            
            <tag> 打包构建 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> Loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[打包优化]Webpack DLL</title>
      <link href="2021/06/07/WebpackDLL/"/>
      <url>2021/06/07/WebpackDLL/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6967164397127270436">打包优化]Webpack DLL (juejin.cn)</a></p></blockquote><h1>认识DLL库</h1><ul><li><p>什么是DLL</p><ul><li>DLL全称是动态链接库(Dynamic Link Library)，是为软件在Windows中实现共享函数库的一种实现方式;</li><li>那么webpack中也有内置DLL的功能，它指的是可以将可以共享，并且不经常改变的代码，抽取成一个共享的库;</li><li>这个库在之后编译的过程中，会被引入到其他项目的代码中，减少的打包的时间;</li></ul></li><li><p>DDL库的使用分为两步:</p><ul><li>第一步:打包一个DLL库;</li><li>第二步:项目中引入DLL库</li></ul></li></ul><h2 id="DLL打包">DLL打包</h2><blockquote><p>webpack内置DllPlugin帮助生成DLL文件</p></blockquote><ul><li>webpack.common.js<ul><li>context：执行上下文，</li><li>entry：<ul><li>key：name（placeholder）</li><li>value：要打包的包名</li></ul></li><li>output（常规）</li><li>plugins<ul><li>DllPlugin<ul><li>name：定义生成dll文件的名称</li><li>path：生成dll文件的文件路径</li></ul></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;DllPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;merge&#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="function">(<span class="params">isProduction</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        context: path.resolve(__dirname, <span class="string">&quot;../&quot;</span>),</span><br><span class="line">        entry: &#123;</span><br><span class="line">            react:[<span class="string">&quot;react&quot;</span>,<span class="string">&quot;react-dom&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">           path:path.resolve(__dirname,<span class="string">&quot;../dll&quot;</span>),</span><br><span class="line">            filename:<span class="string">&quot;dll_[name].js&quot;</span>,</span><br><span class="line">            library:<span class="string">&quot;dll_[name]&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> DllPlugin(&#123;</span><br><span class="line">                name:<span class="string">&#x27;[name].manifest.json&#x27;</span>,</span><br><span class="line">                path:path.resolve(__dirname, <span class="string">&quot;../dll/[name].manifest.json&quot;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.dev&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.prod&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isProduction = env.production;</span><br><span class="line">    process.env.NODE_ENV = isProduction ? <span class="string">&quot;production&quot;</span> : <span class="string">&quot;development&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> config = isProduction ? prodConfig : devConfig</span><br><span class="line">    <span class="keyword">return</span> merge(commonConfig(isProduction), config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打包完成后，在根目录下会有一个dll文件夹，内有Dll文件和相应manifest.json文件。</p></blockquote><h2 id="DLL使用">DLL使用</h2><ul><li>如果我们的代码中使用了react、react-dom，有配置splitChunks的情况下，他们会进行分包，打包到 一个独立的chunk中。<ul><li>但是现在有了dll_react，不再需要单独去打包它们，可以直接去引用dll_react即可:</li><li>第一步:通过DllReferencePlugin插件告知要使用的DLL库;</li><li>第二步:通过AddAssetHtmlPlugin插件，将打包的DLL库引入到Html模块中;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">    context:path.resolve(__dirname, <span class="string">&quot;../&quot;</span>),</span><br><span class="line">    manifest:path.resolve(__dirname,<span class="string">&quot;../dll/react.manifest.json&quot;</span>)</span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">    outputPath:<span class="string">&quot;../build/js&quot;</span>,</span><br><span class="line">    filepath:path.resolve(__dirname, <span class="string">&quot;../dll/dll_react.js&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure> <hr/><p>[<a href="https://juejin.cn/post/6967164397127270436">打包优化]Webpack DLL (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Webpack </tag>
            
            <tag> 打包构建 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> Loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[探索]Webpack DevServer和HMR原理</title>
      <link href="2021/06/07/WebpackDevServer%E5%92%8CHMR%E5%8E%9F%E7%90%86/"/>
      <url>2021/06/07/WebpackDevServer%E5%92%8CHMR%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p><p>[<a href="https://juejin.cn/post/6966422095274180639">探索]Webpack DevServer和HMR原理 (juejin.cn)</a></p></blockquote><h1>Webpack-Dev-Server</h1><blockquote><p>为什么要搭建本地服务器</p></blockquote><ul><li><p>目前开发的代码，为了运行需要有两个操作</p><ul><li><code>npm run build</code>编译</li><li>通过live-server或者直接通过浏览器打开html文件，查看效果</li></ul></li><li><p>为了完成自动编译，webpack提供了几种可选的方式</p><ul><li>Webpack watch mode</li><li>Webpack-dev-server</li><li>Webpack-dev-middleware</li></ul></li></ul><h2 id="Webpack-Watch-Mode">Webpack Watch Mode</h2><ul><li><p>webpack提供了watch模式</p><ul><li>在该模式下，webpack依赖图中所有文件，只要有一个发生了更新，那么代码将被重新编译。</li><li>不需要手动<code>npm run build</code></li></ul></li><li><p>如何开启？</p><ul><li>方式一：在导出的配置中，添加watch:true</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;js/bundle.js&quot;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:<span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：在启动webapck的命令中，添加–watch标识</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">npm script:&#123;</span><br><span class="line"> &quot;watch&quot;: &quot;webpack --watch&quot;</span><br><span class="line">&#125;</span><br><span class="line"># npm run watch</span><br></pre></td></tr></table></figure><h2 id="Webpack-Dev-Server">Webpack Dev Server</h2><ul><li><p>上面的方式可以监听到文件的变化，但是没有自动刷新浏览器的功能</p><ul><li>webpack-dev-server可以实现</li></ul></li><li><p>安装</p><ul><li><code>npm install --save webpack-dev-server</code></li></ul></li><li><p>修改npm script，同时可在配置文件中devServer属性下配置devServer</p></li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">script:&#123;</span><br><span class="line">    &quot;serve&quot;:&quot;webpack serve&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>webpack-dev-server在编译之后不会写入到任何输出文件。而是将bundle文件保留在内存中<ul><li>事实上webpck-dev-server使用了一个叫memfs的库。</li></ul></li></ul><h2 id="Webpack-Dev-Middleware">Webpack Dev Middleware</h2><ul><li><p>webpack-dev-middleware是一个封装器，它可以把webpack处理过的文件发送到一个server</p><ul><li>webpack-dev-server在内部使用了它，然而它也可以作为一个单独的package来使用，以便根据需求进行更多自定义配置</li><li>搭配一个服务器来使用它，比如express.</li><li><code>npm install --save express webpack-dev-middleware</code></li></ul></li><li><p>编写Server.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">&quot;webpack-dev-middleware&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>  app = express()</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&quot;./webpack.config&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config)</span><br><span class="line"></span><br><span class="line">app.use(webpackDevMiddleware(compiler,&#123;</span><br><span class="line">    publicPath:config.output.publicPath</span><br><span class="line">&#125;),<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这里是回调函数&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Server running&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Node Server.js即可运行起一个服务，并监听文件更改和刷新浏览器。</li></ul><h2 id="PublicPath">PublicPath</h2><ul><li><p>Output中有两个很重要的属性：path和publicPath</p><ul><li>path：用于指定文件的输出路径，是一个聚堆路径</li><li>publicPath：默认是一个空字符串，它为我们项目中的资源制定一个公共的路径publicPath</li></ul></li><li><p>这个publicPath很不容易理解，其实就是给我们打包的资源，给它一个路径</p><ul><li>资源的路径 = output.publicePath + 打包资源的路径(比如&quot;js/[name].bundle.js&quot;)</li></ul></li><li><p>常用的值</p><ul><li>./ :本地环境下可以使用这个相对路径</li><li>/ :服务器部署时使用，服务器地址 + /js/[name].bundle.js</li></ul></li><li><p>devServer的publicPath、output的publicPath和[webpackDevMiddleware的publicPath]需一致</p></li></ul><h2 id="ContentBase">ContentBase</h2><ul><li><p>devServer中contentBase对于我们直接访问打包后的资源其实并没有太大的作用，它的主要作用是如果我们打包后的资源，又依赖于其他的一些资源，那么就需要指定从哪里来查找这个内容:</p><ul><li>比如在index.html中，我们需要依赖一个 abc.js 文件，这个文件我们存放在 public文件中;</li><li>在index.html中，我们应该如何去引入这个文件?<ul><li>比如代码是这样的:<script src="./public/abc.js"></script>;</li><li>这样打包后浏览器无法通过相对路径去找到这个文件夹;</li><li>所以代码是这样:<script src="/abc.js"></script>;</li><li>如何让它去查找到这个文件的存在? 设置contentBase即可;</li></ul></li></ul></li><li><p>当然在devServer中还有一个可以监听contentBase发生变化后重新编译的一个属性：watchContentBase。</p></li></ul><h2 id="Proxy代理">Proxy代理</h2><blockquote><p>proxy是我们开发中常用的一个配置选项，它的目的设置代理来解决跨域访问的问题</p></blockquote><ul><li>设置<ul><li>target：标识的是代理到的目标地址，比如/api/moment会被代理到http://localhost:8888/api/moment</li><li>pathRewrite：默认情况下，我们的/api也会被写入到URL中，如果希望删除，可以使用</li><li>secure：默认情况下不接受转发到https的服务器，如果希望支持，设置为false</li><li>changeOrigin：表示是否更新代理后请求headers中的host地址</li><li>historyApiFallback：解决SPA页面在路由跳转后，进行页面刷新返回404的错误<ul><li>boolean值：默认是false，如果设置为true，刷新的时候，返回404错误时，会自动返回index.html的内容</li><li>object值：可以配置rewrites属性<ul><li>可以配置from来匹配路径，决定要跳到哪个页面，详情查阅官方文档。</li></ul></li></ul></li></ul></li></ul><h2 id="Other-Config">Other Config</h2><ul><li><p>hotOnly</p><ul><li>默认情况下当代码编译失败修复后会刷新页面，不希望刷新设置hotOnly:true</li></ul></li><li><p>host主机地址</p><ul><li>默认值是localhost</li><li>如果其他PC也可以访问可设置0.0.0.0</li></ul></li><li><p>localhost和0.0.0.0的区别</p><ul><li>localhost本质上是一个域名会被解析为127.0.0.1</li><li>127.0.0.1是一个会换地址，表达得意思是主机自己发出去的包，直接被自己接受<ul><li>正常的数据库包经常 应用层 -&gt; 传输层 -&gt; 网络层 -&gt; 数据链路层 -&gt; 物理层</li><li>而回环地址，在网联络层直接就被获取</li><li>监听127.0.0.1时，同个网段下的主机中，通过ip地址是不能访问的。</li></ul></li><li>0.0.0.0：监听IPV4上所有的地址，再根据端口找到不同的应用程序。<ul><li>监听0.0.0.0时，在同一个网段下的主机中，通过IP地址是可以访问的。</li></ul></li></ul></li><li><p>Port</p><ul><li>设置监听的端口，默认为8080</li></ul></li><li><p>open是否打开浏览器</p><ul><li>默认为false，true会打开浏览器</li><li>也可以设置类似于Google Chrome等值</li></ul></li><li><p>compress是否为静态文件开启gzip compression</p><ul><li>默认是是false，可以设置为true</li></ul></li></ul><h2 id="配置示例">配置示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    hostOnly:<span class="literal">true</span>,</span><br><span class="line">    host:<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    port:<span class="number">8080</span>,</span><br><span class="line">    open:<span class="literal">true</span>,</span><br><span class="line">    compress:<span class="literal">true</span>,</span><br><span class="line">    proxy:&#123;</span><br><span class="line">        <span class="string">&quot;/api&quot;</span>:&#123;</span><br><span class="line">            target:<span class="string">&quot;http://localhost:8888&quot;</span>,</span><br><span class="line">            pathRewrite:&#123;</span><br><span class="line">                <span class="string">&quot;^/api&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            secure:<span class="literal">false</span>,</span><br><span class="line">            changeOrigin:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Hot Module Replacement</h1><ul><li><p>什么是HMR?</p><ul><li>HMR全称Hot Module Replacement，翻译为模块热替换</li><li>模块热替换是指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面。</li></ul></li><li><p>HMR通过如下几种方式，来提高开发的速度。</p><ul><li>不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；</li><li>只需更新需要变化的内容，节省开发时间</li><li>修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的devtools中直接修改样式。</li></ul></li><li><p>如何使用HMR？</p><ul><li>默认情况下，webpack-dev-server已经支持HMR，只需要开启即可。</li><li>在不开启HMR的情况下，修改了源代码后，整个页面会自动刷新，使用的是live reloading。</li></ul></li><li><p>如何开启</p><ul><li>修改webpack.config.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;js/bundle.js&quot;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    watch:<span class="literal">true</span>,</span><br><span class="line">    mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">      hot:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>更新后还是刷新整个浏览器，因为需要定义使用HMR的模块。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">&quot;./App.vue&quot;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;vue更新了&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="框架的HMR">框架的HMR</h2><blockquote><p>有一个问题:在开发其他项目时，我们是否需要经常手动去写入 module.hot.accpet相关的API呢?</p></blockquote><ul><li><p>比如开发Vue、React项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作?</p></li><li><p>社区已经针对这些有很成熟的解决方案了:</p><ul><li>比如vue开发中，我们使用vue-loader，此loader支持vue组件的HMR，提供开箱即用的体验;</li><li>比如react开发中，有React Hot Loader，实时调整react组件(目前React官方已经弃用了，改成使用react- refresh);</li></ul></li></ul><h2 id="Vue的HMR">Vue的HMR</h2><ul><li><p>Vue的加载需要vue-loader，而vue-loader加载的默认会进行HMR处理</p></li><li><p>安装加载Vue所需依赖</p><ul><li><code>npm install vue-loader vue-template-compiler</code></li></ul></li><li><p>配置Webpack.config.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&quot;vue-loader/lib/plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">            use: [<span class="string">&quot;vue-loader&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">   ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[<span class="keyword">new</span> VueLoaderPlugin()]</span><br></pre></td></tr></table></figure><h2 id="React的HMR">React的HMR</h2><ul><li><p>在之前，React是借助React Hot Loader来实现HMR，目前已经改成使用react-refesh来实现了</p></li><li><p>安装相关依赖</p><ul><li><code>npm install @pmmmwh/react-refresh-webpack-plugin react-refresh</code></li></ul></li><li><p>webpack.config.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactRefreshWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;@pmmmwh/react-refresh-webpack-plugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> ReactRefreshWebpackPlugin(),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><ul><li>babel.config.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    presets: [</span><br><span class="line">        [<span class="string">&quot;@babel/preset-env&quot;</span>, &#123;</span><br><span class="line">            useBuiltIns: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">            corejs: <span class="number">3.8</span></span><br><span class="line">        &#125;],</span><br><span class="line">        [<span class="string">&quot;@babel/preset-react&quot;</span>],</span><br><span class="line">        [<span class="string">&quot;@babel/preset-typescript&quot;</span>]</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">        [<span class="string">&#x27;react-refresh/babel&#x27;</span>]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HMR的原理">HMR的原理</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/98219680ad66478c89385a4e0fbaacd8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210502184548214"></p><ul><li><p>那么HMR的原理是什么呢？如何可以做到只更新一个模块中的内容？</p><ul><li>webpack-dev-server会创建两个服务：提供静态资源的服务（express）和Socket（net.Socket）</li><li>Express Server负责直接提供静态资源服务（打包后的资源直接被浏览器请求和解析）</li></ul></li><li><p>HMR Socket Server是一个socket长连接</p><ul><li>长连接有一个最好的好处是建立连接后双方可以通信（服务器可以直接发送文件到客户端）</li><li>当服务期间听到对应模块发上变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li><li>通过长连接，可以直接将这两个文件主动发送给客户端。</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新。</li></ul><hr/></li></ul><p>[<a href="https://juejin.cn/post/6966422095274180639">探索]Webpack DevServer和HMR原理 (juejin.cn)</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Webpack </tag>
            
            <tag> 打包构建 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> Loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack模块化原理和SourceMap</title>
      <link href="2021/05/25/Webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8CSourceMap/"/>
      <url>2021/05/25/Webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%9F%E7%90%86%E5%92%8CSourceMap/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！<br/><a href="https://juejin.cn/post/6965677810862161950">掘金原文链接</a></p></blockquote><h1>Webpack模块化</h1><ul><li><p>Webpack打包的代码，允许我们使用各种各样的模块化，但是最常用的是CommonJS、ES Module。</p></li><li><p>包括如下原理:</p><ul><li>CommonJS模块化实现原理;</li><li>ES Module实现原理;</li><li>CommonJS加载ES Module的原理;</li><li>ES Module加载CommonJS的原理;</li></ul></li></ul><h2 id="CommonJS：">CommonJS：</h2><h3 id="打包前">打包前</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; dateFormat, priceFormat &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./js/format&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dateFormat(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(priceFormat(<span class="string">&quot;abc&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="打包后">打包后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了一个对象</span></span><br><span class="line"><span class="comment">// 模块的路径(key): 函数(value)</span></span><br><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">  <span class="string">&quot;./src/js/format.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> dateFormat = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2020-12-12&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> priceFormat = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;100.00&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将我们要导出的变量, 放入到module对象中的exports对象</span></span><br><span class="line">      <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        dateFormat,</span><br><span class="line">        priceFormat</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个对象, 作为加载模块的缓存</span></span><br><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是一个函数, 当我们加载一个模块时, 都会通过这个函数来加载</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.判断缓存中是否已经加载过</span></span><br><span class="line">  <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_module_cache__[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.给module变量和__webpack_module_cache__[moduleId]赋值了同一个对象</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = __webpack_module_cache__[moduleId] = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.加载执行模块</span></span><br><span class="line">  __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.导出module.exports &#123;dateFormat: function, priceForamt: function&#125;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体开始执行代码逻辑</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.加载./src/js/format.js</span></span><br><span class="line">  <span class="keyword">const</span> &#123; dateFormat, priceFormat &#125; = __webpack_require__(<span class="string">&quot;./src/js/format.js&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(dateFormat(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(priceFormat(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h2 id="ES-Module">ES Module</h2><h3 id="打包前-2">打包前</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum, mul &#125; <span class="keyword">from</span> <span class="string">&quot;./js/math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><h3 id="打包后-2">打包后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义了一个对象, 对象里面放的是我们的模块映射</span></span><br><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">  <span class="string">&quot;./src/es_index.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 调用r的目的是记录时一个__esModule -&gt; true</span></span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// _js_math__WEBPACK_IMPORTED_MODULE_0__ == exports</span></span><br><span class="line">      <span class="keyword">var</span> _js_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">&quot;./src/js/math.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(_js_math__WEBPACK_IMPORTED_MODULE_0__.mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">      <span class="built_in">console</span>.log(_js_math__WEBPACK_IMPORTED_MODULE_0__.sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    &#125;),</span><br><span class="line">  <span class="string">&quot;./src/js/math.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用了d函数: 给exports设置了一个代理definition</span></span><br><span class="line">      <span class="comment">// exports对象中本身是没有对应的函数</span></span><br><span class="line">      __webpack_require__.d(__webpack_exports__, &#123;</span><br><span class="line">        <span class="string">&quot;sum&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> sum; &#125;,</span><br><span class="line">        <span class="string">&quot;mul&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> mul; &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> mul = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.模块的缓存</span></span><br><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.require函数的实现(加载模块)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_module_cache__[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = __webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// __webpack_require__这个函数对象添加了一个属性: d -&gt; 值function</span></span><br><span class="line">  __webpack_require__.d = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, definition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> definition) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(<span class="built_in">exports</span>, key)) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, key, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">get</span>: definition[key] &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// __webpack_require__这个函数对象添加了一个属性: o -&gt; 值function </span></span><br><span class="line">  __webpack_require__.o = <span class="function"><span class="keyword">function</span> (<span class="params">obj, prop</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop); &#125;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// __webpack_require__这个函数对象添加了一个属性: r -&gt; 值function</span></span><br><span class="line">  __webpack_require__.r = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">&#x27;Module&#x27;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__webpack_require__(<span class="string">&quot;./src/es_index.js&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="ES-Module和CommonJS混合导入导出">ES Module和CommonJS混合导入导出</h2><h3 id="打包前-3">打包前</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es module导出内容, CommonJS导入内容</span></span><br><span class="line"><span class="keyword">const</span> &#123; sum, mul &#125; = <span class="built_in">require</span>(<span class="string">&quot;./js/math&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS导出内容, es module导入内容</span></span><br><span class="line"><span class="keyword">import</span> &#123; dateFormat, priceFormat &#125; <span class="keyword">from</span> <span class="string">&quot;./js/format&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dateFormat(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(priceFormat(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(abc);</span><br></pre></td></tr></table></figure><h3 id="打包后-3">打包后</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> __webpack_modules__ = (&#123;</span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">      &quot;use strict&quot;</span>;</span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line">      <span class="keyword">var</span> _js_format__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">&quot;./src/js/format.js&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> _js_format__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_js_format__WEBPACK_IMPORTED_MODULE_0__);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// es module导出内容, CommonJS导入内容</span></span><br><span class="line">      <span class="keyword">const</span> math = __webpack_require__(<span class="string">&quot;./src/js/math.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CommonJS导出内容, es module导入内容</span></span><br><span class="line">      <span class="built_in">console</span>.log(math.sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">      <span class="built_in">console</span>.log(math.mul(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">      <span class="built_in">console</span>.log(_js_format__WEBPACK_IMPORTED_MODULE_0___default().dateFormat(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line">      <span class="built_in">console</span>.log(_js_format__WEBPACK_IMPORTED_MODULE_0___default().priceFormat(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">    &#125;),</span><br><span class="line">  <span class="string">&quot;./src/js/format.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> dateFormat = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;2020-12-12&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> priceFormat = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;100.00&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        dateFormat,</span><br><span class="line">        priceFormat</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;./src/js/math.js&quot;</span>:</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      </span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line">      __webpack_require__.d(__webpack_exports__, &#123;</span><br><span class="line">        <span class="string">&quot;sum&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> sum; &#125;,</span><br><span class="line">        <span class="string">&quot;mul&quot;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> mul; &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> mul = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The require function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check if module is in cache</span></span><br><span class="line">  <span class="keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_module_cache__[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = __webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="comment">// no module.id needed</span></span><br><span class="line">    <span class="comment">// no module.loaded needed</span></span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute the module function</span></span><br><span class="line">  __webpack_modules__[moduleId](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the exports of the module</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// getDefaultExport function for compatibility with non-harmony modules</span></span><br><span class="line">  __webpack_require__.n = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> getter = <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule ?</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">&#x27;default&#x27;</span>]; &#125; :</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>; &#125;;</span><br><span class="line">    __webpack_require__.d(getter, &#123; <span class="attr">a</span>: getter &#125;);</span><br><span class="line">    <span class="keyword">return</span> getter;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webpack/runtime/define property getters */</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// define getter functions for harmony exports</span></span><br><span class="line">  __webpack_require__.d = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, definition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> definition) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(<span class="built_in">exports</span>, key)) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, key, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">get</span>: definition[key] &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webpack/runtime/hasOwnProperty shorthand */</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  __webpack_require__.o = <span class="function"><span class="keyword">function</span> (<span class="params">obj, prop</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop); &#125;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webpack/runtime/make namespace object */</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// define __esModule on exports</span></span><br><span class="line">  __webpack_require__.r = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">&#x27;Module&#x27;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">__webpack_require__(<span class="string">&quot;./src/index.js&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><blockquote><p>原理都是类似的</p></blockquote><ol><li>通过一个webpack_module对象来存储模块化代码<ul><li>key为文件名称</li><li>value为文件代码</li></ul></li><li>通过webpack_module_cache来缓存模块化代码</li><li>通过webpack_require来从webpack_module_cache或webpack_module中读取并从引入代码</li></ol><h2 id="认识Source-Map">认识Source-Map</h2><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/SourceMap.jsm">参考文档 </a></p></blockquote><ul><li><p>我们的代码通常运行在浏览器上时，是通过打包压缩的:</p><ul><li>也就是真实跑在浏览器上的代码，和我们编写的代码其实是有差异的;</li><li>比如ES6的代码可能被转换成ES5;</li><li>比如对应的代码行号、列号在经过编译后肯定会不一致;</li><li>比如代码进行丑化压缩时，会将编码名称等修改;</li><li>比如我们使用了TypeScript等方式编写的代码，最终转换成JavaScript;</li></ul></li><li><p>通过SourceMap可以调试这种转换后不一致的代码</p><ul><li>source-map是从已转换的代码，映射到原始的源文件;</li><li>使浏览器可以重构原始源并在调试器中显示重建的原始源;</li><li>更容易定位到源文件错误</li></ul></li></ul><h3 id="如何使用SourceMap">如何使用SourceMap</h3><ul><li><p>第一步:根据源文件，生成source-map文件，webpack在打包时，可以通过配置生成source-map;</p><p><code>devtool:'source-map'</code></p></li><li><p>第二步:在转换后的代码，最后添加一个注释，它指向sourcemap;</p><p><code>//# sourceMappingURL=common.bundle.js.map</code></p></li><li><p>浏览器会根据我们的注释，查找相应的source-map，并且根据source-map还原我们的代码，方便进行调试。</p></li><li><p>在Chrome中，我们可以按照如下的方式打开source-map:</p><ul><li>√Enable JavaScript source maps</li><li>√Enable CSS source maps</li></ul></li><li><p>最初source-map生成的文件带下是原始文件的10倍，第二版减少了约50%，第三版又减少了50%，所以目前一个 133kb的文件，最终的source-map的大小大概在300kb。</p></li><li><p>目前的source-map长什么样子？</p><ul><li>version:当前使用的版本，也就是最新的第三版;</li><li>sources:从哪些文件转换过来的source-map和打包的代码(最初始的文件);</li><li>names:转换前的变量和属性名称(因为目前使用的是development模式，所以不需要保留转换前的名称);</li><li>mappings:source-map用来和源文件映射的信息(比如位置信息等)，一串base64 VLQ(veriable- length quantity可变长度值)编码;</li><li>file:打包后的文件(浏览器加载的文件);</li><li>sourceContent:转换前的具体代码信息(和sources是对应的关系);</li><li>sourceRoot:所有的sources相对的根目录;</li></ul></li></ul><h3 id="生成SourceMap">生成SourceMap</h3><blockquote><p>如何在使用webpack打包的时候，生成对应的source-map?</p></blockquote><ul><li><p>webpack为我们提供了非常多的选项(目前是26个)，来处理source-map;</p></li><li><p>参考文档：<a href="https://webpack.docschina.org/configuration/devtool/">https://webpack.docschina.org/configuration/devtool/</a></p></li><li><p>选择不同的值，生成的source-map会稍微有差异，打包的过程也会有性能的差异，可以根据不同的情况进行 选择;</p></li></ul><blockquote><p>下面几个值不会生成source-map</p></blockquote><ul><li><p>false:不使用source-map，也就是没有任何和source-map相关的内容。</p></li><li><p>none:production模式下的默认值（什么值都不写），不生成source-map。</p></li><li><p>eval:development模式下的默认值，不生成source-map</p><ul><li>但是它会在eval执行的代码中，添加 //# sourceURL=;</li><li>它会被浏览器在执行时解析，并且在调试面板中生成对应的一些文件目录，方便我们调试代码;</li></ul></li></ul><blockquote><p>使用source-map的值</p></blockquote><ul><li><p>source-map</p><ul><li>生成独立的source-map文件，并在打包后的JS文件中有一个注释指向source-map文件；<ul><li>注释：   `` //# sourceMappingURL=bundle.js.map`</li></ul></li></ul></li><li><p>eval-source-map</p><ul><li>source-map以DataUrl的形式添加到eval函数后面</li></ul></li><li><p>inline-source-map</p><ul><li>source-map以DataUrl的形式添加到打包后的JS文件后面（注释）</li></ul></li><li><p>cheap-source-map:</p><ul><li>会生成source-map，但是会更加高效一些(cheap低开销)，因为它没有生成列映射(Column Mapping)</li><li>因为在开发中，我们只需要行信息通常就可以定位到错误了</li></ul></li><li><p>cheap-module-source-map:</p><ul><li>会生成source-map，类似于cheap-source-map，但是对源自loader的source-map处理会更好。</li><li>对源自loader的source-map处理会更好，官方也没有给出很好的解释 其实是如果loader对我们的源码进行了特殊的处理，比如babel,会恢复成源文件的代码模块格式，例如不会删除自定义的空行。</li></ul></li><li><p>hidden-source-map:</p><ul><li>会生成sourcemap，但是不会对source-map文件进行引用;</li><li>相当于删除了打包文件中对sourcemap的引用注释</li><li># sourceMappingURL=bundle.js.map</li><li>如果手动添加进来，那么source-map就会生效了</li></ul></li><li><p>nosources-source-map:</p><ul><li>会生成sourcemap，但是生成的sourcemap只有错误信息的提示，不会生成源代码文件;</li><li>点击错误信息也无法查看源码</li></ul></li></ul><blockquote><p>多个值的组合</p></blockquote><ul><li><p>事实上，webpack提供给我们的26个值，是可以进行多组合的。</p></li><li><p>组合的规则如下:</p></li><li><p>inline-|hidden-|eval:三个值时三选一;</p></li><li><p>nosources:可选值;</p></li><li><p>cheap可选值，并且可以跟随module的值;</p></li></ul><blockquote><p>那么在开发中，最佳的实践是什么呢?</p></blockquote><ul><li><p>开发阶段:推荐使用 source-map或者cheap-module-source-map</p><ul><li>这分别是vue和react使用的值，可以获取调试信息，方便快速开发;</li></ul></li><li><p>测试阶段:推荐使用 source-map或者cheap-module-source-map</p><ul><li>测试阶段我们也希望在浏览器下看到正确的错误提示;</li></ul></li><li><p>发布阶段:false、缺省值(不写)</p></li></ul><hr/><p><a href="https://juejin.cn/post/6965677810862161950">掘金原文链接</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Webpack </tag>
            
            <tag> 打包构建 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> Loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack_Plugin知识分享</title>
      <link href="2021/05/22/Webpack-Plugin%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
      <url>2021/05/22/Webpack-Plugin%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！<br/><a href="https://juejin.cn/post/6963822022434504734">掘金原文链接</a></p></blockquote><h1>认识Plugin</h1><ul><li><p>Loader是用于特定的模块类型进行转换;</p></li><li><p>Plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等;</p></li></ul><h1>常用Plugin</h1><h2 id="CleanWebpackPlugin">CleanWebpackPlugin</h2><ul><li><p>每次修改了一些配置，重新打包时，都需要手动删除dist文件夹:</p></li><li><p>我们可以借助于一个插件来帮助我们完成，这个插件就是CleanWebpackPlugin;</p></li></ul><h3 id="安装：">安装：</h3><ul><li><code>npm install clean-webpack-plugin --save</code></li></ul><h3 id="配置：">配置：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> CleanWebpackPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="HtmlWebpackPlugin">HtmlWebpackPlugin</h2><ul><li><p>我们的HTML文件是编写在根目录下的，而最终打包的dist文件夹中是没有index.html文件的。</p></li><li><p>在进行项目部署的时，必然也是需要有对应的入口文件index.html;</p></li><li><p>所以我们也需要对index.html进行打包处理;</p></li></ul><h3 id="安装">安装</h3><ul><li><code>npm install html-webpack-plugin --save</code></li></ul><h3 id="配置">配置</h3><ul><li><p>可传入变量例如title，</p></li><li><p>可自定义模板，template填写模板路径</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">&quot;LeBronChao Webpack&quot;</span>,</span><br><span class="line">      template: <span class="string">&quot;./public/index.html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="模板和变量引用方法">模板和变量引用方法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>LeBronChao Webpack<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="效果">效果</h3><ul><li><p>现在自动在build文件夹中，生成了一个index.html的文件</p></li><li><p>该文件中也自动添加了我们打包的bundle.js文件</p></li><li><p>这个文件是如何生成的呢?</p><ul><li>默认情况下是根据ejs的一个模板来生成的;</li><li>在html-webpack-plugin的源码中，有一个default_index.ejs模块;</li></ul></li></ul><h2 id="DefinePlugin">DefinePlugin</h2><blockquote><p>用于定义全局常量</p></blockquote><h3 id="安装-2">安装</h3><ul><li>Webpack内置，无需安装</li></ul><h3 id="配置-2">配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; DefinePlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> DefinePlugin(&#123;</span><br><span class="line">      BASE_URL: <span class="string">&quot;&#x27;./favicon.ico&#x27;&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ol><li>定义的变量赋值时若为字符串需嵌套字符串，若为变量在&quot;&quot;内填写变量，如上。</li></ol></blockquote><h3 id="模板中的使用方法">模板中的使用方法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>LeBronChao Webpack<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CopyWebpackPlugin">CopyWebpackPlugin</h2><ul><li>在vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist文件夹中。<ul><li>这个复制的功能，我们可以使用CopyWebpackPlugin来完成;</li></ul></li></ul><h3 id="安装：-2">安装：</h3><ul><li><code>npm install copy-webpack-plugin --save</code></li></ul><h3 id="配置：-2">配置：</h3><ul><li><p>复制的规则在patterns中设置;</p></li><li><p>from:设置从哪一个源中开始复制;</p></li><li><p>to:复制到的位置，可以省略，会默认复制到打包的目录下,路径编写以打包目录为根目录;</p></li><li><p>globOptions:设置一些额外的选项，其中ignore可以编写需要忽略的文件:</p><ul><li>DS_Store:mac目录下会自动生成的一个文件;</li><li>index.html:也不需要复制，因为我们已经通过HtmlWebpackPlugin完成了index.html的生成;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;...&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">from</span>: <span class="string">&quot;public&quot;</span>,</span><br><span class="line">          <span class="comment">// 可不写，默认到output</span></span><br><span class="line">          to: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">          globOptions: &#123;</span><br><span class="line">            ignore: [<span class="string">&quot;**/index.html&quot;</span>, <span class="string">&quot;**/.DS_Store&quot;</span>, <span class="string">&quot;**/abc.txt&quot;</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>自定义Plugin</h1><ul><li><p>webpack有两个非常重要的类Compiler和Compilation</p><ul><li>他们通过注入插件的方式，来监听webpack的所有生命周期</li><li>插件的注入离不开各种各样的Hook</li><li>Hook来源于Tapable库</li></ul></li><li><p>想自定义Plugin，先了解一个库Tapable</p><ul><li>Tapable是官方编写和维护的一个库</li><li>Tapable是管理着需要的Hook，这些Hook可以应用到插件中</li></ul></li></ul><h2 id="Tapable-Hook分类">Tapable Hook分类</h2><ul><li><p>同步Sync</p><ul><li>SyncHook</li><li>SyncBailHook</li><li>SyncWaterfallHook</li><li>SyncLoopHook</li></ul></li><li><p>异步Async</p><ul><li>Paralle（并行）<ul><li>AsyncPrarllelHook</li><li>AsyncParallelBailHook</li></ul></li><li>Series（串行）<ul><li>AsyncSeriesHook</li><li>AsyncSeriesBailHook</li><li>AsyncSeriresWaterfallHook</li></ul></li><li>同步和异步的<ul><li>以sync开头的为同步hook</li><li>以async开头的，两个事件处理回调，不会等待上一次处理回调结束后再执行下一次回调。</li></ul></li></ul></li><li><p>其他的类别</p><ul><li>baill：当有返回值时，就不会执行后续的事件触发了。</li><li>Loop：当返回值为true时，就会反复执行该事件，当返回值为undefined或者不返回内容时，退出事件</li><li>Waterfall：当返回值不为undefined时，会将这次返回的结果作为下次事件的第一个参数</li><li>Parallel：并行，会同时执行事件处理回调的Hook</li><li>Series：串行，会等待上一事件处理回调的Hook</li></ul></li></ul><h2 id="Hook的使用过程">Hook的使用过程</h2><ol><li><p>创建Hook对象</p><ul><li>New 对象传入的数组为需传入参数key</li></ul></li><li><p>注册Hook中的事件</p></li><li><p>触发事件</p></li></ol><ul><li>plugin.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;SyncWaterfallHook&#125; = <span class="built_in">require</span>(<span class="string">&quot;tapable&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tapableTest</span></span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hooks = &#123;</span><br><span class="line">            syncHook:<span class="keyword">new</span> SyncWaterfallHook([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.hooks.syncHook.tap(<span class="string">&quot;event1&quot;</span>,<span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;event1&quot;</span>, name, age);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;event1&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.hooks.syncHook.tap(<span class="string">&quot;event2&quot;</span>,<span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;event2&quot;</span>, name, age);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">emit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.hooks.syncHook.call(<span class="string">&quot;lebron&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index= <span class="keyword">new</span> tapableTest()</span><br><span class="line">index.emit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// event1 lebron 21 </span></span><br><span class="line"><span class="comment">// event2 event1 21</span></span><br></pre></td></tr></table></figure><h2 id="自定义一个AutoUploadPlugin">自定义一个AutoUploadPlugin</h2><blockquote><p>前端开发完成后，经常要打包上传代码。个人开发者一般会使用Nginx部署服务，每次上传代码太麻烦了，自己写个Plugin让他自动上传到Nginx文件夹吧。</p></blockquote><ul><li>plugin配置<ul><li>host：主机地址</li><li>username：主机用户名</li><li>password：主机ssh登录密码</li><li>remotePath：远程部署服务的文件夹</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AutoUploadPlugin = <span class="built_in">require</span>(<span class="string">&quot;../plugins/autoUploadPlugin&quot;</span>)</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlgin(),</span><br><span class="line">    <span class="keyword">new</span> AutoUploadPlugin(&#123;</span><br><span class="line">        host:<span class="string">&quot;xx.xx.xx.xx&quot;</span>,</span><br><span class="line">        username:<span class="string">&quot;root&quot;</span>,</span><br><span class="line">        password:<span class="string">&quot;xxxxxxx&quot;</span>,</span><br><span class="line">        remotePath:<span class="string">&quot;/test&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>AutoUploadPlugin.js<ul><li><p>借助node-ssh库完成远程系列操作</p><ol><li><code>npm i node-ssh</code></li></ol></li><li><p>Constructor</p><ol><li><p>生成ssh对象</p></li><li><p>接收options参数-</p></li></ol></li><li><p>每个Plugin都需要一个apply函数来注册插件</p><ol><li>通过compiler对象调用hooks注册事件</li><li>通过compilation对象获取打包输出文件夹路径</li><li>建立ssh连接</li><li>删除远程服务器中原本的内容</li><li>上传生成后的文件到服务器</li><li>关闭ssh连接</li><li>执行回调</li></ol></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; NodeSSH &#125; = <span class="built_in">require</span>(<span class="string">&quot;node-ssh&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoUploadPlugin</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.ssh = <span class="keyword">new</span> NodeSSH()</span><br><span class="line">        <span class="built_in">this</span>.options = options</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply (compiler) &#123;</span><br><span class="line">        <span class="comment">// 使用文件生成后的钩子</span></span><br><span class="line">        compiler.hooks.afterEmit.tapAsync(<span class="string">&quot;AutoUploadPlugin&quot;</span>, <span class="keyword">async</span> (compilation, callback) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 获取输出的文件夹路径</span></span><br><span class="line">            <span class="keyword">const</span> outputPath = compilation.outputOptions.path</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 连接服务器（ssh）</span></span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.connectServer()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 删除原来目录中的内容</span></span><br><span class="line">            <span class="keyword">const</span> serverDir = <span class="built_in">this</span>.options.remotePath</span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.ssh.execCommand(<span class="string">`rm -rf <span class="subst">$&#123;serverDir&#125;</span>/*`</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 上传文件到服务器</span></span><br><span class="line">            <span class="keyword">await</span> <span class="built_in">this</span>.uploadFiles(outputPath, serverDir)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 关闭SSH</span></span><br><span class="line">            <span class="built_in">this</span>.ssh.dispose();</span><br><span class="line"></span><br><span class="line">            callback()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> connectServer () &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">this</span>.ssh.connect(&#123;</span><br><span class="line">            host: <span class="built_in">this</span>.options.host,</span><br><span class="line">            username: <span class="built_in">this</span>.options.username,</span><br><span class="line">            password: <span class="built_in">this</span>.options.password</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> uploadFiles (localPath, remotePath) &#123;</span><br><span class="line">        <span class="keyword">const</span> status = <span class="keyword">await</span> <span class="built_in">this</span>.ssh.putDirectory(localPath, remotePath, &#123;</span><br><span class="line">            <span class="comment">// 递归上传所有文件</span></span><br><span class="line">            recursive: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 并发数</span></span><br><span class="line">            concurrency: <span class="number">10</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Upload &quot;</span> + status ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = AutoUploadPlugin</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6963822022434504734">掘金原文链接</a></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Webpack </tag>
            
            <tag> 打包构建 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> Loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack Loader知识分享</title>
      <link href="2021/05/18/Webpack%20Loader%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
      <url>2021/05/18/Webpack%20Loader%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！<br/>如果觉得文章不错，欢迎关注、点赞和分享！</p></blockquote><h1>认识Loader</h1><blockquote><p>Loader可以用于对模块的源代码进行转换；</p><p>在加载这个模块时，webpack其实并不知道如何对其进行加载，我们必须定制对应的loader来完成这个功能。</p></blockquote><h2 id="loader配置方式">loader配置方式</h2><ul><li><p>内联方式：<code>import &quot;css-loader!../css/index.css&quot;</code>; loader和文件路径用！分隔</p></li><li><p>配置方式：webpack.config.js</p></li><li><p>配置方式表示的意思是在我们的webpack.config.js文件中写明配置信息</p><ul><li>module.rules中允许我们配置多个loader（因为我们也会继续使用其他Loader，来完成其他文件的加载）</li><li>这种方式可以更好地标识loader配置，也方便后期的维护，同时也让你对各个Loader有一个全局的概览；</li></ul></li><li><p>module.rules的配置如下</p></li><li><p>rules属性对应的值是一个数组：[Rule]</p></li><li><p>数组中存放的是一个个Rule，Rule是一个对象，对象中可以设置多个属性</p><ul><li>test属性：用于多resource（资源）文件名进行匹配，通常会设置成正则表达式；</li><li>use属性：对应的值是一个数组[useEntry]<ul><li>执行顺序从后往前，比如解析css，css-loader应在style-loader后面。</li><li>UseEntry是一个对象，可以通过对象的属性来设置一些其他属性<ul><li>loader：必须有一个loader属性，对应的值是一个字符串</li><li>options：可选的属性，值是一个字符串或者对象，值会被传入到loader中；</li><li>query：目前已被options替代</li></ul></li><li>传递字符串（如：use:[‘style-loader’]）是loader属性的简写（如：use:[{loader:‘style-loader’}]）</li></ul></li></ul></li></ul><h1>常见Loader</h1><h2 id="CSS-loader">CSS loader</h2><ul><li><p>我们可以将css文件也看成是一个模块，我们是通过import来加载这个模块的</p></li><li><p>那么需要一个什么样的loader呢</p><ul><li><p>对于加载css文件来说，我们需要一个可以读取css文件的loader</p></li><li><p>最常用的是css-loader</p></li><li><p>只负责解析css文件，不会作用于页面，此外还需要style-loader作用于页面</p><p><code>npm i style-loader --save</code></p></li></ul></li><li><p>css-loader的安装：</p><p><code>npm install css-loader --save</code></p></li><li><p>以下为一个css-loader的配置文件</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">//资源文件匹配正则表达式</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 简写：</span></span><br><span class="line">          <span class="comment">// “css-loader”</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>less同理</p><p><code>npm install less-loader less --save</code>安装这两个插件后</p></li><li><p>依次在use数组内写入style-loader、css-loader、less-loader</p></li></ul><h2 id="浏览器兼容性">浏览器兼容性</h2><ul><li><p>如果在css兼容性和js兼容性下共享我们的配置兼容性条件呢</p><ul><li>就是当我么们设置了一个条件：&gt;1% last 2 version Firefox、Chrome… not dead 都是可选项，多个选项以，分隔为 || 条件；and为&amp;&amp;关系；可用not条件</li><li>意思为js、css兼容市场占有率大于1%的Firefox、Chrome浏览器和最新的两个版本，并且24个月内有官方支持和更新的浏览器（dead过滤条件）</li></ul></li><li><p>在根目录.browserlistrc文件编写条件</p></li><li><p>通过可实现对市场占有比率的要去，版本要求等进行配置，适配浏览器</p></li><li><p>所用工具：</p><ul><li>数据来源：browserlist，浏览器市场占有率，精确到每个版本</li><li>处理插件：autoprefixer、babel、postcss-preset-env等</li></ul></li></ul><h2 id="认识PostCSS工具">认识PostCSS工具</h2><ul><li><p>什么是PostCSS工具呢？</p><ul><li>PostCSS是一个通过JavaScript来转换样式的工具</li><li>这个工具可以帮助我们进行一些CSS样式的转换和适配，比如自动添加浏览器前缀、css样式的充值；</li><li>但是实现这些功能，我们需要借助于PostCSS插件</li></ul></li><li><p>如何使用PostCSS</p></li></ul><ol><li>查找PostCSS在构建工具中的扩展，比如webpack中的postcss-loader；</li><li>选择可以添加你需要的PostCss相关插件</li></ol><h3 id="手动使用PostCSS">手动使用PostCSS</h3><blockquote><p>使用postcss-cli操作，需要用到autoprefixer插件</p></blockquote><ol><li><code>npm install postcss postcss-cli --save</code></li><li><code>npm install autoprefixer --save</code></li><li><code>npx postcss --use autoprefixer  -o '输出路径'   '输出路径' </code>，例如：<ol><li><code>npx postcss --use autoprefixer  -o ./src/css/result.css ./src/css/user.css</code></li></ol></li></ol><h3 id="Webpack配置文件使用PostCSS">Webpack配置文件使用PostCSS</h3><ol><li>安装postcss-loader和autoprefixer<ul><li><code>npm install postcss-loader autoprefixer --save</code></li></ul></li><li>编写配置文件<ul><li>css-loader处理前先用postcss-loader处理</li><li>在options的postcssOptions中，配置plugins，使用autoprefixer</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">//资源文件匹配正则表达式</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 简写：</span></span><br><span class="line">          <span class="comment">// “css-loader”</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              postcssOptions: &#123;</span><br><span class="line">                plugins: [<span class="built_in">require</span>(<span class="string">&quot;autoprefixer&quot;</span>)],</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="postcss-preset-env">postcss-preset-env</h3><ul><li><p>事实上，在配置postcss-loader时，我们配置插件并不需要使用autoprefixer。</p></li><li><p>我们可以使用另外一个插件:postcss-preset-env</p><ul><li><p>postcss-preset-env也是一个postcss的插件;</p></li><li><p>它可以帮助我们将一些现代的CSS特性，转成大多数浏览器认识的CSS，并且会根据目标浏览器或者运行时环 境添加所需的polyfill;</p><ul><li>例如八位的十六进制颜色会帮我们转换成RGBA</li></ul></li><li><p>也包括会自动帮助我们添加autoprefixer(所以相当于已经内置了autoprefixer);</p></li><li><p>首先，我们需要安装postcss-preset-env:</p><p><code>npm install postcss-preset-env --save</code></p></li><li><p>之后，我们直接修改掉之前的autoprefixer即可:</p></li></ul></li><li><p>配置简化</p><ul><li>在use中只写postcss-loader</li><li>在项目根目录建立postcss.config.js，写入配置</li></ul></li></ul><blockquote><p>webpack.config.js</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">//资源文件匹配正则表达式</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 简写：</span></span><br><span class="line">          <span class="comment">// “css-loader”</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;postcss-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>postcss.config.js</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">      <span class="comment">// 引入</span></span><br><span class="line">      <span class="comment">// require(&quot;postcss-preset-env&quot;)</span></span><br><span class="line">      <span class="comment">//简写</span></span><br><span class="line">      <span class="string">&quot;postcss-preset-env&quot;</span></span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="效果">效果</h3><blockquote><p>Before</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:fullscreen</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    user-select: none;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">2s</span> ease;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>After</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">:-webkit-full-screen&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:-ms-fullscreen&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:fullscreen</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">       -moz-user-select: none;</span><br><span class="line">        -ms-user-select: none;</span><br><span class="line">            user-select: none;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">2s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVzZXIuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUZBOztBQUVBOztBQUZBOztBQUVBOztBQUVBO0lBQ0kseUJBQWlCO09BQWpCLHNCQUFpQjtRQUFqQixxQkFBaUI7WUFBakIsaUJBQWlCO0lBQ2pCLHVCQUF1QjtBQUMzQiIsImZpbGUiOiJyZXN1bHQuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiOmZ1bGxzY3JlZW57XG5cbn1cblxuLmNvbnRlbnR7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgdHJhbnNpdGlvbjogYWxsIDJzIGVhc2U7XG59Il19 */</span></span><br></pre></td></tr></table></figure><h2 id="importLoaders">importLoaders</h2><ul><li><p>正常css文件解析遇到@import，不会再从use数组最后一个loader开始重新解析</p></li><li><p>通过设置importLoaders可以实现递归解析</p></li><li><p>填写的数字为在use数组中往后的loader的数量</p></li><li><p>例如：</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/js/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">//资源文件匹配正则表达式</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 简写：</span></span><br><span class="line">          <span class="comment">// “css-loader”</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 完整写法</span></span><br><span class="line">            loader: <span class="string">&quot;css-loader&quot;</span>, <span class="comment">// 对应的loader</span></span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;less-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="File-Loader">File Loader</h2><blockquote><p>希望解析、读取文件，例如图片</p></blockquote><ol><li>安装file-loader<ul><li><code>npm install --save file-loader</code></li></ul></li><li>编写配置文件</li></ol><blockquote><p>rule：</p></blockquote><ul><li>options解释：<ul><li>name:输出名称，[name]名称引用，.字符，[hash:6]哈希信息截取6位，[ext]后缀名</li><li>ouputPath:输出的文件夹，也可以在文件名前加 img/</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader:<span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">              name:<span class="string">&quot;[name].[hash:6].[ext]&quot;</span>,</span><br><span class="line">              outputPath:<span class="string">&quot;img&quot;</span></span><br><span class="line">              <span class="comment">// limit（url-loader）</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>和file-loader有同样功能的还有url-loader<ul><li>不同的是，它不是打包，而是把图片转为BASE64编码。</li><li>可以通过use对象的options下写入limit属性，限制大小，对小图片进行BASE4编码，减少请求数。</li></ul></li></ul><h2 id="Asset-module-type">Asset module type</h2><ul><li><p>我们当前使用的webpack版本是webpack5:</p><ul><li>在webpack5之前，加载这些资源我们需要使用一些loader，比如raw-loader 、url-loader、file-loader;</li><li>在webpack5之后，我们可以直接使用资源模块类型(asset module type)，来替代上面的这些loader;</li></ul></li><li><p>资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader:</p><ul><li>asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现;</li><li>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现;</li><li>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现;</li><li>asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源</li></ul></li><li><p>比如加载图片，我们可以使用下面的方式:</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打包图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// BASE64编码并限制大小</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/inline&quot;</span>,</span><br><span class="line">        parser: &#123;</span><br><span class="line">          dataUrlCondition: &#123;</span><br><span class="line">            maxSize: <span class="number">100</span> * <span class="number">1024</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 混合使用，限制大小，判断打包方式</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        parser: &#123;</span><br><span class="line">          dataUrlCondition: &#123;</span><br><span class="line">            maxSize: <span class="number">100</span> * <span class="number">1024</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>但是，如何可以自定义文件的输出路径和文件名呢?<ul><li>方式一:修改output，添加assetModuleFilename属性;</li><li>方式二:在Rule中，添加一个generator属性，并且设置filename;</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一 ouput对象</span></span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    assetModuleFilename: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 方式二 rule对象（推荐）</span></span><br><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;img/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="加载字体文件">加载字体文件</h3><blockquote><p>rule对象：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.ttf|eot|woff2?$/i</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;font/[name].[hash:6][ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1>自定义Loader</h1><blockquote><p>Loader是用于对模块的源代码进行转换处理，之前已经使用过很多Loader，例如css-loader、style-loader、babel-loader等</p></blockquote><ul><li><p>Loader本质是一个导出为函数的JavaScript模块</p></li><li><p>Loader runner库会调用这个函数，然后将上一个loader产生的结果或者资源文件传入进去。</p></li><li><p>编写一个自定义Loader会接收三个参数</p><ul><li>content：资源文件参数</li><li>map：sourcemap相关数据</li><li>meta：一些元数据</li></ul></li><li><p>注：传入的路径是和content有关系的</p><ul><li>webpack.config.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    context: path.resolve(__dirname, <span class="string">&quot;../&quot;</span>),</span><br><span class="line">    entry: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">       path:path.resolve(__dirname,<span class="string">&quot;../build&quot;</span>),</span><br><span class="line">        filename:<span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&quot;./loaders/demoLoader.js&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果希望直接去加载loader文件夹，可以配置resoveLoader属性</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&quot;demoLoader&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;,</span><br><span class="line">resolveLoader:&#123;</span><br><span class="line">    modules:[<span class="string">&quot;./loaders&quot;</span>, <span class="string">&quot;node_modules&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个Loader使用执行顺序<ul><li>从后向前，从右向左</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules:[</span><br><span class="line">    &#123;</span><br><span class="line">        test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&quot;demoLoader1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;demoLoader2&quot;</span>,</span><br><span class="line">            <span class="string">&quot;demoLoader3&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210502234237127.png" alt="image.png"></p><h2 id="Pitch-Loader和enforce">Pitch-Loader和enforce</h2><blockquote><p>事实上还有另一种Loader，称之为PitchLoader</p></blockquote><ul><li><p>其实这也是为什么loader的执行顺序是相反的</p><ul><li>run-loader先优先执行PitchLoader，在执行PitchLoader时进行loaderIndex++；</li><li>run-loader之后会执行NormalLoader，在执行NormalLoader时进行loaderIndex–；</li></ul></li><li><p>那么，怎么改变他们的执行顺序?</p><ul><li>可以拆分成多个Rule对象，通过enforce来改变它们的顺序</li><li>enforce是rule对象的一个属性。</li></ul></li><li><p>enforce一共有四种方式</p><ul><li>默认所有loader都是normal</li><li>在行内设置的loader都是inline</li><li>也可以通过enforce设置pre和post</li></ul></li><li><p>在Pitch和Normal它们的执行顺序分别是</p><ul><li>post、inline、normal、pre</li><li>pre、normal、inline、post</li></ul></li></ul><h2 id="同步的Loader">同步的Loader</h2><ul><li><p>什么是同步loader?</p><ul><li>默认创建的Loader就是同步的Loader</li><li>这个Loader必须通过return或者this.callback来返回结果，交给下一个loader来处理</li><li>通常在有错误的情况下，会使用this.callback</li></ul></li><li><p>this.callback用法如下</p><ul><li>第一个参数为ERR或者null</li><li>第二个参数是string或者buffer</li><li>loader.js</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;loader&quot;</span>, content)</span><br><span class="line">    <span class="built_in">this</span>.callback(<span class="literal">null</span>,content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步的Loader">异步的Loader</h2><ul><li><p>什么是异步的Loader</p><ul><li>有时候使用Loader进行一些异步的操作</li><li>我们希望在异步操作完成之后，再返回这个loader处理的结果</li><li>这个时候就要使用异步的Loader了</li></ul></li><li><p>loader-runner已经在执行loader时给我们提供了方法，让loader变成一个异步的loader</p></li><li><p>loader.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="built_in">this</span>.async()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;async loader&quot;</span>,content)</span><br><span class="line">        callback(<span class="literal">null</span>, content)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传入和获取参数">传入和获取参数</h2><ul><li><p>在使用loader时传入参数，</p></li><li><p>可以通过webpack官方提供的一个解析库loader-utils</p><ul><li><code>npm i loader-utils</code></li></ul></li><li><p>webpack.config.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">    use:[</span><br><span class="line">        <span class="string">&quot;syncLoader&quot;</span>,</span><br><span class="line">        <span class="string">&quot;asyncLoader&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            loader:<span class="string">&quot;optionLoader&quot;</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                type:<span class="string">&quot;options&quot;</span>,</span><br><span class="line">                desc:<span class="string">&quot;demo&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>optionLoader.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; getOptions &#125;  = <span class="built_in">require</span>(<span class="string">&quot;loader-utils&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = getOptions(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;asyncLoader&quot;</span>,content, options)</span><br><span class="line">        callback(<span class="literal">null</span>, content)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  asyncLoader console.log(&quot;main.js&quot;) &#123; type: &#x27;options&#x27;, desc: &#x27;demo&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="参数校验">参数校验</h2><ul><li><p>可以通过wepack官方提供的校验库schema-utils</p><ul><li><code>npm i schema-utils</code></li></ul></li><li><p>schema.json（校验规则）</p></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;objcet&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;请输入正确的参数类型&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;描述必须为字符串类型&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;additionalProperties&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>loader.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; getOptions &#125;  = <span class="built_in">require</span>(<span class="string">&quot;loader-utils&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; validate &#125; = <span class="built_in">require</span>(<span class="string">&quot;schema-utils&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> loaderSchema = <span class="built_in">require</span>(<span class="string">&quot;../schema/schema.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = getOptions(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    validate(loaderSchema, options)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;asyncLoader&quot;</span>,content, options)</span><br><span class="line">        callback(<span class="literal">null</span>, content)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="babel-loader案例">babel-loader案例</h2><ul><li><p>我们知道babel-loader可以进行JS代码转换</p></li><li><p>接下来尝试定义一个自己的babel-loader</p></li><li><p>myBabelLoader.js</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; getOptions &#125;  = <span class="built_in">require</span>(<span class="string">&quot;loader-utils&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; validate &#125; = <span class="built_in">require</span>(<span class="string">&quot;schema-utils&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> babelSchema = <span class="built_in">require</span>(<span class="string">&quot;../schema/babel.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> option = getOptions(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    validate(babelSchema, option)</span><br><span class="line"></span><br><span class="line">    babel.transform(content, option, <span class="function">(<span class="params">err, res</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            callback(err)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            callback(<span class="literal">null</span>, res.code)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>babelSchema.json</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;array&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;additinalProperties&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>webapck.config.js</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/i</span>,</span><br><span class="line">            use:[</span><br><span class="line">                <span class="string">&quot;syncLoader&quot;</span>,</span><br><span class="line">                <span class="string">&quot;asyncLoader&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader:<span class="string">&quot;optionLoader&quot;</span>,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        type:<span class="string">&quot;options&quot;</span>,</span><br><span class="line">                        desc:<span class="string">&quot;demo&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader:<span class="string">&quot;myBabelLoader&quot;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets:[<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="自定义md-loader">自定义md-loader</h2><ul><li><p>借助marked和highlight库实现markdownLoader</p><ul><li><code>npm i marked highlight.js</code></li></ul></li><li><p>webpack.config.js</p><ul><li>配置css加载和md加载规则</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules:[</span><br><span class="line">    &#123;</span><br><span class="line">      test:<span class="regexp">/\.css$/i</span>,</span><br><span class="line">      use:[</span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test:<span class="regexp">/\.md$/i</span>,</span><br><span class="line">      use:[<span class="string">&quot;mdLoader&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>mdLoader.js<ul><li>使用marked和highlight处理content，并返回模块化代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">&quot;marked&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> hljs = <span class="built_in">require</span>(<span class="string">&quot;highlight.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>)</span>&#123;</span><br><span class="line">    marked.setOptions(&#123;</span><br><span class="line">        highlight:<span class="function"><span class="keyword">function</span> (<span class="params">code,lang</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hljs.highlight(lang, code).value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> htmlContent = marked(content)</span><br><span class="line">    <span class="keyword">const</span> innerContent = <span class="string">&quot;`&quot;</span> + htmlContent + <span class="string">&quot;`&quot;</span></span><br><span class="line">    <span class="keyword">const</span> moduleCode = <span class="string">`var code=<span class="subst">$&#123;innerContent&#125;</span>;export default code;`</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(moduleCode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> moduleCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>main.js<ul><li>同时引入css文件</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> md <span class="keyword">from</span> <span class="string">&quot;./index.md&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;highlight.js/styles/default.css&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;main.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ele = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>)</span><br><span class="line">ele.innerHTML = md;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ele)</span><br></pre></td></tr></table></figure><ul><li>效果</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/image-20210502234524690.png" alt="image-20210502234524690"></p><ul><li><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p></li><li><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p></li><li><p>持续分享技术博文，关注微信公众号👇🏻</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Webpack </tag>
            
            <tag> 打包构建 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> Loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Webpack</title>
      <link href="2021/05/12/%E5%88%9D%E8%AF%86Webpack/"/>
      <url>2021/05/12/%E5%88%9D%E8%AF%86Webpack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写作不易，未经作者允许禁止以任何形式转载！</p><p>如果觉得文章不错，欢迎关注、点赞和分享！</p></blockquote><h1>Webpack初体验</h1><h2 id="用Webpack解决什么问题">用Webpack解决什么问题</h2><ol><li>模块化</li><li>高级特性、开发效率、安全性<ul><li>ES6+、Typescript、sacc、less</li></ul></li><li>监听文件变化并反映到浏览器上，提高开发效率</li><li>开发完成后的打包，压缩、合并、tree-shaking等以及其他相关的优化</li></ol><h2 id="Webpack是什么">Webpack是什么</h2><ul><li><p>Webpck是一个静态的模块化打包工具，为现代的JS应用程序</p></li><li><p>我们来对上面的解释进行拆解：</p><ul><li>打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具。</li><li>静态的static：这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）</li><li>模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等</li><li>现代的modern：现代前端开发面临各种各样的问题，才催生了webpack的出现和发展</li></ul></li></ul><h2 id="Webpack和Vite">Webpack和Vite</h2><blockquote><p>Webpack会被Vite取代吗？</p></blockquote><ol><li>vite推出后确实引起了很多的反响，也有很多人看好vite的发展</li><li>但是目前vite取代webpack还有很长的路要走<ul><li>目前vue项目支持使用vite，也支持使用webpack</li><li>vite最终打包的过程，依然需要借助于rollup完成</li></ul></li><li>vite核心思想并不是首创<ul><li>事实上，vite的思想和之前的snowpack是重合的，而且相对目前来说snowpack会更加成熟</li><li>当然，后续发展来看vite可能会超越snowpack</li></ul></li><li>webpack的更新迭代<ul><li>webpack在发展工程中，也会不断改进自己，借鉴其他工具的一些优势和思想</li><li>在这么多年的发展中，无论是自身的优势还是生态都是非常强大的。</li></ul></li></ol><blockquote><p>关于Vite的思考</p></blockquote><ol><li><p>学习任何的东西，重要的是学习核心思想</p><ul><li>学习了JS学TS不是从0开始</li><li>学习了Vue，学React也不是从0开始</li></ul></li><li><p>任何工具的出现，都是更好地服务于我们开发</p><ul><li><p>无论是vite的出现，还是以后新的工具出现，不要有任何排斥的思想；</p></li><li><p>我们要深刻地明白，工具都是为了更好地给我们提供服务</p></li><li><p>不可能出现了某个工具，让我们的开发效率变得更低，而这个工具却可以变得非常流行，这是不存在的</p></li></ul></li></ol><h1>Webpack默认打包</h1><ul><li><p>我们可以通过webpack进行打包，之后运行打包之后的代码</p><ul><li><p>在目录下直接执行webpack命令</p><p><code>webpack</code></p></li><li><p>直接在终端执行webpack可能本机安装版本和项目版本不同，所以在package.json中定义命令例如：“build”:“webpack”，这样就会根据package.json中的webpack版本进行打包（前提是已install）。</p></li></ul></li><li><p>生成一个dist文件夹，里面存放一个main.js文件，就是打包之后的文件</p><ul><li>这个文件中的代码被压缩和丑化了</li><li>暂时不关心他是如何做到的，后续我讲webpack实现模块化原理时会再次讲到。</li><li>另外发现代码中依然存在ES6的语法，比如箭头函数、const等，这是因为默认情况下webpack并不清楚我们打包后的文件是否需要转成ES5之前的语法，后续我们需要通过babel来进行转换和设置；</li></ul></li><li><p>发现可以正常进行打包的，但是有一个问题，webpack是如何确地入口的？</p><ul><li>事实上，我们运行webpack时，webpack会查找到当前目录下的src/index.js作为入口</li><li>所以，如果当前项目中没有src/index.js，那么会报错</li></ul></li><li><p>当然也可以通过配置来指定入口和出口，例如(通常写配置文件)</p><p><code>npx webpack --entry ./src/main.js --output-path ./build</code></p></li></ul><h1>Webpack配置文件</h1><ul><li><p>通常情况下，webpack需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然是不可以的。</p></li><li><p>我们可以在根目录下创建一个webpack.config.js文件，来作为webpack的配置文件,例如</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>继续执行webpack命令，依然可以正常打包</p></li><li><p>也可以不使用webpack.config.js作为文件名，使用命令定义路径和文件名即可，例如</p></li><li><p><code>webpack --config  ./wk.congfig.js</code></p></li></ul><h1>Webpack依赖图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null).png" alt="img"></p><blockquote><p>webpack到底是如何对我们的项目进行打包的呢？</p></blockquote><ul><li><p>事实上webpack在处理应用程序的时候，它会根据命令或者配置文件找到入门文件；</p></li><li><p>从入口开始，会生成一个依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块（比如js文件、css文件、字体等）</p></li><li><p>然后遍历图结构，打包一个个模块（根据文件的不同使用不同的loader解析）</p></li></ul><h1>Mode配置</h1><ul><li><p>Mode配置选项，可以告知webpack使用响应模式的内置优化:</p></li><li><p>默认值是production(什么都不设置的情况下);</p></li><li><p>可选值有:‘none’ | ‘development’ | ‘production’;</p></li><li><p>这几个选项有什么样的区别呢?</p></li></ul><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>developtment</code></td><td>会将<code>DefinePlugin</code>中<code>process.env.NODE_ENV</code>的值设置为``developtment`，为模块和chunk启用有效的名</td></tr><tr><td><code>production</code></td><td>会将``DefinePlugin<code>中</code>process.env.NODE_ENV<code>的值设置为</code>production<code>。为模块和chunk启用确定性的混淆名称，</code>FlagDependencyUsagePlugin<code>，</code>FlagInlcudeedChunkPlugin<code>，</code>ModuleConcatenationPlugin<code>，</code>NoEmitOnErrorsPlugin<code>和</code>TerserPlugin`</td></tr><tr><td><code>none</code></td><td>不使用任何默认优化选项</td></tr></tbody></table><blockquote><p>Mode配置代表配置了更多</p></blockquote><ul><li>绿色选项 = 所有红色选项</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210502174148481.(null)" alt="img"></p><h1>Webpack核心流程</h1><blockquote><p>引用于[<a href="https://juejin.cn/post/6949040393165996040">万字总结] 一文吃透 Webpack 核心原理</a></p></blockquote><p>这个过程核心完成了 <strong>内容转换 + 资源合并</strong> 两种功能，实现上包含三个阶段：</p><ul><li><p>初始化阶段：</p><ol><li><strong>初始化参数</strong>：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li><li><strong>创建编译器对象</strong>：用上一步得到的参数创建 Compiler 对象</li><li><strong>初始化编译环境</strong>：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li><li><strong>开始编译</strong>：执行 compiler 对象的 run 方法</li><li><strong>确定入口</strong>：根据配置中的 entry 找出所有的入口文件，调用 compilition.addEntry 将入口文件转换为 dependence 对象</li></ol></li><li><p>构建阶段：</p><ol><li><strong>编译模块(make)</strong>：根据 entry 对应的 dependence 创建 module 对象，调用 loader 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><strong>完成模块编译</strong>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 <strong>依赖关系图</strong></li></ol></li><li><p>生成阶段：</p><ol><li><strong>输出资源(seal)</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><strong>写入文件系统(emitAssets)</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol></li></ul><blockquote><p>单次构建过程自上而下按顺序执行，下面会展开聊聊细节，在此之前，对上述提及的各类技术名词不太熟悉的同学，可以先看看简介：</p></blockquote><ul><li><p><code>Entry</code>：编译入口，webpack 编译的起点</p></li><li><p><code>Compiler</code>：编译管理器，webpack 启动后会创建 compiler 对象，该对象一直存活知道结束退出</p></li><li><p><code>Compilation</code>：单次编辑过程的管理器，比如<code>watch = true</code> 时，运行过程中只有一个 <code>compiler </code>但每次文件变更触发重新编译时，都会创建一个新的 <code>compilation</code> 对象</p></li><li><p><code>Dependence</code>：依赖对象，webpack 基于该类型记录模块间依赖关系</p></li><li><p><code>Module</code>：webpack 内部所有资源都会以“module”对象形式存在，所有关于资源的操作、转译、合并都是以 “module” 为基本单位进行的</p></li><li><p><code>Chunk</code>：编译完成准备输出时，webpack 会将 <code>module</code> 按特定的规则组织成一个一个的 <code>chunk</code>，这些 <code>chunk</code> 某种程度上跟最终输出一一对应</p></li><li><p><code>Loader</code>：资源内容转换器，其实就是实现从内容 A 转换 B 的转换器</p></li><li><p><code>Plugin</code>：webpack构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程</p></li></ul><p>webpack 编译过程都是围绕着这些关键对象展开的，更详细完整的信息，可以参考 <a href="https://juejin.cn/post/6948763207397965855">Webpack 知识图谱</a> 。</p><h1>Webpack和Gulp</h1><ul><li><p>gulp的核心理念是task runner</p><ul><li>可以定义自己的一系列任务，等待任务被执行;</li><li>基于文件Stream的构建流; p我们可以使用gulp的插件体系来完成某些任务;</li></ul></li><li><p>webpack的核心理念是module bundler pwebpack是一个模块化的打包工具;</p><ul><li>可以使用各种各样的loader来加载不同的模块;</li><li>可以使用各种各样的插件在webpack打包的生命周期完成其他的任务;</li></ul></li><li><p>gulp相对于webpack的优缺点:</p><ul><li>gulp相对于webpack思想更加的简单、易用，更适合编写一些自动化的任务;</li><li>但是目前对于大型项目（Vue、React、Angular）并不会使用gulp来构建，比如默认gulp是不支持模块化的。</li></ul></li></ul><h1>优质文章推荐：</h1><ol><li>[<a href="https://juejin.cn/post/6949040393165996040">万字总结] 一文吃透 Webpack 核心原理</a></li><li>[<a href="https://juejin.cn/post/6955421936373465118">源码解读] Webpack 插件架构深度讲解</a></li><li><a href="https://juejin.cn/post/6955878306981871623">十分钟精进 Webpack：module.issuer 属性详解</a></li><li><a href="https://juejin.cn/post/6958811421224206343">有点难的 webpack 知识点：Dependency Graph 深度解析</a></li><li><a href="https://juejin.cn/post/6960472347329429511">分享几个 Webpack 实用分析工具</a></li><li><a href="https://juejin.cn/post/6948763207397965855">分享一份 Webpack 知识图谱</a></li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> Webpack </tag>
            
            <tag> 打包构建 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 湾区之光</title>
      <link href="2021/04/06/%E6%91%84%E5%BD%B1-%E6%B9%BE%E5%8C%BA%E4%B9%8B%E5%85%89/"/>
      <url>2021/04/06/%E6%91%84%E5%BD%B1-%E6%B9%BE%E5%8C%BA%E4%B9%8B%E5%85%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 24-70GM<br>出镜：无<br>地点：华侨城·欢乐港湾</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09976.JPG" alt="DSC09976"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09985.JPG" alt="DSC09985"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00001.JPG" alt="DSC00001"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00006.JPG" alt="DSC00006"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00028.JPG" alt="DSC00028"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00033.JPG" alt="DSC00033"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00044.JPG" alt="DSC00044"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00003.JPG" alt="DSC00003"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09997.JPG" alt="DSC09997"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09978.JPG" alt="DSC09978"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09987.JPG" alt="DSC09987"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00083.JPG" alt="DSC00083"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00150.JPG" alt="DSC00150"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00155.JPG" alt="DSC00155"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC00161.JPG" alt="DSC00161"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 风光 </tag>
            
            <tag> 摩天轮 </tag>
            
            <tag> 欢乐港湾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue进阶 Diff算法详解 |  学习笔记</title>
      <link href="2021/03/24/Vue%E8%BF%9B%E9%98%B6-Diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/24/Vue%E8%BF%9B%E9%98%B6-Diff%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>一、虚拟DOM</h1><blockquote><p>什么是虚拟DOM？</p></blockquote><p>虚拟DOM就是把真实DOM树的结构和信息抽象出来，以对象的形式模拟树形结构，如下：</p><p>真实DOM:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的虚拟DOM就是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode = &#123;</span><br><span class="line">    tag: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    children:[ &#123;<span class="attr">tag</span>:<span class="string">&#x27;p&#x27;</span>, <span class="attr">text</span>:<span class="string">&#x27;Hello World&#x27;</span>&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么需要虚拟DOM？</p></blockquote><p>渲染真实DOM会有一定的开销，如果每次修改数据都进行真实DOM渲染，都会引起DOM树的重绘和重排，性能开销很大。那么有没有可能只修改一小部分数据而不渲染整个DOM呢？虚拟DOM和Diff算法可以实现。</p><blockquote><p>怎么实现？</p></blockquote><ol><li>先根据真实DOM生成一颗虚拟DOM树</li><li>当某个DOM节点数据发生改变时，生成一个新的Vnode</li><li>新的Vnode和旧的oldVnode进行对比</li><li>通过patch函数一边比对一边给真实DOM打补丁或者创建Vnode、移除oldVnode等</li></ol><blockquote><p>有什么不一样？</p></blockquote><ol><li>真实DOM操作为一个属性一个属性去修改，开销较大。</li><li>虚拟DOM直接修改整个DOM节点再替换真实DOM</li></ol><blockquote><p>还有什么好处？</p></blockquote><p>Vue的虚拟DOM数据更新机制是<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97">异步更新队列</a>，并不是数据变更马上更新DOM，而是被推进一个数据更新异步队列统一更新。想要马上拿到DOM更新后DOM信息？有个API叫 <a href="https://cn.vuejs.org/v2/api/">Vue.nextTick</a></p><h1>二、 Diff算法</h1><h2 id="传统Diff算法">传统Diff算法</h2><blockquote><p>遍历两棵树中的每一个节点，每两个节点之间都要做一次比较。</p></blockquote><blockquote><p>比如 a-&gt;e 、a-&gt;d 、a-&gt;b、a-&gt;c、a-&gt;a</p></blockquote><ul><li>遍历完成的时间复杂度达到了O(n^2)</li><li>对比完差异后还要计算最小转换方式，实现后复杂度来到了O(n^3)</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210326001324690.png" alt="img"></p><h2 id="Vue优化的Diff算法">Vue优化的Diff算法</h2><blockquote><p>Vue的diff算法只会比较同层级的元素，不进行跨层级比较</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/(null)-20210324234529318-20210326001327579.(null)" alt="img"></p><h1>三、 Vue中的Diff算法实现</h1><h2 id="Vnode分类">Vnode分类</h2><ul><li>EmptyVNode: 没有内容的注释节点</li><li>TextVNode: 文本节点</li><li>ElementVNode: 普通元素节点</li><li>ComponentVNode: 组件节点</li><li>CloneVNode: 克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true</li></ul><h2 id="Patch函数">Patch函数</h2><blockquote><p>patch函数接收以下参数：</p></blockquote><ol><li>oldVnode：旧的虚拟节点</li><li>Vnode：新的虚拟节点</li><li>hydrating：是否要和真实DOM混合</li><li>removeOnly：特殊的flag，用于 transition-group</li></ol><blockquote><p>处理流程大致分为以下步骤：</p></blockquote><ol><li>vnode不存在，oldVnode存在时，移除oldVnode</li><li>vnode存在，oldVnode不存在时，创建vnode</li><li>vnode和oldVnode都存在时<ol><li>如果vnode和oldVnode是同一个节点（通过sameVnode函数对比  后续详解），通过patchVnode进行后续比对工作</li><li>如果vnode和oldVnode不是同一个节点，那么根据vnode创建新的元素并挂载至oldVnode父元素下。如果组件根节点被替换，遍历更新父节点element。然后移除旧节点。如果oldVnode是服务端渲染元素节点，需要用hydrate函数将虚拟dom和真是dom进行映射</li></ol></li></ol><blockquote><p>源码如下，已写好注释便于阅读</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果vnode不存在，但是oldVnode存在，移除oldVnode</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果oldVnode不存在，但是vnode存在时，创建vnode</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 剩余情况为vnode和oldVnode都存在</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否为真实DOM元素</span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// 如果vnode和oldVnode是同一个（通过sameVnode函数进行比对  后续详解）</span></span><br><span class="line">        <span class="comment">// 受用patchVnode函数进行后续比对工作 （函数后续详解）</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// vnode和oldVnode不是同一个的情况</span></span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">          <span class="comment">// 如果存在真实的节点，存在data-server-render属性</span></span><br><span class="line">          <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            <span class="comment">// 当旧的Vnode是服务端渲染元素，hydrating记为true</span></span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 需要用hydrate函数将虚拟DOM和真实DOM进行映射</span></span><br><span class="line">          <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">            <span class="comment">// 需要合并到真实DOM上</span></span><br><span class="line">            <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              <span class="comment">// 调用insert钩子</span></span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">              <span class="keyword">return</span> oldVnode</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                <span class="string">&#x27;The client-side rendered virtual DOM tree is not matching &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;server-rendered content. This is likely caused by incorrect &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;HTML markup, for example nesting block-level elements inside &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;full client-side render.&#x27;</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果不是服务端渲染元素或者合并到真实DOM失败，则创建一个空的Vnode节点去替换它</span></span><br><span class="line">          oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取oldVnode父节点</span></span><br><span class="line">        <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">        <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据vnode创建一个真实DOM节点并挂载至oldVnode的父节点下</span></span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果组件根节点被替换，遍历更新父节点Element</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">          <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">          <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">          <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm = vnode.elm</span><br><span class="line">            <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// #6513</span></span><br><span class="line">              <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">              <span class="comment">// e.g. for directives that uses the &quot;inserted&quot; hook.</span></span><br><span class="line">              <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">              <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">                <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor = ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁旧节点</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">          <span class="comment">// 移除老节点</span></span><br><span class="line">          removeVnodes(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          <span class="comment">// 调用destroy钩子</span></span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用insert钩子并返回节点</span></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="sameVnode函数">sameVnode函数</h2><blockquote><p>Vue怎么判断是不是同一个节点？流程如下：</p></blockquote><ol><li>判断Key值是否一样</li><li>tag的值是否一样</li><li>isComment，这个不用太关注。</li><li>数据一样</li><li>sameInputType()，专门对表单输入项进行判断的：input一样但是里面的type不一样算不同的inputType</li></ol><blockquote><p>从这里可以看出key对diff算法的辅助作用，可以快速定位是否为同一个元素，必须保证唯一性。</p></blockquote><blockquote><p>如果你用的是index作为key，每次打乱顺序key都会改变，导致这种判断失效，降低了Diff的效率。</p></blockquote><blockquote><p>因此，用好key也是Vue性能优化的一种方式。</p></blockquote><ul><li>源码如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="patchVnode函数">patchVnode函数</h2><blockquote><p>前置条件vnode和oldVnode是同一个节点</p></blockquote><blockquote><p>执行流程：</p></blockquote><ol><li>如果oldVnode和vnode引用一致，可以认为没有变化，return</li><li>如果oldVnode的isAsyncPlaceholder属性为true，跳过检查异步组件，return</li><li>如果oldVnode跟vnode都是静态节点，且具有相同的key，同时vnode是克隆节点或者v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上，也不用再有其他操作，return</li><li>如果vnode不是文本节或注释节点<ol><li>如果vnode和oldVnode都有子节点并且两者子节点不一致时，就调用updateChildren更新子节点</li><li>如果只有vnode有自子节点，则调用addVnodes创建子节点</li><li>如果只有oldVnode有子节点，则调用removeVnodes把这些子节点都删除</li><li>如果vnode文本为undefined，则清空vnode.elm文本</li></ol></li><li>如果vnode是文本节点但是和oldVnode文本内容不同，只需更新文本。</li></ol><blockquote><p>源代码如下，已写好注释便于阅读</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新老节点引用一致，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果oldVnode的isAsyncPlaceholder属性为true，跳过检查异步组件</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode.isAsyncPlaceholder = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新旧都是静态节点，vnode的key也相同</span></span><br><span class="line">    <span class="comment">// 新vnode是克隆所得或新vnode有 v-once属性</span></span><br><span class="line">    <span class="comment">// 则进行赋值，然后返回。vnode的componentInstance 保持不变</span></span><br><span class="line">    <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">      isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">      vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">    ) &#123;</span><br><span class="line">      vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="comment">// 执行data.hook.prepatch 钩子</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取子元素列表</span></span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">      <span class="comment">// 遍历调用 cbs.update 钩子函数，更新oldVnode所有属性</span></span><br><span class="line">      <span class="comment">// 包括attrs、class、domProps、events、style、ref、directives</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">      <span class="comment">// 执行data.hook.update 钩子</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Vnode 的 text选项为undefined</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">//新老节点的children不同，执行updateChildren方法</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// oldVnode children不存在 执行 addVnodes方法</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        <span class="comment">// vnode不存在执行removeVnodes方法</span></span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        <span class="comment">// 新旧节点都是undefined，且老节点存在text，清空文本。</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">      <span class="comment">// 新老节点文本内容不同，更新文本</span></span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">      <span class="comment">// 执行data.hook.postpatch钩子，至此 patch完成</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="updateChildren函数">updateChildren函数</h2><blockquote><p>重点！！！</p></blockquote><blockquote><p>前置条件：vnode和oldVnode的children不相等</p></blockquote><blockquote><p>整体的执行思路如下：</p></blockquote><ol><li><p>vnode头对比oldVnode头</p></li><li><p>vnode尾对比oldVnode尾</p></li><li><p>vnode头对比oldVnode尾</p></li><li><p>vnode尾对比oldVnode头</p><ul><li>只要符合一种情况就进行patch，移动节点，移动下标等操作</li></ul></li><li><p>都不对再在oldChild中找一个key和newStart相同的节点</p><ul><li><p>找不到，新建一个。</p></li><li><p>找到，获取这个节点，判断它和newStartVnode是不是同一个节点</p><ul><li>如果是相同节点，进行patch  然后将这个节点插入到oldStart之前，newStart下标继续移动</li><li>如果不是相同节点，需要执行createElm创建新元素</li></ul></li></ul></li></ol><blockquote><p>为什么会有头对尾、尾对头的操作？</p></blockquote><ul><li>可以快速检测出reverse操作，加快diff效率。</li></ul><blockquote><p>源码如下   已写好注释便于阅读：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义变量</span></span><br><span class="line">   <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>  <span class="comment">// 老节点Child头下标</span></span><br><span class="line">   <span class="keyword">let</span> newStartIdx = <span class="number">0</span>  <span class="comment">// 新节点Child头下标</span></span><br><span class="line">   <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>  <span class="comment">// 老节点Child尾下标</span></span><br><span class="line">   <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]      <span class="comment">// 老节点Child头结点</span></span><br><span class="line">   <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// 老节点Child尾结点</span></span><br><span class="line">   <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span>   <span class="comment">// 新节点Child尾下标</span></span><br><span class="line">   <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]       <span class="comment">// 新节点Child头结点</span></span><br><span class="line">   <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]  <span class="comment">// 新节点Child尾结点</span></span><br><span class="line">   <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">   <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">   <span class="comment">// during leaving transitions</span></span><br><span class="line">   <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">     checkDuplicateKeys(newCh)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义循环</span></span><br><span class="line">   <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">     <span class="comment">// 存在检测</span></span><br><span class="line">     <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果老结点Child头和新节点Child头是同一个节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">       <span class="comment">// patch差异</span></span><br><span class="line">       patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">       <span class="comment">// patch完成  移动节点位置  继续比对下一个节点</span></span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果老结点Child尾和新节点Child尾是同一个节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">       <span class="comment">// patch差异</span></span><br><span class="line">       patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">       <span class="comment">// patch完成  移动节点位置 继续比对下一个节点</span></span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">       newEndVnode = newCh[--newEndIdx]</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果老结点Child头和新节点Child尾是同一个节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">        <span class="comment">// patch差异</span></span><br><span class="line">       patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">       <span class="comment">// 把oldStart节点放到oldEnd节点后面</span></span><br><span class="line">       canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">       <span class="comment">// patch完成  移动节点位置 继续比对下一个节点</span></span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">       newEndVnode = newCh[--newEndIdx]</span><br><span class="line">     <span class="comment">// 如果老结点Child尾和新节点Child头是同一个节点</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">        <span class="comment">// patch差异</span></span><br><span class="line">       patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">       <span class="comment">// 把oldEnd节点放到oldStart节点前面</span></span><br><span class="line">       canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">       <span class="comment">// patch完成  移动节点位置 继续比对下一个节点</span></span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 如果没有相同的Key，执行createElm方法创建元素</span></span><br><span class="line">       <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">       idxInOld = isDef(newStartVnode.key) ?</span><br><span class="line">         oldKeyToIdx[newStartVnode.key] :</span><br><span class="line">         findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">       <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">         createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 有相同的Key，判断这两个节点是否为sameNode</span></span><br><span class="line">         vnodeToMove = oldCh[idxInOld]</span><br><span class="line">         <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">           <span class="comment">// 如果是相同节点，进行patch  然后举将oldStart插入到oldStart之前，newStart下标继续移动</span></span><br><span class="line">           patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">           oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">           canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果不是相同节点，需要执行createElm创建新元素</span></span><br><span class="line">           createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// oldStartIdx &gt; oldEndIdx说明oldChild先遍历完，使用addVnode方法添加newStartIdx指向的节点到newEndIdx的节点</span></span><br><span class="line">   <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">     refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">     addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">     <span class="comment">// 如果newStartIdx &gt; newEndIdx说明newChild先遍历完，remove掉oldChild未遍历完的节点</span></span><br><span class="line">     removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1>四、总结</h1><ol><li>正确使用key，可以快速执行sameVnode比对，加速Diff效率，可以作为性能优化的一个点。</li><li>DIff只做同级比较，使用sameVnode函数比对，文本节点直接替换文本内容。</li><li>子元素列表的Diff，进行头对头、尾对尾、头对尾等系列比较，直到遍历完两个元素的子元素列表。<ul><li>或一个列表先遍历完了，直接addVnode / removeVnode。</li></ul></li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Front End </tag>
            
            <tag> Vue </tag>
            
            <tag> Diff 算法 </tag>
            
            <tag> 虚拟DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析HTTP缓存</title>
      <link href="2021/03/20/%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98/"/>
      <url>2021/03/20/%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1>为什么需要缓存</h1><ul><li>通过缓存机制，可以在相应场景下复用以前获取的资源。</li><li>显著提高网站的性能和响应速度</li><li>减少网络流量和等待渲染时间</li><li>降低服务器压力</li></ul><h1>HTTP缓存类型</h1><ul><li>强缓存</li><li>协商缓存</li></ul><h1>强缓存</h1><p>对于强缓存，服务器返回的静态资源响应头会设置一个强制缓存的时间，在缓存时间内，如刷新浏览器请求相同资源，在缓存时间未过期的情况下，则直接使用已缓存资源。如缓存资源已过期，执行协商缓存策略。</p><ul><li>以下为与强缓存相关的HTTP头部字段</li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>用途</strong></th><th>实例</th><th><strong>优先级</strong></th><th><strong>HTTP版本</strong></th></tr></thead><tbody><tr><td>Expires</td><td>强缓存的过期日期</td><td>Expires:Thu,06 Aug 2021 14:36:18 GMT</td><td>低</td><td>1.0</td></tr><tr><td>Cache-Control</td><td>指定指令实现缓存机制</td><td>Cache-Control:max-age=60</td><td>高</td><td>1.1</td></tr></tbody></table><h2 id="Expires">Expires</h2><ul><li>响应头Expires字段包含强缓存资源的过期时间</li><li>值为0表示资源已过期或非强缓存</li></ul><h2 id="Cache-Control">Cache-Control</h2><p>通用消息头字段，通过指令来实现缓存机制。说明一下容易弄混的两个字段，其他指令参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">指令大全</a>。</p><ul><li>no-cache</li></ul><p>在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。</p><ul><li>no-store</li></ul><p>缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</p><h2 id="Expires-和-Cache-Control-的区别">Expires 和 Cache-Control 的区别</h2><ul><li>时间区别<ul><li>Expires 过期时间为绝对时间，指未来某个时间点缓存过期。</li><li>Cache-Control 为相对时间，相对于当前时间，如 60s 后缓存过期</li></ul></li><li>优先级<ul><li>Expires 的优先级低于 Cache-Control 字段</li><li>同时存在 Cache-Control 和 Expires时，以 Cache-Control 指令为准</li></ul></li><li>HTTP 版本<ul><li>Expires 是HTTP/1.0 提出的，其浏览器兼容性更好</li><li>Cache-Control 是 HTTP/1.1 提出的，浏览器兼容性不佳，所以 Expires 和 Cache-Control 可以同时存在，在不支持 Cache-Control的浏览器则以Expires为准</li></ul></li></ul><h1>协商缓存</h1><ul><li>协商缓存即和服务器协商是否使用缓存，通过判断后决定重新加载资源 or HTTP StatusCode 304</li><li>以下字段决定是否使用协商缓存，而非强缓存：</li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>协商缓存</strong></th><th><strong>优先级</strong></th></tr></thead><tbody><tr><td>Pragma</td><td>Pragma:no-cache</td><td>高</td></tr><tr><td>Cache-Control</td><td>Cache-Control:no-cache / Cache-Control:max-age=0</td><td>低</td></tr></tbody></table><h2 id="Pragma">Pragma</h2><ul><li>Pragma是一个HTTP1.0中规定的通用首部，如果 Cache-Control不存在的话，它的行为与 Cache-Control: no-cache 一致。强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行协商验证。</li><li>Pragma的值就只有一个，no-cache，并且它的优先级比Cache-Control高。</li></ul><h2 id="Cache-Control-2">Cache-Control</h2><ul><li>上文介绍过Cache-Control，它的指令既可以用于强缓存又可应用于协商缓存策略中</li><li>其中Cache-Control: no-cache 和 Cache-Control: max-age=0 的作用一样，强制要求发起请求给服务器进行验证 (协商资源验证)。</li></ul><h1>协商策略</h1><p>当出现Pragma字段或者Cache-Control:no-cache时，就需要使用协商策略，常见的两对协商缓存字段如下</p><ul><li>ETag/If-None-Match</li><li>Last-Modified/If-Modfied-Since</li></ul><table><thead><tr><th><strong>字段</strong></th><th><strong>对应字段</strong></th><th><strong>值</strong></th><th><strong>描述</strong></th><th><strong>优先级</strong></th></tr></thead><tbody><tr><td>Last-Modified</td><td>If-Modified-Since</td><td>GMT时间</td><td>服务端资源的最后修改时间</td><td>低</td></tr><tr><td>If-Modified-Since</td><td>Last-Modified</td><td>GMT时间</td><td>上次请求响应头的Last-Modified，验证是否为服务端资源最后修改的时间，是返回304，否返回200。</td><td>低</td></tr><tr><td>Etag</td><td>If-None-Match</td><td>内容hash/文件信息</td><td>服务器缓存资源的文件信息或文件内容生成的哈希值</td><td>高</td></tr><tr><td>If-None-Match</td><td>Etag</td><td>内容hash/文件信息</td><td>上次请求响应头的ETag，验证服务器资源有没有修改，有返回200，没有返回304。</td><td>高</td></tr></tbody></table><h2 id="优缺点">优缺点</h2><ul><li>如果服务端修改了一段代码，然后又改回去了。<ul><li>此时资源文件的修改时间变了</li><li>实际上文件没有发生改变</li><li>这样缓存就失效了，产生了不必要的传输</li></ul></li><li>而ETag可以根据内容生成的hash来比较的，只要资源文件内容不变，就会应用客户端的缓存，减少不必要的传输。</li><li>所以ETag比Last-Modified缓存更精确、高效和节省带宽。</li></ul><h1>ETag</h1><h2 id="什么是ETag？">什么是ETag？</h2><p>Etag是 Entity tag的缩写，可以理解为“被请求资源的摘要标识”，Etag是服务端的一个资源的标识，在 HTTP 响应头中将其传送到客户端，类似这样，ETag:W/“50b1c1d4f775c61:df3”</p><h2 id="ETag格式">ETag格式</h2><ul><li>ETag:W/“xxxxxxxx”</li><li>ETag:“xxxxxxx”</li></ul><h3 id="强类型验证">强类型验证</h3><ul><li>比对资源每个字节都要一样。</li></ul><h3 id="W-前缀代表使用弱类型验证">W/前缀代表使用弱类型验证</h3><ul><li>不需要每个字节都一样，例如页脚的时间or展示的广告不一样，都可以认为是一样的。构建应用于弱验证类型的标签（etag）体系可能会比较复杂，因为这会涉及到对页面上不同的元素的重要性进行排序，但是会对缓存性能优化相当有帮助。</li></ul><h2 id="ETag生成需要满足什么条件？">ETag生成需要满足什么条件？</h2><ol><li>当文件更改时，ETag值必须改变</li><li>尽量便于计算，不会特别耗CPU。<ol><li>利用摘要算法生成（MD5, SHA128, SHA256）需慎重考虑，这些为CPU密集型运算。</li></ol></li><li>必须横向扩展，分布式部署时多个服务器节点上生成的ETag值保持一致。</li></ol><h2 id="ETag是怎么生成的（Nginx）">ETag是怎么生成的（Nginx）</h2><p><a href="https://github.com/nginx/nginx/blob/6c3838f9ed45f5c2aa6a971a0da3cb6ffe45b61e/src/http/ngx_http_core_module.c#L1582">Nginx的源码</a>中ETag由last_modified和content_length拼接而成</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">etag-&gt;value.len = ngx_sprintf(etag-&gt;value.data, <span class="string">&quot;\&quot;%xT-%xO\&quot;&quot;</span>,</span><br><span class="line">                                  r-&gt;headers_out.last_modified_time,</span><br><span class="line">                                  r-&gt;headers_out.content_length_n)</span><br><span class="line">                      - etag-&gt;value.data;                                </span><br></pre></td></tr></table></figure><ul><li>翻译为以下伪代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">etag = header.last_modified + <span class="string">&quot;-&quot;</span> + header.content_lenth</span><br></pre></td></tr></table></figure><ul><li>总结：Nginx中ETag由响应头的Last-Modified和Content-Length表示为十六进制组合而成。</li></ul><h3 id="Lodash网站请求检验">Lodash网站请求检验</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/lodash%E8%AF%B7%E6%B1%82-20210325234424565.png" alt="img"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LAST_MODIFIED = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;5fc4907d&#x27;</span>, <span class="number">16</span>) * <span class="number">1000</span>).toJSON()</span><br><span class="line"><span class="keyword">const</span> CONTENT_LENGTH = <span class="built_in">parseInt</span>(<span class="string">&#x27;f48&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(LAST_MODIFIED) <span class="comment">// 2020-11-30T06:26:05.000Z</span></span><br><span class="line"><span class="built_in">console</span>.log(CONTENT_LENGTH) <span class="comment">// 3912</span></span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-20210325234424619.png" alt="img"></p><ul><li>既然在nginx中ETag由Last-Modified和Content-Length组成，那它便算是一个加强版的Last-Modified了，那加强在什么地方呢？</li><li>Last-Modified只能作用于秒级的改变，而 nginx 中的 ETag 添加了文件大小的附加条件，不仅和修改时间有关，也和内容有关，使之更加精确。</li></ul><h2 id="Last-Modified是怎么生成的">Last-Modified是怎么生成的</h2><p>在linux中</p><ul><li>mtime：modified time指文件内容改变的时间戳</li><li>ctime：change time指文件属性改变的时间戳，属性包括mtime。而在 windows 上，它表示的是creation time</li><li>而HTTP服务选择Last-Modified时一般会选择mtime，表示文件内容修改的时间，来兼容Windows和Linux。</li><li>以下为<a href="https://github.com/nginx/nginx/blob/4bf4650f2f10f7bbacfe7a33da744f18951d416d/src/http/modules/ngx_http_static_module.c#L217">nginx源码</a></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r-&gt;headers_out.status = NGX_HTTP_OK;     </span><br><span class="line">r-&gt;headers_out.content_length_n = of.size;     </span><br><span class="line">r-&gt;headers_out.last_modified_time = of.mtime;</span><br></pre></td></tr></table></figure><h2 id="如果-http-响应头中-ETag-值改变了，是否意味着文件内容一定已经更改？">如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改？</h2><ul><li>不一定</li><li>文件在一秒内发生了改变而且文件大小不变</li><li>这种情况非常极端，概率很低</li><li>因此在正常情况下可以容忍一个不太完美但是高效的算法。</li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> HTTP </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的前世今生</title>
      <link href="2021/03/11/Vue%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>2021/03/11/Vue%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1>Vue的前世今生</h1><ul><li>2013 尤雨溪个人项目</li><li>2014.2 0.1版本发布</li><li>2015.10  1.0版本发布<ul><li>模板语法改进</li></ul></li><li>2016.9  2.0版本发布<ul><li>跨端</li><li>新的渲染机制</li></ul></li><li>2019.10 3.0 alpha发布<ul><li>性能</li><li>架构</li><li>按需引入</li><li>Composition API</li><li>Proxy observer</li><li>AOT优化</li></ul></li></ul><h1>Vue 1 响应式原理</h1><h2 id="构建响应式对象流程">构建响应式对象流程</h2><ul><li>walk函数遍历data对象中的属性，调用defineReactive将其变成响应式对象<ul><li>对于对象属性进行递归调用walk，以保证data整个对象树中的属性都是响应式对象。</li></ul></li><li>defineReactive中使用watchers数组储存watcher，使用Object.defineProperty的get函数收集watcher和返回值，set函数用来设置值和对watchers中的watcher进行视图更新。</li></ul><h2 id="Walk函数实现">Walk函数实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).foreach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        defineReactive(data, key, data[key])</span><br><span class="line">        <span class="comment">//对象递归调用walk</span></span><br><span class="line">        walk(data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defineReactive函数实现">defineReactive函数实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldValue = value;</span><br><span class="line">    <span class="keyword">const</span> watchers = []</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//收集watcher</span></span><br><span class="line">            watchers.push(currentWatcher)</span><br><span class="line">            <span class="keyword">return</span> oldValue</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue === oldValue) <span class="keyword">return</span>;</span><br><span class="line">            oldValue = newValue;</span><br><span class="line">            watchers.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> wathcer.update())<span class="comment">//更新视图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看了这么久Watcher到底是什么？">看了这么久Watcher到底是什么？</h2><p><img src= "/img/loading.gif" data-lazy-src="http://bloginfo.lebronchao.com/doc-image/16ab1c1b0537a783" alt=""></p><ul><li>Watcher用于获取数据和更新视图，并实现vue指令<ul><li>watcher从data中get数据render视图，同时data中的响应式对象劫持当前watcher并“储存”起来</li><li>data更新数据会触发响应式对象的set函数，把get数据时“储存”的watchers取出遍历，“通知”其更新视图。</li><li>watcher“接到data中的数据更新通知”，重新render视图。</li><li>视图发生变化会触发data的中响应式对象的set函数，循环形成数据流。</li></ul></li><li>例：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vm指向当前组件，el指向当前dom节点，第三个参数为标签类型，第四个为回调函数</span></span><br><span class="line"><span class="comment">// currentWatcher为全局变量指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通渲染的watcher</span></span><br><span class="line">Watcher(vm, el, <span class="string">&#x27;text&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 将currentWatcher对象指向当前watcher（vdom节点）供响应式对象的get函数获取</span></span><br><span class="line">    currentWatcher = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 读取显示的内容</span></span><br><span class="line">    el.textContext = <span class="built_in">eval</span>(<span class="string">&#x27;vm.data.text&#x27;</span>)</span><br><span class="line">    <span class="comment">// 解绑currentWatcher，防止发生错误。</span></span><br><span class="line">    currentWatcher = <span class="literal">null</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//带v-if指令的watcher</span></span><br><span class="line">Watcher(vm, el, <span class="string">&#x27;text&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 将currentWatcher对象指向当前watcher（vdom节点）供响应式对象的get函数获取</span></span><br><span class="line">    currentWatcher = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 实现v-if指令，通过判断变量值决定是否显示该元素,v-show原理类似</span></span><br><span class="line">    el.style.display = <span class="built_in">eval</span>(<span class="string">&#x27;Boolean(vm.data.text)&#x27;</span>) ? <span class="string">&#x27;block&#x27;</span> : <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    <span class="comment">// 解绑currentWatcher，防止发生错误。</span></span><br><span class="line">    currentWatcher = <span class="literal">null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>Vue 1 中存在的几个明显问题</h1><ol><li>启动时拦截所有组件的状态，进行递归响应式代理影响首次渲染速度</li><li>内存占用率高，一个“指令”，“computed计算属性”，“handlebar表达式”等等均需要创建一个watcher，watcher数量过多导致内存占用率高。</li><li>模板经过编译后直接操作dom，无法跨端。</li></ol><h1>Vue中的优化</h1><ol><li>新的渲染引擎 - vdom</li><li>Watcher依赖力度调整</li><li>其他<ol><li>API、语法糖重新设计与定义</li><li>生命周期调整</li><li>双向数据流 -&gt; 单向数据流</li><li>支持了jsx语法</li><li>等等…</li></ol></li></ol><h2 id="新的渲染引擎-vdom">新的渲染引擎 - vdom</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//template</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">if</span>=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;text&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue-loader 编译后的 compile render</span></span><br><span class="line"><span class="comment">// h函数用于生成Vdom节点，第一个参数为当前组件，第二个参数为属性，第三个属性为子节点</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.text</span><br><span class="line">     ? h(</span><br><span class="line">         <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">         <span class="literal">null</span>,</span><br><span class="line">         h(<span class="built_in">this</span>.text, <span class="literal">null</span>,[])</span><br><span class="line">     )</span><br><span class="line">     : vm.createEmptyVNode()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Watcher依赖力度调整">Watcher依赖力度调整</h2><p>watcher不再与单个dom节点、指令关联，一个component对应一个watcher，极大减少了vue 1 中watcher数量过多导致的内存问题。同时以来vdom diff在渲染时能以最小的代价来更新dom。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Watch(compoent, vm, <span class="string">&#x27;text&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newVnode = component.render()</span><br><span class="line">    <span class="keyword">const</span> oldVnode = component.render()</span><br><span class="line">    <span class="comment">//通过diff算法返回新旧节点的差异</span></span><br><span class="line">    <span class="keyword">const</span> patches = vm.diff(newVnode, oldVnode)</span><br><span class="line">    <span class="comment">// 通过patch函数对该组件应用差异</span></span><br><span class="line">    vm.patch(component, patches);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vdom带来的优势">vdom带来的优势</h2><ol><li>框架屏蔽具体渲染细节，抽象了渲染层，组建的抽象能力得以提升，不再依赖浏览器运行，进而可以跨段，如SSR、同构渲染一姐小程序、weex、uni-app等框架。</li><li>通过静态分析进行更多的AOT（Ahead Of Time）编译优化。</li><li>附加能力：大量组件更新时以最小的代价去更新dom。</li><li>vdom对比直接操作dom要慢，大部分情况下效率比vue 1 差，虽然牺牲了一点性能，但是使得vue获得更多特性及优化空间。</li></ol><h2 id="AOT编译优化">AOT编译优化</h2><h3 id="Cache-static-element">Cache static element</h3><ul><li>缓存静态节点、属性，避免重复创建</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">        Static</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">        &#123;&#123;dynmic&#125;&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">const</span> __static1=h(<span class="string">&#x27;span&#x27;</span>,&#123;</span><br><span class="line">    class:&#x27;foo&#x27;</span><br><span class="line">&#125;, <span class="string">&#x27;static&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">        __static1,</span><br><span class="line">        h(<span class="string">&#x27;span&#x27;</span>, <span class="built_in">this</span>.dynamic)</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Component-fast-path">Component fast path</h3><ul><li>编译后 直接判断是组件、原生标签还是文本节点，避免不必要的分支判断，提升性能。</li><li>提高vdom diff时的效率</li></ul><h4 id="Vue2优化前">Vue2优化前</h4><ul><li>每次都要调用h函数去做分支判断</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">&lt;Comp&gt;&lt;/Comp&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue2</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createFragment([</span><br><span class="line">        h(Comp, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">        h(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            h(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        ])</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">type, attrs, children</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isComponent(type))&#123;</span><br><span class="line">        <span class="comment">//创建component vnode</span></span><br><span class="line">        <span class="keyword">return</span> createComponentVNode(type, attrs, children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isDomElement(type))&#123;</span><br><span class="line">        <span class="comment">//创建原生dom vnode</span></span><br><span class="line">        <span class="keyword">return</span> createElementVNode(type, attrs, children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建纯string节点</span></span><br><span class="line">    <span class="keyword">return</span> createStringVNode(type, attrs, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vue3优化后">Vue3优化后</h4><ul><li>编译后直接调用不同的createVNode方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createFragment([</span><br><span class="line">        createComponentVNode(Comp, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">        createElmentVNode(<span class="string">&#x27;div&#x27;</span>,<span class="literal">null</span>, [</span><br><span class="line">           createElmentVNode(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">        ])</span><br><span class="line">    ])</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="SSR-optimize">SSR optimize</h3><ul><li>SSR时采用字符串拼接，不创建vnode。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译前</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;foo&quot;</span>&gt;</span><br><span class="line">            &#123;&#123;msg&#125;&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;comp/</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">        <span class="built_in">this</span>.ssrString(</span><br><span class="line">            <span class="string">`&lt;p class=&quot;foo&quot;&gt;`</span></span><br><span class="line">            + <span class="built_in">this</span>.msg</span><br><span class="line">            + <span class="string">&#x27;&lt;/p&gt;&#x27;</span></span><br><span class="line">        ),</span><br><span class="line">        h(comp)</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Inline-handler">Inline handler</h3><ul><li>缓存dom上的event handler，避免重复创建。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">&lt;div @click=<span class="string">&quot;count++&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">import</span> &#123;getBoundMethod&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>,&#123;</span><br><span class="line">        onClick:getBoundMethod(__fn1,<span class="built_in">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Vue3变更</h1><h2 id="Proxy-Reactive-State">Proxy Reactive State</h2><ul><li>Vue3改用Proxy去生成响应式对象</li><li>Vue1/2中遍历和递归所有data中的属性去生成响应式对象</li><li>Vue3中改为仅在get获取这个属性的时候才去生成响应式对象，延迟了响应式对象生成，加快了首屏渲染速度。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue1/2中的做法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).foreach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        defineReactive(data, key, data[key])</span><br><span class="line">        <span class="comment">//对象递归调用walk</span></span><br><span class="line">        walk(data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue3中的做法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> observerd = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> result = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">             <span class="comment">//只有在取对象子属性的时候才递归</span></span><br><span class="line">            reactive(result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> oldValue = target[key]</span><br><span class="line">            <span class="keyword">if</span> (value == oldValue)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">let</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observerd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Composition-API">Composition API</h2><ul><li>Vue2中，代码根据数据、方法、计算属性等进行分块，导致可能同一个业务功能的代码需要反复上下地跳着去看。<ul><li>虽然有Mixin，但业务和业务之间的关系，包括命名空间都会出现一定问题。</li></ul></li><li>Vue3中引入Composition API使得开发者可以根据业务将代码分块，按需引入响应式对象、watch、生命周期钩子等各种属性，使用方法类似React Hooks，使得开发者更灵活地开发。<ul><li>详情见<a href="https://vue3js.cn/docs/zh/">Vue3中文文档 - vuejs (vue3js.cn)</a></li></ul></li></ul><h3 id="Vue2">Vue2</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;   </span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> &#123;       </span><br><span class="line">            counter: <span class="number">0</span>     </span><br><span class="line">        &#125;   </span><br><span class="line">   &#125;,   </span><br><span class="line">   watch: &#123;     </span><br><span class="line">       <span class="function"><span class="title">counter</span>(<span class="params">newValue, oldValue</span>)</span> &#123;       </span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">&#x27;The new counter value is: &#x27;</span> + <span class="built_in">this</span>.counter)     </span><br><span class="line">       &#125;   </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue3">Vue3</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>) </span><br><span class="line">watch(counter, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;The new counter value is: &#x27;</span> + counter.value) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Why-use-Composition-API">Why use Composition API</h3><ul><li>mixin、hoc、composition api都是为了解决代码复用的问题。但是mixin、hoc过于灵活没有规范，导致开发人员容易写出零散、难以维护的逻辑。</li><li>Compostion API规避了mixin、hoc存在的缺陷，提供固定的编程模式-&gt;函数组合，对各模块解耦使得更优雅、更容易地去组合复用。</li><li>以组件状态为例，传统写法所有state都在一个component，杂糅在一起，语义化不强，compostion api使得state按照不同的逻辑分离出来，抽象出状态层组件。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    template:<span class="string">&#x27;#modal&#x27;</span>,</span><br><span class="line">    mixins:[Mixin1, Mixin2],</span><br><span class="line">    methods:&#123;</span><br><span class="line">        <span class="function"><span class="title">click</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.sendLog()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        appChild:Child</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看完以上代码会发现以下问题<ul><li>sendLog到底来自哪个Mixin</li><li>mixin1，mixin2之间有没有逻辑关系</li><li>mixin1，mixin2如果都注入了sendLog使用哪个</li><li>如果使用hoc的方式，hoc增加了两个组件实例消耗，多了两次diff。</li><li>再来多几个mixin，这个组件更难维护。</li></ul></li><li>明显地体现了Composition API的好处</li></ul><h2 id="Time-Slicing">Time Slicing</h2><ul><li>Vue3最开始实现了这个特性，不过后面移除了</li><li>原因总结为以下两条<ul><li>基于响应式原理及AOT编译优化，相比react而言vue vdom diff具有很高的效率</li><li>Time Slicing只在一些极端情况下有明显作用，引入会降低vdom diff效率，阻塞UI渲染，收益不大。</li></ul></li></ul><h2 id="按需引入、支持treeshaking">按需引入、支持treeshaking</h2><ul><li>Vue各模块（响应式、SSR、runtime等）的解耦，可按需引入。</li></ul><h1>Vue vs React</h1><h2 id="相同点">相同点</h2><ol><li>基于MVVM思想：响应式数据驱动试图更新</li><li>提供组件化的解决方案</li><li>跨端：基于vdom的渲染引擎</li></ol><h2 id="核心差异">核心差异</h2><ol><li>定位<ol><li>React是一个Library，只专注于state到view的映射，状态、路由、动画等解决方案均来自于社区。</li><li>Vue是一个渐进式Framework，设计之初考虑开发者可能面临的问题，官方提供路由、状态管理、动画、插件等比较齐全的解决方案，不强制使用，譬如模块机制、依赖注入，可以通过插件机制很好和社区方案集成。</li><li>Library，职责范围小，开发效率低，需借助外力，但是易于扩展。对维护团队而言，保持版本间兼容成本较低。更容易集中精力专注于核心变更。</li><li>Framework，职责范围大，开发效率高，内置一套解决方案，扩展程度低。对维护团队而言，保持版本间兼容成本较高。</li></ol></li><li>渲染引擎<ol><li>Vue进行数据拦截/代理，它对侦测数据的变化更准确，改变了多少数据，就触发多少更新多少。</li><li>React setState触发局部整体刷新，没有追踪数据变更，做到精确更新，所以提供给开发者shouldComponentUpdate去除一些不必要的更新。</li><li>基于这个响应式设计，间接影响了核心架构的Composition API、React Hooks的实现。</li></ol></li><li>模板DSL<ol><li>Vue template语法更接近html，静态表达能力很强，基于声明式的能力，更方便做AOT编译优化。</li><li>JSX语法可以认为是JS基础上又增加了对html的支持，本质还是命令式变成。静态表达能力偏弱，导致优化信息不足，无法很好地做静态编译。</li></ol></li></ol><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Front End </tag>
            
            <tag> Vue </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析前端路由Router</title>
      <link href="2021/02/15/%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1Router/"/>
      <url>2021/02/15/%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1Router/</url>
      
        <content type="html"><![CDATA[<h1>前端路由介绍</h1><h2 id="什么前端路由">什么前端路由</h2><p>路由这个概念最早出现在后端，通过⽤户请求的url导航到具体的html⻚⾯。现在的前端路由不同</p><p>于传统路由，它不需要服务器解析，⽽是可以通过hash函数或者history API来实现。在前端开发中，我</p><p>们可以使⽤路由设置访问路径，并根据路径与组件的映射关系切换组件的显示，⽽这整个过程都是在同</p><p>⼀个⻚⾯中实现的，不涉及⻚⾯间的跳转，这也就是我们常说的单⻚应⽤（spa）。</p><h2 id="前端路由带来了什么">前端路由带来了什么</h2><h3 id="相⽐多⻚应⽤-mpa-来说，spa有以下优点：">相⽐多⻚应⽤(mpa)来说，spa有以下优点：</h3><ul><li>不涉及html⻚⾯跳转，内容改变不需要重新加载⻚⾯，对服务器压⼒⼩。</li><li>只涉及组件之间的切换，因此跳转流畅，⽤户体验好。</li><li>⻚⾯效果会⽐较炫酷（⽐如切换⻚⾯内容时的转场动画）。</li><li>组件化开发便捷。</li></ul><h3 id="但是同时spa也有以下缺点：">但是同时spa也有以下缺点：</h3><ul><li>⾸屏加载过慢。</li><li>不利于seo。</li><li>⻚⾯复杂度提⾼很多。</li></ul><h1>⽤原⽣ <strong>js</strong> 实现前端路由</h1><h2 id="什么前端路由-2">什么前端路由</h2><p>路由这个概念最早出现在后端，通过⽤户请求的 url 导航到具体的 html ⻚⾯。现在的前端路由不同于</p><p>传统路由，它不需要服务器解析，⽽是可以通过 hash 函数或者 h5 history API 来实现。在前端开发</p><p>中，我们可以使⽤路由设置访问路径，并根据路径与组件的映射关系切换组件的显示，⽽这整个过程都</p><p>是在同⼀个⻚⾯中实现的，不涉及⻚⾯间的跳转，这也就是我们常说的单⻚应⽤（spa）。</p><h2 id="原⽣-js-实现前端路由">原⽣ <strong>js</strong> 实现前端路由</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>lesson2<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/user&quot;</span>&gt;</span>用户中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> view = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, onLoad);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听hash变化</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, onHashChange);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">onLoad</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      view = <span class="built_in">document</span>.getElementById(<span class="string">&quot;view&quot;</span>);</span></span><br><span class="line">      onHashChange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">onHashChange</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">switch</span> (location.hash) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="string">&quot;#/home&quot;</span>:</span></span><br><span class="line"><span class="javascript">          view.innerHTML = <span class="string">&quot;首页&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="string">&quot;#/user&quot;</span>:</span></span><br><span class="line"><span class="javascript">          view.innerHTML = <span class="string">&quot;用户中心&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="string">&quot;#/login&quot;</span>:</span></span><br><span class="line"><span class="javascript">          view.innerHTML = <span class="string">&quot;登录&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">break</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>环境配置与 react-router 简介</h1><h2 id="资源">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="目标">目标</h2><ol><li>掌握 cra 环境</li><li>掌握 react-router 的基本使用</li></ol><h2 id="知识点">知识点</h2><h3 id="快速开始">快速开始</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-react-app router-nut</span><br><span class="line"><span class="built_in">cd</span> router-nut</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure><h3 id="配置-less-与装饰器">配置 less 与装饰器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @craco/craco craco-less @babel/plugin-proposal-decorators</span><br></pre></td></tr></table></figure><p>根目录下添加 craco.config.js 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// * 配置完成后记得重启下</span></span><br><span class="line"><span class="keyword">const</span> CracoLessPlugin = <span class="built_in">require</span>(<span class="string">&quot;craco-less&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  babel: &#123;</span><br><span class="line">    <span class="comment">//用来支持装饰器</span></span><br><span class="line">    plugins: [[<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123;<span class="attr">legacy</span>: <span class="literal">true</span>&#125;]]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123;</span><br><span class="line">      plugin: CracoLessPlugin</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改 package.json</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;start&quot;: &quot;craco start&quot;,</span><br><span class="line">   &quot;build&quot;: &quot;craco build&quot;,</span><br><span class="line">   &quot;test&quot;: &quot;craco test&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="react-router-简介">react-router 简介</h3><p>react-router 包含 3 个库，react-router、react-router-dom 和 react-router-native。react-router 提供最基本的路由功能，实际使用的时候我们不会直接安装 react-router，而是根据应用运行的环境选择安装 react-router-dom（在浏览器中使用）或 react-router-native（在 rn 中使用）。react-router-dom 和 react-router-native 都依赖 react-router，所以在安装时，react-router 也会自动安装，创建 web 应用。</p><h4 id="安装">安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure><h4 id="BrowserRouter-与-HashRouter-对比">BrowserRouter 与 HashRouter 对比</h4><ol><li>HashRouter 最简单，不需要服务器端渲染，靠浏览器的#的来区分 path 就可以，BrowserRouter 需要服务器端对不同的 URL 返回不同的 HTML，后端配置可<a href="https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html">参考</a>。</li><li>BrowserRouter 使用 HTML5 history API（ pushState，replaceState 和 popstate 事件），让页面的 UI 同步与 URL。</li><li>HashRouter 不支持 location.key 和 location.state，动态路由跳转需要通过?传递参数。</li><li>Hash history 不需要服务器任何配置就可以运行，如果你刚刚入门，那就使用它吧。但是我们不推荐在实际线上环境中用到它，因为每一个 web 应用都应该渴望使用 <code>browserHistory</code>。</li></ol><h4 id="MemoryRouter">MemoryRouter</h4><p>把 URL 的历史记录保存在内存中的 <code>&lt;Router&gt;</code>（不读取、不写入地址栏）。在测试和非浏览器环境中很有用，如 React Native。</p><h4 id="基本使用">基本使用</h4><p>react-router 中奉行一切皆组件的思想，路由器-<strong>Router</strong>、链接-<strong>Link</strong>、路由-<strong>Route</strong>、独占-<strong>Switch</strong>、重定向-<strong>Redirect</strong>都以组件形式存在</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Link&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> HomePage <span class="keyword">from</span> <span class="string">&quot;./pages/HomePage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> UserPage <span class="keyword">from</span> <span class="string">&quot;./pages/UserPage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> LoginPage <span class="keyword">from</span> <span class="string">&quot;./pages/LoginPage&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/&quot;</span>&gt;首页&lt;/Link&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/user&quot;</span>&gt;用户中心&lt;/Link&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/login&quot;</span>&gt;登录&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 根路由要添加exact，实现精确匹配 */</span>&#125;</span><br><span class="line">        &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;HomePage&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;UserPage&#125; /&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/login&quot;</span> component=&#123;LoginPage&#125; /&gt;</span><br><span class="line">      &lt;/Router&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h1>Route 渲染内容的三种方式</h1><h2 id="资源-2">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="目标-2">目标</h2><ol><li>掌握 Route 渲染内容的三种方式</li><li>掌握 404 路由</li></ol><h2 id="知识点-2">知识点</h2><p>Route 渲染优先级：children&gt;component&gt;render。</p><p>三者能接收到同样的[route props]，包括 match, location and history，但是当不匹配的时候，children 的 match 为 null。</p><p>这三种方式互斥，你只能用一种。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Link, Switch&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> HomePage <span class="keyword">from</span> <span class="string">&quot;./pages/HomePage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> UserPage <span class="keyword">from</span> <span class="string">&quot;./pages/UserPage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> LoginPage <span class="keyword">from</span> <span class="string">&quot;./pages/LoginPage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> _404Page <span class="keyword">from</span> <span class="string">&quot;./pages/_404Page&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          setCount(count + <span class="number">1</span>);</span><br><span class="line">        &#125;&#125;&gt;</span><br><span class="line">        add: &#123;count&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/&quot;</span>&gt;首页&lt;/Link&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/user&quot;</span>&gt;用户中心&lt;/Link&gt;</span><br><span class="line">        &lt;Link to=<span class="string">&quot;/login&quot;</span>&gt;登录&lt;/Link&gt;</span><br><span class="line">        &#123;<span class="comment">/* 独占路由 */</span>&#125;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route</span><br><span class="line">            path=<span class="string">&quot;/&quot;</span></span><br><span class="line">            exact</span><br><span class="line">            <span class="comment">//children=&#123;children&#125;</span></span><br><span class="line">            component=&#123;HomePage&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ! 渲染component的时候会调用React.createElement，如果使用下面这种匿名函数的形式，每次都会生成一个新的匿名的函数，</span></span><br><span class="line">            <span class="comment">// ! 导致生成的组件的type总是不相同，这个时候会产生重复的卸载和挂载</span></span><br><span class="line">            <span class="comment">//!  错误举例 课下自己尝试下 观察下HomePage的didMount和willUnmount函数 */&#125;</span></span><br><span class="line">            <span class="comment">//component=&#123;() =&gt; &lt;HomePage /&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// render=&#123;render&#125;</span></span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;UserPage&#125; /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/login&quot;</span> component=&#123;LoginPage&#125; /&gt;</span><br><span class="line">          &lt;Route component=&#123;_404Page&#125; /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/Router&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;children props&quot;</span>, props); <span class="comment">//sy-log</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>children<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;props props&quot;</span>, props); <span class="comment">//sy-log</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>render<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="children：func">children：func</h3><p>有时候，不管 location 是否匹配，你都需要渲染一些内容，这时候你可以用 children。</p><p>除了不管 location 是否匹配都会被渲染之外，其它工作方法与 render 完全一样。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Link, Route&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItemLink</span>(<span class="params">&#123;to, name, ...rest&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Route</span><br><span class="line">      path=&#123;to&#125;</span><br><span class="line">      children=&#123;<span class="function">(<span class="params">&#123;match&#125;</span>) =&gt;</span> (</span><br><span class="line">        &lt;li className=&#123;match ? <span class="string">&quot;active&quot;</span> : <span class="string">&quot;&quot;</span>&#125;&gt;</span><br><span class="line">          &lt;Link to=&#123;to&#125; &#123;...rest&#125;&gt;</span><br><span class="line">            &#123;name&#125;</span><br><span class="line">          &lt;/Link&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteChildren</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;RouteChildren&lt;/h3&gt;</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">            &lt;ListItemLink to=<span class="string">&quot;/somewhere&quot;</span> name=<span class="string">&quot;链接1&quot;</span> /&gt;</span><br><span class="line">            &lt;ListItemLink to=<span class="string">&quot;/somewhere-else&quot;</span> name=<span class="string">&quot;链接2&quot;</span> /&gt;</span><br><span class="line">          &lt;/ul&gt;</span><br><span class="line">        &lt;/Router&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="render：func">render：func</h3><p>但是当你用 render 的时候，你调用的只是个函数。但是它和 component 一样，能访问到所有的[route props]。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便的内联渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/home&quot;</span> render=&#123;<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125; /&gt;</span><br><span class="line">  &lt;/Router&gt;,</span><br><span class="line">  node</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapping/composing</span></span><br><span class="line"><span class="comment">//把route参数传递给你的组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FadingRoute</span>(<span class="params">&#123;component: Component, ...rest&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Route &#123;...rest&#125; render=&#123;<span class="function"><span class="params">routeProps</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...routeProps</span>&#125; /&gt;</span></span>&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;FadingRoute path=<span class="string">&quot;/cool&quot;</span> component=&#123;Something&#125; /&gt;</span><br><span class="line">  &lt;/Router&gt;,</span><br><span class="line">  node</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="component-component">component: component</h3><p>只在当 location 匹配的时候渲染。</p><h3 id="注意">注意</h3><p>当你用<code>component</code>的时候，Route 会用你指定的组件和 React.createElement 创建一个新的[React element]。这意味着当你提供的是一个内联函数的时候，每次 render 都会创建一个新的组件。这会导致不再更新已经现有组件，而是直接卸载然后再去挂载一个新的组件。因此，当用到内联函数的内联渲染时，请使用 render 或者 children。</p><p>Route 核心渲染代码如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/0082zybply1gc7moo8djgj311c0u0wv0-20210325005548144-20210326000547431.jpg" alt="image20200224174023810"></p><h3 id="404-页面">404 页面</h3><p>设定一个没有 path 的路由在路由列表最后面，表示一定匹配</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/&quot;</span> exact component=&#123;HomePage&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/user&quot;</span> component=&#123;UserPage&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/login&quot;</span> component=&#123;LoginPage&#125; /&gt;</span><br><span class="line">  &lt;Route component=&#123;_404Page&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><h1>动态路由</h1><h2 id="资源-3">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="目标-3">目标</h2><ol><li>动态路由</li></ol><h2 id="知识点-3">知识点</h2><h3 id="动态路由">动态路由</h3><p>使用:id的形式定义动态路由</p><p>定义路由:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/product/:id&quot;</span> component=&#123;Product&#125; /&gt;</span><br></pre></td></tr></table></figure><p>添加导航链接:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Link to=&#123;<span class="string">&quot;/product/123&quot;</span>&#125;&gt;搜索&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>创建Search组件并获取参数:</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">&#123;location, match&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;match&quot;</span>, match); <span class="comment">//sy-log</span></span><br><span class="line">  <span class="keyword">const</span> &#123;id&#125; = match.params;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Product-&#123;id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>嵌套路由</h1><h2 id="资源-4">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="⽬标">⽬标</h2><ul><li>掌握嵌套路由</li></ul><h2 id="知识点-4">知识点</h2><h3 id="嵌套路由">嵌套路由</h3><p>Route组件嵌套在其他⻚⾯组件中就产⽣了嵌套关系</p><p>修改Product，添加新增和详情</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Route path&#x3D;&#123;url + &quot;&#x2F;detail&quot;&#125; component&#x3D;&#123;Detail&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">&#123;match&#125;</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;match&quot;</span>, match); <span class="comment">//sy-log</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;params, url&#125; = match;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;id&#125; = params;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">&lt;div&gt; </span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Search-&#123;id&#125;&lt;/h1&gt; </span><br><span class="line"></span><br><span class="line">&lt;Link to=&#123;url + <span class="string">&quot;/detail&quot;</span>&#125;&gt;详情&lt;/Link&gt; </span><br><span class="line"></span><br><span class="line">&lt;Route path=&#123;url + <span class="string">&quot;/detail&quot;</span>&#125; component=&#123;Detail&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt; );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>⼿写实现<strong>BrowserRouter</strong>、<strong>Route</strong>、<strong>Link</strong></h1><h2 id="资源-5">资源</h2><ol><li><a href="https://react.docschina.org/">React 官网</a></li><li><a href="http://react-router.docschina.org/">react-router</a></li></ol><h2 id="⽬标-2">⽬标</h2><ul><li>react-router初步实现</li></ul><h2 id="知识点-5">知识点</h2><h3 id="跨层级传输数据-Context">跨层级传输数据 Context</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Context做数据跨层级传递</span></span><br><span class="line"><span class="comment">// step1: 创建context对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RouterContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// step2: 使用context对象的Provider传递value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step3: 子组件消费value： Consumer、useContext、contextType</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现Router">实现<strong>Router</strong></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RouterContext&#125; <span class="keyword">from</span> <span class="string">&quot;./Context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">computeRootMatch</span>(<span class="params">pathname</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">url</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">params</span>: &#123;&#125;, <span class="attr">isExact</span>: pathname === <span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            location: props.history.location</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.unlisten = props.history.listen(<span class="function"><span class="params">location</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                location</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.unlisten) &#123;</span><br><span class="line">            <span class="built_in">this</span>.unlisten();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;RouterContext.Provider</span><br><span class="line">                value=&#123;&#123;</span><br><span class="line">                    history: <span class="built_in">this</span>.props.history,</span><br><span class="line">                    location: <span class="built_in">this</span>.state.location,</span><br><span class="line">                    match: Router.computeRootMatch(<span class="built_in">this</span>.state.location.pathname)</span><br><span class="line">                &#125;&#125;&gt;</span><br><span class="line">                &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">            &lt;/RouterContext.Provider&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现BrowserRouter">实现<strong>BrowserRouter</strong></h3><p><strong>BrowserRouter</strong>：历史记录管理对象history初始化及向下传递，location变更监听</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createBrowserHistory&#125; <span class="keyword">from</span> <span class="string">&quot;history&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&quot;./Router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.history = createBrowserHistory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Route">实现<strong>Route</strong></h3><p>路由配置，匹配检测，内容渲染</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// match 按照互斥规则 优先渲染顺序为children component render null，children如果是function执⾏function，是节点直接渲染</span></span><br><span class="line"><span class="comment">// 不match children 或者null （只渲染function）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;RouterContext.Consumer&gt;</span><br><span class="line">                &#123;<span class="function"><span class="params">context</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 优先从props中取值</span></span><br><span class="line">                    <span class="keyword">const</span> location = <span class="built_in">this</span>.props.location || context.location;</span><br><span class="line">                    <span class="comment">// 优先从props中取值计算</span></span><br><span class="line">                    <span class="keyword">const</span> match = <span class="built_in">this</span>.props.computedMatch</span><br><span class="line">                        ? <span class="built_in">this</span>.props.computedMatch</span><br><span class="line">                        : <span class="built_in">this</span>.props.path</span><br><span class="line">                            ? matchPath(location.pathname, <span class="built_in">this</span>.props)</span><br><span class="line">                            : context.match;</span><br><span class="line">                    <span class="keyword">const</span> props = &#123;</span><br><span class="line">                        ...context,</span><br><span class="line">                        location,</span><br><span class="line">                        match</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">let</span> &#123;path, children, component, render&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">                    <span class="comment">// match 渲染这三者之⼀：children component render或者null</span></span><br><span class="line">                    <span class="comment">// 不match，渲染children 或者 null</span></span><br><span class="line">                    <span class="keyword">return</span> (</span><br><span class="line">                        &lt;RouterContext.Provider value=&#123;props&#125;&gt;</span><br><span class="line">                            &#123;match</span><br><span class="line">                                ? children</span><br><span class="line">                                    ? <span class="keyword">typeof</span> children === <span class="string">&quot;function&quot;</span></span><br><span class="line">                                        ? children(props)</span><br><span class="line">                                        : children</span><br><span class="line">                                    : component</span><br><span class="line">                                        ? React.createElement(component, props)</span><br><span class="line">                                        : render</span><br><span class="line">                                            ? render(props)</span><br><span class="line">                                            : <span class="literal">null</span></span><br><span class="line">                                : <span class="keyword">typeof</span> children === <span class="string">&quot;function&quot;</span></span><br><span class="line">                                    ? children(props)</span><br><span class="line">                                    : <span class="literal">null</span>&#125;</span><br><span class="line">                        &lt;/RouterContext.Provider&gt;</span><br><span class="line">                    );</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &lt;/RouterContext.Consumer&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现<strong>Link</strong></p><p>Link.js: 跳转链接，处理点击事件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RouterContext&#125; <span class="keyword">from</span> <span class="string">&quot;./RouterContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Link</span>(<span class="params">&#123;to, children, ...restProps&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = React.useContext(RouterContext);</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    context.history.push(to);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=&#123;to&#125; &#123;...restProps&#125; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Switch">实现<strong>Switch</strong></h3><p>渲染与该地址匹配的第⼀个⼦节点 <Route> 或者 <Redirect> 。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component, isValidElement&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RouterContext&#125; <span class="keyword">from</span> <span class="string">&quot;./Context&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> matchPath <span class="keyword">from</span> <span class="string">&quot;./matchPath&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Switch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;RouterContext.Consumer&gt;</span><br><span class="line">                &#123;<span class="function"><span class="params">context</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> &#123;location&#125; = context;</span><br><span class="line">                    <span class="keyword">let</span> match, element;</span><br><span class="line">                    <span class="comment">// children element | array</span></span><br><span class="line">                    React.Children.forEach(<span class="built_in">this</span>.props.children, <span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (match == <span class="literal">null</span> &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">                            element = child;</span><br><span class="line">                            <span class="keyword">const</span> &#123;path&#125; = child.props;</span><br><span class="line">                            match = path</span><br><span class="line">                                ? matchPath(location.pathname, child.props)</span><br><span class="line">                                : context.match;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">return</span> match</span><br><span class="line">                        ? React.cloneElement(element, &#123;<span class="attr">computedMatch</span>: match&#125;)</span><br><span class="line">                        : <span class="literal">null</span>;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            &lt;/RouterContext.Consumer&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> React </tag>
            
            <tag> Front End </tag>
            
            <tag> 底层原理 </tag>
            
            <tag> Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript入门 | 学习笔记</title>
      <link href="2021/01/22/TypeScript%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/22/TypeScript%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="TypeScript学习笔记">TypeScript学习笔记</h3><h3 id="TS简介">TS简介</h3><blockquote><p>Ts微软开发，包含ES6、包含ES5</p></blockquote><p>编译 tsc xx.ts<br>每一次都得编译，可以自动编译</p><h3 id="开发工具中配置typescirpt自动编译">开发工具中配置typescirpt自动编译</h3><p>vscode:</p><ol><li>创建tsconfig.json文件 tsc --init 生成配置文件</li><li>tsconfig.json配置文件中，修改outDir配置项，取消注释然后修改为.js</li><li>vscode中，点击上方栏位run task，选择ts监听</li><li>完成</li></ol><h3 id="TS类型">TS类型</h3><ul><li>与es5中的区别</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5：类型变化不报错</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">flag = <span class="number">234</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts：必须指定类型</span></span><br><span class="line">typescript</span><br><span class="line"><span class="keyword">var</span> flag:<span class="built_in">boolean</span>=<span class="literal">true</span>;</span><br><span class="line">flag = <span class="number">131</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h4 id="TS类型：">TS类型：</h4><ul><li>boolean</li><li>number</li><li>string</li><li>array数组：<br>方式1：var arr:number[] = [1,2,3]//制定arr里面全是数字<br>方式2：var arr:Array= [1,2,3]</li></ul><h4 id="元组类型（tuple）">元组类型（tuple）</h4><ul><li>方式1：属于数组的一种，即数组中每一个元素指定类型</li><li>方式2：var arr:[number, string]=[123,“this is ts”];</li></ul><h4 id="枚举类型-enum">枚举类型(enum)</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用来标识状态码</span></span><br><span class="line"><span class="built_in">enum</span> Flag&#123;</span><br><span class="line">   success=<span class="number">1</span>,</span><br><span class="line">     error=<span class="number">2</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> f:Flag=Flag.error;</span><br><span class="line"> <span class="built_in">console</span>.log(f);<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 没有标识符没有赋值，那么打印的就是下标</span></span><br><span class="line"><span class="built_in">enum</span> Color&#123;blue,red,orange&#125;;</span><br><span class="line"> <span class="keyword">var</span> c:Color=Color.red;</span><br><span class="line"> <span class="built_in">console</span>.log(c);  <span class="comment">//1，下标</span></span><br><span class="line"> <span class="built_in">enum</span> Color&#123;blue,red=<span class="number">3</span>,orange&#125;;</span><br><span class="line"> <span class="keyword">var</span> c:Color=Color.red;</span><br><span class="line"> <span class="built_in">console</span>.log(c);  <span class="comment">//3</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 常用来标识状态码</span></span><br><span class="line"> <span class="built_in">enum</span> Err&#123;</span><br><span class="line">  <span class="string">&#x27;undefined&#x27;</span>=-<span class="number">1</span>,</span><br><span class="line">   <span class="string">&#x27;null&#x27;</span>=-<span class="number">2</span>,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> c:Err=Err.null</span><br><span class="line"> <span class="built_in">console</span>.log(c) <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><h4 id="任意类型any">任意类型any</h4><ul><li>类似ES5不指定变量类型的var</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="built_in">any</span>=<span class="number">123</span>;</span><br><span class="line">num = <span class="literal">true</span>;<span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><h4 id="null类型和undefined其他数据类型的子类型">null类型和undefined其他数据类型的子类型</h4><ul><li>变量定义之后没有赋值，报undefined</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个元素可能是number类型，可能是null或者undefined</span></span><br><span class="line"><span class="keyword">var</span> num:<span class="built_in">number</span> | <span class="literal">undefined</span> | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="void和java一样-没有返回值类型">void和java一样 没有返回值类型</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果方法没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;asdf&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果方法有返回值：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">number</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="never类型，代表从来不会出现的值，是其他类型（包括null‘和undefined）的子类型，代表从不会出现的值">never类型，代表从来不会出现的值，是其他类型（包括null‘和undefined）的子类型，代表从不会出现的值</h4><ul><li>自己理解为上述类型之外的数据类型</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下，接收Err类型的数据</span></span><br><span class="line">   <span class="keyword">var</span> a:<span class="built_in">never</span>;</span><br><span class="line">   a = <span class="literal">undefined</span>;<span class="comment">//报错</span></span><br><span class="line">   a = (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Throw Err(<span class="string">&quot;报错&quot;</span>)</span><br><span class="line">   &#125;)()</span><br></pre></td></tr></table></figure><h3 id="函数的定义">函数的定义</h3><ul><li>ES5中：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">var</span> run2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TS中：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">var</span> fun2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ts中定义方法传参">ts中定义方法传参</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getInfo= <span class="function"><span class="keyword">function</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法可选参数">方法可选参数</h3><blockquote><p>es5里方法实参和形参可以不一样，但是ts必须一致，如果不一样就需要配置可选参数</p></blockquote><ul><li>参数后边加?可以设置参数可选传</li><li>可选参数必须配置到参数的最后边</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age?<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认参数">默认参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认参数，直接在形参赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span>, age:<span class="built_in">number</span>=<span class="number">20</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩余参数">剩余参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span>, c:<span class="built_in">number</span>, d:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b+c+d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三点运算符：接收不固定参数的（剩余参数）的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">…rest:<span class="built_in">number</span>[]</span>):<span class="title">number</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum= <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;rest.length;i++)&#123;</span><br><span class="line">sum+=rest[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载">函数重载</h3><ul><li>类似java，同名但是不同参数的多个函数方法</li><li>ts为了兼容es5，以及es6，和java有区别</li><li>es5中，出现同名方法时候，下面的方法会替换上面的方法</li><li>ts中的重载：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">age:<span class="built_in">number</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">str:<span class="built_in">any</span></span>):<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> str ===<span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我叫：&quot;</span>+ str;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我的年龄是:&quot;</span> + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数">箭头函数</h3><p>箭头函数里面的this指向上下文</p><h3 id="类">类</h3><p>1、ES5中定义类：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=<span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">alert(p.name);</span><br></pre></td></tr></table></figure><p>2、构造函数和原型链里面定义</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明的构造方法</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">       <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">       <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">           alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 原型链的属性和方法</span></span><br><span class="line">   Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">   Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       alert(xx)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">   p.work();</span><br></pre></td></tr></table></figure><p>3、静态方法</p><p>4、es5中的继承-对象冒充继承</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要实现Web类 继承 Person类  原型链+对象冒充的组合继承模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要实现Web类 继承 Person类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>); <span class="comment">//对象冒充继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web();</span><br><span class="line">w.run();<span class="comment">//执行父类Person的run，对象冒充可以继承构造函数里面的属性和方法</span></span><br><span class="line">w.work();<span class="comment">// 对象冒充可以继承构造函数的属性和方法 但是没办法继承原型链的属性和方法（prototype）</span></span><br></pre></td></tr></table></figure><ul><li>关于call：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.error(add.call(obj, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 10</span></span><br><span class="line">大统上的说法就是，call改变了<span class="built_in">this</span>的指向。然后，介绍<span class="built_in">this</span> xxx什么一大堆名词，反正不管你懂不懂，成功绕晕你就已经ok了，但是实际发生的过程，可以看成下面的样子。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">给o对象添加一个add属性，这个时候 <span class="built_in">this</span> 就指向了 o，</span><br><span class="line">o.add(<span class="number">5</span>,<span class="number">7</span>)得到的结果和add.call(o, <span class="number">5</span>, <span class="number">6</span>)相同。</span><br></pre></td></tr></table></figure><p>5、原型链继承方法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// web原型链方式继承 person</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">web</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">web.prototype= <span class="keyword">new</span> person();<span class="comment">// 原型链继承</span></span><br><span class="line"></span><br><span class="line">web.work();<span class="comment">// 可以工作，可以继承原型链属性方法</span></span><br></pre></td></tr></table></figure><p>6、原型链实现继承的问题？？无法给父类传参</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> person(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">p.run(); <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// 继承，无法给父类传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Web.prototype= <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">&#x27;sss&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">w.run();<span class="comment">// 父类会alert出来“undefiend在运动”</span></span><br><span class="line"><span class="comment">// 实例化子类时候没法给父类传参</span></span><br></pre></td></tr></table></figure><p>7、原型链+构造函数的组合继承模式</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> person(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">p.run(); <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// 继承，无法给父类传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>,name,age); <span class="comment">// 对象冒充继承 可以继承构造函数里面的属性和方法 实例化子类可以给父类传参</span></span><br><span class="line">&#125;</span><br><span class="line">Web.prototype = <span class="keyword">new</span> Person();<span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">&#x27;sss&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">w.run();<span class="comment">// 父类会alert出来“undefiend在运动”</span></span><br><span class="line"><span class="comment">// 实例化子类时候没法给父类传参</span></span><br></pre></td></tr></table></figure><p>8、原型链+对象冒充的另一种写法</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>))</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name+<span class="string">&quot;在运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链的属性和方法</span></span><br><span class="line">Person.prototype.sex=<span class="string">&quot;男&quot;</span>;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> person(<span class="string">&#x27;李四&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">p.run(); <span class="comment">// 没问题</span></span><br><span class="line"><span class="comment">// 继承，无法给父类传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>,name,age); <span class="comment">// 对象冒充继承 可以继承构造函数里面的属性和方法 实例化子类可以给父类传参</span></span><br><span class="line">&#125;</span><br><span class="line">Web.prototype = Person.prototype; <span class="comment">// 和方法7中不同的是这里！！！</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">&#x27;sss&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">w.run();<span class="comment">// 父类会alert出来“undefiend在运动”</span></span><br><span class="line"><span class="comment">// 实例化子类时候没法给父类传参</span></span><br></pre></td></tr></table></figure><h3 id="类的定义">类的定义</h3><p>1、ts中定义类，类似java：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>()</span>&#123;</span><br><span class="line">    name:<span class="built_in">string</span>; <span class="comment">//属性 前面省略了private</span></span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">n:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    run():<span class="built_in">void</span>&#123;</span><br><span class="line">        log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、继承</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Web(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">alert(w.run());</span><br></pre></td></tr></table></figure><p>3、类里面的修饰符</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">ts提供了三种修饰符：</span><br><span class="line"><span class="keyword">public</span>(默认的)： 公有 在类里面、子类类外边都可以访问</span><br><span class="line"><span class="keyword">protected</span>：在类里面、子类里面可以访问、在类外部无法访问</span><br><span class="line"><span class="keyword">private</span>：在类里面可以访问、子类、类外部没法访问</span><br></pre></td></tr></table></figure><h3 id="静态属性-静态方法">静态属性 静态方法</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.run1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">// 实例方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.run2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 静态方法</span></span><br><span class="line"></span><br><span class="line">调用实例方法：(实例化之后才能调用的)</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.run1();</span><br><span class="line"></span><br><span class="line">调用静态方法：</span><br><span class="line">Person.run2();</span><br></pre></td></tr></table></figure><blockquote><p>为什么会有静态方法和实例方法之分？<br>JQuery的实例方法css()方法和静态方法$.get()方法大概原码为：</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生命一个节点/元素对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.element = 获取dome节点的方法;</span><br><span class="line">    <span class="built_in">this</span>.css = <span class="function"><span class="keyword">function</span>(<span class="params">str, value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.element.style[str] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $方法去实例化这个BAse对象、实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Base(element); <span class="comment">// 实例化一个方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法get</span></span><br><span class="line">$.<span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 那么css调用时候就可以这样写</span></span><br><span class="line">实例方法:</span><br><span class="line">$(<span class="string">&quot;#box&quot;</span>).css(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line"></span><br><span class="line">静态方法：</span><br><span class="line">$.get(<span class="string">&#x27;url&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>另一种方式声明静态方法，利用static关键字声明：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">static</span> sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;<span class="comment">// 静态方法 里面没办法直接调用类里面的属性，</span></span><br><span class="line">        alert(<span class="string">&quot;静态方法：&quot;</span>+Person.sex);<span class="comment">// 如果调用this.name就会报错！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $.get()&#123;// jq里面的get就是静态方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态">多态</h3><blockquote><p>父类定义一个方法不去实现，让继承他的子类去实现，每一个子类都有不同的表现</p></blockquote><h3 id="抽象方法">抽象方法</h3><ul><li>用来定义一个标准</li><li>ts中的抽象类，它是提供其他类继承的基类，不能直接被实例化</li><li>用abstract关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现</li><li>abstract 抽象方法只能放在抽象类中</li><li>抽象类和抽象方法用来定义标准，基类要求他的子类必须包含某种方法</li><li>抽象方法只能出现在抽象类中</li><li>抽象类中必须包含至少一个抽象方法，不然没有意义</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line">    <span class="keyword">abstract</span> eat():<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类无法直接实例化</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal();<span class="comment">// 这句话是错的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Dog(<span class="string">&quot;sss&quot;</span>)</span><br><span class="line">d.eat();<span class="comment">// sss吃</span></span><br></pre></td></tr></table></figure><h3 id="接口">接口</h3><blockquote><p>也是定义标准，定义了行为和动作的规范</p></blockquote><p>1、属性接口</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义了这个方法的参数是jsonObjec，而且必须有</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelInfo:&#123;label:<span class="built_in">string</span>&#125;</span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(labelInfo.label);</span><br><span class="line">&#125;</span><br><span class="line">printLabel(<span class="string">&quot;ssss&quot;</span>); <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">printLabel(&#123;<span class="attr">name</span>:<span class="string">&quot;asdf&quot;</span>&#125;); <span class="comment">// 错误</span></span><br><span class="line">printLabel(&#123;<span class="attr">label</span>:<span class="string">&quot;sss&quot;</span>&#125;); <span class="comment">// 正确，打印sss</span></span><br></pre></td></tr></table></figure><p>2、接口，对批量方法进行约束</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对批量方法传入参数进行约束</span></span><br><span class="line"><span class="comment">// 传入对象的约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明类型</span></span><br><span class="line"><span class="keyword">interface</span> FullName&#123;</span><br><span class="line">    firstName:<span class="built_in">string</span>; <span class="comment">// 注意是;结束</span></span><br><span class="line">    secondName:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法名中引用FullName类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params">name:FullName</span>)</span>&#123;</span><br><span class="line">    log(name.firstName +<span class="string">&quot;  &quot;</span>+ name.secondName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式一（下方调用方式是会报错的，interface定义的属性object只能包含firstName和secondName）</span></span><br><span class="line">printName(&#123;</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">    firstName: <span class="string">&quot;张&quot;</span>,</span><br><span class="line">    secondName: <span class="string">&quot;三&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式二，下方引入其他的object即可忽略多余参数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">    firstName: <span class="string">&quot;张&quot;</span>,</span><br><span class="line">    secondName: <span class="string">&quot;三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">printName(obj);<span class="comment">// 这个不报错</span></span><br></pre></td></tr></table></figure><p>3、接口、可选属性，加?问号表示可传可不传</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> FullName&#123;</span><br><span class="line">    firstName:<span class="built_in">string</span>;</span><br><span class="line">    secondName?:<span class="built_in">string</span>;<span class="comment">// secondName可传可不传</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、模拟封装一个ajax</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config&#123;</span><br><span class="line">    <span class="keyword">type</span>:<span class="built_in">string</span>;</span><br><span class="line">    url:<span class="built_in">string</span>;</span><br><span class="line">    data?:<span class="built_in">string</span>;</span><br><span class="line">    dataType:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、函数类型接口、对方法传入的参数、以及返回值进行约束、批量约束</p><ul><li>例子：定义加密的函数类型接口</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> encrypt&#123;</span><br><span class="line"><span class="comment">// 定义了函数参数为string、value，返回string</span></span><br><span class="line">(key:<span class="built_in">string</span>,<span class="attr">value</span>:<span class="built_in">string</span>):<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> md5:encrypt=<span class="function"><span class="keyword">function</span>(<span class="params">key:<span class="built_in">string</span>, value:<span class="built_in">string</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line"><span class="comment">// 实现encrypt类型的函数return key+value;//模拟下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6、可索引接口：对数组、对象的约束</p><ul><li>ts定义数组方法：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr:<span class="built_in">number</span>[]=[<span class="number">123</span>,<span class="number">234</span>];</span><br><span class="line"><span class="keyword">var</span> arr1:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;222&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>对数组的约束，数组类型接口</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserArray&#123;</span><br><span class="line">    <span class="comment">// 表示数组中index必须是number，value必须是string</span></span><br><span class="line">    [index:numer]:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr:UserArray=[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;22312&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>对对象的约束，对象类型接口</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserObj&#123;</span><br><span class="line">    [index:<span class="built_in">string</span>]:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj:UserObj=&#123;<span class="attr">name</span>:<span class="string">&quot;2342&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>对类的约束，类类型接口，和抽象类有点相似</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal&#123;</span><br><span class="line">    <span class="comment">// 规定实现类必须要有name属性和eat方法</span></span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    eat(str:<span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    name:<span class="built_in">string</span>;<span class="comment">// 若没此属性，ts会编译报错</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        log(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的扩展：接口可以继承接口</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal&#123;</span><br><span class="line">   eat():<span class="built_in">void</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">   work():<span class="built_in">void</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="title">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">       <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// eat必须定义</span></span><br><span class="line">      <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+<span class="string">&quot;吃&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// work也必须定义</span></span><br><span class="line">      <span class="function"><span class="title">work</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+<span class="string">&quot;工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Animal&#123;</span><br><span class="line">   eat():<span class="built_in">void</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">interface</span> Person <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">   work():<span class="built_in">void</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span></span>&#123;</span><br><span class="line">   <span class="comment">//构造方法省略</span></span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="title">coding</span>(<span class="params">code:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+ <span class="string">&quot;  &quot;</span>+code)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">Programmer</span> <span class="title">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> name:<span class="built_in">string</span>;</span><br><span class="line">       <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// eat必须定义</span></span><br><span class="line">      <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+<span class="string">&quot;吃&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// work也必须定义</span></span><br><span class="line">      <span class="function"><span class="title">work</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       log(<span class="built_in">this</span>.name+<span class="string">&quot;工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="泛型">泛型</h3><blockquote><p>和any有什么区别？</p></blockquote><ul><li>any放弃了类型检查</li><li>如果想做到传入什么类型就返回什么类型，例如传入number就返回number，这时候就可以使用泛型</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">value:<span class="built_in">any</span></span>):<span class="title">any</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;&quot;</span><span class="comment">//什么类型都可以</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="泛型：">泛型：</h4><ul><li>软件工程中，我们不仅要创建一致的定义好的API，同时也要考虑可重用性，组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能</li><li>在像c#和java中，可以使用泛型来创建可重用的组件，一个组件可支持多种类型的数据，这样用户就可以以自己的数据类型来使用组件</li><li>通俗理解：泛型就是解决 类 接口 方法的重用性、以及对不特定数据类型的支持</li><li>可以支持不特定的数据类型</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;<span class="comment">//传入什么返回什么</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样调用</span></span><br><span class="line">getData&lt;<span class="built_in">number</span>&gt;(<span class="number">123123</span>);</span><br><span class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;12131&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以写成：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;<span class="comment">//传入什么返回什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型类，比如有个最小堆算法，需要同时支持返回数字和字符串两种类型，通过类的泛型来实现，示例：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> list:<span class="built_in">number</span>[]=[];</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">num:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.list.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    min():<span class="built_in">number</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> minNum = <span class="built_in">this</span>.list[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="built_in">this</span>.list.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minNum&gt;<span class="built_in">this</span>.list[i])&#123;</span><br><span class="line">                minNum=<span class="built_in">this</span>.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MinClass();</span><br><span class="line">m.add(<span class="number">3</span>);</span><br><span class="line">m.add(<span class="number">2</span>);</span><br><span class="line">log(m.min());<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>但是上边的只能传入数字类型，是否可以用泛型解决？可以：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> list:T[]=[];</span><br><span class="line">    add(num:T):<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.list.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    min():T&#123;</span><br><span class="line">        <span class="keyword">var</span> minNum = <span class="built_in">this</span>.list[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="built_in">this</span>.list.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minNum&gt;<span class="built_in">this</span>.list[i])&#123;</span><br><span class="line">                minNum=<span class="built_in">this</span>.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用，实例化时候要先声明参数类型&lt;bumber</span></span><br><span class="line"><span class="keyword">var</span> m1 = <span class="keyword">new</span> MinClass&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">m1.add(<span class="number">2</span>);</span><br><span class="line">m1.add(<span class="number">4</span>);</span><br><span class="line">log(m.min());<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h5 id="函数类型接口">函数类型接口</h5><ul><li>指定特殊类型的方法：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ConfigFn&#123;</span><br><span class="line">   (value1:<span class="built_in">string</span>, <span class="attr">value2</span>:<span class="built_in">string</span>):<span class="built_in">string</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> setData:ConfigFn=<span class="function"><span class="keyword">function</span>(<span class="params">value1:<span class="built_in">string</span>, value2:<span class="built_in">string</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">   setData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三);</span></span><br></pre></td></tr></table></figure><ul><li>泛型接口写法1：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config&#123;</span><br><span class="line">   &lt;T&gt;(value:T):T;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> getData:ConfigFn=<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   getData&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>泛型接口写法2：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">interface</span> Config&lt;T&gt;&#123;</span><br><span class="line">   (value:T):T;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> myGetData:ConfigFn&lt;<span class="built_in">string</span>&gt;=getData;</span><br><span class="line"></span><br><span class="line">   myGetData(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>把类作为参数来约束数据传入的类型</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">   username:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       password:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MySqlDb</span></span>&#123;</span><br><span class="line">   add(user:User):<span class="built_in">boolean</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(user);</span><br><span class="line">           retrun <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用</span></span><br><span class="line">   <span class="keyword">var</span> u = <span class="keyword">new</span> User();</span><br><span class="line">   u.username=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">   u.password=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> Db = <span class="keyword">new</span> MySqlDb();</span><br><span class="line">   Db.add(u);<span class="comment">// console.log(u)</span></span><br></pre></td></tr></table></figure><ul><li>上述方法可以改为泛型类</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作数据库的泛型类，这样可以规范插入数据库数据的类规范</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySqlDb</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   add(info:T):<span class="built_in">boolean</span>&#123;</span><br><span class="line">       log(info);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 想给User表增加数据</span></span><br><span class="line">   <span class="comment">// 1、定义一个User类 和数据库进行映射</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">   username:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       password:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> u = <span class="keyword">new</span> User();</span><br><span class="line">   u.username= <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">   u.password=<span class="string">&quot;2312&quot;</span>；</span><br><span class="line">   <span class="keyword">var</span> Db = <span class="keyword">new</span> MySqlDb&lt;User&gt;();<span class="comment">// 这一步很关键，要定义User类型</span></span><br><span class="line">   Db.add(u);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2、文章类，数据库映射</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Article</span></span>&#123;</span><br><span class="line">   title:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       desc:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       status:<span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line">       <span class="title">constructor</span>(<span class="params">params:&#123;</span></span><br><span class="line"><span class="params">       title:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="params">           desc:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="params">           status?<span class="built_in">number</span> | <span class="literal">undefined</span>;<span class="regexp">//</span> status可选参数</span></span><br><span class="line"><span class="params">       &#125;</span>)&#123;</span><br><span class="line">       <span class="built_in">this</span>.title=params.title;</span><br><span class="line">           <span class="built_in">this</span>.desc=params.desc;</span><br><span class="line">           <span class="built_in">this</span>.status=params.status;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用</span></span><br><span class="line">   <span class="keyword">var</span> a = <span class="keyword">new</span> Article(&#123;</span><br><span class="line">   title:<span class="string">&quot;分类&quot;</span>,</span><br><span class="line">       desc:<span class="string">&quot;111&quot;</span>,</span><br><span class="line">       status:<span class="number">1</span></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//类当前参数的泛型类</span></span><br><span class="line">   <span class="keyword">var</span> Db = MySqlDB&lt;Article&gt;();<span class="comment">// 指定类型</span></span><br><span class="line">   Db.add(a);<span class="comment">// log a</span></span><br></pre></td></tr></table></figure><h3 id="实战：要实现TS封装统一操作Mysql-Mongodb-Mssql的底层库">实战：要实现TS封装统一操作Mysql Mongodb Mssql的底层库</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先定义一个接口，用于提供各类型数据库规范</span></span><br><span class="line">   <span class="keyword">interface</span> DBI&lt;T&gt;&#123;</span><br><span class="line">   add(info:T):<span class="built_in">boolean</span>;</span><br><span class="line">       update(info:T, <span class="attr">id</span>:<span class="built_in">number</span>):<span class="built_in">boolean</span>;</span><br><span class="line">       <span class="keyword">delete</span>(id:<span class="built_in">number</span>):<span class="built_in">boolean</span>;</span><br><span class="line">       get(id:<span class="built_in">number</span>):<span class="built_in">any</span>[];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义一个操作mysql的类，注意 要实现泛型接口 这个类也应该一定是个泛型类</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MysqlDb</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">DBI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   add(info:T): <span class="built_in">boolean</span>&#123;</span><br><span class="line">       log(info);</span><br><span class="line">       &#125;</span><br><span class="line">       update...</span><br><span class="line">       <span class="keyword">delete</span>...</span><br><span class="line">       get...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 操作数据表，定义一个User类和数据库进行映射，并进行MySql数据的插入操作</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">   username:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       password:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> u = <span class="keyword">new</span> User();</span><br><span class="line">   u.username = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">   u.password=<span class="string">&quot;213&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> oMysql = <span class="keyword">new</span> MysqlDb&lt;User&gt;();<span class="comment">// 声明User类型参数</span></span><br><span class="line">   oMysql.add(u);<span class="comment">// 插入</span></span><br></pre></td></tr></table></figure><h3 id="模块">模块</h3><p>概念：</p><ul><li>把一些公共的功能单独抽离成一个文件作为一个模块</li><li>模块里面的变量 函数 类等默认都是私有的，如果我们要在外部访问模块内的数据（函数、变量、类）</li><li>我们就需要通过export暴露模块里面的数据</li><li>然后其他地方通过import引入模块就可以使用模块内的数据</li></ul><p>模块暴露export：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  方式一</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; a &#125;</span><br></pre></td></tr></table></figure><p>模块导入import:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, a <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">a();</span><br><span class="line">alias();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>模块默认导出default，一个模块只能用一次<br>暴露：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引入(不用花括号)：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">a();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DB库用模块化封装// 省略了，代码比较简单</p><h3 id="TS命名空间">TS命名空间</h3><blockquote><p>内部模块，主要用于组织代码，避免命名冲突，<br>个人理解：模块之中再分模块<br>定义模块、并导出不同命名空间：</p></blockquote><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="keyword">interface</span> Animal&#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        eat(): <span class="built_in">void</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">export</span> Class Dog <span class="keyword">implements</span> Animal&#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        eat:<span class="function"><span class="title">void</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            log(<span class="built_in">this</span>.name +<span class="string">&quot;在空间A中吃狗粮&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> B&#123;</span><br><span class="line">    <span class="keyword">interface</span> Animal&#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        eat(): <span class="built_in">void</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">export</span> Class Dog <span class="keyword">implements</span> Animal&#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        eat:<span class="function"><span class="title">void</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            log(<span class="built_in">this</span>.name +<span class="string">&quot;在空间A中吃狗粮&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>调用：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> A.Dog(<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">d.eat();<span class="comment">// 小黑在空间A中吃狗粮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> B.Dog(<span class="string">&quot;小花&quot;</span>);</span><br><span class="line">dog.eat(); <span class="comment">// 小花在空间B中吃狗粮</span></span><br></pre></td></tr></table></figure><h3 id="装饰器">装饰器</h3><p>定义：</p><ul><li>装饰器是一种特殊类型的声明，他能够被附加到类声明，方法，属性或者参数上，可以修改类的行为。</li><li>通俗的将装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。</li><li>常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器</li><li>装饰器的写法：普通装饰器（无法传参）、装饰器工厂（可传参）</li><li>装饰器是过去几年中js最大的成就之一，已经是ES7的标准特性之一</li></ul><h4 id="类装饰器：普通装饰器">类装饰器：普通装饰器</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">    <span class="comment">// params就是当前类</span></span><br><span class="line">    params.prototype.apiUrl = <span class="string">&quot;动态扩展的属性&quot;</span>;</span><br><span class="line">    params.prototype.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我是一个run方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@logClass</span>  <span class="comment">// 类装饰器，普通装饰器，无法传参，默认吧class传入</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类装饰器：装饰器工厂">类装饰器：装饰器工厂</h4><p>作用：</p><ol><li>修改构造函数</li><li>扩展类属性和方法<br>定义：</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">params:<span class="built_in">string</span></span>)</span>&#123;<span class="comment">// params是下方传过来的参数</span></span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span></span>)</span>&#123;<span class="comment">// target相当于是默认传过来的</span></span><br><span class="line">           log(target);</span><br><span class="line">           log(params);</span><br><span class="line">           target.prototype.apiUrl = params;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@logClass</span>(<span class="string">&quot;https://baidu.com&quot;</span>)<span class="comment">// 可以传参</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> http:<span class="built_in">any</span> = <span class="keyword">new</span> HttpClient();</span><br><span class="line">   <span class="built_in">console</span>.log(http.apiUrl);<span class="comment">// https://baidu.com</span></span><br><span class="line"></span><br><span class="line">可以修改构造函数的写法</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">target:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">       log(target);</span><br><span class="line">       <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">target</span></span>&#123;</span><br><span class="line">           apiUrl:<span class="built_in">any</span> = <span class="string">&quot;我是修改后的新数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="built_in">this</span>.apiUrl = <span class="built_in">this</span>.apiUrl + <span class="string">&quot;----&quot;</span>;</span><br><span class="line">               log(<span class="built_in">this</span>.apiUrl);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@logClass</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> apiUrl:<span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">       <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.apiUrl = <span class="string">&quot;我是构造函数里面的apiUrl&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           log(<span class="built_in">this</span>.apiUrl)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> http= <span class="keyword">new</span> HttpClient();</span><br><span class="line">   http.getData();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="属性装饰器">属性装饰器</h4><p>作用：</p><ol><li>可以给属性赋值</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">params:<span class="built_in">string</span></span>)</span>&#123;<span class="comment">// params是下方传过来的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span></span>)</span>&#123;<span class="comment">// target相当于是默认传过来的</span></span><br><span class="line">        log(target);</span><br><span class="line">        log(params);</span><br><span class="line">        target.prototype.apiUrl = params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProperty</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 固定写法，参数中，target为类对象，attr为参数名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, attr:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(target);</span><br><span class="line">        log(attr);</span><br><span class="line">        target[attr] = params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@logClass</span>(<span class="string">&quot;https://baidu.com&quot;</span>)<span class="comment">// 可以传参</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个属性修饰器的作用就是给url赋值初始值</span></span><br><span class="line">    <span class="meta">@logProperty</span>(<span class="string">&quot;http://baidu.com&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> url:<span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http:<span class="built_in">any</span> = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="built_in">console</span>.log(http.apiUrl);<span class="comment">// https://baidu.com</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法装饰器">方法装饰器</h4><p>用的是最多的</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, desc:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(target); <span class="comment">// 类属性</span></span><br><span class="line">        log(methodName); <span class="comment">// 方法名字 getData</span></span><br><span class="line">        log(desc); <span class="comment">// 方法的描述，desc.value是方法描述</span></span><br><span class="line">        target.apiUrl = <span class="string">&quot;xxx&quot;</span>; <span class="comment">// 修改雷属性</span></span><br><span class="line">        target.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            log(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> url:<span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@get</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        log(<span class="built_in">this</span>.url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http:<span class="built_in">any</span> = <span class="keyword">new</span> HttpClient();</span><br><span class="line">log(http.apiUrl); <span class="comment">// https://www.baidu.com‘</span></span><br><span class="line">http.run(); <span class="comment">// log run</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修改当前的方法（主要作用是装饰方法，并把方法的参数给变换类型）：</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法装饰其主要作用就是把参数都给格式化成string类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, desc:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(target); <span class="comment">// 类属性 </span></span><br><span class="line">        log(methodName); <span class="comment">// 方法名字 getData</span></span><br><span class="line">        log(desc.value); <span class="comment">// 方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想修改下方法，装饰一下，让他们的所有参数变成string类型，并且打印出来</span></span><br><span class="line">        <span class="keyword">var</span> oMethod = desc.value;</span><br><span class="line">        desc.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args:<span class="built_in">any</span>[]</span>)</span>&#123;</span><br><span class="line">            args = args.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">String</span>(value);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用apply进行对象冒充，对getdata进行修改，如果没有apply就相当于是把getData方法给替换掉了</span></span><br><span class="line"></span><br><span class="line">            oMethod.apply(<span class="built_in">this</span>, args);<span class="comment">// this就是指function(...args:any[])这个函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> url:<span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@get</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params">...args:<span class="built_in">any</span>[]</span>)</span>&#123;</span><br><span class="line">        log(args);</span><br><span class="line">        log(<span class="string">&quot;我是getData方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http:<span class="built_in">any</span> = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.get(<span class="number">123</span>,<span class="string">&quot;xxx&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 就会先打印[&quot;123&quot;, &quot;xxx&quot;]后打印 我是getData方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方法参数装饰器">方法参数装饰器</h4><p>用的比较少，类装饰器也可以实现这个功能</p><ul><li>运行时候当做函数被调用，可以使用参数张诗琪为累的原型增加一些元素数据，传入下列三个参数：</li><li>1对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li><li>2方法的名字</li><li>3参数在函数参数列表中的索引</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logParams</span>(<span class="params">params:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target:<span class="built_in">any</span>, methodName:<span class="built_in">any</span>, paramsIndex:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(params);<span class="comment">// xxxx</span></span><br><span class="line">        log(target); <span class="comment">// 原型对象</span></span><br><span class="line">        log(methodName);<span class="comment">// getData</span></span><br><span class="line">        log(paramsIndex); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> url:<span class="built_in">any</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"><span class="meta">@logParams</span>(<span class="string">&quot;xxxx&quot;</span>) uuid:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        log(uuid); <span class="comment">// iii</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> HttpClient();</span><br><span class="line">a.getData(<span class="string">&quot;iii&quot;</span>);</span><br><span class="line"></span><br><span class="line">先后输出：</span><br><span class="line"><span class="number">1.</span> xxxx</span><br><span class="line"><span class="number">2.</span> 原型对象</span><br><span class="line"><span class="number">3.</span> getData</span><br><span class="line"><span class="number">4.</span> <span class="number">0</span> </span><br><span class="line"><span class="number">5.</span> iii</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="装饰器执行顺序">装饰器执行顺序</h4><p>当存在  多个装饰器时候：</p><ul><li><p>执行优先级：属性装饰器&gt;方法装饰器&gt;方法参数装饰器&gt;类装饰器</p></li><li><p>如果有多个同样的装饰器，它会先从后边执行</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Front End </tag>
            
            <tag> TypeScript </tag>
            
            <tag> JavaScript超集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统 | 第八章 数据库编程</title>
      <link href="2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
      <url>2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="嵌入式SQL">嵌入式SQL</h2><ul><li>SQL语言提供了两种不同的使用方式<ul><li>交互式</li><li>嵌入式</li></ul></li><li>为什么要引入嵌入式SQL<ul><li>SQL语言是非过程性语言</li><li>事务处理应用需要高级语言</li></ul></li><li>这两种方式细节上有差别，在程序设计的环境下，SQL语句要做某些必要的扩充</li></ul><h3 id="嵌入式SQL的处理过程">嵌入式SQL的处理过程</h3><ul><li><p>主语言<br>嵌入式SQL是将SQL语句嵌入程序设计语言中，被嵌入的程序设计语言，如C、C++、Java，称为宿主语言，简称主语言。</p></li><li><p>处理过程<br>预编译方法</p></li><li><p>为了区分SQL语句与主语言语句，所有SQL语句必须加前缀EXEC SQL，</p><ul><li><p>主语言为C语言时，语句格式：<br>EXEC SQL &lt;SQL语句&gt;;</p></li><li><p>主语言为Java语言时，语句格式：<br># SQL &lt;SQL语句&gt;;</p></li><li><p>主语言为C++语言时</p><p>使用ADO：</p></li></ul></li></ul><h3 id="嵌入式SQL语句与主语言之间的通信">嵌入式SQL语句与主语言之间的通信</h3><ul><li><p>将SQL嵌入到高级语言中混合编程，程序中会含有两种不同计算模型的语句</p><ul><li>SQL语句<br>描述性的面向集合的语句<br>负责操纵数据库</li><li>高级语言语句<br>过程性的面向记录的语句<br>负责控制逻辑流程</li><li>它们之间应该如何通信？</li></ul></li><li><p>数据库工作单元与源程序工作单元之间的通信<br>（1）向主语言传递SQL语句的执行状态信息，使主语言能够据此控制程序流程，主要用SQL通信区实现<br>（2）主语言向SQL语句提供参数，主要用主变量实现<br>（3）将SQL语句查询数据库的结果交主语言处理，主要用主变量和游标实现</p></li><li><p>SQLCA： SQL Communication Area<br>SQLCA是一个数据结构</p></li><li><p>SQLCA的用途</p><ul><li>SQL语句执行后，系统反馈给应用程序信息<br>描述系统当前工作状态<br>描述运行环境</li><li>这些信息将送到SQL通信区中</li><li>应用程序从SQL通信区中取出这些状态信息，据此决定接下来执行的语句</li></ul></li><li><p>SQLCA使用方法</p><ul><li>定义SQLCA<ul><li>用EXEC SQL INCLUDE SQLCA定义</li></ul></li><li>使用SQLCA<ul><li>SQLCA中有一个存放每次执行SQL语句后返回代码的变量SQLCODE</li><li>如果SQLCODE等于预定义的常量SUCCESS，则表示SQL语句成功，否则表示出错</li><li>应用程序每执行完一条SQL 语句之后都应该测试一下SQLCODE的值，以了解该SQL语句执行情况并做相应处理</li></ul></li></ul></li><li><p>主变量</p><ul><li>嵌入式SQL语句中可以使用主语言的程序变量来输入或输出数据</li><li>在SQL语句中使用的主语言程序变量简称为主变量（Host Variable）</li></ul></li><li><p>主变量的类型</p><ul><li>输入主变量<br>由应用程序对其赋值，SQL语句引用</li><li>输出主变量<br>由SQL语句对其赋值或设置状态信息，返回给应用程序</li></ul></li><li><p>指示变量</p><ul><li>是一个整型变量，用来“指示”所指主变量的值或条件</li><li>一个主变量可以附带一个指示变量（Indicator Variable）</li><li>指示变量的用途<ul><li>指示输入主变量是否为空值</li><li>检测输出变量是否为空值，值是否被截断</li></ul></li></ul></li><li><p>在SQL语句中使用主变量和指示变量的方法<br>说明主变量和指示变量<br>BEGIN DECLARE SECTION<br>…<br>…  （说明主变量和指示变量）<br>…<br>END DECLARE SECTION</p></li><li><p>在SQL语句中使用主变量和指示变量的方法（续）</p><ul><li>使用主变量<br>说明之后的主变量可以在SQL语句中任何一个能够使用表达式的地方出现<br>为了与数据库对象名（表名、视图名、列名等）区别，SQL语句中的主变量名前要加冒号（:）作为标志</li><li>使用指示变量<br>指示变量前也必须加冒号标志<br>必须紧跟在所指主变量之后</li></ul></li><li><p>在SQL语句之外（主语言语句中）使用主变量和指示变量的方法<br>可以直接引用，不必加冒号</p></li><li><p>为什么要使用游标</p><ul><li>SQL语言与主语言具有不同数据处理方式</li><li>SQL语言是面向集合的，一条SQL语句原则上可以产生或处理多条记录</li><li>主语言是面向记录的，一组主变量一次只能存放一条记录</li><li>仅使用主变量并不能完全满足SQL语句向应用程序输出数据的要求</li><li>嵌入式SQL引入了游标的概念，用来协调这两种不同的处理方式</li></ul></li><li><p>游标</p><ul><li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果</li><li>每个游标区都有一个名字</li><li>用户可以用SQL语句逐一从游标中获取记录，并赋给主变量，交由主语言进一步处理</li></ul></li><li><p>建立数据库连接<br>EXEC SQL CONNECT TO target[AS connection-name][USER user-name];<br>target是要连接的数据库服务器<br>常见的服务器标识串，如<dbname>@<hostname>:<port><br>包含服务器标识的SQL串常量<br>DEFAULT</p></li><li><p>connect-name是可选的连接名，连接名必须是一个有效的标识符</p></li><li><p>在整个程序内只有一个连接时可以不指定连接名</p></li><li><p>程序运行过程中可以修改当前连接<br>EXEC SQL SET CONNECTION connection-name<br>|DEFAULT;</p></li><li><p>关闭数据库连接<br>EXEC SQL DISCONNECT [connection];</p></li></ul><h3 id="不用游标的SQL语句">不用游标的SQL语句</h3><ul><li>不用游标的SQL语句的种类<ul><li>说明性语句</li><li>数据定义语句</li><li>数据控制语句</li><li>查询结果为单记录的SELECT语句</li><li>非CURRENT形式的增删改语句</li></ul></li></ul><h3 id="使用游标的SQL语句">使用游标的SQL语句</h3><ul><li>必须使用游标的SQL语句<ul><li>查询结果为多条记录的SELECT语句</li><li>CURRENT形式的UPDATE语句</li><li>CURRENT形式的DELETE语句</li></ul></li></ul><h3 id="动态SQL">动态SQL</h3><ul><li>静态嵌入式SQL<br>静态嵌入式SQL语句能够满足一般要求<br>无法满足要到执行时才能够确定要提交的SQL语句、查询的条件</li><li>动态嵌入式SQL<br>允许在程序运行过程中临时“组装”SQL语句<br>支持动态组装SQL语句和动态参数两种形式</li></ul><ol><li><p>使用SQL语句主变量</p></li><li><p>动态参数执行准备好的语句（EXECUTE）</p></li><li><p>动态参数</p></li></ol><ul><li><p>主变量</p></li><li><p>[例8.6]  创建基本表TEST。</p><p>​EXEC SQL BEGIN DECLARE SECTION;<br>​       const char *stmt=“CREATE TABLE test(a int);”;<br>​               /<em>SQL语句主变量，内容是创建表的SQL语句</em>/<br>​EXEC SQL END DECLARE SECTION;<br>​    …<br>​EXEC SQL EXECUTE IMMEDIATE :stmt;<br>​               /<em>执行动态SQL语句</em>/</p></li><li><p>动态参数</p><ul><li>SQL语句中的可变元素</li><li>使用参数符号（?）表示该位置的数据在运行时设定</li><li>和主变量的区别<ul><li>动态参数的输入不是编译时完成绑定</li><li>而是通过 PREPARE语句准备主变量和执行语句EXECUTE绑定数据或主变量来完成</li></ul></li></ul></li><li><p>使用动态参数的步骤<br>（1）声明SQL语句主变量<br>（2）准备SQL语句（PREPARE）<br>EXEC SQL PREPARE &lt;语句名&gt;<br>FROM &lt;SQL语句主变量&gt;;</p><p>EXEC SQL EXECUTE &lt;语句名&gt;<br>[INTO &lt;主变量表&gt;]<br>[USING &lt;主变量或常量&gt;];</p></li><li><p>准备好的SQL</p></li><li><p>[例8.7] 向TEST中插入元组。<br>EXEC SQL BEGIN DECLARE SECTION;<br>const char *stmt = “INSERT INTO test VALUES(?);”;<br>/*声明SQL主变量内容是INSERT语句 */<br>EXEC SQL END DECLARE SECTION;<br>…<br>EXEC SQL PREPARE mystmt FROM :stmt; /<em>准备语句</em>/<br>…<br>EXEC SQL EXECUTE mystmt USING 100;<br>/*执行语句，设定INSERT语句插入值100 <em>/<br>EXEC SQL EXECUTE mystmt USING 200;<br>/</em> 执行语句，设定INSERT语句插入值200 */</p></li></ul><h2 id="过程化SQL">过程化SQL</h2><h3 id="过程化SQL的块结构">过程化SQL的块结构</h3><ul><li><p>SQL的扩展</p><ul><li>增加了过程化语句功能</li><li>基本结构是块</li><li>块之间可以互相嵌套</li><li>每个块完成一个逻辑操作</li></ul></li><li><p>过程化SQL块的基本结构</p><ol><li><p>定义部分<br>DECLARE 变量、常量、游标、异常等<br>定义的变量、常量等只能在该基本块中使用<br>当基本块执行结束时，定义就不再存在</p></li><li><p>执行部分<br>BEGIN</p><p>SQL语句、过程化SQL的流程控制语句</p></li></ol><p>EXCEPTION<br>异常处理部分        <br>END；</p></li></ul><h3 id="变量和常量的定义">变量和常量的定义</h3><ol><li>变量定义<br>变量名 数据类型 [[NOT NULL]:=初值表达式]或<br>变量名 数据类型 [[NOT NULL] 初值表达式]</li><li>常量定义<br>常量名 数据类型 CONSTANT :=常量表达式<br>常量必须要给一个值，并且该值在存在期间或常量的作用域内不能改变。如果试图修改它，过程化SQL将返回一个异常</li><li>赋值语句<br>变量名称 :=表达式</li></ol><h3 id="流程控制">流程控制</h3><p>过程化SQL功能</p><ol><li><p>条件控制语句</p></li><li><p>循环控制语句</p></li><li><p>错误处理</p></li></ol><ul><li><p>条件控制语句<br>IF-THEN，IF-THEN-ELSE和嵌套的IF语句<br>（1）IF condition THEN<br>Sequence_of_statements;<br>END IF;<br>（2）IF condition THEN<br>Sequence_of_statements1;<br>ELSE<br>Sequence_of_statements2;<br>END IF;<br>（3）在THEN和ELSE子句中还可以再包含IF语句，即IF语句可以嵌套</p></li><li><p>循环控制语句<br>LOOP，WHILE-LOOP和FOR-LOOP<br>（1）简单的循环语句LOOP<br>LOOP<br>Sequence_of_statements;<br>END LOOP;<br>多数数据库服务器的过程化SQL都提供EXIT、BREAK或<br>LEAVE等循环结束语句，保证LOOP语句块能够结束</p><p>（2）WHILE-LOOP<br>WHILE condition LOOP<br>Sequence_of_statements;<br>END LOOP;<br>每次执行循环体语句之前，首先对条件进行求值<br>如果条件为真，则执行循环体内的语句序列<br>如果条件为假，则跳过循环并把控制传递给下一个语句</p><p>（3）FOR-LOOP<br>FOR count IN [REVERSE] bound1 … bound2 LOOP<br>Sequence_of_statements;<br>END LOOP;</p></li><li><ol start="3"><li>错误处理</li></ol><ul><li>如果过程化SQL在执行时出现异常，则应该让程序在产生异常的语句处停下来，根据异常的类型去执行异常处理语句</li><li>SQL标准对数据库服务器提供什么样的异常处理做出了建议，要求过程化SQL管理器提供完善的异常处理机制</li></ul></li></ul><h2 id="存储过程和函数">存储过程和函数</h2><h3 id="存储过程">存储过程</h3><ul><li><p>过程化SQL块类型</p><ul><li>命名块<br>编译后保存在数据库中，可以被反复调用，运行速度较快，过程和函数是命名块</li><li>匿名块<br>每次执行时都要进行编译，它不能被存储到数据库中，也不能在其他过程化SQL块中调用</li></ul></li><li><p>存储过程：</p><p>由过程化SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只要调用即可。</p><ul><li>存储过程的优点<br>（1）运行效率高<br>（2）降低了客户机和服务器之间的通信量<br>（3）方便实施企业规则</li></ul></li><li><p>存储过程的用户接口<br>（1）创建存储过程<br>（2）执行存储过程<br>（3）修改存储过程<br>（4）删除存储过程</p></li><li><p>（1）创建存储过程<br>CREATE OR REPLACE PROCEDURE 过程名([参数1,参数2,…]) AS &lt;过程化SQL块&gt;；<br>过程名：数据库服务器合法的对象标识<br>参数列表：用名字来标识调用时给出的参数值，必须指定值的数据类型。参数也可以定义输入参数、输出参数或输入/输出参数，默认为输入参数<br>过程体：是一个&lt;过程化SQL块&gt;，包括声明部分和可执行语句部分</p></li><li><p>[例8.8] 利用存储过程来实现下面的应用：从账户1转指定数额的款项到账户2中。</p><p>​CREATE OR REPLACE PROCEDURE TRANSFER(inAccount INT,outAccount  INT,amount FLOAT)<br>​       /<em>定义存储过程TRANSFER，其参数为转入账户、转出账户、转账额度</em>/<br>​AS DECLARE/<em>定义变量</em>/<br>​        totalDepositOut Float;<br>​             totalDepositIn Float;<br>​inAccountnum INT;</p><p>BEGIN                             /*检查转出账户的余额 */<br>SELECT Total INTO totalDepositOut FROM Accout<br>WHERE accountnum=outAccount;<br>IF totalDepositOut IS NULL THEN<br>/<em>如果转出账户不存在或账户中没有存款</em>/<br>ROLLBACK;    /<em>回滚事务</em>/<br>RETURN;<br>END IF;</p><p>IF totalDeposit Out&lt; amount THEN    /<em>如果账户存款不足</em>/<br>ROLLBACK; /<em>回滚事务</em>/<br>RETURN;<br>END IF;</p><p>SELECT Accountnum INTO inAccountnum FROM Account<br>WHERE accountnum=inAccount;</p><p>IF inAccount IS NULL THEN  /<em>如果转入账户不存在</em>/<br>ROLLBACK;           /<em>回滚事务</em>/<br>RETURN;<br>ENDIF;</p><p>UPDATE Account SET total=total-amount WHERE accountnum=outAccount;<br>/* 修改转出账户余额，减去转出额 <em>/<br>UPDATE Account SET total=total + amount<br>WHERE   accountnum=inAccount;<br>/</em> 修改转入账户余额，增加转入额 <em>/<br>COMMIT;                       /</em> 提交转账事务 */<br>END;</p></li><li><p>（2）执行存储过程<br>CALL/PERFORM  PROCEDURE 过程名([参数1,参数2,…])；<br>使用CALL或者PERFORM等方式激活存储过程的执行<br>在过程化SQL中，数据库服务器支持在过程体中调用其他存储过程</p></li><li><p>[例8.9] 从账户01003815868转10000元到01003813828账户中。<br>CALL PROCEDURE TRANSFER(01003813828,01003815868,10000);</p></li><li><p>（3）修改存储过程<br>ALTER PROCEDURE 过程名1  RENAME TO 过程名2;</p></li><li><p>（4）删除存储过程<br>DROP  PROCEDURE 过程名()；</p></li></ul><h3 id="函数">函数</h3><ul><li>函数和存储过程的异同<br>同：都是持久性存储模块<br>异：函数必须指定返回的类型</li></ul><ol><li>函数的定义语句格式<br>CREATE OR REPLACE FUNCTION 函数名 ([参数1,参数2,…]) RETURNS &lt;类型&gt;  AS &lt;过程化SQL块&gt;;</li><li>函数的执行语句格式<br>CALL/SELECT 函数名 ([参数1,参数2,…]);</li><li>修改函数<br>重命名<br>ALTER FUNCTION 过程名1 RENAME TO 过程名2;<br>重新编译<br>ALTER FUNCTION 过程名 COMPILE;</li></ol><p>存储过程：</p><ul><li>优点：<ul><li>有if/else,case,while等控制语句，通过编写存储过程，可以实现一些逻辑比较复杂的功能；</li><li>模块化；对一些功能进行了封装，代码的复用；</li><li>响应速度快，只有在首次执行时需要经过编译和优化步骤，后被调用直接执行，省去了重新编写代码计算的步骤。</li><li>减少网络传输。存储过程直接就在数据库服务器上跑，所有的数据访问都在服务器内部进行，不需要传输数据到其它终端。</li><li>方便DBA优化。所有的SQL集中在一个地方</li></ul></li><li>缺点：<br>复杂的业务逻辑。没办法应用缓存。</li></ul><p>触发器</p><ul><li>优点：<ul><li>安全。以基于数据库的值使用户具有操作数据库的某种权利。可以跟踪用户对数据库的操作。</li><li>触发器能够拒绝或回退那些破坏相关完整性的变化，取消试图进行数据更新的事务。当插入一个与其主健不匹配的外部键时，这种触发器会起作用。</li></ul></li><li>缺点：*数据集数据量又较大时，触发器效果会非常低（因为自动计算数据值，需要变动整个数据集导致效率下降）<ul><li>对于批量操作并不适合使用触发器，使用触发器实现的业务逻辑在出现问题时很难进行定位。</li></ul></li></ul><h2 id="ODBC编程">ODBC编程</h2><ul><li>ODBC优点<ul><li>移植性好</li><li>能同时访问不同的数据库</li><li>共享多个数据资源</li></ul></li></ul><h3 id="ODBC概述">ODBC概述</h3><ul><li><p>ODBC产生的原因</p><ul><li>由于不同的数据库管理系统的存在，在某个关系数据库管理系统下编写的应用程序就不能在另一个关系数据库管理系统下运行</li><li>许多应用程序需要共享多个部门的数据资源，访问不同的关系数据库管理系统</li></ul></li><li><p>ODBC</p><ul><li>是微软公司开放服务体系（Windows Open Services Architecture，WOSA）中有关数据库的一个组成部分</li><li>提供了一组访问数据库的应用程序编程接口（Application Programming Interface，API ）</li></ul></li><li><p>ODBC约束力</p><ul><li>规范应用开发</li><li>规范关系数据库管理系统应用接口</li></ul></li></ul><h3 id="ODBC工作原理概述">ODBC工作原理概述</h3><ul><li><p>ODBC应用系统的体系结构</p><ol><li><p>用户应用程序</p></li><li><p>ODBC驱动程序管理器</p></li><li><p>数据库驱动程序</p></li><li><p>数据源</p></li></ol></li><li><p>ODBC应用程序包括的内容</p><ul><li>请求连接数据库</li><li>向数据源发送SQL语句</li><li>为SQL语句执行结果分配存储空间，定义所读取的数据格式</li><li>获取数据库操作结果或处理错误</li><li>进行数据处理并向用户提交处理结果</li><li>请求事务的提交和回滚操作</li><li>断开与数据源的连接</li></ul></li><li><p>驱动程序管理器：用来管理各种驱动程序</p><ul><li>包含在ODBC32.DLL中</li><li>管理应用程序和驱动程序之间的通信</li><li>建立、配置或删除数据源，并查看系统当前所安装的数据库ODBC驱动程序</li></ul></li><li><p>主要功能：</p><ul><li>装载ODBC驱动程序</li><li>选择和连接正确的驱动程序</li><li>管理数据源</li><li>检查ODBC调用参数的合法性</li><li>记录ODBC函数的调用等</li></ul></li><li><p>ODBC驱动程序类型</p><ul><li>单束<br>数据源和应用程序在同一台机器上<br>驱动程序直接完成对数据文件的I/O操作<br>驱动程序相当于数据管理器</li><li>多束<br>支持客户机—服务器、客户机—应用服务器/数据库服务器等网络环境下的数据访问<br>由驱动程序完成数据库访问请求的提交和结果集接收<br>应用程序使用驱动程序提供的结果集管理接口操纵执行后的结果数据</li></ul></li><li><p>数据源：是最终用户需要访问的数据，包含了数据库位置和数据库类型等信息，是一种数据连接的抽象</p></li><li><p>数据源对最终用户是透明的</p><ul><li>ODBC给每个被访问的数据源指定唯一的数据源名（Data Source Name，简称DSN），并映射到所有必要的、用来存取数据的低层软件</li><li>在连接中，用数据源名来代表用户名、服务器名、所连接的数据库名等</li><li>最终用户无须知道数据库管理系统或其他数据管理软件、网络以及有关ODBC驱动程序的细节</li></ul></li><li><p>例如，假设某个学校在SQL Server和KingbaseES上创建了两个数据库：学校人事数据库和教学科研数据库。<br>学校的信息系统要从这两个数据库中存取数据<br>为了方便地与两个数据库连接，为学校人事数据库创建一个数据源名PERSON，为教学科研数据库创建一个名为EDU的数据源<br>当要访问每一个数据库时，只要与PERSON和EDU连接即可，不需要记住使用的驱动程序、服务器名称、数据库名</p></li></ul><h3 id="ODBC-API基础">ODBC API基础</h3><ul><li><p>ODBC 应用程序编程接口的一致性</p><ul><li>API一致性<br>包含核心级、扩展1级、扩展2级</li><li>语法一致性<br>包含最低限度SQL语法级、核心SQL语法级、扩展SQL语法级</li></ul></li><li><ol><li><p>函数概述</p></li><li><p>句柄及其属性</p></li><li><p>数据类型</p></li></ol></li><li><p>ODBC 3.0 标准提供了76个函数接口</p><ul><li>分配和释放环境句柄、连接句柄、语句句柄</li><li>连接函数（SQLDriverconnect等）</li><li>与信息相关的函数（SQLGetinfo、SQLGetFuction等）</li><li>事务处理函数（如SQLEndTran）</li><li>执行相关函数（SQLExecdirect、SQLExecute等）</li><li>编目函数，ODBC 3.0提供了11个编目函数，如SQLTables、SQLColumn等。应用程序可以通过对编目函数的调用来获取数据字典的信息，如权限、表结构等</li></ul></li><li><p>句柄是32位整数值，代表一个指针</p></li><li><p>ODBC 3.0中句柄分类</p><ul><li>环境句柄</li><li>连接句柄</li><li>语句句柄</li><li>描述符句柄</li></ul></li><li><p>应用程序句柄之间的关系（续）</p><ul><li>在一个连接中可以建立多个语句句柄，它不只是一个SQL语句，还包括SQL语句产生的结果集以及相关的信息等</li><li>在ODBC 3.0中又提出了描述符句柄的概念，它是描述SQL语句的参数、结果集列的元数据集合</li></ul></li><li><p>ODBC数据类型</p><ul><li>SQL数据类型：用于数据源</li><li>C数据类型 ：用于应用程序的C代码</li></ul></li><li><p>应用程序可以通过SQLGetTypeInfo来获取不同的驱动程序对于数据类型的支持情况</p></li><li><p>[例8.11] 将KingbaseES数据库中Student表的数据备份到SQL Server数据库中。</p><ul><li>该应用涉及两个不同的关系数据库管理系统中的数据源</li><li>使用ODBC来开发应用程序，只要改变应用程序中连接函数（SQLConnect）的参数，就可以连接不同关系数据库管理系统的驱动程序，连接两个数据源</li></ul></li><li><p>操作步骤</p><ol><li><p>配置数据源</p></li><li><p>初始化环境</p></li><li><p>建立连接</p></li><li><p>分配语句句柄</p></li><li><p>执行SQL语句</p></li><li><p>结果集处理</p></li><li><p>中止处理</p></li></ol></li><li><p>应用程序中止步骤</p><ul><li>释放语句句柄</li><li>释放数据库连接</li><li>与数据库服务器断开</li><li>释放ODBC环境</li></ul></li></ul><h2 id="小结">小结</h2><ul><li>嵌入式SQL把SQL语句嵌入到某种高级语言中</li><li>SQL与主语言具有不同的数据处理方式</li><li>本章讲解了以下内容<ul><li>嵌入式SQL</li><li>过程化SQL</li><li>存储过程和函数</li><li>ODBC编程</li></ul></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统 | 第七章 数据库设计</title>
      <link href="2021/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="重点和难点">重点和难点</h2><ul><li><p>重点：</p><p>掌握数据库设计步骤和数据库设计过程中的各级模式设计方法。特别是数据库概念结构的设计和逻辑结构的设计，这是数据库设计过程中最重要的两个环节。牢固掌握用E-R图来表示概念模型的方法，掌握E-R图的设计，E-R图向关系模型的转换。</p></li><li><p>难点：</p><p>技术上的难点是E-R图的设计和数据模型的优化，包括对现实世界进行抽象的能力，提取实体、属性、实体型之间的联系，正确划分实体与属性的能力。如何把第6章关系数据理论与本章结合，用关系数据理论指导数据库的逻辑设计。真正的难点是理论与实际的结合。</p></li></ul><h2 id="数据库设计概述">数据库设计概述</h2><ul><li>数据库设计<ul><li>数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</li><li>信息管理要求：在数据库中应该存储和管理哪些数据对象 。</li><li>数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。</li><li>数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境 。</li><li>高效率的运行环境<ul><li>数据库数据的存取效率高</li><li>数据库存储空间的利用率高</li><li>数据库系统运行管理的效率高</li></ul></li></ul></li></ul><h3 id="数据库设计的特点">数据库设计的特点</h3><ul><li><p>数据库建设的基本规律</p><ul><li>三分技术，七分管理，十二分基础数据</li><li>管理<ul><li>数据库建设项目管理</li><li>企业（即应用部门）的业务管理</li></ul></li><li>基础数据<ul><li>数据的收集、整理、组织和不断更新</li></ul></li></ul></li><li><p>结构（数据）设计和行为（处理）设计相结合</p><ul><li>将数据库结构设计和数据处理设计密切结合</li></ul></li><li><p>结构和行为分离的设计</p><ul><li>传统的软件工程：重 行为设计<br>忽视对应用中数据语义的分析和抽象，只要有可能就尽量推迟数据结构设计的决策</li><li>早期的数据库设计：重 结构设计<br>致力于数据模型和数据库建模方法研究，忽视了行为设计对结构设计的影响</li></ul></li></ul><h3 id="数据库设计方法">数据库设计方法</h3><ul><li><p>大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。</p></li><li><p>它要求多方面的知识和技术。主要包括：</p><ul><li>计算机的基础知识</li><li>软件工程的原理和方法</li><li>程序设计的方法和技巧</li><li>数据库的基本知识</li><li>数据库设计技术</li><li>应用领域的知识</li></ul></li><li><p>手工试凑法</p><ul><li>设计质量与设计人员的经验和水平有直接关系</li><li>缺乏科学理论和工程方法的支持，工程的质量难以保证</li><li>数据库运行一段时间后常常又不同程度地发现各种问题，增加了维护代价</li></ul></li><li><p>规范设计法</p><ul><li>手工设计方法</li><li>基本思想<br>过程迭代和逐步求精</li><li>典型方法<ul><li>新奥尔良（New Orleans）方法</li><li>基于E-R模型的数据库设计方法</li><li>3NF（第三范式）的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言（UML）方法</li></ul></li></ul></li></ul><h3 id="数据库设计的基本步骤">数据库设计的基本步骤</h3><ul><li><p>数据库设计分6个阶段</p><ul><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li></ul></li><li><p>需求分析和概念设计独立于任何数据库管理系统</p></li><li><p>逻辑设计和物理设计与选用的数据库管理系统密切相关</p></li><li><p>参加数据库设计的人员</p><ul><li>系统分析人员和数据库设计人员<br>自始至终参与数据库设计，其水平决定了数据库系统的质量</li><li>数据库管理员和用户代表<br>主要参加需求分析与数据库的运行和维护</li><li>应用开发人员<br>包括程序员和操作员<br>在实施阶段参与进来，分别负责编制程序和准备软硬件环境</li></ul></li></ul><ol><li><p>需求分析阶段<br>是否做得充分与准确，决定了构建数据库的速度和质量</p></li><li><p>概念结构设计阶段<br>通过对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型</p></li><li><p>逻辑结构设计阶段<br>将概念结构转换为某个数据库管理系统所支持的数据模型，并对其进行优化</p></li><li><p>物理结构设计阶段<br>为逻辑数据结构选取一个最适合应用环境的物理结构<br>包括存储结构和存取方法</p></li><li><p>数据库实施阶段<br>根据逻辑设计和物理设计的结果构建数据库<br>编写与调试应用程序<br>组织数据入库并进行试运行</p></li><li><p>数据库运行和维护阶段<br>经过试运行后即可投入正式运行<br>在运行过程中必须不断对其进行评估、调整与修改</p></li></ol><ul><li>设计一个完善的数据库应用系统 往往是上述6个阶段的不断反复</li><li>这个设计步骤既是数据库设计的过程，也包括了数据库应用系统的设计过程</li><li>把数据库的设计和对数据库中数据处理的设计紧密结合起来，将这两个方面的需求分析、抽象、设计、实现在各个阶段同时进行，相互参照，相互补充，以完善两方面的设计</li></ul><h2 id="需求分析">需求分析</h2><h3 id="需求分析的任务">需求分析的任务</h3><ul><li><p>需求分析就是分析用户的要求</p><ul><li>是设计数据库的起点</li><li>结果是否准确地反映了用户的实际要求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用</li></ul></li><li><p>详细调查现实世界要处理的对象（组织、部门、企业等）</p></li><li><p>充分了解原系统（手工系统或计算机系统）工作概况</p></li><li><p>明确用户的各种需求</p></li><li><p>在此基础上确定新系统的功能</p></li><li><p>新系统必须充分考虑今后可能的扩充和改变</p></li><li><p>调查的重点是“数据”和“处理”，获得用户对数据库的要求<br>（1）信息要求<br>用户需要从数据库中获得信息的内容与性质<br>由信息要求可以导出数据要求，即在数据库中需要存储哪些数据<br>（2）处理要求<br>用户要完成的处理功能<br>对处理性能的要求<br>（3）安全性与完整性要求</p></li><li><p>确定用户最终需求的难点</p><ul><li>用户缺少计算机知识，不能准确地表达自己的需求，他们所提出的需求往往不断地变化。</li><li>设计人员缺少用户的专业知识，不易理解用户的真正需求，甚至误解用户的需求</li></ul></li><li><p>解决方法</p><p>设计人员必须不断深入地与用户进行交流，才能逐步确定用户的实际需求</p></li></ul><h3 id="需求分析的方法">需求分析的方法</h3><ul><li>调查清楚用户的实际需求并进行初步分析</li><li>与用户达成共识</li><li>分析与表达这些需求</li></ul><p>（1）调查组织机构情况<br>（2）调查各部门的业务活动情况<br>（3）协助用户明确对新系统的各种要求，包括信息要求、处理要求、完全性与完整性要求<br>（4）确定新系统的边界</p><h4 id="常用调查方法">常用调查方法</h4><p>（1）跟班作业<br>通过亲身参加业务工作了解业务活动的情况<br>（2）开调查会<br>通过与用户座谈来了解业务活动情况及用户需求<br>（3）请专人介绍<br>（4）询问<br>对某些调查中的问题，可以找专人询问<br>（5）设计调查表请用户填写<br>调查表设计合理，则很有效<br>（6）查阅记录<br>查阅与原系统有关的数据记录</p><ul><li>分析方法<ul><li>结构化分析方法（Structured Analysis，简称SA方法）<ul><li>SA方法从最上层的系统组织机构入手</li><li>采用自顶向下、逐层分解的方式分析系统</li></ul></li></ul></li><li>对用户需求进行分析与表达后，需求分析报告必须提交给用户，征得用户的认可</li></ul><h3 id="数据字典">数据字典</h3><ul><li><p>数据字典是关于数据库中数据的描述，即元数据，不是数据本身</p></li><li><p>数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善</p></li><li><p>数据字典是进行详细的数据收集和数据分析所获得的主要结果</p></li><li><p>注意：<br>和关系数据库管理系统中数据字典的区别和联系</p></li><li><p>数据字典的内容</p><ul><li>数据项</li><li>数据结构</li><li>数据流</li><li>数据存储</li><li>处理过程</li></ul></li><li><p>数据项是数据的最小组成单位</p></li><li><p>若干个数据项可以组成一个数据结构</p></li><li><p>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容</p></li></ul><h3 id="需求分析小结">需求分析小结</h3><ul><li><p>把需求收集和分析作为数据库设计的第一阶段是十分重要的。</p></li><li><p>第一阶段收集的基础数据（用数据字典来表达）是下一步进行概念设计的基础。</p></li><li><p>强调两点</p><p>（1）设计人员应充分考虑到可能的扩充和改变，使设计易于更改，系统易于扩充<br>（2）必须强调用户的参与</p></li></ul><h2 id="概念结构设计">概念结构设计</h2><h3 id="概念模型">概念模型</h3><ul><li>将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程就是概念结构设计</li><li>概念模型的特点<br>（1）能真实、充分地反映现实世界，是现实世界的一个真实模型。<br>（2）易于理解，从而可以用它和不熟悉计算机的用户交换意见。<br>（3）易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充。<br>（4）易于向关系、网状、层次等各种数据模型转换</li><li>描述概念模型的工具<ul><li>E-R模型</li></ul></li></ul><h3 id="E-R模型">E-R模型</h3><ul><li><p>实体之间的联系<br>两个实体型之间的联系：<br>①一对一联系（1∶1）<br>②一对多联系（1∶n）<br>③多对多联系（m∶n）</p></li><li><p>一对一联系（1∶1）</p><ul><li>如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1∶1。</li><li>例如，学校里一个班级只有一个正班长，而一个班长只在一个班中任职，则班级与班长之间具有一对一联系。</li></ul></li><li><p>一对多联系（1∶n）</p><ul><li>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1∶n。</li><li>例如，一个班级中有若干名学生，而每个学生只在一个班级中学习，则班级与学生之间具有一对多联系。</li></ul></li><li><p>多对多联系（m∶n）</p><ul><li>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体集B具有多对多联系，记为m∶n。</li><li>例如，一门课程同时有若干个学生选修，而一个学生可以同时选修多门课程，则课程与学生之间具有多对多联系。</li></ul></li><li><p>联系的度：参与联系的实体型的数目</p><ul><li>2个实体型之间的联系度为2，也称为二元联系；</li><li>3个实体型之间的联系度为3，称为三元联系；</li><li>N个实体型之间的联系度为N，也称为N元联系</li></ul></li><li><p>E-R图</p><ul><li>E-R图提供了表示实体型、属性和联系的方法：<ul><li>实体型：用矩形表示，矩形框内写明实体名。</li><li>属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来。<br>例如，学生实体具有学号、姓名、性别、出生年份、系、入学时间等属性，用E-R图表示如图7.9所示</li></ul></li></ul></li></ul><h3 id="概念结构设计-2">概念结构设计</h3><ul><li>实体与属性的划分原则<ul><li>为了简化E-R图的处置，现实世界的事物能作为属性对待的，尽量作为属性对待。</li><li>两条准则：<ul><li>作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。</li><li>属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。</li></ul></li></ul></li></ul><h2 id="逻辑结构设计">逻辑结构设计</h2><h3 id="E-R图向关系模型的转换">E-R图向关系模型的转换</h3><ul><li><p>转换内容</p><ul><li>E-R图由实体型、实体的属性和实体型之间的联系三个要素组成</li><li>关系模型的逻辑结构是一组关系模式的集合</li><li>将E-R图转换为关系模型：将实体型、实体的属性和实体型之间的联系转化为关系模式</li></ul></li><li><p>转换原则</p><ul><li>一个实体型转换为一个关系模式。<ul><li>关系的属性：实体的属性</li><li>关系的码：实体的码</li></ul></li><li>实体型间的联系有以下不同情况<br>一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。<br>① 转换为一个独立的关系模式<br>关系的属性：与该联系相连的各实体的码以及联系本身的属性<br>关系的候选码：每个实体的码均是该关系的候选码</li><li>联系形成的关系独立存在：<br>职工（职工号，姓名，年龄）<br>产品（产品号，产品名，价格）<br>负责（职工号，产品号）</li><li>一个1:1联系的转换（续）<br>②与某一端实体对应的关系模式合并<br>合并后关系的属性：加入对应关系的码和联系本身的属性<br>合并后关系的码：不变</li><li>“负责”与“职工”两关系合并：<br>职工（职工号，姓名，年龄，产品号）<br>产品（产品号，产品名，价格）<br>也可以“负责”与“产品”两关系合并：<br>职工（职工号，姓名，年龄）<br>产品（产品号，产品名，价格，职工号）</li><li>一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。<br>①转换为一个独立的关系模式<br>关系的属性：与该联系相连的各实体的码以及联系本身的属性<br>关系的码：n端实体的码</li><li>联系形成的关系独立存在：<br>仓库（仓库号，地点，面积）<br>产品（产品号，产品名，价格）<br>仓储（产品号，仓库号，数量）</li><li>一个m:n联系转换为一个关系模式<br>关系的属性：与该联系相连的各实体的码以及联系本身的属性<br>关系的码：各实体码的组合<br>[例]“选修”联系是一个m:n联系，可以将它转换为如下关系模式，其中学号与课程号为关系的组合码：<br>　　  选修（学号，课程号，成绩）</li><li>三个或三个以上实体间的一个多元联系转换为一个关系模式。<br>关系的属性：与该多元联系相连的各实体的码以及联系本身的属性<br>关系的码：各实体码的组合</li><li>供应商（供应商号，供应商名，地址）<br>零件（零件号，零件名，单价）<br>产品（产品号，产品名，型号）<br>供应（供应商号，零件号，产品号，数量）</li></ul></li></ul><h3 id="数据模型的优化">数据模型的优化</h3><ul><li><p>一般的数据模型还需要向特定数据库管理系统规定的模型进行转换。</p></li><li><p>转换的主要依据是所选用的数据库管理系统的功能及限制。没有通用规则。</p></li><li><p>对于关系模型来说，这种转换通常都比较简单。</p></li><li><p>一般的数据模型还需要向特定数据库管理系统规定的模型进行转换。</p></li><li><p>转换的主要依据是所选用的数据库管理系统的功能及限制。没有通用规则。</p></li><li><p>对于关系模型来说，这种转换通常都比较简单。</p></li><li><p>优化数据模型的方法:<br>（1）确定数据依赖<br>按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间数据依赖。<br>（2）对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。</p><p>（3）按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。<br>（4）按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。</p><p>（5）对关系模式进行必要分解，提高数据操作效率和存储空间的利用率。</p><ul><li><p>常用分解方法</p></li><li><p>水平分解</p><ul><li><p>什么是水平分解<br>把(基本)关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。</p></li><li><p>如何分解</p><p>对符合80/20的，把经常被使用的数据（约20%）<br>水平分解出来，形成一个子关系。<br>水平分解为若干子关系，使每个事务存取的数据对应一个子关系。</p></li></ul></li><li><p>垂直分解</p><ul><li>什么是垂直分解<br>把关系模式R的属性分解为若干子集合，形成若干子关系模式。</li><li>垂直分解的原则<br>经常在一起使用的属性从R中分解出来形成一个子关系模式</li><li>垂直分解的优点<br>可以提高某些事务的效率</li><li>垂直分解的缺点<br>可能使另一些事务不得不执行连接操作，降低了效率</li></ul></li></ul></li><li><p>并不是规范化程度越高的关系就越优</p><ul><li>当查询经常涉及两个或多个关系模式的属性时，系统必须经常地进行连接运算</li><li>连接运算的代价是相当高的</li><li>因此在这种情况下，第二范式甚至第一范式也许是适合的。</li></ul></li><li><p>非BCNF的关系模式虽然会存在不同程度的更新异常，但如果在实际应用中对此关系模式只是查询，并不执行更新操作，就不会产生实际影响。</p></li><li><p>对于一个具体应用来说，到底规范化进行到什么程度，需要权衡响应时间和潜在问题两者的利弊才能决定</p></li></ul><h3 id="设计用户子模式">设计用户子模式</h3><ul><li>定义数据库模式主要是从系统的时间效率、空间效率、易维护等角度出发。</li><li>定义用户外模式时应该更注重考虑用户的习惯与方便。包括三个方面：<ul><li>（1）使用更符合用户习惯的别名<br>合并各分E-R图曾做了消除命名冲突的工作，以使数据库系统中同一关系和属性具有唯一的名字。这在设计数据库整体结构时是非常必要的。<br>用视图机制可以在设计用户视图时可以重新定义某些属性名，使其与用户习惯一致，以方便使用。</li><li>（2）针对不同级别的用户定义不同的视图，以保证系统的安全性。<br>假设有关系模式产品（产品号，产品名，规格，单价，生产车间，生产负责人，产品成本，产品合格率，质量等级），可以在产品关系上建立两个视图：<br>为一般顾客建立视图：    产品1（产品号，产品名，规格，单价）<br>为产品销售部门建立视图：    产品2（产品号，产品名，规格，单价，车间，<br>生产负责人）</li><li>（3）简化用户对系统的使用</li><li>如果某些局部应用中经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图。</li></ul></li></ul><h2 id="物理结构设计">物理结构设计</h2><ul><li><p>什么是数据库的物理设计</p><ul><li>数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。</li><li>为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。</li></ul></li><li><p>数据库物理设计的步骤</p><ul><li>确定数据库的物理结构<br>在关系数据库中主要指存取方法和存储结构;</li><li>对物理结构进行评价<br>评价的重点是时间和空间效率</li><li>若评价结果满足原设计要求，则可进入到物理实施阶段。否则，就需要重新设计或修改物理结构，有时甚至要返回逻辑设计阶段修改数据模型。</li></ul></li></ul><h3 id="数据库物理设计的内容和方法">数据库物理设计的内容和方法</h3><ul><li><p>设计物理数据库结构的准备工作</p><ul><li>充分了解应用环境，详细分析要运行的事务，以获得选择物理数据库设计所需参数。</li><li>充分了解所用关系型数据库管理系统的内部特征，特别是系统提供的存取方法和存储结构。</li></ul></li><li><p>选择物理数据库设计所需参数</p><ul><li>数据库查询事务<ul><li>查询的关系</li><li>查询条件所涉及的属性</li><li>连接条件所涉及的属性</li><li>查询的投影属性</li></ul></li><li>数据更新事务<ul><li>被更新的关系</li><li>每个关系上的更新操作条件所涉及的属性</li><li>修改操作要改变的属性值</li></ul></li><li>每个事务在各关系上运行的频率和性能要求</li></ul></li><li><p>关系数据库物理设计的内容</p><ul><li>为关系模式选择存取方法（建立存取路径）</li><li>设计关系、索引等数据库文件的物理存储结构</li></ul></li></ul><h3 id="关系模式存取方法选择">关系模式存取方法选择</h3><ul><li><p>数据库系统是多用户共享的系统，对同一个关系要建立多条存取路径才能满足多用户的多种应用要求。</p></li><li><p>物理结构设计的任务之一是根据关系数据库管理系统支持的存取方法确定选择哪些存取方法。</p></li><li><p>数据库管理系统常用存取方法</p><ul><li>B+树索引存取方法</li><li>Hash索引存取方法</li><li>聚簇存取方法</li></ul></li><li><p>选择索引存取方法的主要内容</p><ul><li>根据应用要求确定</li><li>对哪些属性列建立索引</li><li>对哪些属性列建立组合索引</li><li>对哪些索引要设计为唯一索引</li></ul></li><li><p>选择索引存取方法的一般规则</p><ul><li>如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）</li><li>如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引</li><li>如果一个（或一组）属性经常在连接操作的连接条件中 出现，则考虑在这个（或这组）属性上建立索引</li></ul></li><li><p>关系上定义的索引数过多会带来较多的额外开销</p><ul><li>维护索引的开销</li><li>查找索引的开销</li></ul></li><li><p>选择Hash存取方法的规则</p><ul><li>如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一<ul><li>该关系的大小可预知，而且不变；</li><li>该关系的大小动态改变，但所选用的数据库管理系统提供了动态Hash存取方法。</li></ul></li></ul></li><li><p>什么是聚簇</p><ul><li>为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中称为聚簇。该属性（或属性组）称为聚簇码（cluster key）</li><li>许多关系型数据库管理系统都提供了聚簇功能</li><li>聚簇存放与聚簇索引的区别</li></ul></li><li><p>聚簇索引</p><ul><li>建立聚簇索引后，基表中数据也需要按指定的聚簇属性值的升序或降序存放。也即聚簇索引的索引项顺序与表中元组的物理顺序一致。</li><li>在一个基本表上最多只能建立一个聚簇索引</li></ul></li><li><p>聚簇索引的适用条件</p><ul><li><p>很少对基表进行增删操作</p></li><li><p>很少对其中的长列进行修改操作</p></li></ul></li><li><p>聚簇的用途<br>对于某些类型的查询，可以提高查询效率</p><ol><li>大大提高按聚簇属性进行查询的效率<br>[例] 假设学生关系按所在系建有索引，现在要查询信息系的所有学生名单。<br>计算机系的500名学生分布在500个不同的物理块上时，至少要执行500次I/O操作。<br>如果将同一系的学生元组集中存放，则每读一个物理块可得到多个满足查询条件的元组，从而显著地减少了访问磁盘的次数。</li><li>节省存储空间<br>聚簇以后，聚簇码相同的元组集中在一起了，因而聚簇码值不必在每个元组中重复存储，只要在一组中存一次就行了。</li></ol></li><li><p>聚簇的局限性</p><ul><li>聚簇只能提高某些特定应用的性能</li><li>建立与维护聚簇的开销相当大<ul><li>对已有关系建立聚簇，将导致关系中元组的物理存储位置移动，并使此关系上原有的索引无效，必须重建。</li><li>当一个元组的聚簇码改变时，该元组的存储位置也要做相应改变。</li></ul></li></ul></li><li><p>聚簇的适用范围</p><ul><li>既适用于单个关系独立聚簇，也适用于多个关系组合聚簇</li><li>当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的时，可以使用聚簇<ul><li>尤其当SQL语句中包含有与聚簇码有关的ORDER BY, GROUP BY, UNION, DISTINCT等子句或短语时，使用聚簇特别有利，可以省去或减化对结果集的排序操作</li></ul></li></ul></li><li><p>选择聚簇存取方法</p><ul><li>设计候选聚簇<br>（1）常在一起进行连接操作的关系可以建立组合聚簇<br>（2）如果一个关系的一组属性经常出现在相等比较条<br>件中，则该单个关系可建立聚簇；<br>（3）如果一个关系的一个（或一组）属性上的值重复<br>率很高，则此单个关系可建立聚簇。</li></ul></li><li><p>检查候选聚簇中的关系，取消其中不必要的关系<br>（1）从聚簇中删除经常进行全表扫描的关系<br>（2）从聚簇中删除更新操作远多于连接操作的关系<br>（3）从聚簇中删除重复出现的关系</p><p>当一个关系同时加入多个聚簇时，必须从这多个聚簇方案<br>（包括不建立聚簇）中选择一个较优的，即在这个聚簇上<br>运行各种事务的总代价最小。</p></li></ul><h3 id="确定数据库的存储结构">确定数据库的存储结构</h3><ul><li><p>确定数据库物理结构主要指确定数据的存放位置和存储结构，包括：确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等。</p></li><li><p>确定数据的存放位置和存储结构要综合考虑存取时间、存储空间利用率和维护代价3个方面的因素。</p></li><li><p>影响数据存放位置和存储结构的因素</p><ul><li>硬件环境</li><li>应用需求<ul><li>存取时间</li><li>存储空间利用率</li><li>维护代价</li></ul></li><li>这三个方面常常是相互矛盾的</li></ul></li><li><p>基本原则</p><ul><li>根据应用情况将<ul><li>易变部分与稳定部分分开存放</li><li>经常存取部分与存取频率较低部分分开存放</li></ul></li></ul></li><li><p>[例]</p><ul><li>可以将比较大的表分别放在两个磁盘上，以加快存取速度，这在多用户环境下特别有效。</li><li>可以将日志文件与数据库对象（表、索引等）放在不同的磁盘以改进系统的性能。</li></ul></li><li><p>数据库管理系统一般都提供了一些存储分配参数</p><ul><li>同时使用数据库的用户数</li><li>同时打开的数据库对象数</li><li>内存分配参数</li><li>缓冲区分配参数（使用的缓冲区长度、个数）</li><li>存储分配参数</li><li>物理块的大小</li><li>物理块装填因子</li><li>时间片大小</li><li>数据库的大小</li><li>锁的数目等</li></ul></li><li><p>系统都为这些变量赋予了合理的缺省值。在进行物理设计时需要根据应用环境确定这些参数值，以使系统性能最优。</p></li><li><p>在物理设计时对系统配置变量的调整只是初步的，要根据系统实际运行情况做进一步的调整，以切实改进系统性能。</p></li></ul><h3 id="评价物理结构">评价物理结构</h3><ul><li>对数据库物理设计过程中产生的多种方案进行评价，从中选择一个较优的方案作为数据库的物理结构。</li><li>评价方法<ul><li>定量估算各种方案<ul><li>存储空间</li><li>存取时间</li><li>维护代价</li></ul></li><li>对估算结果进行权衡、比较，选择出一个较优的合理的物理结构。</li></ul></li></ul><h2 id="数据库的实施和维护">数据库的实施和维护</h2><h3 id="数据的载入和应用程序的调试">数据的载入和应用程序的调试</h3><ul><li><p>数据库结构建立好后，就可以向数据库中装载数据了。组织数据入库是数据库实施阶段最主要的工作。</p></li><li><p>数据装载方法</p><ul><li>人工方法</li><li>计算机辅助数据入库</li></ul></li><li><p>数据库应用程序的设计应该与数据设计并行进行</p></li><li><p>在组织数据入库的同时还要调试应用程序</p></li><li><p>应用程序的设计、编码和调试的方法、步骤在软件工程等课程中有详细讲解，这里就不赘述了</p></li></ul><h3 id="数据库的试运行">数据库的试运行</h3><ul><li><p>应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试，也称数据库的试运行。</p></li><li><p>主要工作包括：</p><ul><li>功能测试：实际运行应用程序，执行对数据库的各种操作，测试应用程序的各种功能。</li><li>性能测试：测量系统的性能指标，分析是否符合设计目标。</li></ul></li><li><p>数据库性能指标的测量</p><ul><li>数据库物理设计阶段在评价数据库结构估算时间、空间指标时，作了许多简化和假设，忽略了许多次要因素，因此结果必然很粗糙。</li><li>数据库试运行则是要实际测量系统的各种性能指标（不仅是时间、空间指标），如果结果不符合设计目标，则需要返回物理设计阶段，调整物理结构，修改参数；有时甚至需要返回逻辑设计阶段，调整逻辑结构。</li></ul></li><li><p>数据的分期入库</p><ul><li>重新设计物理结构甚至逻辑结构，会导致数据重新入库</li><li>由于数据入库工作量实在太大，所以可以采用分期输入数据的方法<ul><li>先输入小批量数据供先期联合调试使用</li><li>待试运行基本合格后再输入大批量数据</li><li>逐步增加数据量，逐步完成运行评价</li></ul></li></ul></li><li><p>数据库的转储和恢复</p><ul><li>在数据库试运行阶段，系统还不稳定，硬、软件故障随时都可能发生</li><li>系统的操作人员对新系统还不熟悉，误操作也不可避免</li><li>因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏</li></ul></li></ul><h3 id="数据库的运行和维护">数据库的运行和维护</h3><ul><li><p>在数据库运行阶段，对数据库经常性的维护工作主要是由数据库管理员完成的，包括：</p><ol><li><p>数据库的转储和恢复<br>数据库管理员要针对不同的应用要求制定不同的转储计划，定期对数据库和日志文件进行备份。<br>一旦发生介质故障，即利用数据库备份及日志文件备份，尽快将数据库恢复到某种一致性状态。</p></li><li><p>数据库的安全性、完整性控制</p><ul><li>初始定义<br>数据库管理员根据用户的实际需要授予不同的操作权限<br>根据应用环境定义不同的完整性约束条件</li><li>修改定义<br>当应用环境发生变化，对安全性的要求也会发生变化，数据库管理员需要根据实际情况修改原有的安全性控制<br>由于应用环境发生变化，数据库的完整性约束条件也会变化，也需要数据库管理员不断修正，以满足用户要求</li></ul></li><li><p>数据库性能的监督、分析和改进</p><ul><li>在数据库运行过程中，数据库管理员必须监督系统运行，对监测数据进行分析，找出改进系统性能的方法。<ul><li>利用监测工具获取系统运行过程中一系列性能参数的值</li><li>通过仔细分析这些数据，判断当前系统是否处于最佳运行状态</li><li>如果不是，则需要通过调整某些参数来进一步改进数据库性能</li></ul></li></ul></li><li><p>数据库的重组织与重构造<br>（1）数据库的重组织<br>为什么要重组织数据库<br>数据库运行一段时间后，由于记录的不断增、删、改，会使数据库的物理存储变坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降。</p><ul><li><p>重组织的形式</p><ul><li>全部重组织</li><li>部分重组织</li><li>只对频繁增、删的表进行重组织</li></ul></li><li><p>重组织的目标</p><p>提高系统性能</p></li><li><p>重组织的工作</p><ul><li>按原设计要求<br>重新安排存储位置<br>回收垃圾<br>减少指针链</li><li>数据库的重组织不会改变原设计的数据逻辑结构和物理结构</li></ul></li><li><p>数据库管理系统一般都提供了供重组织数据库使用的实用程序，帮助数据库管理员重新组织数据库。</p></li></ul><p>（2）数据库的重构造</p><ul><li>为什么要进行数据库的重构造<ul><li>数据库应用环境发生变化，会导致实体及实体间的联系也发生相应的变化，使原有的数据库设计不能很好地满足新的需求<ul><li>增加新的应用或新的实体</li><li>取消某些已有应用</li><li>改变某些已有应用</li></ul></li></ul></li></ul></li></ol></li><li><p>数据库重构造的主要工作</p><ul><li>根据新环境调整数据库的模式和内模式<ul><li>增加或删除某些数据项</li><li>改变数据项的类型</li><li>增加或删除某个表</li><li>改变数据库的容量</li><li>增加或删除某些索引</li></ul></li></ul></li><li><p>重构造数据库的程度是有限的</p><ul><li>若应用变化太大，已无法通过重构数据库来满足新的需求，或重构数据库的代价太大，则表明现有数据库应用系统的生命周期已经结束，应该重新设计新的数据库应用系统了。</li></ul></li></ul><h2 id="小结">小结</h2><ul><li><p>数据库的设计过程</p><ul><li>需求分析</li><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行维护</li><li>设计过程中往往还会有许多反复</li></ul></li><li><p>数据库各级模式的形成</p><ul><li>需求分析阶段：综合各个用户的应用需求（现实世界的需求）。</li><li>概念设计阶段：概念模式（信息世界模型），用E-R图来描述。</li><li>逻辑设计阶段：逻辑模式、外模式。</li><li>物理设计阶段：内模式。</li></ul></li><li><p>概念结构设计</p><ul><li>E-R模型的基本概念和图示方法</li><li>E-R模型的设计</li><li>把E-R模型转换为关系模型的方法</li></ul></li><li><p>在逻辑设计阶段将E-R图转换成具体的数据库产品支持的数据模型如关系模型，形成数据库逻辑模式。</p></li><li><p>然后根据用户处理的要求，安全性的考虑，在基本表的基础上再建立必要的视图，形成数据的外模式</p></li><li><p>在物理设计阶段根据DBMS特点和处理的需要，进行物理存储安排，设计索引，形成数据库内模式</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统 | 第六章 关系数据理论</title>
      <link href="2021/01/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
      <url>2021/01/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="问题的提出">问题的提出</h2><ul><li><p>关系数据库逻辑设计</p><ul><li>针对具体问题，如何构造一个适合于它的数据模式</li><li>数据库逻辑设计的工具──关系数据库的规范化理论</li></ul></li><li><p>关系模式由五部分组成，是一个五元组：</p><p>R(U, D, DOM, F)</p><ul><li>关系名R是符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U中的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为属性组U上的一组数据依赖</li></ul></li><li><p>由于D、DOM与模式设计关系不大，因此在本章中把关系模式看作一个三元组：R&lt;U,F&gt;</p></li><li><p>当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系</p></li><li><p>作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于第一范式（1NF）</p></li><li><p>数据依赖</p><ul><li>是一个关系内部属性与属性之间的一种约束关系</li><li>通过属性间值的相等与否体现出来的数据间相互联系</li><li>是现实世界属性间相互联系的抽象</li><li>是数据内在的性质</li><li>是语义的体现</li></ul></li><li><p>数据依赖的主要类型</p><ul><li>函数依赖（Functional Dependency，简记为FD）</li><li>多值依赖（Multi-Valued Dependency，简记为MVD）</li></ul></li><li><p>函数依赖普遍存在于现实生活中</p><ul><li>描述一个学生关系，可以有学号、姓名、系名等属性。</li><li>一个学号只对应一个学生，一个学生只在一个系中学习</li><li>“学号”值确定后，学生的姓名及所在系的值就被唯一确定。</li><li>Sname=f(Sno)，Sdept=f(Sno)<ul><li>即Sno函数决定Sname</li><li>Sno函数决定Sdept</li><li>记作Sno→Sname，Sno→Sdept</li></ul></li></ul></li><li><p>[例6.1] 建立一个描述学校教务的数据库。涉及的对象包括：</p><ul><li>学生的学号（Sno）</li><li>所在系（Sdept）</li><li>系主任姓名（Mname）</li><li>课程号（Cno）</li><li>成绩（Grade）</li></ul></li><li><p>假设学校教务的数据库模式用一个单一的关系模式Student来表示，则该关系模式的属性集合为：U ＝{Sno, Sdept, Mname, Cno, Grade}</p><ul><li>现实世界的已知事实（语义）：<ul><li>一个系有若干学生， 但一个学生只属于一个系；</li><li>一个系只有一名（正职）负责人；</li><li>一个学生可以选修多门课程，每门课程有若干学生选修；</li><li>每个学生学习每一门课程有一个成绩。</li></ul></li></ul></li><li><p>由此可得到属性组U上的一组函数依赖F：<br>F={Sno→Sdept, Sdept→ Mname, (Sno, Cno)→ Grade}</p></li><li><p>关系模式Student&lt;U, F&gt;中存在的问题：<br>（1）数据冗余</p><ul><li>浪费大量的存储空间<ul><li>每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同。</li></ul></li></ul><p>（2）更新异常（Update Anomalies）</p><ul><li>数据冗余 ，更新数据时，维护数据完整性代价大。<ul><li>某系更换系主任后，必须修改与该系学生有关的每一个元组。</li></ul></li></ul><p>（3）插入异常（Insertion Anomalies）</p><ul><li>如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。</li></ul><p>（4）删除异常（Deletion Anomalies）</p><ul><li>如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。</li></ul></li><li><p>结论</p><ul><li>Student关系模式不是一个好的模式。</li><li>一个“好”的模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。</li></ul></li><li><p>原因<br>由存在于模式中的某些数据依赖引起的。</p></li><li><p>解决方法<br>用规范化理论改造关系模式来消除其中不合适的数据依赖</p></li><li><p>把这个单一的模式分成三个关系模式：</p><ul><li>S(Sno,Sdept,Sno → Sdept);</li><li>SC(Sno,Cno,Grade,(Sno,Cno) → Grade);</li><li>DEPT(Sdept,Mname,Sdept → Mname);</li></ul></li><li><p>这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。</p></li></ul><h2 id="规范化">规范化</h2><h3 id="函数依赖">函数依赖</h3><ul><li><p>定义6.1</p><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。</p></li><li><p>[例] Student(Sno, Sname, Ssex, Sage, Sdept),<br>假设不允许重名，则有:<br>Sno → Ssex，      Sno → Sage<br>Sno → Sdept，    Sno ←→ Sname<br>Sname → Ssex， Sname → Sage<br>Sname → Sdept<br>但Ssex →Sage, Ssex→ Sdept</p><p>若X→Y，并且Y→X, 则记为X←→Y。<br>若Y不函数依赖于X, 则记为X→Y。</p></li><li><p>X→Y，但Y⊈X则称X→Y是非平凡的函数依赖。</p></li><li><p>X→Y，但Y⊆X 则称X→Y是平凡的函数依赖。</p></li><li><p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。<br>若不特别声明， 我们总是讨论非平凡函数依赖。</p></li><li><p>若X→Y，则X称为这个函数依赖的决定因素（Determinant）。<br>若X→Y，Y→X，则记作X←→Y。<br>若Y不函数依赖于X，则记作X↛Y。</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/1610897081703.jpg" alt=""></p><ul><li>定义6.3  在R(U)中，如果X→Y(Y⊈X)，Y↛X，Y→Z，Z⊈Y, 则称Z对X传递函数依赖(transitive functional dependency)。记为：X → Z。<br>注: 如果Y→X, 即X←→Y，则Z直接依赖于X，而不是传递函数依赖。<br>[例] 在关系Std(Sno, Sdept, Mname)中，有：<br>Sno → Sdept，Sdept → Mname，<br>Mname传递函数依赖于Sno</li></ul><h3 id="码">码</h3><ul><li><p>定义6.4</p><p>设K为R&lt;U,F&gt;中的属性或属性组合。若K → U，则K称为R的一个候选码(Candidate Key)。唯一标识实体的属性或属性组合称为码<br>如果U部分函数依赖于K，即K → U,则K称为超码      （Surpkey）。候选码是最小的超码，即K的任意一个真子集都不是候选码。</p></li><li><p>若关系模式R有多个候选码，则选定其中的一个做为主码(Primary key)。</p></li><li><p>主属性与非主属性<br>包含在任何一个候选码中的属性 ，称为主属性          （Prime attribute）<br>不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）</p></li><li><p>全码：整个属性组是码，称为全码（All-key）</p></li><li><p>主码=主键=主关键字，<br>关键字=候选码<br>候选关键字=候选码中除去主码的其他候选码</p></li><li><p>[例6.2]S(Sno, Sdept, Sage)，单个属性Sno是码<br>SC(Sno, Cno, Grade)中，(Sno, Cno)是码</p></li><li><p>[例6.3] R(P,W,A) P：演奏者     W：作品    A：听众<br>一个演奏者可以演奏多个作品<br>某一作品可被多个演奏者演奏<br>听众可以欣赏不同演奏者的不同作品<br>码为(P,W,A)，即All-Key</p></li><li><p>定义6.5  关系模式 R中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码。</p><ul><li>SC(Sno,Cno,Grade)中，Sno不是码</li><li>Sno是 S(Sno,Sdept,Sage)的码，则Sno是SC的外码</li></ul></li><li><p>主码与外部码一起提供了表示关系间联系的手段</p></li></ul><h3 id="范式">范式</h3><ul><li><p>范式是符合某一种级别的关系模式的集合。</p></li><li><p>作为二维表，关系要符合一个最基本的条件：每个分量必须是不可分开的数据项。满足了这个条件的关系模式就属于第一范式（1NF）</p></li><li><p>关系数据库中的关系必须满足一定的要求。满足   不同程度要求的为不同范式。</p></li><li><p>范式的种类</p><ul><li>第一范式（1NF）</li><li>第二范式（2NF）</li><li>第三范式（3NF）</li><li>BC范式（BCNF）</li><li>第四范式（4NF）</li><li>第五范式（5NF）</li></ul></li><li><p>各种范式之间存在联系：<br>某一关系模式R为第n范式，可简记为R∈nNF。</p></li><li><p>一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization）。</p></li></ul><h3 id="2NF">2NF</h3><ul><li><p>定义6.6  若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则R∈2NF</p></li><li><p>[例6.4]  S-L-C(Sno,Sdept,Sloc,Cno,Grade)， Sloc为学生的住处，并且每个系的学生住在同一个地方。S-L-C的码为(Sno,Cno)。<br>函数依赖有</p><ul><li>(Sno,Cno)→Grade</li><li>Sno→Sdept, (Sno,Cno)→Sdept</li><li>Sno→Sloc, (Sno,Cno)→Sloc</li><li>Sdept→Sloc</li></ul></li><li><p>一个关系模式不属于2NF，会产生以下问题：</p><ul><li>插入异常<br>如果插入一个新学生，但该生未选课，即该生无Cno，由于插入元组时，必须给定码值，因此插入失败。</li><li>删除异常<br>如果S4只选了一门课C3，现在他不再选这门课，则删除C3后，整个元组的其他信息也被删除了。</li><li>修改复杂<br>如果一个学生选了多门课，则Sdept，Sloc被存储了多次。如果该生转系，则需要修改所有相关的Sdept和Sloc，造成修改的复杂化。</li></ul></li><li><p>出现这种问题的原因</p><ul><li>例子中有两类非主属性：<ul><li>一类如Grade，它对码完全函数依赖</li><li>另一类如Sdept、Sloc，它们对码不是完全函数依赖</li></ul></li></ul></li><li><p>解决方法：</p><ul><li>用投影分解把关系模式S-L-C分解成两个关系模式<ul><li>SC(Sno,Cno,Grade)</li><li>S-L(Sno,Sdept,Sloc)</li></ul></li></ul></li><li><p>SC的码为(Sno,Cno),SL的码为Sno，这样使得非主属性对候选码都是完全函数依赖了，单关键字的数据库表都符合第二范式</p></li></ul><h3 id="3NF">3NF</h3><ul><li><p>定义6.7（无传递函数依赖即3NF）</p><p>设关系模式R&lt;U,F&gt;∈1NF,若R中不存在这样的码X、属性组Y(非码)及非主属性Z（Z ⊈ Y）, 使得X→Y(Y⊈X，Y ↛ X)，Y→Z成立，则称R&lt;U,F&gt; ∈ 3NF。</p><ul><li>SC没有传递依赖，因此SC ∈ 3NF</li><li>S-L中Sno →Sdept( Sdept ↛ Sno), Sdept→Sloc，可得Sno  →  Sloc。</li><li>解决的办法是将S-L分解成<ul><li>S-D(Sno,Sdept)∈ 3NF</li><li>D-L(Sdept,Sloc)∈ 3NF</li></ul></li></ul></li><li><p>基于2NF，非主属性不能函数依赖于非码。此外，非主属性只能存在一个表中，不应该存在多个表中；</p></li></ul><h3 id="BCNF">BCNF</h3><ul><li><p>BCNF（Boyce Codd Normal Form）由Boyce和Codd提出，比3NF更进了一步。通常认为BCNF是修正的第三范式，有时也称为扩充的第三范式。</p></li><li><p>定义6.8</p><p>设关系模式R&lt;U,F&gt;∈1NF，若X →Y且Y ⊆ X时X必含有码，则R&lt;U,F&gt;∈BCNF。</p></li><li><p>换言之，在关系模式R&lt;U,F&gt;中，如果每一个决定属性集都包含候选码，则R∈BCNF。</p></li><li><p>BCNF的关系模式所具有的性质</p><ul><li>所有非主属性都完全函数依赖于每个候选码(2NF)</li><li>所有主属性都完全函数依赖于每个不包含它的候选码(BCNF)</li><li>没有任何属性完全函数依赖于非码的任何一组属性(3NF+)</li></ul></li><li><p>如果一个关系数据库中的所有关系模式都属于BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常。</p></li><li><p>[例6.5]考察关系模式C(Cno,Cname,Pcno)</p></li><li><p>[例6.6] 关系模式S(Sno,Sname,Sdept,Sage)，</p><ul><li>假定Sname也具有唯一性，那么S就有两个码，这两个码都由单个属性组成，彼此不相交。</li><li>其他属性不存在对码的传递依赖与部分依赖，所以S∈3NF。</li><li>同时S中除Sno，Sname外没有其他决定因素，所以S也属于BCNF。</li></ul></li><li><p>[例6.7] 关系模式SJP(S,J,P)中，S是学生，J表示<br>课程，P表示名次。每一个学生选修每门课程的成绩有一定的名次，每门课程中每一名次只有一个学生（即没有并列名次）。</p><ul><li><p>由语义可得到函数依赖： (S,J)→P；(J,P)→S(S,J)与(J,P)都可以作为候选码。</p></li><li><p>关系模式中没有属性对码传递依赖或部分依赖，所以   SJP∈3NF。</p></li><li><p>除(S,J)与(J,P)以外没有其他决定因素，所以SJP∈BCNF。</p></li></ul></li><li><p>[例6.8] 关系模式STJ(S,T,J)中，S表示学生，T表示教师，J表示课程。每一教师只教一门课。每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。</p><ul><li>由语义可得到函数依赖：(S,J)→T；(S,T)→J；T→J</li><li>因为没有任何非主属性对码传递依赖或部分依赖，STJ ∈ 3NF。</li><li>因为T是决定因素，而T不包含码，所以STJ ∈ BCNF关系。BCNF每个属性均完全依赖于每个候选码(不含它)</li></ul></li><li><p>对于不是BCNF的关系模式，仍然存在不合适的地方。</p></li><li><p>非BCNF的关系模式也可以通过分解成为BCNF。例如STJ可分解为ST(S,T)与TJ(T,J)，它们都是BCNF。</p></li><li><p>3NF和BCNF是在函数依赖的条件下对模式分解所能达到的分离程度的测度。</p><ul><li>一个模式中的关系模式如果都属于BCNF，那么在函数依赖范畴内，它已实现了彻底的分离，已消除了插入和删除的异常。</li><li>3NF的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。</li></ul></li></ul><h3 id="规范化小结">规范化小结</h3><ul><li><p>在关系数据库中，对关系模式的基本要求是满足第一范式。</p></li><li><p>规范化程度过低的关系不一定能够很好地描述现实世界</p><ul><li>可能存在插入异常、删除异常、修改复杂、数据冗余等问题</li><li>解决方法就是对其进行规范化，转换成高级范式。</li></ul></li><li><p>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化。</p></li><li><p>关系数据库的规范化理论是数据库逻辑设计的工具。</p></li><li><p>规范化的基本思想</p><ul><li>是逐步消除数据依赖中不合适的部分，使模式中的各关系模式达到某种程度的“分离”。</li><li>即采用“一事一地”的模式设计原则<ul><li>让一个关系描述一个概念、一个实体或者实体间的一种联系。</li><li>若多于一个概念就把它“分离”出去。</li></ul></li><li>因此 规范化实质上是概念的单一化。</li></ul></li></ul><h2 id="数据依赖的公理系统">数据依赖的公理系统</h2><ul><li><p>一套推理规则，是模式分解算法的理论基础</p></li><li><p>用途</p><ul><li>求给定关系模式的码</li><li>从一组函数依赖求得蕴涵的函数依赖</li></ul></li><li><p>Armstrong公理系统  设U为属性集总体，F是U上的一组函数依赖， 于是有关系模式R &lt;U,F &gt;。对R &lt;U,F&gt; 来说有以下的推理规则：</p><ul><li>A1 自反律（reflexivity rule）：若Y  X  U，则X →Y 为F所蕴涵。</li><li>A2 增广律（augmentation rule）：若X→Y为F所蕴涵，且Z  U，则XZ→YZ 为F所蕴涵。</li><li>A3 传递律（transitivity rule）：若X→Y及Y→Z为F所蕴涵，则X→Z 为F所蕴涵。</li></ul></li><li><p>根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：</p><ul><li>合并规则（union rule）：<br>由X→Y，X→Z，有X→YZ。</li><li>伪传递规则（pseudo transitivity rule）：<br>由X→Y，WY→Z，有XW→Z。</li><li>分解规则（decomposition rule）：<br>由X→Y及ZY，有X→Z。</li></ul></li><li><p>定义6.12</p><p>在关系模式R&lt;U,F&gt;中为F所逻辑蕴涵的函数依赖的全体叫作F的闭包，记为F +。</p></li><li><p>定义6.13</p><p>设F为属性集U上的一组函数依赖，X、Y U， XF+={ A|X→A能由F根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F的闭包。</p></li><li><p>有效性与完备性的含义</p><ul><li>有效性：由F 出发根据Armstrong公理推导出来的每一个函数依赖一定在F +中</li><li>完备性：F +中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来</li></ul></li></ul><h2 id="小结">小结</h2><ul><li>若要求分解具有无损连接性，那么模式分解一定能够达到4NF。</li><li>若要求分解保持函数依赖，那么模式分解一定能够达到3NF，但不一定能够达到BCNF。</li><li>若分解既具有无损连接性，又保持函数依赖，则模式分解一定能够达到3NF，但不一定能够达到BCNF。</li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统 | 第五章 数据库完整性</title>
      <link href="2021/01/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
      <url>2021/01/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库的完整性">数据库的完整性</h2><ul><li><p>数据的正确性<br>是指数据是符合现实世界语义，反映了当前实际状况的</p></li><li><p>数据的相容性</p><ul><li>是指数据库同一对象在不同关系表中的数据是符合逻辑的<br>例如，<ul><li>学生的学号必须唯一</li><li>性别只能是男或女</li><li>本科学生年龄的取值范围为14~50的整数</li><li>学生所选的课程必须是学校开设的课程，学生所在的院系必须是学校已成立的院系等</li></ul></li></ul></li><li><p>数据的完整性和安全性是两个不同概念</p><ul><li>数据的完整性<ul><li>防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据</li><li>防范对象：不合语义的、不正确的数据</li></ul></li><li>数据的安全性<ul><li>保护数据库 防止恶意的破坏和非法的存取</li><li>防范对象：非法用户和非法操作</li></ul></li></ul></li><li><p>为维护数据库的完整性，数据库管理系统必须：</p><ul><li>提供定义完整性约束条件的机制<ul><li>完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件</li><li>SQL标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性</li><li>这些完整性一般由SQL的数据定义语言语句来实现</li></ul></li><li>提供完整性检查的方法<ul><li>数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。</li><li>一般在INSERT、UPDATE、DELETE语句执行后开始检查，也可以在事务提交时检查</li></ul></li><li>违约处理<ul><li>数据库管理系统若发现用户的操作违背了完整性约束条件，就采取一定的动作<ul><li>拒绝（NO ACTION）执行该操作</li><li>级连（CASCADE）执行其他操作</li></ul></li></ul></li></ul></li></ul><h2 id="实体完整性">实体完整性</h2><h3 id="实体完整性定义">实体完整性定义</h3><ul><li><p>关系模型的实体完整性<br>CREATE  TABLE中用PRIMARY KEY定义</p></li><li><p>单属性构成的码有两种说明方法</p><ul><li>定义为列级约束条件</li><li>定义为表级约束条件</li></ul></li><li><p>对多个属性构成的码只有一种说明方法</p><ul><li>定义为表级约束条件</li></ul></li><li><p>[例5.1] 将Student表中的Sno属性定义为码</p><p>（1）在列级定义主码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">                (  Sno  <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">                   Sname  <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,     </span><br><span class="line">                   Ssex  <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">                   Sage  <span class="type">SMALLINT</span>,</span><br><span class="line">                   Sdept  <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">                );</span><br></pre></td></tr></table></figure><p>（2）在表级定义主码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">    (  Sno  <span class="type">CHAR</span>(<span class="number">9</span>),  </span><br><span class="line">     Sname  <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">       Ssex  <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">       Sage  <span class="type">SMALLINT</span>,</span><br><span class="line">       Sdept  <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">       <span class="keyword">PRIMARY</span> KEY (Sno)</span><br><span class="line">     ); </span><br></pre></td></tr></table></figure></li><li><p>[例5.2] 将SC表中的Sno，Cno属性组定义为码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">           (  Sno   <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">              Cno  <span class="type">CHAR</span>(<span class="number">4</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">              Grade    <span class="type">SMALLINT</span>,</span><br><span class="line">              <span class="keyword">PRIMARY</span> KEY (Sno,Cno)    <span class="comment">/*只能在表级定义主码*/</span></span><br><span class="line">           ); </span><br></pre></td></tr></table></figure></li></ul><h3 id="实体完整性检查和违约处理">实体完整性检查和违约处理</h3><ul><li><p>插入或对主码列进行更新操作时，关系数据库管理系统按照实体完整性规则自动进行检查。包括：</p><ul><li>检查主码值是否唯一，如果不唯一则拒绝插入或修改</li><li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</li></ul></li><li><p>检查记录中主码值是否唯一的一种方法是进行全表扫描</p><ul><li>依次判断表中每一条记录的主码值与将插入记录上的主码值（或者修改的新主码值）是否相同</li></ul></li><li><p>表扫描缺点</p><ul><li>十分耗时</li></ul></li><li><p>为避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引</p></li></ul><h2 id="参照完整性">参照完整性</h2><h3 id="参照完整性定义">参照完整性定义</h3><ul><li><p>关系模型的参照完整性定义</p><ul><li>在CREATE  TABLE中用FOREIGN KEY短语定义哪些列为外码</li><li>用REFERENCES短语指明这些外码参照哪些表的主码</li></ul></li><li><p>例如，关系SC中（Sno，Cno）是主码。Sno，Cno分别参照Student表<br>的主码和Course表的主码<br>[例5.3]定义SC中的参照完整性</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">         (  Sno    <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">            Cno     <span class="type">CHAR</span>(<span class="number">4</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">            Grade    <span class="type">SMALLINT</span>,</span><br><span class="line">            <span class="keyword">PRIMARY</span> KEY (Sno, Cno),   <span class="comment">/*在表级定义实体完整性*/</span></span><br><span class="line">               <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno),  </span><br><span class="line">                  <span class="comment">/*在表级定义参照完整性*/</span></span><br><span class="line">               <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)    </span><br><span class="line">                  <span class="comment">/*在表级定义参照完整性*/</span></span><br><span class="line">             );</span><br></pre></td></tr></table></figure></li></ul><h3 id="参照完整性检查和违约处理">参照完整性检查和违约处理</h3><ul><li><p>一个参照完整性将两个表中的相应元组联系起来</p></li><li><p>对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查</p></li><li><p>例如，对表SC和Student有四种可能破坏参照完整性的情况 :</p><ul><li>SC表中增加一个元组，该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</li><li>修改SC表中的一个元组，修改后该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</li><li>从Student表中删除一个元组，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</li><li>修改Student表中一个元组的Sno属性，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等 。</li></ul></li></ul><table><thead><tr><th><strong>被参照表（例如Student）</strong></th><th><strong>参照表（例如SC）</strong></th><th><strong>违约处理</strong></th></tr></thead><tbody><tr><td><strong>可能破坏参照完整性</strong></td><td><strong>插入元组</strong></td><td><strong>拒绝</strong></td></tr><tr><td><strong>可能破坏参照完整性</strong></td><td><strong>修改外码值</strong></td><td><strong>拒绝</strong></td></tr><tr><td><strong>删除元组</strong></td><td><strong>可能破坏参照完整性</strong></td><td><strong>拒绝级连删除设置为空值</strong></td></tr><tr><td><strong>修改主码值</strong></td><td><strong>可能破坏参照完整性</strong></td><td><strong>拒绝级连修改设置为空值</strong></td></tr></tbody></table><ul><li><p>参照完整性违约处理<br>（1） 拒绝（NO ACTION）执行<br>不允许该操作执行。该策略一般设置为默认策略<br>（2） 级联（CASCADE）操作<br>当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组<br>（3）设置为空值（SET-NULL）<br>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</p></li><li><p>[例5.4]  显式说明参照完整性的违约处理示例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">      (  Sno   <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">         Cno   <span class="type">CHAR</span>(<span class="number">4</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">         Grade  <span class="type">SMALLINT</span>,</span><br><span class="line">         <span class="keyword">PRIMARY</span> KEY(Sno,Cno)， </span><br><span class="line">         <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno) </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE        <span class="comment">/*级联删除SC表中相应的元组*/</span></span><br><span class="line">           <span class="keyword">ON</span> UPDATE CASCADE,      <span class="comment">/*级联更新SC表中相应的元组*/</span></span><br><span class="line">         <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)                    </span><br><span class="line">           <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION </span><br><span class="line">               <span class="comment">/*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/</span></span><br><span class="line">           <span class="keyword">ON</span> UPDATE CASCADE   </span><br><span class="line">      <span class="comment">/*当更新course表中的cno时，级联更新SC表中相应的元组*/</span></span><br><span class="line">         );</span><br></pre></td></tr></table></figure></li></ul><h2 id="用户定义的完整性">用户定义的完整性</h2><ul><li>用户定义的完整性是：针对某一具体应用的数据必须满足的语义要求</li><li>关系数据库管理系统提供了定义和检验用户定义完整性的机制，不必由应用程序承担</li></ul><h3 id="属性上的约束条件">属性上的约束条件</h3><ul><li><p>CREATE TABLE时定义属性上的约束条件</p><ul><li>列值非空（NOT NULL）</li><li>列值唯一（UNIQUE）</li><li>检查列值是否满足一个条件表达式（CHECK）</li></ul></li><li><p>（1）不允许取空值<br>[例5.5]  在定义SC表时，说明Sno、Cno、Grade属性不允许取空值。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">        (  Sno <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">           Cno <span class="type">CHAR</span>(<span class="number">4</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">           Grade  <span class="type">SMALLINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY (Sno, Cno),  </span><br><span class="line">             … </span><br><span class="line">              <span class="comment">/* 如果在表级定义实体完整性，隐含了Sno，Cno不允许取空值，则在  </span></span><br><span class="line"><span class="comment">             列级不允许取空值的定义 可以不写 * /</span></span><br><span class="line"><span class="comment">         ); </span></span><br></pre></td></tr></table></figure></li><li><p>（2）列值唯一<br>[例5.6]建立部门表DEPT，要求部门名称Dname列取值唯一，部门编号Deptno列为主码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> DEPT</span><br><span class="line">    (   Deptno  <span class="type">NUMERIC</span>(<span class="number">2</span>),</span><br><span class="line">        Dname  <span class="type">CHAR</span>(<span class="number">9</span>)  <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">                                      <span class="comment">/*要求Dname列值唯一, 并且不能取空值*/</span></span><br><span class="line">        Location  <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY (Deptno)</span><br><span class="line">     );</span><br></pre></td></tr></table></figure></li><li><p>（3）用CHECK短语指定列值应该满足的条件</p><p>​    [例5.7]  Student表的Ssex只允许取“男”或“女”。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">     ( Sno  <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">       Sname <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                     </span><br><span class="line">       Ssex  <span class="type">CHAR</span>(<span class="number">2</span>)  <span class="keyword">CHECK</span> （Ssex <span class="keyword">IN</span> （‘男’,’女’）），           </span><br><span class="line">                                                <span class="comment">/*性别属性Ssex只允许取&#x27;男&#x27;或&#x27;女&#x27; */</span></span><br><span class="line">       Sage  <span class="type">SMALLINT</span>,</span><br><span class="line">       Sdept  <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">     );</span><br></pre></td></tr></table></figure></li><li><p>[例5.8]  SC表的Grade的值应该在0和100之间。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  SC</span><br><span class="line">        (  Sno     <span class="type">CHAR</span>(<span class="number">9</span>) ,</span><br><span class="line">           Cno    <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line">Grade   <span class="type">SMALLINT</span> <span class="keyword">CHECK</span> (Grade<span class="operator">&gt;=</span><span class="number">0</span> <span class="keyword">AND</span> Grade <span class="operator">&lt;=</span><span class="number">100</span>)，      <span class="comment">/*Grade取值范围是0到100*/</span></span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY (Sno,Cno),</span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Cno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">          );</span><br></pre></td></tr></table></figure></li><li><p>属性上的约束条件检查和违约处理</p><ul><li>插入元组或修改属性的值时，关系数据库管理系统检查属性上的约束条件是否被满足</li><li>如果不满足则操作被拒绝执行</li></ul></li></ul><h3 id="元组上的约束条件">元组上的约束条件</h3><ul><li><p>在CREATE TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制</p></li><li><p>同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件</p></li><li><p>[例5.9]当学生的性别是男时，其名字不能以Ms.打头。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">     (  Sno    <span class="type">CHAR</span>(<span class="number">9</span>), </span><br><span class="line">        Sname  <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>，</span><br><span class="line">        Ssex    <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">        Sage   <span class="type">SMALLINT</span>,</span><br><span class="line">        Sdept  <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY (Sno),</span><br><span class="line">        <span class="keyword">CHECK</span> (Ssex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> <span class="keyword">OR</span> Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;Ms.%&#x27;</span>)</span><br><span class="line">               <span class="comment">/*定义了元组中Sname和 Ssex两个属性值之间的约束条件*/</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure><p>性别是女性的元组都能通过该项检查，因为Ssex=‘女’成立;<br>当性别是男性时，要通过检查则名字一定不能以Ms.打头</p></li><li><p>元组上的约束条件检查和违约处理</p><ul><li>插入元组或修改属性的值时，关系数据库管理系统检查元组上的约束条件是否被满足</li><li>如果不满足则操作被拒绝执行</li></ul></li></ul><h2 id="完整性约束命名子句">完整性约束命名子句</h2><ul><li><p>完整性约束命名子句<br>CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;</p><ul><li>&lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY短语、FOREIGN KEY短语、CHECK短语等</li></ul></li><li><p>[例5.10]建立学生登记表Student，要求学号在90000~99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">  (   Sno  <span class="type">NUMERIC</span>(<span class="number">6</span>)</span><br><span class="line">      <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">90000</span> <span class="keyword">AND</span> <span class="number">99999</span>),</span><br><span class="line">      Sname  <span class="type">CHAR</span>(<span class="number">20</span>)  </span><br><span class="line">      <span class="keyword">CONSTRAINT</span> C2 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">      Sage  <span class="type">NUMERIC</span>(<span class="number">3</span>)</span><br><span class="line">      <span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span> (Sage <span class="operator">&lt;</span> <span class="number">30</span>),</span><br><span class="line">      Ssex  <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">CONSTRAINT</span> C4 <span class="keyword">CHECK</span> (Ssex <span class="keyword">IN</span> ( ‘男’,<span class="string">&#x27;女&#x27;</span>)),</span><br><span class="line">      <span class="keyword">CONSTRAINT</span> StudentKey <span class="keyword">PRIMARY</span> KEY(Sno)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>在Student表上建立了5个约束条件，包括主码约束（命名为StudentKey）以及C1、C2、C3、C4四个列级约束。</p></li><li><p>[例5.11]建立教师表TEACHER，要求每个教师的应发工资不低于3000元。<br>应发工资是工资列Sal与扣除项Deduct之和。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEACHER</span><br><span class="line">        (   Eno    <span class="type">NUMERIC</span>(<span class="number">4</span>)  <span class="keyword">PRIMARY</span> KEY    <span class="comment">/*在列级定义主码*/</span></span><br><span class="line">            Ename  <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">            Job     <span class="type">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">   Sal     <span class="type">NUMERIC</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   Deduct  <span class="type">NUMERIC</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">   Deptno  <span class="type">NUMERIC</span>(<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> TEACHERFKey <span class="keyword">FOREIGN</span> KEY (Deptno) <span class="keyword">REFERENCES</span> DEPT(Deptno),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sal <span class="operator">+</span> Deduct <span class="operator">&gt;=</span> <span class="number">3000</span>) </span><br><span class="line">          );</span><br></pre></td></tr></table></figure></li><li><p>修改表中的完整性限制<br>使用ALTER TABLE语句修改表中的完整性限制<br>[例5.12]去掉例5.10 Student表中对性别的限制。<br>ALTER TABLE Student<br>DROP CONSTRAINT C4;</p></li><li><p>[例5.13]  修改表Student中的约束条件，要求学号改为在900000~999999之间，年龄由小于30改为小于40<br>可以先删除原来的约束条件，再增加新的约束条件</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C1;</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">900000</span> <span class="keyword">AND</span> <span class="number">999999</span>),</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C3;</span><br><span class="line">        <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">        <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span>(Sage <span class="operator">&lt;</span> <span class="number">40</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="断言">断言</h2><ul><li><p>SQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。</p></li><li><p>可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。</p></li><li><p>断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行</p></li><li><p>创建断言的语句格式<br>CREATE ASSERTION&lt;断言名&gt;&lt;CHECK 子句&gt;<br>每个断言都被赋予一个名字，&lt;CHECK 子句&gt;中的约束条件与WHERE子句的条件表达式类似。</p><p>[例5.18] 限制数据库课程最多60名学生选修</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_DB_NUM</span><br><span class="line"><span class="keyword">CHECK</span> (<span class="number">60</span> <span class="operator">&gt;=</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">                  <span class="comment">/*此断言的谓词涉及聚集操作count的SQL语句*/</span></span><br><span class="line">                <span class="keyword">From</span> Course,SC</span><br><span class="line">        <span class="keyword">Where</span> SC.Cno<span class="operator">=</span>Course.Cno <span class="keyword">and</span> Course.Cname <span class="operator">=</span><span class="string">&#x27;数据库&#x27;</span>)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure></li><li><p>[例5.19]限制每一门课程最多60名学生选修</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION ASSE_SC_CNUM1</span><br><span class="line"><span class="keyword">CHECK</span>(<span class="number">60</span> <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> SC </span><br><span class="line">          <span class="keyword">GROUP</span> <span class="keyword">by</span> cno)</span><br><span class="line">         );</span><br><span class="line"><span class="comment">/*此断言的谓词，涉及聚集操作count 和分组函数group by的SQL语句*/</span></span><br></pre></td></tr></table></figure></li><li><p>[例5.20]限制每个学期每一门课程最多60名学生选修</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  首先需要修改SC表的模式，增加一个“学期（TERM）”属性</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SC <span class="keyword">ADD</span> TERM <span class="type">DATE</span>;</span><br><span class="line">   然后，定义断言：</span><br><span class="line">   <span class="keyword">CREATE</span> ASSERTION ASSE_SC_CNUM2</span><br><span class="line"> <span class="keyword">CHECK</span>(<span class="number">60</span> <span class="operator">&gt;=</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)  <span class="keyword">FROM</span> SC</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">by</span> cno,TERM)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure></li><li><p>删除断言的语句格式为</p><ul><li>DROP ASSERTION &lt;断言名&gt;;</li><li>如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的</li></ul></li></ul><h2 id="触发器">触发器</h2><h3 id="定义触发器">定义触发器</h3><ul><li><p>CREATE TRIGGER语法格式<br>CREATE TRIGGER &lt;触发器名&gt;<br>{BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt;<br>REFERENCING NEW|OLD ROW AS&lt;变量&gt;<br>FOR EACH  {ROW | STATEMENT}<br>[WHEN &lt;触发条件&gt;]&lt;触发动作体&gt;<br>触发器又叫做事件-条件-动作（event-condition-action）规则。<br>当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执<br>行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通<br>常是一段SQL存储过程。</p></li><li><p>定义触发器的语法说明<br>（1）表的拥有者才可以在表上创建触发器<br>（2）触发器名<br>触发器名可以包含模式名，也可以不包含模式名<br>同一模式下，触发器名必须是唯一的<br>触发器名和表名必须在同一模式下<br>（3）表名<br>触发器只能定义在基本表上，不能定义在视图上<br>当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器</p><p>（4）触发事件</p><ul><li>触发事件可以是INSERT、DELETE或UPDATE也可以是这几个事件的组合</li><li>还可以UPDATE OF&lt;触发列，…&gt;，即进一步指明修改哪些列时激活触发器</li><li>AFTER/BEFORE是触发的时机<ul><li>AFTER表示在触发事件的操作执行之后激活触发器</li><li>BEFORE表示在触发事件的操作执行之前激活触发器</li></ul></li></ul><p>（5）触发器类型</p><ul><li>行级触发器（FOR EACH ROW）</li><li>语句级触发器（FOR EACH STATEMENT）<br>例如,在例5.11的TEACHER表上创建一个AFTER UPDATE触发器，触发事件是UPDATE语句：<br>UPDATE TEACHER SET Deptno=5;<br>假设表TEACHER有1000行<ul><li>如果是语句级触发器，那么执行完该语句后，触发动作只发生一次</li><li>如果是行级触发器，触发动作将执行1000次</li></ul></li></ul><p>（6）触发条件</p><ul><li>触发器被激活时，只有当触发条件为真时触发动作体才执行;否则触发动作体不执行。</li><li>如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行</li></ul><p>（7）触发动作体</p><ul><li>触发动作体可以是一个匿名PL/SQL过程块<br>也可以是对已创建存储过程的调用</li><li>如果是行级触发器，用户都可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值</li><li>如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用</li><li>如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化<br>注意：不同的RDBMS产品触发器语法各部相同</li></ul></li><li><p>[例5.21]当对表SC的Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：<br>SC_U（Sno,Cno,Oldgrade,Newgrade）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">    其中Oldgrade是修改前的分数，Newgrade是修改后的分数。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span>  SC_T</span><br><span class="line">AFTER UPDATE <span class="keyword">OF</span> Grade <span class="keyword">ON</span> SC</span><br><span class="line">     <span class="keyword">REFERENCING</span></span><br><span class="line">      <span class="keyword">OLD</span> <span class="type">row</span>  <span class="keyword">AS</span>  OldTuple,</span><br><span class="line">      <span class="keyword">NEW</span> <span class="type">row</span> <span class="keyword">AS</span>  NewTuple</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> </span><br><span class="line"><span class="keyword">WHEN</span> (NewTuple.Grade <span class="operator">&gt;=</span> <span class="number">1.1</span><span class="operator">*</span>OldTuple.Grade)</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC_U(Sno,Cno,OldGrade,NewGrade)  </span><br><span class="line"><span class="keyword">VALUES</span>(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade)</span><br></pre></td></tr></table></figure></li><li><p>[例5.22] 将每次对表Student的插入操作所增加的学生个数记录到表StudentInsertLog中。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Student_Count</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> Student  </span><br><span class="line">        <span class="comment">/*指明触发器激活的时间是在执行INSERT后*/</span>     </span><br><span class="line"><span class="keyword">REFERENCING</span></span><br><span class="line">    <span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> DELTA</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT  </span><br><span class="line">       <span class="comment">/*语句级触发器, 即执行完INSERT语句后下面的触发动作体才执行一次*/</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> StudentInsertLog (Numbers)</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> DELTA</span><br></pre></td></tr></table></figure></li><li><p>[例5.23] 定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于4000元，如果低于4000元，自动改为4000元”。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Insert_Or_Update_Sal </span><br><span class="line">    BEFORE <span class="keyword">INSERT</span> <span class="keyword">OR</span> UPDATE <span class="keyword">ON</span> Teacher  </span><br><span class="line">                 <span class="comment">/*触发事件是插入或更新操作*/</span></span><br><span class="line">     <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>        <span class="comment">/*行级触发器*/</span></span><br><span class="line">     <span class="keyword">BEGIN</span>                             <span class="comment">/*定义触发动作体，是PL/SQL过程块*/</span></span><br><span class="line">         IF (new.Job<span class="operator">=</span><span class="string">&#x27;教授&#x27;</span>) <span class="keyword">AND</span> (new.Sal <span class="operator">&lt;</span> <span class="number">4000</span>) </span><br><span class="line">         <span class="keyword">THEN</span>  new.Sal :<span class="operator">=</span><span class="number">4000</span>;                </span><br><span class="line">       <span class="keyword">END</span> IF;</span><br><span class="line">   <span class="keyword">END</span>;      </span><br></pre></td></tr></table></figure></li></ul><h3 id="激活触发器">激活触发器</h3><ul><li>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行</li><li>一个数据表上可能定义了多个触发器，遵循如下的执行顺序:<br>（1） 执行该表上的BEFORE触发器;<br>（2） 激活触发器的SQL语句;<br>（3） 执行该表上的AFTER触发器。</li></ul><h3 id="删除触发器">删除触发器</h3><ul><li>删除触发器的SQL语法：<br>DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;</li><li>触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。</li></ul><h2 id="小结">小结</h2><ul><li><p>数据库的完整性是为了保证数据库中存储的数据是正确的</p></li><li><p>关系数据库管理系统完整性实现的机制</p><ul><li>完整性约束定义机制</li><li>完整性检查机制</li><li>违背完整性约束条件时关系数据库管理系统应采取的动作</li></ul></li><li><p>按照约束来源分类:</p><ul><li>结构约束: 主键约束, 外键约束,是否允许空值等 primary key, foreign key, not null,unique</li><li>内容约束:  取值范围, check(sage&lt;25 and sage&lt;40), CREATE ASSERTION&lt;断言名&gt;CHECK(&lt;条件&gt;)[约束性质]（Mysql 不支持断言）</li><li>动态动态: DB改变状态时要满足的约束, CREATE TRIGGER</li></ul></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统 | 第四章 数据库安全性</title>
      <link href="2021/01/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>2021/01/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库安全性概述">数据库安全性概述</h2><ul><li>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏 。</li><li>系统安全保护措施是否有效是数据库系统主要的性能指标之一。</li></ul><h3 id="数据库的不安全因素">数据库的不安全因素</h3><ul><li><p>非授权用户对数据库的恶意存取和破坏</p><ul><li>一些黑客（Hacker）和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据。</li><li>数据库管理系统提供的安全措施主要包括<ul><li>用户身份鉴别</li><li>存取控制</li><li>视图等技术。</li></ul></li></ul></li><li><p>数据库中重要或敏感的数据被泄露</p><ul><li>黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露。</li><li>数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。</li><li>审计日志分析</li></ul></li><li><p>安全环境的脆弱性</p><ul><li>数据库的安全性与计算机系统的安全性紧密联系<br>计算机硬件、操作系统、网络系统等的安全性</li><li>建立一套可信（Trusted）计算机系统的概念和标准</li></ul></li></ul><h3 id="安全标准简介">安全标准简介</h3><ul><li><p>1985年美国国防部（DoD）正式颁布《DoD可信计算机系统评估准则》（简称TCSEC或DoD85）</p></li><li><p>不同国家建立在TCSEC概念上的评估准则</p><ul><li>欧洲的信息技术安全评估准则（ITSEC）</li><li>加拿大的可信计算机产品评估准则（CTCPEC）</li><li>美国的信息技术安全联邦标准（FC）</li></ul></li><li><p>1993年，CTCPEC、FC、TCSEC和ITSEC联合行动，解决原标准中概念和技术上的差异，称为CC（Common Criteria）项目</p></li><li><p>1999年  CC V2.1版被ISO采用为国际标准<br>2001年  CC V2.1版被我国采用为国家标准</p></li><li><p>目前CC已基本取代了TCSEC，成为评估信息产品安全性的主要标准。</p></li></ul><h2 id="数据库安全性控制">数据库安全性控制</h2><ul><li>非法使用数据库的情况<ul><li>编写合法程序绕过数据库管理系统及其授权机制</li><li>直接或编写应用程序执行非授权操作</li><li>通过多次合法查询数据库从中推导出一些保密数据</li></ul></li><li>数据库安全性控制的常用方法<ul><li>用户标识和鉴定</li><li>存取控制</li><li>视图</li><li>审计</li><li>数据加密</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/1610873373106.jpg" alt="在这里插入图片描述"></p><ul><li>系统根据用户标识鉴定用户身份，合法用户才准许进入计算机系统</li><li>数据库管理系统还要进行存取控制，只允许用户执行合法操作</li><li>操作系统有自己的保护措施</li><li>数据以密码形式存储到数据库中</li></ul><h3 id="存取控制流程">存取控制流程</h3><ul><li>首先，数据库管理系统对提出SQL访问请求的数据库用户进行身份鉴别，防止不可信用户使用系统。</li><li>然后，在SQL处理层进行自主存取控制和强制存取控制，进一步可以进行推理控制。</li><li>还可以对用户访问行为和系统关键操作进行审计，对异常用户行为进行简单入侵检测。</li></ul><h3 id="用户身份鉴别">用户身份鉴别</h3><ul><li><p>用户身份鉴别（Identification &amp;  Authentication）</p><ul><li>系统提供的最外层安全保护措施</li><li>用户标识：由用户名和用户标识号组成（用户标识号在系统整个生命周期内唯一）</li></ul></li><li><p>用户身份鉴别的方法</p><ul><li>静态口令鉴别<br>静态口令一般由用户自己设定，这些口令是静态不变的</li><li>动态口令鉴别<br>口令是动态变化的，每次鉴别时均需使用动态产生的新口令登录数据库管理系统，即采用一次一密的方法</li><li>生物特征鉴别<br>通过生物特征进行认证的技术，生物特征如指纹、虹膜和掌纹等</li><li>智能卡鉴别<br>智能卡是一种不可复制的硬件，内置集成电路的芯片，具有硬件加密功能</li></ul></li></ul><h3 id="存取控制">存取控制</h3><ul><li><p>存取控制机制组成</p><ul><li>定义用户权限，并将用户权限登记到数据字典中<ul><li>用户对某一数据对象的操作权力称为权限</li><li>DBMS提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则</li></ul></li><li>合法权限检查<ul><li>用户发出存取数据库操作请求</li><li>DBMS查找数据字典，进行合法权限检查</li></ul></li></ul></li><li><p>用户权限定义和合法权检查机制一起组成了数据库管理系统的存取控制子系统</p></li><li><p>常用存取控制方法</p><ul><li>自主存取控制（Discretionary Access Control ，简称DAC）<ul><li>C2级</li><li>用户对不同的数据对象有不同的存取权限</li><li>不同的用户对同一对象也有不同的权限</li><li>用户还可将其拥有的存取权限转授给其他用户</li></ul></li><li>强制存取控制（Mandatory Access Control，简称 MAC）<ul><li>B1级</li><li>每一个数据对象被标以一定的密级</li><li>每一个用户也被授予某一个级别的许可证</li><li>对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul></li></ul></li></ul><h3 id="自助存取控制方法">自助存取控制方法</h3><ul><li>通过 SQL 的GRANT 语句和REVOKE 语句实现</li><li>用户权限组成<ul><li>数据对象</li><li>操作类型</li></ul></li><li>定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作</li><li>定义存取权限称为授权</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/1610873768501.jpg" alt="在这里插入图片描述"></p><h3 id="授权与回收">授权与回收</h3><h4 id="GRANT">GRANT</h4><ul><li><p>GRANT语句的一般格式：<br>GRANT &lt;权限&gt;[,&lt;权限&gt;]…<br>ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]…<br>TO &lt;用户&gt;[,&lt;用户&gt;]…<br>[WITH GRANT OPTION];</p></li><li><p>语义：将对指定操作对象的指定操作权限授予指定的用户</p></li><li><p>发出GRANT：</p><ul><li>数据库管理员</li><li>数据库对象创建者（即属主Owner）</li><li>拥有该权限的用户</li></ul></li><li><p>按受权限的用户</p><ul><li>一个或多个具体用户</li><li>PUBLIC（即全体用户）</li></ul></li><li><p>WITH GRANT OPTION子句:</p><ul><li>指定：可以再授予</li><li>没有指定：不能传播</li><li>不允许循环授权</li></ul></li><li><p>[例4.1] 把查询Student表权限授给用户U1</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>   <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span>   <span class="keyword">TABLE</span>   Student </span><br><span class="line"><span class="keyword">TO</span>   U1;</span><br></pre></td></tr></table></figure></li><li><p>[例4.2] 把对Student表和Course表的全部权限授予用户U2和U3</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student,Course </span><br><span class="line"><span class="keyword">TO</span> U2,U3;</span><br></pre></td></tr></table></figure></li><li><p>[例4.3] 把对表SC的查询权限授予所有用户</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">TO</span> PUBLIC;</span><br></pre></td></tr></table></figure></li><li><p>[例4.4] 把查询Student表和修改学生学号的权限授给用户U4</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">GRANT</span> UPDATE(Sno), <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">TO</span> U4;</span><br></pre></td></tr></table></figure><p>对属性列的授权时必须明确指出相应属性列名</p></li><li><p>[例4.5] 把对表SC的INSERT权限授予U5用户，并允许他再将此权限授予其他用户</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">TO</span> U5</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure></li><li><p>执行例4.5后，U5不仅拥有了对表SC的INSERT权限，<br>还可以传播此权限：<br>[例4.6]</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">TO</span> U6</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure><p>同样，U6还可以将此权限授予U7：<br>[例4.7]</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">TO</span> U7;</span><br></pre></td></tr></table></figure><p>但U7不能再传播此权限。</p></li></ul><h4 id="REVOKE">REVOKE</h4><ul><li><p>授予的权限可以由数据库管理员或其他授权者用REVOKE语句收回</p></li><li><p>REVOKE语句的一般格式为：<br>REVOKE &lt;权限&gt;[,&lt;权限&gt;]…<br>ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…<br>FROM &lt;用户&gt;[,&lt;用户&gt;]…[CASCADE | RESTRICT];</p></li><li><p>[例4.8] 把用户U4修改学生学号的权限收回</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> UPDATE(Sno)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">FROM</span> U4;</span><br></pre></td></tr></table></figure></li><li><p>[例4.9] 收回所有用户对表SC的查询权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">FROM</span> PUBLIC;</span><br></pre></td></tr></table></figure></li><li><p>[例4.10] 把用户U5对SC表的INSERT权限收回</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC </span><br><span class="line"><span class="keyword">FROM</span> U5 CASCADE ;</span><br></pre></td></tr></table></figure><p>将用户U5的INSERT权限收回的时候应该使用CASCADE，否则拒绝执行该语句<br>如果U6或U7还从其他用户处获得对SC表的INSERT权限，则他们仍具有此权限，系统只收回直接或间接从U5处获得的权限</p></li></ul><h4 id="小结">小结</h4><ul><li>数据库管理员：<ul><li>拥有所有对象的所有权限</li><li>根据实际情况不同的权限授予不同的用户</li></ul></li><li>用户：<ul><li>拥有自己建立的对象的全部的操作权限可以使用GRANT，把权限授予其他用户</li></ul></li><li>被授权的用户<ul><li>如果具有“继续授权”的许可，可以把获得的权限再授予其他用户</li></ul></li><li>所有授予出去的权力在必要时又都可用REVOKE语句收回</li></ul><h4 id="创建数据库模式的权限">创建数据库模式的权限</h4><ul><li>数据库管理员在创建用户时实现<br>CREATE USER语句格式<br>CREATE  USER  &lt;username&gt;<br>[WITH][DBA|RESOURCE|CONNECT];<br>注：<br>CREATE USER不是SQL标准，各个系统的实现相差甚远</li><li>CREATE USER语句格式说明<ul><li>只有系统的超级用户才有权创建一个新的数据库用户</li><li>新创建的数据库用户有三种权限：CONNECT、RESOURCE和DBA</li><li>如没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库</li><li>拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主。但不能创建模式，不能创建新的用户</li><li>拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户</li></ul></li></ul><h3 id="数据库角色">数据库角色</h3><ul><li><p>数据库角色：被命名的一组与数据库操作相关的权限</p><ul><li>角色是权限的集合</li><li>可以为一组具有相同权限的用户创建一个角色</li><li>简化授权的过程</li></ul></li><li><p>角色的创建<br>CREATE  ROLE  &lt;角色名&gt;</p></li><li><p>给角色授权<br>GRANT  &lt;权限&gt;[,&lt;权限&gt;]…<br>ON &lt;对象类型&gt;对象名<br>TO &lt;角色&gt;[,&lt;角色&gt;]…</p></li><li><p>将一个角色授予其他的角色或用户<br>GRANT  &lt;角色1&gt;[,&lt;角色2&gt;]…<br>TO  &lt;角色3&gt;[,&lt;用户1&gt;]…<br>[WITH ADMIN OPTION]</p><ul><li>该语句把角色授予某用户，或授予另一个角色</li><li>予者是角色的创建者或拥有在这个角色上的ADMIN OPTION</li><li>指定了WITH ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色</li><li>一个角色的权限：直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限</li></ul></li><li><p>角色权限的收回<br>REVOKE &lt;权限&gt;[,&lt;权限&gt;]…<br>ON &lt;对象类型&gt; &lt;对象名&gt;<br>FROM &lt;角色&gt;[,&lt;角色&gt;]…</p><ul><li>用户可以回收角色的权限，从而修改角色拥有的权限</li><li>REVOKE执行者<ul><li>角色的创建者</li><li>拥有在这个（些）角色上的ADMIN OPTION</li></ul></li></ul></li><li><p>[例4.11] 通过角色来实现将一组权限授予一个用户。<br>步骤如下：<br>（1）首先创建一个角色 R1</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  ROLE  R1;</span><br></pre></td></tr></table></figure><p>（2）然后使用GRANT语句，使角色R1拥有Student表的SELECT、UPDATE、INSERT权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, UPDATE, <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">TO</span> R1;</span><br></pre></td></tr></table></figure><p>（3）将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>  R1 </span><br><span class="line"><span class="keyword">TO</span> 王平,张明,赵玲;</span><br></pre></td></tr></table></figure><p>（4） 可以一次性通过R1来回收王平的这3个权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span>  R1 </span><br><span class="line"><span class="keyword">FROM</span> 王平;</span><br></pre></td></tr></table></figure></li><li><p>[例4.12] 角色的权限修改</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> R1;</span><br></pre></td></tr></table></figure><p>使角色R1在原来的基础上增加了Student表的DELETE 权限</p></li><li><p>[例4.13]</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">  <span class="keyword">FROM</span>  R1；</span><br></pre></td></tr></table></figure><p>使R1减少了SELECT权限</p></li></ul><h3 id="强制存取控制方法">强制存取控制方法</h3><h4 id="自主存取控制缺点">自主存取控制缺点</h4><ul><li>可能存在数据的“无意泄露”</li><li>原因：这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记</li><li>解决：对系统控制下的所有主客体实施强制存取控制策略</li></ul><h4 id="强制存取控制（MAC）">强制存取控制（MAC）</h4><ul><li><p>保证更高程度的安全性</p></li><li><p>用户不能直接感知或进行控制</p></li><li><p>适用于对数据有严格而固定密级分类的部门</p><ul><li>军事部门</li><li>政府部门</li></ul></li><li><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</p></li><li><p>主体是系统中的活动实体</p><ul><li>数据库管理系统所管理的实际用户</li><li>代表用户的各进程</li></ul></li><li><p>客体是系统中的被动实体，受主体操纵</p><ul><li>文件、基本表、索引、视图</li></ul></li><li><p>敏感度标记（Label）</p><ul><li>对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label）</li><li>敏感度标记分成若干级别<ul><li>绝密（Top Secret，TS）</li><li>机密（Secret，S）</li><li>可信（Confidential，C）</li><li>公开（Public，P）</li><li>TS&gt;=S&gt;=C&gt;=P</li></ul></li></ul></li><li><p>主体的敏感度标记称为许可证级别（Clearance Level）</p></li><li><p>客体的敏感度标记称为密级（Classification Level）</p></li><li><p>强制存取控制规则<br>（1）仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体<br>（2）仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体</p></li><li><p>强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。</p></li><li><p>实现强制存取控制时要首先实现自主存取控制</p><ul><li>原因：较高安全性级别提供的安全保护要包含较低级别的所有保护</li></ul></li><li><p>自主存取控制与强制存取控制共同构成数据库管理系统的安全机制</p></li></ul><h2 id="视图机制">视图机制</h2><ul><li><p>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护</p></li><li><p>间接地实现支持存取谓词的用户权限定义</p></li><li><p>[例4.14] 建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">先建立计算机系学生的视图CS_Student</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CS_Student</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>   Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"></span><br><span class="line">在视图上进一步定义存取权限</span><br><span class="line"><span class="keyword">GRANT</span>  <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span>  CS_Student  </span><br><span class="line"><span class="keyword">TO</span> 王平;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES</span><br><span class="line"><span class="keyword">ON</span>  CS_Student  </span><br><span class="line"><span class="keyword">TO</span>  张明; </span><br></pre></td></tr></table></figure></li></ul><h2 id="审计">审计</h2><ul><li><p>什么是审计</p><ul><li>启用一个专用的审计日志（Audit Log）<br>将用户对数据库的所有操作记录在上面</li><li>审计员利用审计日志<br>监控数据库中的各种行为，找出非法存取数据的人、时间和内容</li><li>C2以上安全级别的DBMS必须具有审计功能</li></ul></li><li><p>审计功能的可选性</p><ul><li>审计很费时间和空间</li><li>DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能</li><li>审计功能主要用于安全性要求较高的部门</li></ul></li><li><p>审计事件</p><ul><li>服务器事件<br>审计数据库服务器发生的事件</li><li>系统权限<br>对系统拥有的结构或模式对象进行操作的审计<br>要求该操作的权限是通过系统权限获得的</li><li>语句事件<br>对SQL语句，如DDL、DML、DQL及DCL语句的审计</li><li>模式对象事件<br>对特定模式对象上进行的SELECT或DML操作的审计</li></ul></li><li><p>审计功能</p><ul><li>基本功能<ul><li>提供多种审计查阅方式提供多种审计查阅方式</li></ul></li><li>多套审计规则：一般在初始化设定</li><li>提供审计分析和报表功能</li><li>审计日志管理功能<ul><li>防止审计员误删审计记录，审计日志必须先转储后删除</li><li>对转储的审计记录文件提供完整性和保密性保护</li><li>只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录等</li></ul></li><li>提供查询审计设置及审计记录信息的专门视图</li></ul></li><li><p>AUDIT语句和NOAUDIT语句</p><ul><li>AUDIT语句：设置审计功能</li><li>NOAUDIT语句：取消审计功能</li></ul></li><li><p>用户级审计</p><ul><li>任何用户可设置的审计</li><li>主要是用户针对自己创建的数据库表和视图进行审计</li></ul></li><li><p>系统级审计</p><ul><li>只能由数据库管理员设置</li><li>监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作</li></ul></li><li><p>[例4.15] 对修改SC表结构或修改SC表数据的操作进行审计<br>AUDIT ALTER,UPDATE<br>ON  SC;</p></li><li><p>[例4.16] 取消对SC表的一切审计<br>NOAUDIT  ALTER,UPDATE<br>ON  SC;</p></li></ul><h2 id="数据加密">数据加密</h2><ul><li>防止数据库中数据在存储和传输中失密的有效手段</li><li>加密的基本思想</li><li>根据一定的算法将原始数据—明文（Plain text）变换为不可直接识别的格式­—密文（Cipher text）</li><li>加密方法<ul><li>存储加密</li><li>传输加密</li></ul></li></ul><h3 id="存储加密">存储加密</h3><ul><li>透明存储加密<ul><li>内核级加密保护方式，对用户完全透明</li><li>将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密</li><li>数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可<br>内核级加密方法: 性能较好，安全完备性较高</li></ul></li><li>非透明存储加密<ul><li>通过多个加密函数实现</li></ul></li></ul><h3 id="传输加密">传输加密</h3><ul><li>链路加密<ul><li>在链路层进行加密</li><li>传输信息由报头和报文两部分组成</li><li>报文和报头均加密</li></ul></li><li>端到端加密<ul><li>在发送端加密，接收端解密</li><li>只加密报文不加密报头</li><li>所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息</li></ul></li></ul><h3 id="基于安全套接层协议SSL传输方案的实现思路：">基于安全套接层协议SSL传输方案的实现思路：</h3><p>（1）确认通信双方端点的可靠性</p><ul><li>采用基于数字证书的服务器和客户端认证方式</li><li>通信时均首先向对方提供己方证书，然后使用本地的CA 信任列表和证书撤销列表对接收到的对方证书进行验证</li></ul><p>（2）协商加密算法和密钥</p><ul><li>确认双方端点的可靠性后，通信双方协商本次会话的加密算法与密钥</li></ul><p>（3）可信数据传输</p><ul><li>业务数据在被发送之前将被用某一组特定的密钥进行加密和消息摘要计算，以密文形式在网络上传输</li><li>当业务数据被接收的时候，需用相同一组特定的密钥进行解密和摘要计算</li></ul><h2 id="其他安全性保护">其他安全性保护</h2><ul><li><p>推理控制</p><ul><li>处理强制存取控制未解决的问题</li><li>避免用户利用能够访问的数据推知更高密级的数据</li><li>常用方法<ul><li>基于函数依赖的推理控制</li><li>基于敏感关联的推理控制</li></ul></li></ul></li><li><p>隐蔽信道</p><ul><li>处理强制存取控制未解决的问题</li></ul></li><li><p>数据隐私保护</p><ul><li>描述个人控制其不愿他人知道或他人不便知道的个人数据的能力</li><li>范围很广：数据收集、数据存储、数据处理和数据发布等各个阶段</li></ul></li></ul><h2 id="小结-2">小结</h2><ul><li><p>数据的共享日益加强，数据的安全保密越来越重要。</p></li><li><p>数据库管理系统是管理数据的核心，因而其自身必须具有一整套完整而有效的安全性机制。</p></li><li><p>实现数据库系统安全性的技术和方法</p><ul><li>用户身份鉴别</li><li>存取控制技术：自主存取控制和强制存取控制</li><li>视图技术</li><li>审计技术</li><li>数据加密存储和加密传输</li></ul></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统 | 第三章 关系数据库标准语言SQL</title>
      <link href="2021/01/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL/"/>
      <url>2021/01/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL功能极强，完成核心功能只用了9个动词。">SQL功能极强，完成核心功能只用了9个动词。</h2><table><thead><tr><th>SQL功能</th><th>动词</th></tr></thead><tbody><tr><td>数据查询</td><td>SELECT</td></tr><tr><td>数据定义</td><td>CREATE,DROP,ALTER</td></tr><tr><td>数据操纵</td><td>INSERT,UPDATE,DELETE</td></tr><tr><td>数据控制</td><td>GRANT,REVOKE</td></tr></tbody></table><h2 id="SQL基本概念">SQL基本概念</h2><ul><li><p>基本表</p><ul><li>本身独立存在的表</li><li>SQL中一个关系就对应一个基本表</li><li>一个（或多个）基本表对应一个存储文件</li><li>一个表可以带若干索引</li></ul></li><li><p>存储文件</p><ul><li>逻辑结构组成了关系数据库的内模式</li><li>物理结构对用户是隐蔽的</li></ul></li><li><p>视图</p><ul><li>从一个或几个基本表导出的表</li><li>数据库中只存放视图的定义而不存放视图对应的数据</li><li>视图是一个虚表</li><li>用户可以在视图上再定义视图</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/1610805980082.jpg" alt="在这里插入图片描述"></p><h2 id="定义模式">定义模式</h2><ul><li><p>[例3.1] 为用户WANG定义一个学生-课程模式S-T</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA “S<span class="operator">-</span>T” <span class="keyword">AUTHORIZATION</span> WANG;</span><br></pre></td></tr></table></figure></li><li><p>[例3.2] CREATE SCHEMA AUTHORIZATION WANG;<br>该语句没有指定&lt;模式名&gt;，&lt;模式名&gt;隐含为&lt;用户名&gt;</p></li><li><p>[例3.3]为用户ZHANG创建了一个模式TEST，并且在其中定义一个表TAB1</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA TEST <span class="keyword">AUTHORIZATION</span> ZHANG </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TAB1   ( COL1 <span class="type">SMALLINT</span>, </span><br><span class="line">                      COL2 <span class="type">INT</span>,</span><br><span class="line">                      COL3 <span class="type">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">                      COL4 <span class="type">NUMERIC</span>(<span class="number">10</span>,<span class="number">3</span>),</span><br><span class="line">                      COL5 <span class="type">DECIMAL</span>(<span class="number">5</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure></li></ul><h2 id="删除模式">删除模式</h2><ul><li><p>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</p><ul><li>CASCADE（级联）<ul><li>删除模式的同时把该模式中所有的数据库对象全部删除</li></ul></li><li>RESTRICT（限制）<ul><li>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。</li><li>仅当该模式中没有任何下属的对象时才能执行。</li></ul></li></ul></li><li><p>[例3.4]</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA ZHANG CASCADE;</span><br></pre></td></tr></table></figure><p>删除模式ZHANG<br>同时该模式中定义的表TAB1也被删除</p><h2 id="基本表的定义、删除与修改">基本表的定义、删除与修改</h2><h3 id="定义基本表">定义基本表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">      (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[ <span class="operator">&lt;</span>列级完整性约束条件<span class="operator">&gt;</span> ]</span><br><span class="line">      [,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[ <span class="operator">&lt;</span>列级完整性约束条件<span class="operator">&gt;</span>] ] </span><br><span class="line">   …</span><br><span class="line">      [,<span class="operator">&lt;</span>表级完整性约束条件<span class="operator">&gt;</span> ] );</span><br></pre></td></tr></table></figure><ul><li><p>&lt;表名&gt;：所要定义的基本表的名字</p></li><li><p>&lt;列名&gt;：组成该表的各个属性（列）</p></li><li><p>&lt;列级完整性约束条件&gt;：涉及相应属性列的完整性约束条件</p></li><li><p>&lt;表级完整性约束条件&gt;：涉及一个或多个属性列的完整性约束条件</p></li><li><p>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。</p></li><li><p>[例3.5]  建立“学生”表Student。学号是主码，姓名取值唯一。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student          </span><br><span class="line">      (Sno   <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY,      <span class="comment">/* 列级完整性约束条件,Sno是主码*/</span>                  </span><br><span class="line">        Sname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,             <span class="comment">/* Sname取唯一值*/</span></span><br><span class="line">        Ssex    <span class="type">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">        Sage   <span class="type">SMALLINT</span>,</span><br><span class="line">        Sdept  <span class="type">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">      ); </span><br></pre></td></tr></table></figure></li><li><p>[例3.6 ] 建立一个“课程”表Course</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  Course</span><br><span class="line">         (Cno       <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">        Cname  <span class="type">CHAR</span>(<span class="number">40</span>),            </span><br><span class="line">         Cpno     <span class="type">CHAR</span>(<span class="number">4</span>),                                     </span><br><span class="line">           Ccredit  <span class="type">SMALLINT</span>，</span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Cpno) <span class="keyword">REFERENCES</span>  Course(Cno) </span><br><span class="line">         ); </span><br></pre></td></tr></table></figure></li><li><p>[例3.7]  建立一个学生选课表SC</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  SC</span><br><span class="line">          (Sno  <span class="type">CHAR</span>(<span class="number">9</span>), </span><br><span class="line">           Cno  <span class="type">CHAR</span>(<span class="number">4</span>),  </span><br><span class="line">           Grade  <span class="type">SMALLINT</span>，</span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY (Sno,Cno),  </span><br><span class="line">                          <span class="comment">/* 主码由两个属性构成，必须作为表级完整性进行定义*/</span></span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line">                         <span class="comment">/* 表级完整性约束条件，Sno是外码，被参照表是Student */</span></span><br><span class="line">           <span class="keyword">FOREIGN</span> KEY (Cno)<span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">                          <span class="comment">/* 表级完整性约束条件， Cno是外码，被参照表是Course*/</span></span><br><span class="line">        ); </span><br></pre></td></tr></table></figure></li></ul><h3 id="修改基本表">修改基本表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [ 完整性约束 ] ]</span><br><span class="line">[ <span class="keyword">ADD</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[ <span class="keyword">DROP</span> [ <span class="keyword">COLUMN</span> ] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span> RESTRICT] ]</span><br><span class="line">[ <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span>[ RESTRICT <span class="operator">|</span> CASCADE ] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> ] ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>&lt;表名&gt;是要修改的基本表</p></li><li><p>ADD子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件</p></li><li><p>DROP COLUMN子句用于删除表中的列</p><ul><li>如果指定了CASCADE短语，则自动删除引用了该列的其他对象</li><li>如果指定了RESTRICT短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列</li></ul></li><li><p>DROP CONSTRAINT子句用于删除指定的完整性约束条件</p></li><li><p>ALTER COLUMN子句用于修改原有的列定义，包括修改列名和数据类型</p></li><li><p>[例3.8] 向Student表增加“入学时间”列，其数据类型为日期型</p><p>​     ALTER TABLE Student ADD S_entrance DATE;</p><p>不管基本表中原来是否已有数据，新增加的列一律为空值</p></li><li><p>[例3.9] 将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。<br>ALTER TABLE Student ALTER COLUMN Sage INT;</p></li><li><p>[例3.10] 增加课程名称必须取唯一值的约束条件。<br>ALTER TABLE Course ADD UNIQUE(Cname);</p></li></ul><h3 id="删除基本表">删除基本表</h3><ul><li><p>[例3.11]  删除Student表<br>DROP TABLE  Student  CASCADE;<br>基本表定义被删除，数据被删除<br>表上建立的索引、视图、触发器等一般也将被删除</p></li><li><p>[例3.12 ]若表上建有视图，选择RESTRICT时表不能删除;选择CASCADE时可以删除表，视图也自动删除。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student      </span><br><span class="line">   <span class="keyword">AS</span> </span><br><span class="line">    <span class="keyword">SELECT</span> Sno,Sname,Sage</span><br><span class="line">    <span class="keyword">FROM</span>  Student</span><br><span class="line">       <span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;IS&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">DROP</span> <span class="keyword">TABLE</span> Student RESTRICT;   </span><br><span class="line"><span class="comment">--ERROR: cannot drop table Student because other objects depend on it</span></span><br></pre></td></tr></table></figure></li><li><p>[例3.12续]如果选择CASCADE时可以删除表，视图也自动被删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> Student CASCADE;     </span><br><span class="line"> <span class="comment">--NOTICE: drop cascades to view IS_Student</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> IS_Student;</span><br><span class="line"><span class="comment">--ERROR: relation &quot; IS_Student &quot; does not exist </span></span><br></pre></td></tr></table></figure></li></ul><h2 id="数据类型">数据类型</h2><table><thead><tr><th><strong>数据类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>CHAR</strong></td><td><strong>长度为n的定长字符串</strong></td></tr><tr><td><strong>VARCHAR</strong></td><td><strong>最大长度为n的变长字符串</strong></td></tr><tr><td><strong>CLOB</strong></td><td><strong>字符串大对象</strong></td></tr><tr><td><strong>BLOB</strong></td><td><strong>二进制大对象</strong></td></tr><tr><td><strong>INT</strong>，<strong>INTEGER</strong></td><td><strong>长整数</strong></td></tr><tr><td><strong>SMALLINT</strong></td><td><strong>短整数</strong></td></tr><tr><td><strong>BIGINT</strong></td><td><strong>大整数</strong></td></tr><tr><td><strong>NUMERIC</strong></td><td><strong>定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字</strong></td></tr><tr><td><strong>DECIMAL</strong></td><td><strong>同NUMERIC</strong></td></tr><tr><td><strong>REAL</strong></td><td><strong>取决于机器精度的单精度浮点数</strong></td></tr><tr><td><strong>DOUBLE PRECISION</strong></td><td><strong>取决于机器精度的双精度浮点数</strong></td></tr><tr><td><strong>FLOAT</strong></td><td><strong>可选精度的浮点数，精度至少为n位数字</strong></td></tr><tr><td><strong>BOOLEAN</strong></td><td><strong>逻辑布尔量</strong></td></tr><tr><td><strong>DATE</strong></td><td><strong>日期，包含年、月、日，格式为YYYY-MM-DD</strong></td></tr><tr><td><strong>TIME</strong></td><td><strong>时间，包含一日的时、分、秒，格式为HH:MM:SS</strong></td></tr><tr><td><strong>TIMESTAMP</strong></td><td><strong>时间戳类型</strong></td></tr><tr><td><strong>INTERVAL</strong></td><td><strong>时间间隔类型</strong></td></tr></tbody></table><h2 id="模式与表">模式与表</h2><ul><li><p>每一个基本表都属于某一个模式</p></li><li><p>一个模式包含多个基本表</p></li><li><p>定义基本表所属模式</p><ul><li>方法一：在表名中明显地给出模式名<br>Create table&quot;S-T&quot;.Student(…);     /<em>模式名为 S-T</em>/<br>Create table “S-T”.Cource(…);<br>Create table “S-T”.SC(…);</li><li>方法二：在创建模式语句中同时创建表</li><li>方法三：设置所属的模式</li></ul></li><li><p>创建基本表（其他数据库对象也一样）时，若没有指定模式，系统根据搜索路径来确定该对象所属的模式</p></li><li><p>关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名</p></li><li><p>若搜索路径中的模式名都不存在，系统将给出错误</p><ul><li>显示当前的搜索路径： SHOW search_path;</li><li>搜索路径的当前默认值是：$user， PUBLIC</li></ul></li><li><p>数据库管理员用户可以设置搜索路径，然后定义基本表<br>SET search_path TO “S-T”,PUBLIC;<br>Create table Student(…);<br>结果建立了S-T.Student基本表。<br>关系数据库管理系统发现搜索路径中第一个模式名S-T，<br>就把该模式作为基本表Student所属的模式。</p></li></ul><h2 id="索引的建立与删除">索引的建立与删除</h2><ul><li><p>建立索引的目的：加快查询速度</p></li><li><p>关系数据库管理系统中常见索引：</p><ul><li>顺序文件上的索引</li><li>B+树索引（参见爱课程网3.2节动画《B+树的增删改》）</li><li>散列（hash）索引</li><li>位图索引</li></ul></li><li><p>特点：</p><ul><li>B+树索引具有动态平衡的优点</li><li>HASH索引具有查找速度快的特点</li></ul></li><li><p>谁可以建立索引<br>数据库管理员 或 表的属主（即建立表的人）</p></li><li><p>谁维护索引<br>关系数据库管理系统自动完成</p></li><li><p>使用索引<br>关系数据库管理系统自动选择合适的索引作为存取路径，用户不必也不能显式地选择索引</p></li></ul><h3 id="建立索引">建立索引</h3><ul><li><p>语句格式<br>CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;<br>ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…);</p><ul><li>&lt;表名&gt;：要建索引的基本表的名字</li><li>索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔</li><li>&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省值：ASC</li><li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录</li><li>CLUSTER：表示要建立的索引是聚簇索引</li></ul></li><li><p>[例3.13] 为学生-课程数据库中的Student，Course，SC三个表建立索引。Student表按学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建唯一索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX  Stusno <span class="keyword">ON</span> Student(Sno);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX  Coucno <span class="keyword">ON</span> Course(Cno);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX  SCno <span class="keyword">ON</span> SC(Sno <span class="keyword">ASC</span>,Cno <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改索引">修改索引</h3><ul><li><p>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;<br>[例3.14] 将SC表的SCno索引名改为SCSno</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> INDEX SCno RENAME <span class="keyword">TO</span> SCSno;</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除索引">删除索引</h3><ul><li><p>DROP INDEX &lt;索引名&gt;;<br>删除索引时，系统会从数据字典中删去有关该索引的<br>描述。<br>[例3.15]  删除Student表的Stusname索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX Stusname;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据字典">数据字典</h2><ul><li>数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息：<ul><li>关系模式定义</li><li>视图定义</li><li>索引定义</li><li>完整性约束定义</li><li>各类用户对数据库的操作权限</li><li>统计信息等</li></ul></li><li>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。</li></ul><h2 id="数据查询">数据查询</h2><ul><li>语句格式</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>] …</span><br><span class="line">       <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> ]…<span class="operator">|</span>(<span class="keyword">SELECT</span> 语句)      </span><br><span class="line">                   [<span class="keyword">AS</span>]<span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [ <span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [ <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></table></figure><ul><li>SELECT子句：指定要显示的属性列</li><li>FROM子句：指定查询对象（基本表或视图）</li><li>WHERE子句：指定查询条件</li><li>GROUP BY子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。</li><li>HAVING短语：只有满足指定条件的组才予以输出</li><li>ORDER BY子句：对查询结果表按指定列值的升序或降序排序</li></ul><h3 id="单表查询">单表查询</h3><ul><li><p>查询指定列</p></li><li><p>[例3.16]  查询全体学生的学号与姓名。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname <span class="keyword">FROM</span> Student; </span><br></pre></td></tr></table></figure></li><li><p>[例3.17]  查询全体学生的姓名、学号、所在系。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sno,Sdept <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure></li><li><p>查询全部列<br>选出所有属性列：<br>在SELECT关键字后面列出所有列名<br>将&lt;目标列表达式&gt;指定为  *</p></li><li><p>[例3.18]  查询全体学生的详细记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Sno,Sname,Ssex,Sage,Sdept </span><br><span class="line"><span class="keyword">FROM</span> Student; </span><br><span class="line">或</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student; </span><br></pre></td></tr></table></figure></li><li><p>查询经过计算的值<br>SELECT子句的&lt;目标列表达式&gt;不仅可以为表中的属性列，也可以是表达式</p></li><li><p>[例3.19]  查全体学生的姓名及其出生年份。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,<span class="number">2014</span><span class="operator">-</span>Sage          <span class="comment">/*假设当时为2014年*/</span></span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p>输出结果：<br>Sname   2014-Sage<br>李勇         1994<br>刘晨         1995<br>王敏         1996<br>张立         1995</p></li><li><p>[例3.20] 查询全体学生的姓名、出生年份和所在的院系，要求用小写字母表示系名。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,<span class="string">&#x27;Year of Birth: &#x27;</span>,<span class="number">2014</span><span class="operator">-</span>Sage,<span class="built_in">LOWER</span>(Sdept)</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p>输出结果：<br>Sname   ‘Year of Birth:’  2014-Sage   LOWER(Sdept)</p><p>​      李勇    Year of Birth:    1994       cs<br>​      刘晨    Year of Birth:    1995       cs<br>​      王敏    Year of Birth:    1996       ma<br>​      张立    Year of Birth:    1995      is</p></li><li><p>使用列别名改变查询结果的列标题:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname NAME,<span class="string">&#x27;Year of Birth:&#x27;</span>  BIRTH,</span><br><span class="line"><span class="number">2014</span><span class="operator">-</span>Sage  BIRTHDAY,<span class="built_in">LOWER</span>(Sdept)  DEPARTMENT</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p>输出结果：<br>NAME      BIRTH         BIRTHDAY   DEPARTMENT</p><p>​     李勇    Year of Birth:    1994             cs<br>​     刘晨    Year of Birth:    1995             cs<br>​     王敏    Year of Birth:    1996             ma<br>​     张立    Year of Birth:    1995             is</p></li><li><p>消除取值重复的行<br>如果没有指定DISTINCT关键词，则缺省为ALL<br>[例3.21]  查询选修了课程的学生学号。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno   <span class="keyword">FROM</span> SC;</span><br><span class="line">等价于：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ALL</span>  Sno  <span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p>​执行上面的SELECT语句后，结果为：<br>​    Sno</p><p>​201215121<br>​201215121<br>​201215121<br>​201215122<br>​201215122</p></li><li><p>指定DISTINCT关键词，去掉表中重复的行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"> <span class="keyword">FROM</span> SC; </span><br></pre></td></tr></table></figure><p>执行结果：<br>Sno</p><p>​201215121<br>​201215122</p></li></ul><h4 id="常用查询条件">常用查询条件</h4><table><thead><tr><th><strong>查 询 条 件</strong></th><th><strong>谓  词</strong></th></tr></thead><tbody><tr><td><strong>比  较</strong></td><td><strong>=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;; NOT+上述比较运算符</strong></td></tr><tr><td><strong>确定范围</strong></td><td><strong>BETWEEN AND, NOT BETWEEN AND</strong></td></tr><tr><td><strong>确定集合</strong></td><td><strong>IN, NOT IN</strong></td></tr><tr><td><strong>字符匹配</strong></td><td><strong>LIKE, NOT LIKE</strong></td></tr><tr><td><strong>空  值</strong></td><td><strong>IS NULL, IS NOT NULL</strong></td></tr><tr><td><strong>多重条件（逻辑运算）</strong></td><td><strong>AND, OR, NOT</strong></td></tr></tbody></table><h4 id="比较大小">比较大小</h4><ul><li><p>[例3.22] 查询计算机科学系全体学生的名单。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span>‘CS’; </span><br></pre></td></tr></table></figure></li><li><p>[例3.23]查询所有年龄在20岁以下的学生姓名及其年龄。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage </span><br><span class="line"> <span class="keyword">FROM</span>     Student    </span><br><span class="line"> <span class="keyword">WHERE</span>  Sage <span class="operator">&lt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.24]查询考试成绩有不及格的学生的学号。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sn</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade<span class="operator">&lt;</span><span class="number">60</span>; </span><br></pre></td></tr></table></figure></li></ul><h4 id="确定范围">确定范围</h4><ul><li><p>谓词:   BETWEEN …  AND  …<br>NOT BETWEEN  …  AND  …</p></li><li><p>[例3.25] 查询年龄在20~23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Sdept, Sage</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>   Sage <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>; </span><br></pre></td></tr></table></figure></li><li><p>[例3.26]  查询年龄不在20~23岁之间的学生姓名、系别和年龄</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Sdept, Sage</span><br><span class="line"><span class="keyword">FROM</span>    Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>; </span><br></pre></td></tr></table></figure></li></ul><h4 id="确定集合">确定集合</h4><ul><li><p>谓词：IN &lt;值表&gt;,  NOT IN &lt;值表&gt;</p></li><li><p>[例3.27]查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Ssex</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span> (<span class="string">&#x27;CS&#x27;</span>,<span class="string">&#x27;MA’,&#x27;</span><span class="keyword">IS</span><span class="string">&#x27; );</span></span><br></pre></td></tr></table></figure></li><li><p>[例3.28]查询既不是计算机科学系、数学系，也不是信息系的学生的姓名和性别。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;IS&#x27;</span>,<span class="string">&#x27;MA’,&#x27;</span>CS<span class="string">&#x27; );</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="字符匹配">字符匹配</h4><ul><li><p>谓词： [NOT] LIKE  ‘&lt;匹配串&gt;’  [ESCAPE ‘ &lt;换码字符&gt;’]</p><ul><li><p>&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和 _</p></li><li><p>% （百分号）  代表任意长度（长度可以为0）的字符串<br>例如a%b表示以a开头，以b结尾的任意长度的字符串</p></li><li><p>_ （下横线）  代表任意单个字符。<br>例如a_b表示以a开头，以b结尾的长度为3的任意字符串</p></li></ul></li><li><p>匹配串为固定字符串</p></li><li><p>[例3.29]  查询学号为201215121的学生的详细情况。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>    </span><br><span class="line"><span class="keyword">FROM</span>  Student  </span><br><span class="line"><span class="keyword">WHERE</span>  Sno <span class="keyword">LIKE</span> ‘<span class="number">201215121</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#等价于： </span></span><br><span class="line"><span class="string">SELECT  * </span></span><br><span class="line"><span class="string">FROM  Student </span></span><br><span class="line"><span class="string">WHERE Sno = &#x27;</span> <span class="number">201215121</span> <span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure></li><li><p>匹配串为含通配符的字符串</p></li><li><p>[例3.30]  查询所有姓刘学生的姓名、学号和性别。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Sno, Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sname <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.31]  查询姓&quot;欧阳&quot;且全名为三个汉字的学生的姓名。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span>   Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sname <span class="keyword">LIKE</span> <span class="string">&#x27;欧阳__&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.32]  查询名字中第2个字为&quot;阳&quot;字的学生的姓名和学号。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname，Sno</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sname <span class="keyword">LIKE</span> <span class="string">&#x27;__阳%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.33]  查询所有不姓刘的学生姓名、学号和性别。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Sno, Ssex</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用换码字符将通配符转义为普通字符</p></li><li><p>[例3.34]  查询DB_Design课程的课程号和学分。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cno，Ccredit</span><br><span class="line"><span class="keyword">FROM</span>     Course</span><br><span class="line"><span class="keyword">WHERE</span>  Cname <span class="keyword">LIKE</span> <span class="string">&#x27;DB\_Design&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\ &#x27;</span> ;</span><br></pre></td></tr></table></figure></li><li><p>[例3.35]  查询以&quot;DB_&quot;开头，且倒数第3个字符为 i的课程的详细情况。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>    Course</span><br><span class="line"><span class="keyword">WHERE</span>  Cname <span class="keyword">LIKE</span>  <span class="string">&#x27;DB\_%i_ _&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\ &#x27;</span> ;</span><br><span class="line"><span class="keyword">ESCAPE</span> <span class="string">&#x27;＼&#x27;</span> 表示“ ＼” 为换码字符</span><br></pre></td></tr></table></figure></li></ul><h4 id="涉及空值的查询">涉及空值的查询</h4><ul><li><p>谓词： IS NULL 或 IS NOT NULL</p><ul><li>“IS” 不能用 “=” 代替</li></ul></li><li><p>[例3.36]  某些学生选修课程后没有参加考试，所以有选课记录，但没 有考试成绩。查询缺少成绩的学生的学号和相应的课程号。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno，Cno</span><br><span class="line"><span class="keyword">FROM</span>    SC</span><br><span class="line"><span class="keyword">WHERE</span>  Grade <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li><li><p>[例3.37]  查所有有成绩的学生学号和课程号。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno，Cno</span><br><span class="line"><span class="keyword">FROM</span>     SC</span><br><span class="line"><span class="keyword">WHERE</span>  Grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="多重条件查询">多重条件查询</h4><ul><li><p>逻辑运算符：AND和 OR来连接多个查询条件</p><ul><li>AND的优先级高于OR</li><li>可以用括号改变优先级</li></ul></li><li><p>[例3.38]  查询计算机系年龄在20岁以下的学生姓名。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">AND</span> Sage<span class="operator">&lt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>改写[例3.27]<br>[例3.27]  查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Ssex</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept <span class="keyword">IN</span> (<span class="string">&#x27;CS &#x27;</span>,<span class="string">&#x27;MA &#x27;</span>,<span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line">可改写为：</span><br><span class="line"><span class="keyword">SELECT</span> Sname, Ssex</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27; CS&#x27;</span> <span class="keyword">OR</span> Sdept<span class="operator">=</span> <span class="string">&#x27; MA&#x27;</span> <span class="keyword">OR</span> Sdept<span class="operator">=</span> <span class="string">&#x27;IS &#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="ORDER-BY-子句">ORDER BY 子句</h4><ul><li><p>ORDER BY子句</p><ul><li>可以按一个或多个属性列排序</li><li>升序：ASC;降序：DESC;缺省值为升序</li></ul></li><li><p>对于空值，排序时显示的次序由具体系统实现来决定</p></li><li><p>[例3.39]查询选修了3号课程的学生的学号及其成绩，查询结果按分数降序排列。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Grade</span><br><span class="line"><span class="keyword">FROM</span>    SC</span><br><span class="line"><span class="keyword">WHERE</span>  Cno<span class="operator">=</span> <span class="string">&#x27; 3 &#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.40]查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Sdept, Sage <span class="keyword">DESC</span>;  </span><br></pre></td></tr></table></figure></li></ul><h4 id="聚集函数">聚集函数</h4><ul><li><p>聚集函数：</p><ul><li>统计元组个数<br>COUNT(*)</li><li>统计一列中值的个数<br>COUNT([DISTINCT|ALL] &lt;列名&gt;)</li><li>计算一列值的总和（此列必须为数值型）<br>SUM([DISTINCT|ALL] &lt;列名&gt;)</li><li>计算一列值的平均值（此列必须为数值型）<br>AVG([DISTINCT|ALL] &lt;列名&gt;)</li><li>求一列中的最大值和最小值<br>MAX([DISTINCT|ALL] &lt;列名&gt;)<br>MIN([DISTINCT|ALL] &lt;列名&gt;)</li></ul></li><li><p>[例3.41]  查询学生总人数。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span>  Student; </span><br></pre></td></tr></table></figure></li><li><p>[例3.42]  查询选修了课程的学生人数。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure></li><li><p>[例3.43]  计算1号课程的学生平均成绩。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span>    SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">&#x27; 1 &#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.44]  查询选修1号课程的学生最高分数。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.45 ] 查询学生201215012选修课程的总学分数。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Ccredit)</span><br><span class="line"><span class="keyword">FROM</span>  SC,Course</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span><span class="string">&#x27;201215012&#x27;</span> <span class="keyword">AND</span> SC.Cno<span class="operator">=</span>Course.Cno; </span><br></pre></td></tr></table></figure></li></ul><h4 id="GROUP-BY子句">GROUP BY子句</h4><ul><li><p>GROUP BY子句分组：</p></li><li><p>细化聚集函数的作用对象</p></li><li><p>如果未对查询结果分组，聚集函数将作用于整个查询结果</p></li><li><p>对查询结果分组后，聚集函数将分别作用于每个组</p></li><li><p>按指定的一列或多列值分组，值相等的为一组</p></li><li><p>[例3.46]  求各个课程号及相应的选课人数。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cno，<span class="built_in">COUNT</span>(Sno)</span><br><span class="line"><span class="keyword">FROM</span>    SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno; </span><br></pre></td></tr></table></figure><p>查询结果可能为：<br>Cno     COUNT(Sno)<br>1             22<br>2             34<br>3             44<br>4             33<br>5             48</p></li><li><p>[例3.47]  查询选修了3门以上课程的学生学号。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span><span class="number">3</span>;   </span><br></pre></td></tr></table></figure></li><li><p>HAVING短语与WHERE子句的区别：</p><ul><li>作用对象不同</li><li>WHERE子句作用于基表或视图，从中选择满足条件的元组</li><li>HAVING短语作用于组，从中选择满足条件的组。</li></ul></li><li><p>[例3.48 ]查询平均成绩大于等于90分的学生学号和平均成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#下面的语句是不对的：</span><br><span class="line">    <span class="keyword">SELECT</span> Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line">    <span class="keyword">FROM</span>  SC</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="built_in">AVG</span>(Grade)<span class="operator">&gt;=</span><span class="number">90</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br><span class="line"></span><br><span class="line">#因为<span class="keyword">WHERE</span>子句中是不能用聚集函数作为条件表达式</span><br><span class="line">#正确的查询语句应该是：</span><br><span class="line">    <span class="keyword">SELECT</span>  Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line">    <span class="keyword">FROM</span>  SC</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line">    <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade)<span class="operator">&gt;=</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure></li><li><p>group by后不可以接别名</p></li><li><p>select 后出现的列，在group by后必须全部出现</p></li><li><p>group by后不能使用where，因为where是在分组之前起作用的，分组后的数据在进行过滤需要使用having</p></li><li><p>group by之前可以使用where过滤数据</p></li></ul><h3 id="连接查询">连接查询</h3><ul><li>连接查询：同时涉及两个以上的表的查询</li><li>连接条件或连接谓词：用来连接两个表的条件<br>一般格式：<ul><li>[&lt;表名1&gt;.]&lt;列名1&gt;  &lt;比较运算符&gt;  [&lt;表名2&gt;.]&lt;列名2&gt;</li><li>[&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;</li></ul></li><li>连接字段：连接谓词中的列名称<ul><li>连接条件中的各连接字段类型必须是可比的，但名字不必相同</li></ul></li></ul><h4 id="等值连接与非等值连接查询">等值连接与非等值连接查询</h4><p>等值连接：连接运算符为=</p><ul><li><p>[例 3.49]  查询每个学生及其选修课程的情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Student.<span class="operator">*</span>, SC.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>     Student, SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno <span class="operator">=</span> SC.Sno;</span><br></pre></td></tr></table></figure></li></ul><h4 id="连接操作的执行过程">连接操作的执行过程</h4><ul><li><p>嵌套循环法（NESTED-LOOP）<br>首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。<br>表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。<br>重复上述操作，直到表1中的全部元组都处理完毕</p></li><li><p>排序合并法（SORT-MERGE）<br>常用于=连接<br>首先按连接属性对表1和表2排序<br>对表1的第一个元组，从头开始扫描表2，顺序查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。当遇到表2中第一条大于表1连接字段值的元组时，对表2的查询不再继续</p><p>找到表1的第二条元组，然后从刚才的中断点处继续顺序扫描表2，查找满足连接条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组。直接遇到表2中大于表1连接字段值的元组时，对表2的查询不再继续<br>重复上述操作，直到表1或表2中的全部元组都处理完毕为止</p></li><li><p>索引连接（INDEX-JOIN）<br>对表2按连接字段建立索引<br>对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组</p></li><li><p>自然连接—等值连接里去掉目标列重复的属性列</p></li><li><p>[例 3.50]  对[例 3.49]用自然连接完成。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>     Student,SC</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno <span class="operator">=</span> SC.Sno;</span><br></pre></td></tr></table></figure></li></ul><h4 id="自身连接">自身连接</h4><ul><li><p>自身连接：一个表与其自己进行连接</p></li><li><p>需要给表起别名以示区别</p></li><li><p>由于所有属性名都是同名属性，因此必须使用别名前缀</p></li><li><p>[例 3.52]查询每一门课的间接先修课（即先修课的先修课）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  FIRST.Cno, SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>, Course  <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> SECOND.Cno;</span><br></pre></td></tr></table></figure></li></ul><h4 id="外连接">外连接</h4><ul><li><p>外连接与普通连接的区别</p><ul><li>普通连接操作只输出满足连接条件的元组</li><li>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</li><li>左外连接<br>列出左边关系中所有的元组</li><li>右外连接<br>列出右边关系中所有的元组</li></ul></li><li><p>[例 3.49]  查询每个学生及其选修课程的情况<br>[例 3. 53] 改写[例 3.49]</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>  Student  <span class="keyword">LEFT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span>    </span><br><span class="line">(Student.Sno<span class="operator">=</span>SC.Sno); </span><br></pre></td></tr></table></figure></li></ul><h4 id="多表连接">多表连接</h4><ul><li><p>多表连接：两个以上的表进行连接</p></li><li><p>[例3.54]查询每个学生的学号、姓名、选修的课程名及成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span>    Student, SC, Course    <span class="comment">/*多表连接*/</span></span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno </span><br><span class="line"><span class="keyword">AND</span> SC.Cno <span class="operator">=</span> Course.Cno;</span><br></pre></td></tr></table></figure></li></ul><h3 id="嵌套查询">嵌套查询</h3><ul><li><p>嵌套查询概述</p><ul><li>一个SELECT-FROM-WHERE语句称为一个查询块</li><li>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname                           <span class="comment">/*外层查询/父查询*/</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span>( <span class="keyword">SELECT</span> Sno        <span class="comment">/*内层查询/子查询*/</span></span><br><span class="line">              <span class="keyword">FROM</span> SC</span><br><span class="line">              <span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">&#x27; 2 &#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>上层的查询块称为外层查询或父查询</p></li><li><p>下层查询块称为内层查询或子查询</p></li><li><p>SQL语言允许多层嵌套查询<br>即一个子查询中还可以嵌套其他子查询</p></li><li><p>子查询的限制<br>不能使用ORDER BY子句</p></li><li><p>不相关子查询：</p><ul><li>子查询的查询条件不依赖于父查询</li><li>由里向外 逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的查找条件。</li></ul></li><li><p>相关子查询：子查询的查询条件依赖于父查询</p><ul><li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表</li><li>然后再取外层表的下一个元组</li><li>重复这一过程，直至外层表全部检查完为止</li></ul></li></ul><h4 id="带IN谓词的子查询">带IN谓词的子查询</h4><ul><li><p>[例 3.55]  查询与“刘晨”在同一个系学习的学生。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept  <span class="keyword">IN</span>(<span class="keyword">SELECT</span> Sdept</span><br><span class="line">                <span class="keyword">FROM</span> Student</span><br><span class="line">                <span class="keyword">WHERE</span> Sname<span class="operator">=</span> <span class="string">&#x27; 刘晨 &#x27;</span>);</span><br><span class="line">#此查询为不相关子查询。</span><br></pre></td></tr></table></figure></li><li><p>用自身连接完成[例 3.55]查询要求</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  S1.Sno, S1.Sname,S1.Sdept</span><br><span class="line"><span class="keyword">FROM</span>     Student S1,Student S2</span><br><span class="line"><span class="keyword">WHERE</span>  S1.Sdept <span class="operator">=</span> S2.Sdept  <span class="keyword">AND</span></span><br><span class="line">S2.Sname <span class="operator">=</span> <span class="string">&#x27;刘晨&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例 3.56]查询选修了课程名为“信息系统”的学生学号和姓名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname                 ③ 最后在Student关系中</span><br><span class="line"><span class="keyword">FROM</span>    Student                          取出Sno和Sname</span><br><span class="line"><span class="keyword">WHERE</span> Sno  <span class="keyword">IN</span></span><br><span class="line">           (<span class="keyword">SELECT</span> Sno                     ② 然后在SC关系中找出选</span><br><span class="line">            <span class="keyword">FROM</span>    SC                         修了<span class="number">3</span>号课程的学生学号</span><br><span class="line">            <span class="keyword">WHERE</span>  Cno <span class="keyword">IN</span></span><br><span class="line">                   (<span class="keyword">SELECT</span> Cno             ① 首先在Course关系中找出</span><br><span class="line">                     <span class="keyword">FROM</span> Course           “信息系统”的课程号，为<span class="number">3</span>号</span><br><span class="line">                     <span class="keyword">WHERE</span> Cname<span class="operator">=</span> <span class="string">&#x27;信息系统&#x27;</span>                      </span><br><span class="line">          )</span><br><span class="line">            );</span><br></pre></td></tr></table></figure></li><li><p>用连接查询实现[例 3.56] ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname</span><br><span class="line"> <span class="keyword">FROM</span>    Student,SC,Course</span><br><span class="line"> <span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno  <span class="keyword">AND</span></span><br><span class="line">                SC.Cno <span class="operator">=</span> Course.Cno <span class="keyword">AND</span></span><br><span class="line">                Course.Cname<span class="operator">=</span><span class="string">&#x27;信息系统&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="带比较运算符的子查询">带比较运算符的子查询</h4><ul><li><p>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt; &gt;）。</p></li><li><p>在[例 3.55]中，由于一个学生只可能在一个系学习，则可以用 = 代替IN ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sdept</span><br><span class="line"><span class="keyword">FROM</span>    Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept   <span class="operator">=</span>(<span class="keyword">SELECT</span> Sdept</span><br><span class="line">               <span class="keyword">FROM</span>    Student</span><br><span class="line">               <span class="keyword">WHERE</span> Sname<span class="operator">=</span> <span class="string">&#x27;刘晨&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>[例 3.57 ]找出每个学生超过他选修课程平均成绩的课程号。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"> <span class="keyword">FROM</span>    SC  x</span><br><span class="line"> <span class="keyword">WHERE</span> Grade <span class="operator">&gt;=</span>(<span class="keyword">SELECT</span> AVG（Grade） #相关子查询</span><br><span class="line">                       <span class="keyword">FROM</span>  SC y</span><br><span class="line">                                <span class="keyword">WHERE</span> y.Sno<span class="operator">=</span>x.Sno);</span><br></pre></td></tr></table></figure></li></ul><h4 id="带ANY-SOME-或ALL谓词的子查询">带ANY(SOME)或ALL谓词的子查询</h4><p>使用ANY或ALL谓词时必须同时使用比较运算<br>语义为：</p><ul><li><p>&gt; ANY大于子查询结果中的某个值</p></li><li><p>&gt; ALL大于子查询结果中的所有值</p></li><li><p>&lt; ANY小于子查询结果中 的某个值</p></li><li><p>&lt; ALL小于子查询结果中的所有值</p></li><li><p>= ANY大于等于子查询结果中的某个值</p></li><li><p>= ALL大于等于子查询结果中的所有值</p></li><li><p>&lt;= ANY小于等于子查询结果中的某个值</p></li><li><p>&lt;= ALL小于等于子查询结果中的所有值</p></li><li><p>= ANY等于子查询结果中的某个值</p></li><li><p>=ALL等于子查询结果中的所有值（通常没有实际意义）</p></li><li><p>!=（或&lt;&gt;）ANY不等于子查询结果中的某个值</p></li><li><p>!=（或&lt;&gt;）ALL不等于子查询结果中的任何一个值</p></li><li><p>[例 3.58]  查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span>    Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="keyword">ANY</span> (<span class="keyword">SELECT</span>  Sage</span><br><span class="line">                                     <span class="keyword">FROM</span>    Student</span><br><span class="line">                                     <span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">&#x27; CS &#x27;</span>)</span><br><span class="line"> <span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span> ‘CS <span class="string">&#x27; ;           /*父查询块中的条件 */</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> 用聚集函数实现[例 3.58] </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"> SELECT Sname,Sage</span></span><br><span class="line"><span class="string"> FROM   Student</span></span><br><span class="line"><span class="string"> WHERE Sage &lt; </span></span><br><span class="line"><span class="string">                         (SELECT MAX（Sage）</span></span><br><span class="line"><span class="string">                           FROM Student</span></span><br><span class="line"><span class="string">                           WHERE Sdept= &#x27;</span>CS <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">   AND Sdept &lt;&gt; &#x27;</span> CS <span class="string">&#x27;;</span></span><br><span class="line"><span class="string">  </span></span><br></pre></td></tr></table></figure></li><li><p>[例 3.59]  查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名及年龄。</p><p>方法一：用ALL谓词</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="keyword">ALL</span></span><br><span class="line">                       (<span class="keyword">SELECT</span> Sage</span><br><span class="line">                        <span class="keyword">FROM</span> Student</span><br><span class="line">                        <span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">&#x27; CS &#x27;</span>)</span><br><span class="line">  <span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span> <span class="string">&#x27; CS ’;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">   方法二：用聚集函数</span></span><br><span class="line"><span class="string">    SELECT Sname,Sage</span></span><br><span class="line"><span class="string">    FROM Student</span></span><br><span class="line"><span class="string">    WHERE Sage &lt; </span></span><br><span class="line"><span class="string">                           (SELECT MIN(Sage)</span></span><br><span class="line"><span class="string">                            FROM Student</span></span><br><span class="line"><span class="string">                            WHERE Sdept= &#x27;</span> CS <span class="string">&#x27;)</span></span><br><span class="line"><span class="string">      AND Sdept &lt;&gt;&#x27;</span> CS <span class="string">&#x27;;</span></span><br><span class="line"><span class="string">  </span></span><br></pre></td></tr></table></figure></li></ul><h4 id="带EXISTS谓词的子查询">带EXISTS谓词的子查询</h4><ul><li><p>EXISTS谓词</p><ul><li>存在量词 </li><li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。<ul><li>若内层查询结果非空，则外层的WHERE子句返回真值</li><li>若内层查询结果为空，则外层的WHERE子句返回假值</li></ul></li><li>由EXISTS引出的子查询，其目标列表达式通常都用 * ，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义。</li></ul></li><li><p>NOT EXISTS谓词</p><ul><li>若内层查询结果非空(true)，则外层的WHERE子句返回假值</li><li>若内层查询结果为空(False)，则外层的WHERE子句返回真值</li></ul></li><li><p>[例 3.60]查询所有选修了1号课程的学生姓名。<br>思路分析：<br>本查询涉及Student和SC关系<br>在Student中依次取每个元组的Sno值，用此值去检查SC表<br>若SC中存在这样的元组，其Sno值等于此Student.Sno值，并且其Cno= ‘1’，则取此Student.Sname送入结果表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">              (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">               <span class="keyword">FROM</span> SC</span><br><span class="line">               <span class="keyword">WHERE</span> Sno<span class="operator">=</span>Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span> <span class="string">&#x27; 1 &#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>[例 3.61]  查询没有选修1号课程的学生姓名。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">              (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">               <span class="keyword">FROM</span> SC</span><br><span class="line">               <span class="keyword">WHERE</span> Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>不同形式的查询间的替换</p><ul><li>一些(比如元组涉及空值)带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换</li><li>所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换</li><li>（需要具体分析性能，有的自动优化，EXISTS经常性能占优，一般更适合于外表小而内表大的情况；而IN适用于不相关子查询，或者一般适于外查询表很大而内查询表小的情况；）</li></ul></li><li><p>用EXISTS/NOT EXISTS实现全称量词（难点）(双重否定)</p><ul><li>SQL语言中没有全称量词 （For all）</li><li>可以把带有全称量词的谓词转换为等价的带有存在量词的谓词：<br>（x）P ≡  （ x（ P））</li></ul></li><li><p>[例 3.62] 查询选修了全部课程的学生姓名。<br>P谓词：(学生y)选修了某课程x<br>查询每一门课程都选修的学生姓名<br>双重否定：没有一门课程没有选修的学生姓名<br>NOT EXISTS 1 (遍历所有课程)没有一门课程（没有选修）<br>NOT EXISTS 2 没有选修(某课程)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">          (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> Course</span><br><span class="line">           <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">                    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                     <span class="keyword">FROM</span> SC</span><br><span class="line">                     <span class="keyword">WHERE</span> Sno<span class="operator">=</span> Student.Sno</span><br><span class="line">                     <span class="keyword">AND</span> Cno<span class="operator">=</span> Course.Cno));</span><br></pre></td></tr></table></figure></li><li><p>[例 3.63]查询至少选修了学生201215122选修的全部课程的学生号码。<br>解题思路：<br>用逻辑蕴涵表达：查询学号为x的学生，对所有的课程y，只要201215122学生选修了课程y，则x也选修了y。<br>形式化表示：<br>用P表示谓词 “学生201215122选修了课程y”<br>用q表示谓词 “学生x选修了课程y”<br>变换后语义：不存在这样的课程y，学生201215122选修了y，而学生x没有选y。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line">   <span class="keyword">FROM</span> SC SCX</span><br><span class="line">   <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">                 (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                  <span class="keyword">FROM</span> SC SCY</span><br><span class="line">                  <span class="keyword">WHERE</span> SCY.Sno <span class="operator">=</span> <span class="string">&#x27; 201215122 &#x27;</span>  <span class="keyword">AND</span></span><br><span class="line">                                <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">                                (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                                 <span class="keyword">FROM</span> SC SCZ</span><br><span class="line">                                 <span class="keyword">WHERE</span> SCZ.Sno<span class="operator">=</span>SCX.Sno <span class="keyword">AND</span></span><br><span class="line">                                               SCZ.Cno<span class="operator">=</span>SCY.Cno));</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="集合查询">集合查询</h3><ul><li><p>集合操作的种类</p><ul><li>并操作UNION</li><li>交操作INTERSECT</li><li>差操作EXCEPT</li></ul></li><li><p>参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同</p></li><li><p>[例 3.64]  查询计算机科学系的学生及年龄不大于19岁的学生。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<span class="operator">&lt;=</span><span class="number">19</span>;</span><br></pre></td></tr></table></figure><p>UNION：将多个查询结果合并起来时，系统自动去掉重复元组<br>UNION ALL：将多个查询结果合并起来时，保留重复元组</p></li><li><p>[例 3.65]  查询选修了课程1或者选修了课程2的学生。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27; 1 &#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span> <span class="string">&#x27; 2 &#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.66]  查询计算机科学系的学生与年龄不大于19岁的学生    的交集。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span> </span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage<span class="operator">&lt;=</span><span class="number">19</span> </span><br></pre></td></tr></table></figure></li><li><p>[例 3.67]查询既选修了课程1又选修了课程2的学生。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line">  <span class="keyword">FROM</span> SC</span><br><span class="line">  <span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27; 1 &#x27;</span> </span><br><span class="line">  <span class="keyword">INTERSECT</span></span><br><span class="line">  <span class="keyword">SELECT</span> Sno</span><br><span class="line">  <span class="keyword">FROM</span> SC</span><br><span class="line">  <span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27;2 &#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例 3.68]  查询计算机科学系的学生与年龄不大于19岁的学生的差集。</p><p>实际上是查询计算机科学系中年龄大于19岁的学生</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">&lt;=</span><span class="number">19</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于派生表的查询">基于派生表的查询</h4><ul><li><p>子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中，这时子查询生成的临时派生表（Derived Table）成为主查询的查询对象</p><p>[例3.57]找出每个学生超过他自己选修课程平均成绩的课程号</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"><span class="keyword">FROM</span> SC, (<span class="keyword">SELECT</span> Sno, <span class="built_in">Avg</span>(Grade) </span><br><span class="line">                    <span class="keyword">FROM</span> SC</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno)</span><br><span class="line">                    <span class="keyword">AS</span>   Avg_sc(avg_sno,avg_grade)</span><br><span class="line"><span class="keyword">WHERE</span> SC.Sno <span class="operator">=</span> Avg_sc.avg_sno</span><br><span class="line">  <span class="keyword">and</span> SC.Grade <span class="operator">&gt;=</span>Avg_sc.avg_grade</span><br></pre></td></tr></table></figure></li><li><p>如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其缺省属性。<br>[例3.60]查询所有选修了1号课程的学生姓名，可以用如下查询完成：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span>     Student,  </span><br><span class="line">               (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27; 1 &#x27;</span>) <span class="keyword">AS</span> SC1</span><br><span class="line"><span class="keyword">WHERE</span>  Student.Sno<span class="operator">=</span>SC1.Sno;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据更新">数据更新</h2><h3 id="插入数据">插入数据</h3><h5 id="插入元祖">插入元祖</h5><ul><li><p>语句格式</p><p>INSERT</p><p>INTO &lt;表名&gt; [(&lt;属性列1&gt;[,&lt;属性列2 &gt;…)]</p><p>VALUES (&lt;常量1&gt; [,&lt;常量2&gt;]… );</p></li><li><p>功能<br>将新元组插入指定表中</p></li><li><p>INTO子句</p><ul><li>指定要插入数据的表名及属性列</li><li>属性列的顺序可与表定义中的顺序不一致</li><li>没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致</li><li>指定部分属性列：插入的元组在其余属性列上取空值</li></ul></li><li><p>VALUES子句</p><ul><li>提供的值必须与INTO子句匹配<ul><li>值的个数</li><li>值的类型</li></ul></li></ul></li><li><p>[例3.69]将一个新学生元组（学号：201215128;姓名：陈冬;性别：男;所在系：IS;年龄：18岁）插入到Student表中。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span>  Student (Sno,Sname,Ssex,Sdept,Sage)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;201215128&#x27;</span>,<span class="string">&#x27;陈冬&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;IS&#x27;</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure></li><li><p>[例3.71] 插入一条选课记录（ ‘200215128’,'1 '）。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">INSERT</span></span><br><span class="line"> <span class="keyword">INTO</span> SC(Sno,Cno)</span><br><span class="line"> <span class="keyword">VALUES</span> (<span class="string">&#x27;201215128 &#x27;</span>,<span class="string">&#x27; 1 &#x27;</span>);</span><br><span class="line">关系数据库管理系统将在新插入记录的Grade列上自动地</span><br><span class="line">赋空值。</span><br><span class="line">或者：</span><br><span class="line"> <span class="keyword">INSERT</span></span><br><span class="line"> <span class="keyword">INTO</span> SC</span><br><span class="line"> <span class="keyword">VALUES</span> (<span class="string">&#x27; 201215128 &#x27;</span>,<span class="string">&#x27; 1 &#x27;</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p>​    [例3.70]将学生张成民的信息插入到Student表中。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span>  Student</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;201215126&#x27;</span>,<span class="string">&#x27;张成民&#x27;</span>,<span class="string">&#x27;男’,18,&#x27;</span>CS<span class="string">&#x27;); </span></span><br></pre></td></tr></table></figure></li></ul><h5 id="插入子查询结果">插入子查询结果</h5><p>语句格式<br>INSERT<br>INTO &lt;表名&gt;  [(&lt;属性列1&gt; [,&lt;属性列2&gt;…  )]<br>子查询;</p><ul><li><p>INTO子句</p></li><li><p>子查询</p><ul><li>SELECT子句目标列必须与INTO子句匹配<ul><li>值的个数</li><li>值的类型</li></ul></li></ul></li><li><p>[例3.72]  对每一个系，求学生的平均年龄，并把结果存入数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">第一步：建表</span><br><span class="line">      <span class="keyword">CREATE</span>  <span class="keyword">TABLE</span>  Dept_age</span><br><span class="line">          ( Sdept     <span class="type">CHAR</span>(<span class="number">15</span>)                     <span class="comment">/*系名*/</span></span><br><span class="line">            Avg_age <span class="type">SMALLINT</span>);          <span class="comment">/*学生平均年龄*/</span></span><br><span class="line">第二步：插入数据</span><br><span class="line">        <span class="keyword">INSERT</span></span><br><span class="line">       <span class="keyword">INTO</span>  Dept_age(Sdept,Avg_age)</span><br><span class="line">              <span class="keyword">SELECT</span>  Sdept，<span class="built_in">AVG</span>(Sage)</span><br><span class="line">              <span class="keyword">FROM</span>     Student</span><br><span class="line">              <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sdept;</span><br></pre></td></tr></table></figure></li><li><p>关系数据库管理系统在执行插入语句时会检查所插元组是否破坏表上已定义的完整性规则</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性<ul><li>NOT NULL约束</li><li>UNIQUE约束</li><li>值域约束</li></ul></li></ul></li></ul><h3 id="修改数据">修改数据</h3><ul><li>语句格式<br>UPDATE  &lt;表名&gt;<br>SET  &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]…<br>[WHERE &lt;条件&gt;];</li><li>功能<ul><li>修改指定表中满足WHERE子句条件的元组</li><li>SET子句给出&lt;表达式&gt;的值用于取代相应的属性列</li><li>如果省略WHERE子句，表示要修改表中的所有元组</li></ul></li></ul><h4 id="修改某一个元组的值">修改某一个元组的值</h4><ul><li><p>[例3.73]  将学生201215121的年龄改为22岁</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE  Student</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span><span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span>  Sno<span class="operator">=</span><span class="string">&#x27; 201215121 &#x27;</span>; </span><br></pre></td></tr></table></figure></li></ul><h4 id="修改多个元组的值">修改多个元组的值</h4><ul><li><p>[例3.74]  将所有学生的年龄增加1岁。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE Student</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span> Sage<span class="operator">+</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="带子查询的修改语句">带子查询的修改语句</h4><ul><li><p>[例3.75]  将计算机科学系全体学生的成绩置零。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE SC</span><br><span class="line"><span class="keyword">SET</span>     Grade<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno  <span class="keyword">IN</span></span><br><span class="line">       (SELETE Sno</span><br><span class="line">        <span class="keyword">FROM</span>     Student</span><br><span class="line">        <span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> );</span><br></pre></td></tr></table></figure></li></ul><p>关系数据库管理系统在执行修改语句时会检查所插元组是否破坏表上已定义的完整性规则</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性<ul><li>NOT NULL约束</li><li>UNIQUE约束</li><li>值域约束</li></ul></li></ul><h3 id="删除数据">删除数据</h3><ul><li>语句格式<br>DELETE<br>FROM     &lt;表名&gt;<br>[WHERE &lt;条件&gt;];</li><li>功能<br>删除指定表中满足WHERE子句条件的元组</li><li>WHERE子句<br>指定要删除的元组<br>缺省表示要删除表中的全部元组，表的定义仍在字典中</li></ul><h4 id="删除某个元祖的值">删除某个元祖的值</h4><ul><li><p>​    [例3.76]  删除学号为201215128的学生记录。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span> <span class="number">201215128</span> <span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="删除多个元组的值">删除多个元组的值</h4><ul><li><p>[例3.77]  删除所有的学生选课记录。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure></li></ul><h4 id="带子查询的删除语句">带子查询的删除语句</h4><ul><li><p>[例3.78]  删除计算机科学系所有学生的选课记录。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span>  SC</span><br><span class="line"><span class="keyword">WHERE</span>  Sno  <span class="keyword">IN</span></span><br><span class="line">(SELETE  Sno</span><br><span class="line">            <span class="keyword">FROM</span>   Student</span><br><span class="line">            <span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>) ;</span><br></pre></td></tr></table></figure></li></ul><h2 id="空值的处理">空值的处理</h2><ul><li><p>空值就是“不知道”或“不存在”或“无意义”的值。</p></li><li><p>一般有以下几种情况：</p><ul><li>该属性应该有一个值，但目前不知道它的具体值</li><li>该属性不应该有值</li><li>由于某种原因不便于填写</li></ul></li><li><p>空值是一个很特殊的值，含有不确定性。对关系运算带来特殊的问题，需要做特殊的处理。</p></li><li><p>空值的产生</p></li><li><p>[例 3.79]向SC表中插入一个元组，学生号是”201215126”，课程号是”1”，成绩为空。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC(Sno,Cno,Grade)</span><br><span class="line"> <span class="keyword">VALUES</span>(<span class="string">&#x27;201215126 &#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="keyword">NULL</span>);   <span class="comment">/*该学生还没有考试成绩，取空值*/</span></span><br><span class="line">或</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC(Sno,Cno)</span><br><span class="line"> <span class="keyword">VALUES</span>(<span class="string">&#x27; 201215126 &#x27;</span>,<span class="string">&#x27;1&#x27;</span>);             <span class="comment">/*没有赋值的属性，其值为空值*/</span></span><br></pre></td></tr></table></figure></li><li><p>[例3.80]  将Student表中学生号为”201215200”的学生所属的系改为空值。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE Student</span><br><span class="line"><span class="keyword">SET</span> Sdept <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span><span class="string">&#x27;201215200&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>判断一个属性的值是否为空值，用IS NULL或IS NOT NULL来表示。<br>[例 3.81]  从Student表中找出漏填了数据的学生信息</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> Ssex <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> Sage <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> Sdept <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li><li><p>属性定义（或者域定义）中</p><ul><li>有NOT NULL约束条件的不能取空值</li><li>加了UNIQUE限制的属性不能取空值</li><li>码属性不能取空值</li></ul></li><li><p>空值与另一个值（包括另一个空值）的算术运算的结果为空值</p></li><li><p>空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。</p></li><li><p>有UNKNOWN后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑</p></li><li><p>[例3.82]  找出选修1号课程的不及格的学生。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">#查询结果不包括缺考的学生，因为他们的Grade值为<span class="keyword">null</span>。</span><br><span class="line">#正确：</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> (Grade<span class="operator">&lt;</span><span class="number">60</span> <span class="keyword">OR</span> Grade <span class="keyword">IS</span> <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="视图">视图</h2><ul><li>视图的特点<ul><li>虚表，是从一个或几个基本表（或视图）导出的表</li><li>只存放视图的定义，不存放视图对应的数据</li><li>基表中的数据发生变化，从视图中查询出的数据也随之改变</li></ul></li></ul><h3 id="定义视图">定义视图</h3><ul><li>关系数据库管理系统执行CREATE VIEW语句时只是把视图定义存入数据字典，并不执行其中的SELECT语句。</li><li>在对视图查询时，按视图的定义从基本表中将数据查出。</li></ul><h4 id="建立视图">建立视图</h4><ul><li><p>语句格式</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> </span><br><span class="line">      <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span>  [(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>  [,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>]…)]</span><br><span class="line"><span class="keyword">AS</span>  <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span>  <span class="keyword">CHECK</span>  OPTION];</span><br></pre></td></tr></table></figure><ul><li>WITH CHECK OPTION<br>对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）</li><li>子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则决定具体系统的实现。</li></ul></li><li><p>[例3.84]  建立信息系学生的视图。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span>     Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.85]建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生 。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure></li><li><p>定义IS_Student视图时加上了WITH CHECK OPTION子句，对该视图进行插入、修改和删除操作时，RDBMS会自动加上Sdept='IS’的条件。</p></li><li><p>若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，我们称这类视图为行列子集视图。</p><ul><li>IS_Student视图就是一个行列子集视图。</li></ul></li><li><p>基于多个基表的视图</p><p>[例3.86]  建立信息系选修了1号课程的学生的视图（包括学号、姓名、成绩）。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S1(Sno,Sname,Grade)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span>  Student,SC</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">               Student.Sno<span class="operator">=</span>SC.Sno <span class="keyword">AND</span></span><br><span class="line">               SC.Cno<span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>基于视图的视图</p><p>[例3.87]  建立信息系选修了1号课程且成绩在90分以上的学生的视图。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span>  IS_S1</span><br><span class="line"><span class="keyword">WHERE</span>  Grade<span class="operator">&gt;=</span><span class="number">90</span>;</span><br></pre></td></tr></table></figure></li><li><p>带表达式的视图<br>[例3.88]  定义一个反映学生出生年份的视图。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> BT_S(Sno,Sname,Sbirth)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,<span class="number">2014</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">FROM</span>  Student;</span><br></pre></td></tr></table></figure></li><li><p>分组视图<br>[例3.89]  将学生的学号及平均成绩定义为一个视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> S_G(Sno,Gavg)</span><br><span class="line">     <span class="keyword">AS</span>  </span><br><span class="line">     <span class="keyword">SELECT</span> Sno,<span class="built_in">AVG</span>(Grade)</span><br><span class="line">     <span class="keyword">FROM</span>  SC</span><br><span class="line">     <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure></li><li><p>[例3.90]将Student表中所有女生记录定义为一个视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> F_Student(F_Sno,name,sex,age,dept)</span><br><span class="line">  <span class="keyword">AS</span></span><br><span class="line">  <span class="keyword">SELECT</span>  <span class="operator">*</span>                        <span class="comment">/*没有不指定属性列*/</span></span><br><span class="line">  <span class="keyword">FROM</span>  Student</span><br><span class="line">  <span class="keyword">WHERE</span> Ssex<span class="operator">=</span>‘女’;</span><br><span class="line"> 缺点：</span><br><span class="line">修改基表Student的结构后，Student表与F_Student视图  的映象关系被破坏，导致该视图不能正确工作。</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除视图">删除视图</h4><ul><li><p>语句的格式：<br>DROP  VIEW  &lt;视图名&gt;[CASCADE];</p><ul><li>该语句从数据字典中删除指定的视图定义</li><li>如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除</li><li>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除</li></ul></li><li><p>[例3.91 ] 删除视图BT_S和IS_S1</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> BT_S;<span class="comment">/*成功执行*/</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IS_S1;<span class="comment">/*拒绝执行*/</span></span><br><span class="line">     </span><br><span class="line">  要删除IS_S1，需使用级联删除：</span><br><span class="line">  <span class="keyword">DROP</span> <span class="keyword">VIEW</span> IS_S1 CASCADE;    </span><br></pre></td></tr></table></figure></li></ul><h3 id="查询视图">查询视图</h3><ul><li><p>用户角度：查询视图与查询基本表相同</p></li><li><p>关系数据库管理系统实现视图查询的方法</p><ul><li>视图消解法（View Resolution）<ul><li>进行有效性检查</li><li>转换成等价的对基本表的查询</li><li>执行修正后的查询</li></ul></li></ul></li><li><p>[例3.92]  在信息系学生的视图中找出年龄小于20岁的学生。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">SELECT</span>   Sno,Sage</span><br><span class="line">       <span class="keyword">FROM</span>      IS_Student</span><br><span class="line">       <span class="keyword">WHERE</span>   Sage<span class="operator">&lt;</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">视图消解转换后的查询语句为：</span><br><span class="line"> <span class="keyword">SELECT</span>  Sno,Sage       </span><br><span class="line"> <span class="keyword">FROM</span>  Student</span><br><span class="line"> <span class="keyword">WHERE</span>  Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span>  <span class="keyword">AND</span>  Sage<span class="operator">&lt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.93]  查询选修了1号课程的信息系学生</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  IS_Student.Sno,Sname</span><br><span class="line"><span class="keyword">FROM</span>     IS_Student,SC</span><br><span class="line"><span class="keyword">WHERE</span>  IS_Student.Sno <span class="operator">=</span>SC.Sno <span class="keyword">AND</span> SC.Cno<span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新视图">更新视图</h3><ul><li><p>[例3.95]  将信息系学生视图IS_Student中学号”201215122”的学生姓名改为”刘辰”。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE  IS_Student</span><br><span class="line"><span class="keyword">SET</span>  Sname<span class="operator">=</span> <span class="string">&#x27;刘辰&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span>  Sno<span class="operator">=</span> <span class="string">&#x27; 201215122 &#x27;</span>;</span><br><span class="line">转换后的语句：</span><br><span class="line">UPDATE  Student</span><br><span class="line"><span class="keyword">SET</span> Sname<span class="operator">=</span> <span class="string">&#x27;刘辰&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span> <span class="string">&#x27; 201215122 &#x27;</span> <span class="keyword">AND</span> Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>[例3.96]  向信息系学生视图IS_S中插入一个新的学生记录，其中学号为”201215129”，姓名为”赵新”，年龄为20岁</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> IS_Student</span><br><span class="line"><span class="keyword">VALUES</span>(‘<span class="number">201215129</span>’,’赵新’,<span class="number">20</span>);</span><br><span class="line">转换为对基本表的更新：</span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span>   Student(Sno,Sname,Sage,Sdept)</span><br><span class="line"><span class="keyword">VALUES</span>(‘<span class="number">200215129</span> <span class="string">&#x27;,&#x27;</span>赵新<span class="string">&#x27;,20,&#x27;</span><span class="keyword">IS</span><span class="string">&#x27; );</span></span><br></pre></td></tr></table></figure></li><li><p>[例3.97]删除信息系学生视图IS_Student中学号为”201215129”的记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> IS_Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span> <span class="string">&#x27; 201215129 &#x27;</span>;</span><br><span class="line">转换为对基本表的更新：</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span> <span class="string">&#x27; 201215129 &#x27;</span> <span class="keyword">AND</span> Sdept<span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>更新视图的限制：一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新<br>例：例3.89定义的视图S_G为不可更新视图。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE  S_G</span><br><span class="line"><span class="keyword">SET</span>          Gavg<span class="operator">=</span><span class="number">90</span></span><br><span class="line"><span class="keyword">WHERE</span>  Sno<span class="operator">=</span> <span class="string">&#x27;201215121&#x27;</span>;</span><br><span class="line">这个对视图的更新无法转换成对基本表SC的更新</span><br></pre></td></tr></table></figure></li><li><p>允许对行列子集视图进行更新</p></li><li><p>对其他类型视图的更新不同系统有不同限制</p></li><li><p>DB2对视图更新的限制：</p><ul><li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li><li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。</li><li>若视图的字段来自集函数，则此视图不允许更新。</li><li>若视图定义中含有GROUP BY子句，则此视图不允许更新。</li><li>若视图定义中含有DISTINCT短语，则此视图不允许更新。</li><li>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。</li></ul></li><li><p>例：将SC中成绩在平均成绩之上的元组定义成一个视图</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">     <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> GOOD_SC</span><br><span class="line">     <span class="keyword">AS</span> </span><br><span class="line">     <span class="keyword">SELECT</span>  Sno,Cno,Grade</span><br><span class="line">     <span class="keyword">FROM</span>     SC</span><br><span class="line">     <span class="keyword">WHERE</span> Grade <span class="operator">&gt;</span></span><br><span class="line">                             (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade)</span><br><span class="line">                               <span class="keyword">FROM</span>     SC);</span><br><span class="line">一个不允许更新的视图上定义的视图也不允许更新</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图的作用">视图的作用</h3><ul><li><p>视图能够简化用户的操作</p><p>当视图中数据不是直接来自基本表时，定义视图能够简化用户的操作</p><ul><li>基于多张表连接形成的视图</li><li>基于复杂嵌套查询的视图</li><li>含导出属性的视图</li></ul></li><li><p>视图使用户能以多种角度看待同一数据</p><ul><li>视图机制能使不同用户以不同方式看待同一数据，适应数据库共享的需要</li></ul></li><li><p>视图对重构数据库提供了一定程度的逻辑独立性</p><ul><li><p>数据库重构 ：<br>例：学生关系Student(Sno,Sname,Ssex,Sage,Sdept)<br>“垂直”地分成两个基本表：<br>SX(Sno,Sname,Sage)<br>SY(Sno,Ssex,Sdept)</p><p>通过建立一个视图Student：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span>  Student(Sno,Sname,Ssex,Sage,Sdept)</span><br><span class="line"><span class="keyword">AS</span>  </span><br><span class="line">     <span class="keyword">SELECT</span>  SX.Sno,SX.Sname,SY.Ssex,SX.Sage,SY.Sdept</span><br><span class="line">     <span class="keyword">FROM</span>  SX,SY</span><br><span class="line">     <span class="keyword">WHERE</span>  SX.Sno<span class="operator">=</span>SY.Sno;</span><br></pre></td></tr></table></figure><p>使用户的外模式保持不变，用户的应用程序通过视图仍然能够<br>查找数据</p></li><li><p>视图只能在一定程度上提供数据的逻辑独立性</p><ul><li>由于对视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因基本表结构的改变而改变。</li></ul></li></ul></li><li><p>视图能够对机密数据提供安全保护</p><ul><li>对不同用户定义不同视图，使每个用户只能看到他有权看到的数据</li></ul></li><li><p>适当的利用视图可以更清晰的表达查询</p><ul><li><p>经常需要执行这样的查询“对每个同学找出他获得最高成绩的课程号”。可以先定义一个视图，求出每个同学获得的最高成绩</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> VMGRADE</span><br><span class="line">     <span class="keyword">AS</span></span><br><span class="line">          <span class="keyword">SELECT</span> Sno, <span class="built_in">MAX</span>(Grade)  Mgrade</span><br><span class="line">          <span class="keyword">FROM</span>  SC</span><br><span class="line">          <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="小结">小结</h2><ul><li>SQL可以分为四大部分<ul><li>数据定义</li><li>数据查询</li><li>数据更新</li><li>数据控制</li></ul></li><li>SQL是关系数据库语言的工业标准。大部分数据库管理系统产品都能支持SQL92,但是许多数据库系统只支持SQL99、SQL2008和SQL2011的部分特征，至今尚没有一个数据库系统能够完全支持SQL99以上的标准。</li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统 | 第二章 关系数据库</title>
      <link href="2021/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2021/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="关系数据结构及形式化定义">关系数据结构及形式化定义</h2><h3 id="关系">关系</h3><ul><li>单一的数据结构----关系<br>现实世界的实体以及实体间的各种联系均用关系来表示</li><li>逻辑结构----二维表<br>从用户角度，关系模型中数据的逻辑结构是一张二维表</li><li>建立在集合代数的基础上</li></ul><h4 id="域">域</h4><ul><li>域是一组具有相同数据类型的值的集合。例:<br>整数<br>实数<br>介于某个取值范围的整数<br>指定长度的字符串集合<br>{‘男’，‘女’}<br>………………</li></ul><h4 id="笛卡尔积">笛卡尔积</h4><ul><li>笛卡尔积<br>给定一组域D1，D2，…，Dn，允许其中某些域是相同的。<br>D1，D2，…，Dn的笛卡尔积为：<br>D1×D2×…×Dn ＝<br>｛（d1，d2，…，dn）｜diDi，i＝1，2，…，n｝<br>所有域的所有取值的一个组合<br>不能重复</li><li>元组（Tuple）<br>笛卡尔积中每一个元素（d1，d2，…，dn）叫作一个n元组（n-tuple）或简称元组<br>(张清玫，计算机专业，李勇)、<br>(张清玫，计算机专业，刘晨)  等 都是元组</li><li>分量（Component）<br>笛卡尔积元素（d1，d2，…，dn）中的每一个值di 叫作一个分量<br>张清玫、计算机专业、李勇、刘晨等都是分量</li><li>基数（Cardinal number）<br>若Di（i＝1，2，…，n）为有限集，其基数为mi（i＝1，2，…，n），则D1×D2×…×Dn的基数M为：</li><li>笛卡尔积的表示方法<br>笛卡尔积可表示为一张二维表<br>表中的每行对应一个元组，表中的每列对应一个域</li></ul><h4 id="关系-2">关系</h4><ul><li><p>关系<br>D1×D2×…×Dn的子集叫作在域D1，D2，…，Dn上的<br>关系，表示为</p><p>​       R（D1，D2，…，Dn）<br>​</p><p>R：关系名<br>n：关系的目或度（Degree）</p></li><li><p>元组<br>关系中的每个元素是关系中的元组，通常用t表示。</p></li><li><p>单元关系与二元关系<br>当n=1时，称该关系为单元关系（Unary relation）<br>或一元关系<br>当n=2时，称该关系为二元关系（Binary relation）</p></li><li><p>关系的表示<br>关系也是一个二维表，表的每行对应一个元组，表的每<br>列对应一个域</p></li><li><p>属性<br>关系中不同列可以对应相同的域<br>为了加以区分，必须对每列起一个名字，称为属性（Attribute）<br>n目关系必有n个属性</p></li><li><p>码</p><ul><li>候选码（Candidate key）<br>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码<br>简单的情况：候选码只包含一个属性</li><li>全码（All-key）<br>最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li><li>主码<br>若一个关系有多个候选码，则选定其中一个为主码（Primary key）</li><li>主属性<br>候选码的诸属性称为主属性（Prime attribute）<br>不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）</li></ul></li><li><p>三类关系</p><ul><li>基本关系（基本表或基表）<br>实际存在的表，是实际存储数据的逻辑表示</li><li>查询表<br>查询结果对应的表</li><li>视图表<br>由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li></ul></li><li><p>基本关系的性质<br>① 列是同质的（Homogeneous）<br>② 不同的列可出自同一个域</p><ul><li>其中的每一列称为一个属性</li><li>不同的属性要给予不同的属性名</li></ul><p>③ 列的顺序无所谓,，列的次序可以任意交换<br>④ 任意两个元组的候选码不能相同<br>⑤ 行的顺序无所谓，行的次序可以任意交换</p><p>⑥ 分量必须取原子值这是规范条件中最基本的一条</p></li></ul><h3 id="关系模式">关系模式</h3><h4 id="什么是关系模式">什么是关系模式</h4><ul><li>关系模式（Relation Schema）是型</li><li>关系是值</li><li>关系模式是对关系的描述<ul><li>元组集合的结构<ul><li>属性构成</li><li>属性来自的域</li><li>属性与域之间的映象关系</li></ul></li><li>完整性约束条件</li></ul></li></ul><h4 id="定义关系模式">定义关系模式</h4><ul><li>关系模式可以形式化地表示为：<br>R（U，D，DOM，F）<br>R            关系名<br>U            组成该关系的属性名集合<br>D            U中属性所来自的域<br>DOM       属性向域的映象集合<br>F             属性间数据的依赖关系的集合</li></ul><h4 id="关系模式与关系">关系模式与关系</h4><ul><li>关系模式<ul><li>对关系的描述</li><li>静态的、稳定的</li></ul></li><li>关系<ul><li>关系模式在某一时刻的状态或内容</li><li>动态的、随时间不断变化的</li></ul></li><li>关系模式和关系往往笼统称为关系<br>- 通过上下文加以区别</li></ul><h3 id="关系数据库">关系数据库</h3><ul><li>关系数据库<br>在一个给定的应用领域中，所有关系的集合构成一个关系数据库</li><li>关系数据库的型与值<ul><li>关系数据库的型: 关系数据库模式，是对关系数据库的描述</li><li>关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库</li></ul></li></ul><h3 id="关系模型的存储结构">关系模型的存储结构</h3><ul><li>关系数据库的物理组织<ul><li>有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成</li><li>有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理</li></ul></li></ul><h2 id="关系操作">关系操作</h2><ul><li><p>常用的关系操作</p><ul><li>查询操作：选择、投影、连接、除、并、差、交、笛卡尔积<ul><li><strong>选择、投影、并、差、笛卡尔基是5种基本操作</strong></li></ul></li><li>数据更新：插入、删除、修改</li></ul></li><li><p>关系操作的特点<br>集合操作方式：操作的对象和结果都是集合，一次一集合的方式</p></li><li><p>关系代数语言</p><ul><li>用对关系的运算来表达查询要求</li><li>代表：ISBL</li></ul></li><li><p>关系演算语言：用谓词来表达查询要求</p><ul><li>元组关系演算语言<ul><li>谓词变元的基本对象是元组变量</li><li>代表：APLHA, QUEL</li></ul></li><li>域关系演算语言<ul><li>谓词变元的基本对象是域变量</li><li>代表：QBE</li></ul></li></ul></li><li><p>具有关系代数和关系演算双重特点的语言<br>代表：SQL（Structured Query Language</p></li></ul><h2 id="关系的完整性">关系的完整性</h2><h3 id="实体完整性">实体完整性</h3><ul><li>规则2.1  实体完整性规则（Entity Integrity）<br>若属性A是基本关系R的主属性，则属性A不能取空值<br>空值就是“不知道”或“不存在”或“无意义”的值<br>例：<br>选修（学号，课程号，成绩）<br>“学号、课程号”为主码<br>“学号”和“课程号”两个属性都不能取空值</li><li>实体完整性规则的说明<ul><li>实体完整性规则是针对基本关系而言的。 一个基本表通常对应现实世界的一个实体集。</li><li>现实世界中的实体是可区分的，即它们具有某种唯一性标识。</li><li>关系模型中以主码作为唯一性标识。</li><li>主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性</li></ul></li></ul><h3 id="参照完整性">参照完整性</h3><h4 id="关系间的引用">关系间的引用</h4><ul><li>在关系模型中实体及实体间的联系都是用关系来描述的，自然存在着关系与关系间的引用。<br>[例2.1]  学生实体、专业实体<br>　学生（学号，姓名，性别，<strong>专业号</strong>，年龄）<br>　  专业（<strong>专业号</strong>，专业名）</li><li>学生关系引用了专业关系的主码“专业号”。</li><li>学生关系中的“专业号”值必须是确实存在的专业的专业号</li><li>例[2.2] 学生、课程、学生与课程之间的多对多联系<br>学生（学号，姓名，性别，专业号，年龄）<br>课程（课程号，课程名，学分）<br>选修（学号，课程号，成绩）</li></ul><h4 id="外码">外码</h4><ul><li>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是R的外码</li><li>基本关系R称为参照关系（Referencing  Relation）</li><li>基本关系S称为被参照关系（Referenced Relation）或目标关系（Target Relation）</li><li>[例2.1]中学生关系的“专业号”与专业关系的主码“专业号”相对应<br>“专业号”属性是学生关系的外码<br>专业关系是被参照关系，学生关系为参照关系</li><li>关系R和S不一定是不同的关系</li><li>目标关系S的主码Ks 和参照关系的外码F必须定义在同一个（或一组）域上</li><li>外码并不一定要与相应的主码同名<br>当外码与相应的主码属于不同关系时，往往取相同的名 字，以便于识别</li></ul><h4 id="参照完整性规则">参照完整性规则</h4><ul><li>规则2.2  参照完整性规则<br>若属性（或属性组）F是基本关系R的外码它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：<ul><li>或者取空值（F的每个属性值均为空值）</li><li>或者等于S中某个元组的主码值</li></ul></li><li>[例2.1]中<br>学生关系中每个元组的“专业号”属性只取两类值：<br>（1）空值，表示尚未给该学生分配专业<br>（2）非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配一个不存在的专业</li><li>[例2.2] 中<br>选修（学号，课程号，成绩）<br>“学号”和“课程号”可能的取值 ：<br>（1）选修关系中的主属性，不能取空值<br>（2）只能取相应被参照关系中已经存在的主码值</li><li>[例2.3] 中<br>学生（学号，姓名，性别，专业号，年龄，班长）<br>“班长”属性值可以取两类值：<br>（1）空值，表示该学生所在班级尚未选出班长<br>（2）非空值，该值必须是本关系中某个元组的学号值</li></ul><h3 id="用户定义的完整性">用户定义的完整性</h3><ul><li><p>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</p></li><li><p>关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能</p></li><li><p>例:<br>课程（课程号，课程名，学分）<br>“课程号”属性必须取唯一值<br>非主属性“课程名”也不能取空值<br>“学分”属性只能取值{1，2，3，4}</p></li></ul><h2 id="关系代数">关系代数</h2><ul><li>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询</li><li>关系代数<ul><li>运算对象是关系</li><li>运算结果亦为关系</li><li>关系代数的运算符有两类：集合运算符和专门的关系运算符</li></ul></li><li>传统的集合运算是从关系的“水平”方向即行的角度进行</li><li>专门的关系运算不仅涉及行而且涉及列</li></ul><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td><strong>∪</strong></td><td><strong>并</strong></td></tr><tr><td><strong>-</strong></td><td><strong>差</strong></td></tr><tr><td><strong>∩</strong></td><td><strong>交</strong></td></tr><tr><td><strong>×</strong></td><td><strong>笛卡尔积</strong></td></tr><tr><td><strong>σ</strong></td><td><strong>选择</strong></td></tr><tr><td><strong>π</strong></td><td><strong>投影</strong></td></tr><tr><td></td><td><strong>连接</strong></td></tr><tr><td><strong>÷</strong></td><td><strong>除</strong></td></tr></tbody></table><p>先引入几个记号</p><ul><li><p>R，tR，t[Ai]<br>设关系模式为R(A1，A2，…，An)<br>它的一个关系设为R<br>tR表示t是R的一个元组<br>t[Ai]则表示元组t中相应于属性Ai的一个分量</p></li><li><p>A，t[A]， A<br>若A={Ai1，Ai2，…，Aik}，其中Ai1，Ai2，…，Aik是A1，A2，…，An中的一部分，则A称为属性列或属性组。<br>t[A]=(t[Ai1]，t[Ai2]，…，t[Aik])表示元组t在属性列A上诸分量的集合。<br>A则表示{A1，A2，…，An}中去掉{Ai1，Ai2，…，Aik}后剩余的属性组。</p></li><li><p>tr ts<br>R为n目关系，S为m目关系。<br>tr R，tsS， tr ts称为元组的连接。<br>tr ts是一个n + m列的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</p></li><li><p>象集Zx<br>给定一个关系R（X，Z），X和Z为属性组。<br>当t[X]=x时，x在R中的象集（Images Set）为：<br>Zx={t[Z]|t R，t[X]=x}<br>它表示R中属性组X上值为x的诸元组在Z上分量的集合</p></li></ul><h3 id="选择">选择</h3><ul><li><p>选择又称为限制（Restriction）</p></li><li><p>选择运算符的含义</p><ul><li>在关系R中选择满足给定条件的诸元组<br>σF® = {t|tR∧F(t)= ‘真’}</li><li>F：选择条件，是一个逻辑表达式，取值为“真”或“假”<br>基本形式为：X1θY1<br>θ表示比较运算符，它可以是＞，≥，＜，≤，＝或&lt;&gt;</li></ul></li><li><p>[例2.4]  查询信息系（IS系）全体学生。<br>σSdept = ‘IS’ (Student)</p><p>结果：</p><table><thead><tr><th><strong>Sno</strong></th><th><strong>Sname</strong></th><th><strong>Ssex</strong></th><th><strong>Sage</strong></th><th><strong>Sdept</strong></th></tr></thead><tbody><tr><td><strong>201215125</strong></td><td><strong>张立</strong></td><td><strong>男</strong></td><td><strong>19</strong></td><td><strong>IS</strong></td></tr></tbody></table></li><li><p>[例2.5]  查询年龄小于20岁的学生。<br>σSage &lt; 20(Student)<br>结果：</p><table><thead><tr><th><strong>Sno</strong></th><th><strong>Sname</strong></th><th><strong>Ssex</strong></th><th><strong>Sage</strong></th><th><strong>Sdept</strong></th></tr></thead><tbody><tr><td><strong>201215122</strong></td><td><strong>刘晨</strong></td><td><strong>女</strong></td><td><strong>19</strong></td><td><strong>IS</strong></td></tr><tr><td><strong>201215123</strong></td><td><strong>王敏</strong></td><td><strong>女</strong></td><td><strong>18</strong></td><td><strong>MA</strong></td></tr><tr><td><strong>201215125</strong></td><td><strong>张立</strong></td><td><strong>男</strong></td><td><strong>19</strong></td><td><strong>IS</strong></td></tr></tbody></table></li></ul><h3 id="投影">投影</h3><ul><li><p>从R中选择出若干属性列组成新的关系<br>πA® = { t[A] | t R }<br>A：R中的属性列</p></li><li><p>投影操作主要是从列的角度进行运算</p></li><li><p>投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）</p></li><li><p>[例2.6]  查询学生的姓名和所在系。<br>即求Student关系上学生姓名和所在系两个属性上的投影<br>πSname,Sdept(Student)<br>结果：</p><table><thead><tr><th><strong>Sname</strong></th><th><strong>Sdept</strong></th></tr></thead><tbody><tr><td><strong>李勇</strong></td><td><strong>CS</strong></td></tr><tr><td><strong>刘晨</strong></td><td><strong>CS</strong></td></tr><tr><td><strong>王敏</strong></td><td><strong>MA</strong></td></tr><tr><td><strong>张立</strong></td><td><strong>IS</strong></td></tr></tbody></table></li></ul><h3 id="连接">连接</h3><ul><li>连接也称为θ连接</li><li>连接运算的含义<br>从两个关系的笛卡尔积中选取属性间满足一定条件的元组<br>R         S = {          | tr  R∧ts S∧tr[A]θts[B] }<ul><li>A和B：分别为R和S上度数相等且可比的属性组</li><li>θ：比较运算符</li><li>连接运算从R和S的广义笛卡尔积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组</li></ul></li></ul><h4 id="常用链接运算">常用链接运算</h4><h5 id="等值连接">等值连接</h5><ul><li>θ为“＝”的连接运算称为等值连接</li><li>从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组，即等值连接为：<br>R    S = {       | tr R∧ts S∧tr[A] = ts[B] }</li></ul><h5 id="自然连接">自然连接</h5><ul><li>自然连接是一种特殊的等值连接<br>两个关系中进行比较的分量必须是相同的属性组<br>在结果中把重复的属性列去掉</li><li>自然连接的含义<br>R和S具有相同的属性组B<br>R   S = {       [U-B] | tr R∧ts S∧tr[B] = ts[B] }</li></ul><h5 id="悬浮元组（Dangling-tuple）">悬浮元组（Dangling tuple）</h5><ul><li>两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组。</li></ul><h5 id="外连接（Outer-Join）">外连接（Outer Join）</h5><ul><li><p>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(Null)，就叫做外连接</p></li><li><p>左外连接(LEFT OUTER JOIN或LEFT JOIN)</p><p>只保留左边关系R中的悬浮元组</p><p>右外连接(RIGHT OUTER JOIN或RIGHT JOIN)<br>只保留右边关系S中的悬浮元组</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统 | 第一章 绪论</title>
      <link href="2021/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/"/>
      <url>2021/01/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="四个基本概念">四个基本概念</h2><h3 id="数据">数据</h3><ul><li>是数据库中存储的基本对象</li></ul><h4 id="定义">定义</h4><ul><li>描述事物的符号记录</li></ul><h4 id="数据的种类">数据的种类</h4><ul><li>数字、文字、图形、图像、音频、视频、学生的档案记录等</li></ul><h4 id="数据的含义">数据的含义</h4><ul><li>数据的含义称为数据的语义，数据与其语义是不可分的。</li></ul><h3 id="数据库">数据库</h3><h4 id="定义-2">定义</h4><ul><li>数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合。</li></ul><h4 id="数据库的基本特征">数据库的基本特征</h4><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul><h3 id="数据库管理系统">数据库管理系统</h3><h4 id="什么是数据库管理系统">什么是数据库管理系统</h4><ul><li>位于用户与操作系统之间的一层数据管理软件</li><li>是基础软件，是一个大型复杂的软件系统</li></ul><h4 id="数据库管理系统的用途">数据库管理系统的用途</h4><ul><li>科学地组织和存储数据、高效地获取和维护数据</li></ul><h4 id="数据库管理系统的主要功能">数据库管理系统的主要功能</h4><ul><li><p>数据定义功能</p><ul><li>提供数据定义语言（DDL）</li><li>定义数据库中的数据对象</li></ul></li><li><p>数据组织、存储和管理</p><ul><li>分类组织、存储和管理各种数据</li><li>确定组织数据的文件结构和存取方式</li><li>实现数据之间的联系</li><li>提供多种存取方法提高存取效率</li></ul></li><li><p>数据操纵功能</p><ul><li>提供数据操纵语言（DML）</li><li>实现对数据库的基本操作  （查询、插入、删除和修改）</li></ul></li><li><p>数据库的事务管理和运行管理</p><ul><li>数据库在建立、运行和维护时由数据库管理系统统一管理和控制</li><li>保证数据的安全性、完整性、多用户对数据的并发使用</li><li>发生故障后的系统恢复</li></ul></li><li><p>数据库的建立和维护</p><ul><li>数据库初始数据的装载和转换</li><li>数据库转储、恢复功能</li><li>数据库的重组织</li><li>性能监视、分析等</li></ul></li><li><p>其他功能</p><ul><li>数据库管理系统与网络中其它软件系统的通信</li><li>数据库管理系统系统之间的数据转换</li><li>异构数据库之间的互访和互操作</li></ul></li></ul><h3 id="数据库系统（Database-System，简称DBS）">数据库系统（Database System，简称DBS）</h3><h4 id="数据库系统的构成">数据库系统的构成</h4><ul><li>数据库</li><li>数据库管理系统（及其应用开发工具）</li><li>应用程序</li><li>数据库管理员</li></ul><h2 id="数据库管理技术的产生和发展">数据库管理技术的产生和发展</h2><h3 id="什么是数据管理">什么是数据管理</h3><ul><li>对数据进行分类、组织、编码、存储、检索和维护</li><li>数据处理的中心问题</li></ul><h3 id="数据管理技术的发展过程">数据管理技术的发展过程</h3><ul><li>人工管理阶段（20世纪50年代中之前）</li><li>文件系统阶段（20世纪50年代末–60年代中）</li><li>数据库系统阶段（20世纪60年代末–现在）</li></ul><h3 id="数据管理技术的发展动力">数据管理技术的发展动力</h3><ul><li>应用需求的推动</li><li>计算机硬件的发展</li><li>计算机软件的发展</li></ul><h3 id="人工管理阶段">人工管理阶段</h3><ul><li>时期<br>20世纪50年代中之前</li><li>产生的背景<ul><li>应用背景科学计算</li><li>硬件背景无直接存取存储设备</li><li>软件背景没有操作系统</li><li>处理方式批处理</li></ul></li><li>特点<ul><li>数据的管理者：用户（程序员），数据不保存</li><li>数据面向的对象：某一应用程序</li><li>数据的共享程度：无共享、冗余度极大</li><li>数据的独立性：不独立，完全依赖于程序</li><li>数据的结构化：无结构</li><li>数据控制能力：应用程序自己控制</li></ul></li></ul><h3 id="文件系统阶段">文件系统阶段</h3><ul><li>时期<br>20世纪50年代末–60年代中</li><li>产生的背景<ul><li>应用背景科学计算、数据管理</li><li>硬件背景磁盘、磁鼓</li><li>软件背景有文件系统</li><li>处理方式联机实时处理、批处理</li></ul></li><li>特点<ul><li>数据的管理者：文件系统，数据可长期保存</li><li>数据面向的对象：某一应用</li><li>数据的共享程度：共享性差、冗余度大</li><li>数据的结构化：记录内有结构，整体无结构</li><li>数据的独立性：独立性差</li><li>数据控制能力：应用程序自己控制</li></ul></li></ul><h3 id="数据库系统阶段">数据库系统阶段</h3><ul><li><p>文件系统到数据库系统，标志着数据管理技术的飞跃</p></li><li><p>时期<br>20世纪60年代末以来</p></li><li><p>产生的背景</p><ul><li>应用背景大规模数据管理</li><li>硬件背景大容量磁盘、磁盘阵列</li><li>软件背景有数据库管理系统</li><li>处理方式联机实时处理,分布处理,批处理</li></ul></li><li><p>特点</p><ul><li><p>数据结构化</p><p>数据的整体结构化是数据库的主要特征之一</p><p>整体结构化</p><ul><li>不再仅仅针对某一个应用，而是面向全组织</li><li>不仅数据内部结构化，整体是结构化的，数据之间具有联系</li><li>数据记录可以变长</li><li>数据的最小存取单位是数据项</li></ul><p>数据的用数据模型描述，无需应用程序定义</p></li><li><p>数据的共享性高，冗余度低且易扩充</p><p>数据面向整个系统，可以被多个用户、多个应用共享使用。</p><ul><li>数据共享的好处</li><li>减少数据冗余，节约存储空间</li><li>避免数据之间的不相容性与不一致性</li><li>使系统易于扩充</li></ul></li><li><p>数据独立性高</p><ul><li>物理独立性<br>指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不用改变。</li><li>逻辑独立性<br>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变。</li><li>数据独立性由数据库管理系统的二级映像功能来保证。</li></ul></li><li><p>数据由数据库管理系统统一管理和控制</p><ul><li><p>数据库管理系统提供的数据控制功能</p></li><li><p>数据的安全性（Security）保护</p><p>保护数据以防止不合法的使用造成的数据的泄密和破坏。</p></li><li><p>数据的完整性（Integrity）检查<br>保证数据的正确性、有效性和相容性。</p></li><li><p>并发（Concurrency）控制<br>对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</p></li><li><p>数据库恢复（Recovery）<br>将数据库从错误状态恢复到某一已知的正确状态。</p></li></ul></li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/1610783335629.jpg" alt="在这里插入图片描述"></p><h2 id="数据模型">数据模型</h2><ul><li><p>数据模型是对现实世界数据特征的抽象。</p></li><li><p>通俗地讲数据模型就是现实世界的模拟。</p></li><li><p>数据模型应满足三方面要求</p><ul><li>能比较真实地模拟现实世界</li><li>容易为人所理解</li><li>便于在计算机上实现</li></ul></li><li><p>数据模型是数据库系统的核心和基础</p></li><li><p>数据模型分为两类（两个不同的层次）</p><ul><li>概念模型   也称信息模型<ul><li>它是按用户的观点来对数据和信息建模，用于数据库设计。</li></ul></li><li>逻辑模型和物理模型<ul><li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。按计算机系统的观点对数据建模，用于DBMS实现。</li><li>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</li></ul></li></ul></li><li><p>客观对象的抽象过程—两步抽象</p><ul><li>现实世界中的客观对象抽象为概念模型；<br>将现实世界抽象为信息世界</li><li>把概念模型转换为某一数据库管理系统支持的数据模型。<br>将信息世界转换为机器世界</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/1610783713995.jpg" alt="在这里插入图片描述"></p><h3 id="概念模型">概念模型</h3><ul><li>概念模型的用途<ul><li>概念模型用于信息世界的建模</li><li>是现实世界到机器世界的一个中间层次</li><li>是数据库设计的有力工具</li><li>数据库设计人员和用户之间进行交流的语言</li></ul></li><li>对概念模型的基本要求<ul><li>较强的语义表达能力</li><li>简单、清晰、易于用户理解</li></ul></li></ul><h5 id="信息世界中的基本概念">信息世界中的基本概念</h5><ul><li>实体（Entity）<br>客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。</li><li>属性（Attribute）<br>实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。</li><li>码（Key）<br>唯一标识实体的属性集称为码。</li><li>实体型（Entity Type）<br>用实体名及其属性名集合来抽象和刻画同类实体称为实体型</li><li>实体集（Entity Set）<br>同一类型实体的集合称为实体集</li><li>联系（Relationship）<ul><li>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。</li><li>实体内部的联系通常是指组成实体的各属性之间的联系</li><li>实体之间的联系通常是指不同实体集之间的联系</li><li>实体之间的联系有一对一、一对多和多对多等多种类型</li></ul></li></ul><h5 id="概念模型的一种表示方法：实体-联系方法（Entity-Relationship-Approach）">概念模型的一种表示方法：实体-联系方法（Entity-Relationship Approach）</h5><ul><li>用E-R图来描述现实世界的概念模型</li><li>E-R方法也称为E-R模型</li></ul><h3 id="数据模型的组成要素">数据模型的组成要素</h3><h4 id="数据结构">数据结构</h4><ul><li>数据模型的数据结构</li><li>描述数据库的组成对象，以及对象之间的联系</li><li>描述的内容<ol><li>与对象的类型、内容、性质有关</li><li>与数据之间联系有关</li></ol></li><li>数据结构是对系统静态特性的描述</li></ul><h4 id="数据操作">数据操作</h4><ul><li>数据操作<br>对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则</li><li>数据操作的类型<br>查询、更新（包括插入、删除、修改）</li><li>数据模型对操作的定义<ul><li>操作的确切含义</li><li>操作符号</li><li>操作规则（如优先级）</li><li>实现操作的语言</li></ul></li><li>数据操作是对系统动态特性的描述</li></ul><h4 id="数据的完整性约束条件">数据的完整性约束条件</h4><ul><li>一组完整性规则的集合</li><li>完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则</li><li>用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容</li><li>数据模型对完整性约束条件的定义<ul><li>反映和规定必须遵守的基本的通用的完整性约束条件。</li><li>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</li></ul></li></ul><h3 id="常用的数据模型">常用的数据模型</h3><ul><li>层次模型（Hierarchical Model）</li><li>网状模型（Network Model）</li><li>关系模型（Relational Model)）</li><li>面向对象数据模型（Object Oriented Data Model）</li><li>对象关系数据模型（Object Relational Data Model）</li><li>半结构化数据模型（Semistruture Data Model）</li></ul><h3 id="层次模型">层次模型</h3><p>满足下面两个条件的基本层次联系的集合为层次模型</p><ul><li>有且只有一个结点没有双亲结点，这个结点称为根结点</li><li>根以外的其它结点有且只有一个双亲结点</li></ul><p>层次模型中的几个术语</p><ul><li><p>根结点，双亲结点，兄弟结点，叶结点</p></li><li><p>层次模型是数据库系统中最早出现的数据模型</p></li><li><p>层次数据库系统的典型代表是IBM公司的IMS（Information Management System）数据库管理系统</p></li><li><p>层次模型用树形结构来表示各类实体以及实体间的联系</p></li></ul><h4 id="层次模型的特点：">层次模型的特点：</h4><ul><li>结点的双亲是唯一的</li><li>只能直接处理一对多的实体联系</li><li>每个记录类型可以定义一个排序字段，也称为码字段</li><li>任何记录值只有按其路径查看时，才能显出它的全部意义</li><li>没有一个子女记录值能够脱离双亲记录值而独立存在</li></ul><h4 id="层次模型的完整性约束条件">层次模型的完整性约束条件</h4><ul><li>无相应的双亲结点值就不能插入子女结点值</li><li>如果删除双亲结点值，则相应的子女结点值也被同时删除</li><li>更新操作时，应更新所有相应记录，以保证数据的一致性</li></ul><h4 id="优点">优点</h4><ul><li>层次模型的数据结构比较简单清晰</li><li>查询效率高，性能优于关系模型，不低于网状模型</li><li>层次数据模型提供了良好的完整性支持</li></ul><h4 id="缺点">缺点</h4><ul><li>结点之间的多对多联系表示不自然</li><li>对插入和删除操作的限制多，应用程序的编写比较复杂</li><li>查询子女结点必须通过双亲结点</li><li>层次命令趋于程序化</li></ul><h3 id="网状模型">网状模型</h3><ul><li><p>网状数据库系统采用网状模型作为数据的组织方式</p></li><li><p>典型代表是DBTG系统：</p><ul><li>亦称CODASYL系统</li><li>20世纪70年代由DBTG提出的一个系统方案</li></ul></li><li><p>实际系统</p><ul><li>Cullinet  Software公司的 IDMS</li><li>Univac公司的 DMS1100</li><li>Honeywell公司的IDS/2</li><li>HP公司的IMAGE</li></ul></li><li><p>网状模型条件</p></li><li><p>满足下面两个条件的基本层次联系的集合：</p><ul><li>允许一个以上的结点无双亲；</li><li>一个结点可以有多于一个的双亲。</li></ul></li></ul><h4 id="表示方法（与层次数据模型相同）">表示方法（与层次数据模型相同）</h4><ul><li>实体型：用记录类型描述<br>每个结点表示一个记录类型（实体）</li><li>属性：用字段描述<br>每个记录类型可包含若干个字段</li><li>联系：用结点之间的连线表示记录类型（实体）之<br>间的一对多的父子联系</li></ul><h4 id="网状模型与层次模型的区别">网状模型与层次模型的区别</h4><ul><li>网状模型允许多个结点没有双亲结点</li><li>网状模型允许结点有多个双亲结点</li><li>网状模型允许两个结点之间有多种联系（复合联系）</li><li>网状模型可以更直接地描述现实世界</li><li>层次模型实际上是网状模型的一个特例</li></ul><h4 id="多对多联系在网状模型中的表示">多对多联系在网状模型中的表示</h4><ul><li>用网状模型间接表示多对多联系</li><li>方法：将多对多联系直接分解成一对多联系</li></ul><h4 id="优点-2">优点</h4><ul><li>能够更为直接地描述现实世界，如一个结点可以有多个双亲</li><li>具有良好的性能，存取效率较高</li></ul><h4 id="缺点-2">缺点</h4><ul><li>结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握</li><li>DDL、DML语言复杂，用户不容易使用</li><li>记录之间联系是通过存取路径实现的，用户必须了解系统结构的细节</li></ul><h3 id="关系模型">关系模型</h3><ul><li><p>关系（Relation）<br>一个关系对应通常说的一张表</p></li><li><p>元组（Tuple）<br>表中的一行即为一个元组</p></li><li><p>属性（Attribute）<br>表中的一列即为一个属性，给每一个属性起一个名称即属性名</p></li><li><p>主码（Key）<br>也称码键。表中的某个属性组，它可以唯一确定一个元组</p></li><li><p>域（Domain）</p><p>是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。</p></li><li><p>分量<br>元组中的一个属性值。</p></li><li><p>关系模式<br>对关系的描述   关系名（属性1，属性2，…，属性n）<br>学生（学号，姓名，年龄，性别，系名，年级）</p></li><li><p>关系必须是规范化的，满足一定的规范条件<br>最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表</p></li></ul><table><thead><tr><th><strong>关系术语</strong></th><th><strong>一般表格的术语</strong></th></tr></thead><tbody><tr><td><strong>关系名</strong></td><td><strong>表名</strong></td></tr><tr><td><strong>关系模式</strong></td><td><strong>表头（表格的描述）</strong></td></tr><tr><td><strong>关系</strong></td><td><strong>（一张）二维表</strong></td></tr><tr><td><strong>元组</strong></td><td><strong>记录或行</strong></td></tr><tr><td><strong>属性</strong></td><td><strong>列</strong></td></tr><tr><td><strong>属性名</strong></td><td><strong>列名</strong></td></tr><tr><td><strong>属性值</strong></td><td><strong>列值</strong></td></tr><tr><td><strong>分量</strong></td><td><strong>一条记录中的一个列值</strong></td></tr><tr><td><strong>非规范关系</strong></td><td><strong>表中有表（大表中嵌有小表）</strong></td></tr></tbody></table><ul><li>关系的完整性约束条件<ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li></ul><h4 id="优点-3">优点</h4><ul><li>建立在严格的数学概念的基础上</li><li>概念单一<ul><li>实体和各类联系都用关系来表示</li><li>对数据的检索结果也是关系</li></ul></li><li>关系模型的存取路径对用户透明<ul><li>具有更高的数据独立性，更好的安全保密性</li><li>简化了程序员的工作和数据库开发建立的工作</li></ul></li></ul><h4 id="缺点-3">缺点</h4><ul><li>存取路径对用户透明，查询效率往往不如格式化数据模型</li><li>为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度</li></ul><h2 id="数据库系统的结构">数据库系统的结构</h2><ul><li><p>从数据库应用开发人员角度看</p><p>数据库系统通常采用三级模式结构，是数据库系统内部的系统结构</p></li><li><p>从数据库最终用户角度看，数据库系统的结构分为:</p><ul><li>单用户结构</li><li>主从式结构</li><li>分布式结构</li><li>客户-服务器</li><li>浏览器-应用服务器／数据库服务器多层结构等</li></ul></li></ul><h3 id="数据库系统模式的概念">数据库系统模式的概念</h3><ul><li><p>“型” 和“值” 的概念</p><ul><li>型（Type）<br>对某一类数据的结构和属性的说明</li><li>值（Value）<br>是型的一个具体赋值</li></ul></li><li><p>例如<br>学生记录：<br>（学号，姓名，性别，系别，年龄，籍贯）<br>一个记录值：<br>（201315130，李明，男，计算机系，19，江苏南京市）</p></li><li><p>模式（Schema）</p><ul><li>数据库逻辑结构和特征的描述</li><li>是型的描述，不涉及具体值</li><li>反映的是数据的结构及其联系</li><li>模式是相对稳定的</li></ul></li><li><p>实例（Instance）</p><ul><li>模式的一个具体值</li><li>反映数据库某一时刻的状态</li><li>同一个模式可以有很多实例</li><li>实例随数据库中的数据的更新而变动</li></ul></li></ul><h3 id="数据库系统的三级模式结构">数据库系统的三级模式结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/1610790172929.jpg" alt="在这里插入图片描述"></p><h4 id="模式（Schema）">模式（Schema）</h4><ul><li>模式（也称逻辑模式）<ul><li>数据库中全体数据的逻辑结构和特征的描述</li><li>所有用户的公共数据视图</li></ul></li><li>一个数据库只有一个模式</li><li>模式的地位：是数据库系统模式结构的中间层<ul><li>与数据的物理存储细节和硬件环境无关</li><li>与具体的应用程序、开发工具及高级程序设计语言无关</li></ul></li><li>模式的定义<ul><li>数据的逻辑结构（数据项的名字、类型、取值范围等）</li><li>数据之间的联系</li><li>数据有关的安全性、完整性要求</li></ul></li></ul><h4 id="外模式（External-Schema）">外模式（External Schema）</h4><ul><li>外模式（也称子模式或用户模式）<ul><li>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</li><li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li></ul></li><li>外模式的地位：介于模式与应用之间<ul><li>模式与外模式的关系：一对多<ul><li>外模式通常是模式的子集</li><li>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</li><li>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同</li></ul></li><li>外模式与应用的关系：一对多<ul><li>同一外模式也可以为某一用户的多个应用系统所使用</li><li>但一个应用程序只能使用一个外模式</li></ul></li></ul></li><li>外模式的用途<ul><li>保证数据库安全性的一个有力措施</li><li>每个用户只能看见和访问所对应的外模式中的数据</li></ul></li></ul><h4 id="内模式（Internal-Schema）">内模式（Internal Schema）</h4><ul><li>内模式（也称存储模式）<ul><li>是数据物理结构和存储方式的描述</li><li>是数据在数据库内部的表示方式<ul><li>记录的存储方式（例如，顺序存储，按照B树结构存储，按hash方法存储等）</li><li>索引的组织方式</li><li>数据是否压缩存储</li><li>数据是否加密</li><li>数据存储记录结构的规定</li></ul></li></ul></li><li>一个数据库只有一个内模式</li></ul><h3 id="数据库的二级映像功能与数据独立性">数据库的二级映像功能与数据独立性</h3><ul><li>三级模式是对数据的三个抽象级别</li><li>二级映象在数据库管理系统内部实现这三个抽象层次的联系和转换<ul><li>外模式／模式映像</li><li>模式／内模式映像</li></ul></li></ul><h4 id="外模式-模式映像">外模式/模式映像</h4><ul><li>模式：描述的是数据的全局逻辑结构</li><li>外模式：描述的是数据的局部逻辑结构</li><li>同一个模式可以有任意多个外模式</li><li>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</li><li>映象定义通常包含在各自外模式的描述中</li><li>保证数据的逻辑独立性<ul><li>当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变</li><li>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li></ul></li></ul><h4 id="模式-内模式映像">模式/内模式映像</h4><ul><li><p>模式/内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。</p><ul><li>例如，说明逻辑记录和字段在内部是如何表示的</li></ul></li><li><p>数据库中模式/内模式映象是唯一的</p></li><li><p>该映象定义通常包含在模式描述中</p></li><li><p>保证数据的物理独立性</p><ul><li>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变。</li><li>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li></ul></li><li><p>数据库模式</p><ul><li>即全局逻辑结构是数据库的中心与关键</li><li>独立于数据库的其他层次</li><li>设计数据库模式结构时应首先确定数据库的逻辑模式</li></ul></li><li><p>数据库的内模式</p><ul><li>依赖于它的全局逻辑结构</li><li>独立于数据库的用户视图，即外模式</li><li>独立于具体的存储设备</li><li>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率</li></ul></li><li><p>数据库的外模式</p><ul><li>面向具体的应用程序</li><li>定义在逻辑模式之上</li><li>独立于存储模式和存储设备</li><li>当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动</li><li>设计外模式时应充分考虑到应用的扩充性</li></ul></li><li><p>特定的应用程序</p><ul><li>在外模式描述的数据结构上编制的</li><li>依赖于特定的外模式</li><li>与数据库的模式和存储结构独立</li><li>不同的应用程序有时可以共用同一个外模式</li></ul></li><li><p>数据库的二级映像</p><ul><li>保证了数据库外模式的稳定性</li><li>从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改</li></ul></li><li><p>数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去</p></li><li><p>数据的存取由数据库管理系统管理</p><ul><li>简化了应用程序的编制</li><li>大大减少了应用程序的维护和修改</li></ul></li></ul><h2 id="数据库系统的组成">数据库系统的组成</h2><ul><li>数据库</li><li>数据库管理系统（及其开发工具）</li><li>应用程序</li><li>数据库管理员</li><li>硬件平台及数据库</li><li>软件</li><li>人员</li></ul><h3 id="硬件平台及数据库">硬件平台及数据库</h3><ul><li>数据库系统对硬件资源的要求</li><li>足够大的内存</li><li>足够的大的磁盘或磁盘阵列等设备</li><li>较高的通道能力，提高数据传送率</li></ul><h3 id="软件">软件</h3><ul><li>数据库管理系统</li><li>支持数据库管理系统运行的操作系统</li><li>与数据库接口的高级语言及其编译系统</li><li>以数据库管理系统为核心的应用开发工具</li><li>为特定应用环境开发的数据库应用系统</li></ul><h3 id="人员">人员</h3><h4 id="数据库管理员">数据库管理员</h4><ul><li>监控数据库的使用和运行<ul><li>周期性转储数据库<ul><li>数据文件</li><li>日志文件</li></ul></li><li>系统故障恢复</li><li>介质故障恢复</li><li>监视审计文件</li></ul></li><li>数据库的改进和重组<ul><li>性能监控和调优</li><li>定期对数据库进行重组织，以提高系统的性能</li><li>需求增加和改变时，数据库须需要重构造</li></ul></li></ul><h4 id="系统分析员和数据库设计人员">系统分析员和数据库设计人员</h4><ul><li>系统分析员<ul><li>负责应用系统的需求分析和规范说明</li><li>与用户及数据库管理员结合，确定系统的硬软件配置</li><li>参与数据库系统的概要设计</li></ul></li><li>数据库设计人员<ul><li>参加用户需求调查和系统分析</li><li>确定数据库中的数据</li><li>设计数据库各级模式</li></ul></li></ul><h4 id="应用程序员">应用程序员</h4><ul><li>设计和编写应用系统的程序模块</li><li>进行调试和安装</li></ul><h4 id="用户">用户</h4><ul><li>用户是指最终用户（End User）。最终用户通过应用系统的用户接口使用数据库。</li><li>偶然用户<ul><li>不经常访问数据库，但每次访问数据库时往往需要不同的数据库信息</li><li>企业或组织机构的高中级管理人员</li></ul></li><li>简单用户<ul><li>主要工作是查询和更新数据库</li><li>银行的职员、机票预定人员、旅馆总台服务员</li></ul></li><li>复杂用户<ul><li>工程师、科学家、经济学家、科技工作者等</li><li>直接使用数据库语言访问数据库，甚至能够基于数据库管理系统的应用程序接口编制自己的应用程序</li></ul></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Back End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 | 第六章 应用层</title>
      <link href="2021/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>2021/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1>1. 概述</h1><p>因为不同的网络应用之间需要有一个确定的通信规则<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702215803534.png" alt="在这里插入图片描述"></p><h2 id="1-1-两种常用的网络应用模型">1.1 两种常用的网络应用模型</h2><h3 id="1-1-1-客户-服务器模型（Client-Server）">1.1.1 客户/服务器模型（Client/Server）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702220439646.png" alt="在这里插入图片描述"></p><h3 id="1-1-2-P2P模型（Peer-to-Peer）">1.1.2 P2P模型（Peer-to-Peer）</h3><p>网络健壮性指的是P2P模型不容易坏掉，即使一个节点坏了也没问题，可以有其他节点代替<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702220544850.png" alt="在这里插入图片描述"></p><h1>2. 域名系统协议（DNS）</h1><h2 id="2-1-概述">2.1 概述</h2><p>DNS就是将打在地址栏的域名转化为IP地址的东西<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702220920296.png" alt="在这里插入图片描述"></p><h3 id="2-1-1-域名">2.1.1 域名</h3><p><a href="http://xn--www-q33er8owvhvrt.xxx.com">域名就是www.xxx.com</a>，当然这是最简单的一种<br>.com之后还可以有东西，称之为根<br>域名从左向右，级别逐渐增高<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702221601437-20210325234906861.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702221626114-20210325234910604.png" alt="在这里插入图片描述"></p><h2 id="2-2-域名服务器（DNS服务器）">2.2 域名服务器（DNS服务器）</h2><p>DNS服务器有很多台，根据层次结构分为三层，根域名服务器，顶级域名服务器，权限域名服务器<br>本地域名服务器不算层次结构，特点是里主机比较近，当主机和另一台比较近的主机通信时，就不用走哪些更高级的服务器了<br>根域名服务器并不是一个域名只有一台，而是一个域名对应多台域名服务器，全世界一共有13个这样的域名，<a href="http://xn--a-uc8ale040g.rootservers.net">分别是a.rootservers.net</a>，<a href="http://b.rootservers.net">b.rootservers.net</a>，<a href="http://c.rootservers.net">c.rootservers.net</a>，<a href="http://~m.rootservers.net">~m.rootservers.net</a><br>在权限域名服务器中，虽然看似abc.com比y.abc.com少了一位，但是他们的<strong>地位仍是对等的</strong>，对应的两台权限域名服务器<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702222254726.png" alt="在这里插入图片描述"></p><h2 id="2-3-域名解析过程">2.3 域名解析过程</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702223128655.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702223220720.png" alt="在这里插入图片描述"></p><h3 id="2-3-1-递归查询">2.3.1 递归查询</h3><p>在上图中<br>主机先是想本地域名服务器发送请求，如果查不到的话，<br><strong>本地域名服务器</strong>向根域名服务器发送请求（找别人），如果还是查不到的话，<br><strong>根域名域名服务器</strong>向顶级域名服务器发送请求（找别人），如果还是查不到的话，<br><strong>顶级域名服务器</strong>向权限域名服务器发送请求（找别人）<br>可以看到每一次向下一个查询的服务器都变了，不是主机一个个去问，而是<strong>服务器自己一个个问下去</strong></p><h3 id="2-3-2-迭代查询">2.3.2 迭代查询</h3><p>在上图中<br>主机先是想本地域名服务器发送请求，如果查不到的话，<br>本地域名服务器就让<strong>主机</strong>去向根域名服务器发送请求（主机去找，本地域名给目标根域名服务器的IP地址），如果还是查不到的话，<br>根域名域名服务器让<strong>主机</strong>去向对应的顶级域名服务器发送请求（主机去找，根域名给目标顶级域名服务器的IP地址），如果还是查不到的话，<br>顶级域名服务器让<strong>主机</strong>去向权限域名服务器发送请求（主机去找，顶级域名给目标权限域名服务器的IP地址）<br>可以看到这里是<strong>主机</strong>一个个挨个问的地址</p><h3 id="2-3-3-高速缓存">2.3.3 高速缓存</h3><p>为了减少多次查询同一个域名的资源浪费，<strong>本地域名服务器</strong>会存储最近使用的ip地址解析，下次再访问同一个域名就不需要这么多查询步骤了。同时这个高速缓存<strong>主机本身也有存储</strong><br>同时本地域名服务器还可以对顶级域名服务器，权限域名服务器的地址进行缓存，下一次即使是不知道的ip地址，查询也可以更快<br>高速缓存为了保持正确性，需要定时更新</p><h1>3. 文件传输协议（FTP，TFTP）</h1><h2 id="3-1-概述">3.1 概述</h2><p>TFTP是一个轻量的，比较容易实现的，面对小文件的，UDP的文件传输协议<br>这里我们重点是FTP协议<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702224616787.png" alt="在这里插入图片描述"></p><h2 id="3-2-FTP的服务端和客户端">3.2 FTP的服务端和客户端</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702224816512.png" alt="在这里插入图片描述"></p><h2 id="3-3-FTP的工作原理">3.3 FTP的工作原理</h2><p>为什么有匿名登陆：对于一些公共服务器来说，增加验证阶段就是增加资源开销，减少验证阶段就可以节省资源来更好地服务<br>主进程和从属进程的区别：主进程是打开端口，让外部发送的数据可以进来，并且将这些数据逐个分配各从属进程。从属进程则是单独为这些数据服务<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200702225039138.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703000333330.png" alt="在这里插入图片描述"><br>先注释一下这里的主进程被忽略掉了，只是没标在上面，不是没有啊<br>这里客户端和服务器端先建立TCP连接，端口是21，称为控制连接<br>然后看情况是主动建立连接还是被动建立连接<br>主动建立连接是指服务器端主动发送请求和客户端进行连接，此时端口号固定是20<br>被动连接是指客户端发送请求和服务器端建立数据传送连接，此时端口号是不确定，有两者协商得到<br>数据传输完成之后，数据连接断开，控制连接继续保持，直至两边发送断开请求</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703000401174-20210325234926528.png" alt="在这里插入图片描述"><br>FTP的两种传输模式了解即可<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703000905460.png" alt="在这里插入图片描述"></p><h1>4. 电子邮件</h1><h2 id="4-1-概述">4.1 概述</h2><h3 id="4-1-1-电子邮件的格式">4.1.1 电子邮件的格式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703001117831.png" alt="在这里插入图片描述"></p><h3 id="4-1-2-电子邮件系统的组成结构">4.1.2 电子邮件系统的组成结构</h3><p>注释：<br>用户代理的四个功能解释：<br>撰写就是给用户编辑信件的环境<br>显示就是可以看到自己写的和自己收的信件内容<br>处理就是对信件进行操作，包括删除，打印，转发等等<br>通信就是可以将邮件发送到<strong>邮件服务器当中</strong>，同时可以<strong>从邮件服务器当中</strong>读取邮件</p><p>邮件服务器的功能注释<br>邮件服务器端的发送和接受是指从自己的<strong>用户代理处接收邮件</strong>，之后<strong>向对面的邮件服务器发送邮件</strong><br>邮件服务器的报告邮件发送结果就是投递是否成功这种情况<br>邮件服务器既可以作为客户端又可以作为服务器端，使用的是C/S方式</p><p>协议的功能注释<br>发邮件用的是SMTP<br>收邮件的是POP3或者IMAP</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703001436566.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703002119799.png" alt="在这里插入图片描述"></p><h2 id="4-2-几个邮件协议">4.2 几个邮件协议</h2><h3 id="4-2-1-简单邮件传送协议SMTP">4.2.1 简单邮件传送协议SMTP</h3><p>注意一下，这里STMP客户和服务器不是固定死的，可以也可以成为服务器，服务器也可以成为用户，由发送方和接收方决定，发送方就是客户，接收方就是服务器<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703002319315.png" alt="在这里插入图片描述"><br>注释<br>可以看见这里比如</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">220 service ready</span><br><span class="line">250 OK</span><br><span class="line">421 service not available</span><br><span class="line">550 xxx</span><br><span class="line">354 xxx</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>都是应答信息</p><p>这里RCPT能有多条命令的原因是，电子邮件可以有多个收件人，就是群发，所以允许多个RCPT</p><p><strong>再强调一下，这里服务器和客户端可以互换，视具体情况而定，发送方是客户端，接收方是服务器端</strong><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703002844133.png" alt="在这里插入图片描述"></p><h3 id="4-2-2-改进SMTP缺点的MIME协议">4.2.2 改进SMTP缺点的MIME协议</h3><p>MIME改善SMTP发送数据的缺点，是SMTP的功能性扩展<br>MIME协议已经逐渐开始应用到浏览器当中，通过对不同文件类型用不同的标识符标识，来让浏览器读取通过MIME的相关文件<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703003639358.png" alt="在这里插入图片描述"></p><h3 id="4-2-3-邮局协议POP3">4.2.3 邮局协议POP3</h3><p>这里接收方是客户端，邮件服务器是服务器端<br>POP3确实很简单，但是有不少缺点，比较难受的就是邮件一旦下载就自动删除了<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703003942969.png" alt="在这里插入图片描述"></p><h3 id="4-2-4-比较复杂的读取邮件的协议——IMAP协议">4.2.4 比较复杂的读取邮件的协议——IMAP协议</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703004334235.png" alt="在这里插入图片描述"></p><h2 id="4-3-基于万维网的电子邮件">4.3 基于万维网的电子邮件</h2><p>与之前的不同的地方就是，基于万维网的电子邮件的<strong>邮件服务器端可以不同</strong></p><p>同时，发送邮件使用的SMTP/MIME和收邮件时的POP3/IMAP协议都<strong>换成了HTTP协议</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020070300482031.png" alt="在这里插入图片描述"></p><h1>5. 万维网和HTTP协议</h1><h2 id="5-1-万维网概述">5.1 万维网概述</h2><p>URL用来标识整个互联网当中的某一个资源（文字，视屏，音频等）的位置</p><p>HTTP用来将这些资源传送给用户</p><p>HTML帮助设计者来设计页面，让不同设计者设计的页面都可以在界面上显示<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703005114701.png" alt="在这里插入图片描述"></p><h2 id="5-2-HTTP协议">5.2 HTTP协议</h2><h3 id="5-2-1-HTTP协议的过程">5.2.1 HTTP协议的过程</h3><p>这张图里讲了HTTP的具体过程</p><p>服务器通过TCP 80端口来监听HTTP请求</p><p>注意HTTP可以不一次性下载完页面的所有资源，可以只下载文本部分，其他音频视频等待用户下一步请求之后再传输<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703005650472.png" alt="在这里插入图片描述"></p><h3 id="5-2-2-HTTP协议的特点">5.2.2 HTTP协议的特点</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703010043691.png" alt="在这里插入图片描述"></p><h3 id="5-2-3-HTTP的连接方式——持久连接和非持久连接">5.2.3 HTTP的连接方式——持久连接和非持久连接</h3><p>非持久连接在TCP三次握手的<strong>第三次握手时发生</strong>，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。耗时就是RTT*2+文档传输时间。<br>缺点就是这样如果再想传输，那么就需要重新建立TCP连接从头开始</p><p>持久连接和非持久连接类似，都是在第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的TCP连接了</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020070301065437.png" alt="在这里插入图片描述"></p><h4 id="持久连接的两种方式——非流水线和流水线">持久连接的两种方式——非流水线和流水线</h4><p>非流水线就是发一个，确认一个，才能再发下一个<br>流水线就是一个个连着发，然后多个确认<br>和之前说过的停止等待协议，后退N帧协议和选择重传协议很像，忘了的话可以去复习一下<br>开个传送门<a href="https://blog.csdn.net/weixin_45067603/article/details/106980441">计算机网络笔记Part3 数据链路层（Data Link Layer）</a></p><h3 id="5-2-4-HTTP的报文结构">5.2.4 HTTP的报文结构</h3><p>开始行用于区别请求报文和响应报文。可以明显的看到两者第一行的东西都不一样</p><p>请求报文的方法是指命令，就是对所请求的对象进行什么操作，如获取/删除等等<br>URL就是之间说的资源标识符<br>版本是指使用的是什么版本的HTTP协议</p><p>CRLF相当于我们程序里面的<code>；</code>，标识一行的结束。同时，在整个首部行结束时，为了区别首部行和实体主体还会有一行单独的CRLF<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703011608294.png" alt="在这里插入图片描述"><br>这里举了请求报文的例子，和一些常用的状态码</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703012144697.png" alt="在这里插入图片描述"></p><h1>6. 本章思维导图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200703012244338.png" alt="在这里插入图片描述"></p><h1>本章常用中英文对照</h1><p>Server farm 服务器集群<br>Infrastructure 基础设施，或基础架构<br>Self-scalability 自扩展性<br>Timing 实时性<br>Connection-oriented service 面向连接的服务<br>Base HTML file 基本HTML文件<br>Stateless protocol 无状态协议<br>RTT (round-trip time ) 往返时间<br>User agents 用户代理<br>Mail servers 邮件服务器<br>Top-level domain (TLD) servers 顶级域名服务器<br>Authoritative DNS servers P161 权威域名服务器<br>Iterative queries 迭代查询<br>Resource records (RRs) 资源记录<br>Nonpersistent HTTP 非持久HTTP，或非坚持HTTP<br>Persistent HTTP 持久性HTTP，或坚持的HTTP<br>Peer-to-Peer (P2P) Network 对等网络<br>Socket programming 套接字编程</p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 应用层 </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 | 第五章 传输层</title>
      <link href="2021/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>2021/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1>1. 概述</h1><h2 id="1-1-传输层的意义">1.1 传输层的意义</h2><p>网络层可以把数据从一个主机传送到另一个主机，但是没有和进程建立联系。<br>传输层就是讲进程和收到的数据联系到一起，使数据能够为应用服务<br>所以说传输层是主机才有的层次<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630094727731-20210326000249764.png" alt="在这里插入图片描述"></p><h2 id="1-2-传输层的两个协议">1.2 传输层的两个协议</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630094727731-20210326000249764.png" alt="在这里插入图片描述"></p><h2 id="1-3-传输层的寻址和端口">1.3 传输层的寻址和端口</h2><p>端口号只用于计算机分辨本地进程，总共有2^16=65536种端口号，端口号有很多种，不能随便使用<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630095024127-20210326000251433.png" alt="在这里插入图片描述"></p><h3 id="1-3-1-常见的应用程序端口号">1.3.1 常见的应用程序端口号</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630095258962-20210326000251941.png" alt="在这里插入图片描述"></p><h1>2. UDP协议</h1><h2 id="2-1-UDP概述">2.1 UDP概述</h2><p>注释：<br>因为UDP一次发送一个完整报文不会分片，所以需要应用层传输过来的数据不要太大，否则网络层分片任务就很重，但是也不能太小，不然效率较低<br>UDP适合一些实时应用，因为实时应用延迟要求高，需要立即响应<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630095616466-20210326000252430.png" alt="在这里插入图片描述"></p><h2 id="2-2-UDP首部格式">2.2 UDP首部格式</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020063010003161-20210326000252634.png" alt="在这里插入图片描述"></p><h3 id="2-2-1-UDP的校验位构成">2.2.1 UDP的校验位构成</h3><p>这里的伪首部只是用来计算检验和的，计算完了就丢弃，可以见下UDP的校验方式<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630105441329-20210326000252830.png" alt="在这里插入图片描述"></p><h3 id="2-2-2-UDP校验方式">2.2.2 UDP校验方式</h3><h4 id="总结一下步骤：">总结一下步骤：</h4><h5 id="在发送端的时候：">在发送端的时候：</h5><p>1.就是将每一行（4字节）拆成两部分，左右平均2字节大小，将这两字节数据写成二进制，那么2字节一共就需要2*8=16位。此时检验和没有计算，默认填充0，同时如果数据字段不整齐，则用0补齐，这样就可以写出几十行二进制数，如图中方所示<br>2.计算着几十行二进制数按<strong>二进制反码运算求和</strong>，二进制反码运算可以参考<br><a href="https://www.cnblogs.com/jcchan/p/10400504.html">二进制反码求和运算</a><br>得到的最后简介再反码，之后将<strong>反码之后的</strong>放入原来的检验和字段</p><h5 id="在接收端的时候">在<strong>接收端</strong>的时候</h5><p><strong>与发送端的时候不同的是，此时检验和字段不是0了</strong><br>按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和<br>如果最后得到结果全1就是没问题，否则丢弃<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630105526400-20210326000253213.png" alt="在这里插入图片描述"></p><h1>3. TCP协议</h1><h2 id="3-1-TCP协议的特点">3.1 TCP协议的特点</h2><p>TCP必须要建立连接之后才可以进行数据交换，所以TCP是面向连接的<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630194247441-20210326000253627.png" alt="在这里插入图片描述"><br>TCP传输数据是随机切割数据的<img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020063020421472-20210326000253950.png" alt="在这里插入图片描述"></p><h2 id="3-2-TCP报文段的首部">3.2 TCP报文段的首部</h2><p>注释：<br>见上图，可以看到TCP是将数据随机分割后加上TCP头传输的，所以<br>序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号<br>确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据<br>偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630210441410-20210326000254720.png" alt="在这里插入图片描述"><br>窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据<br>紧急指针就是告诉TCP从哪里到哪里是紧急数据<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630212601599-20210326000255421.png" alt="在这里插入图片描述"></p><h3 id="3-2-1-TCP的六个控制位">3.2.1 TCP的六个控制位</h3><h4 id="紧急位URG">紧急位URG</h4><p>URG的特点就是让数据<strong>插队</strong>，URG=1的就会在缓存中被提前到第一个传输<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630211126589-20210326000255606.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630211151331-20210326000341199.png" alt="在这里插入图片描述"></p><h4 id="确认位ACK">确认位ACK</h4><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630211354251-20210326000344882.png" alt="在这里插入图片描述"></p><h4 id="推送为PSH">推送为PSH</h4><p>就是接收端的URG，将PSH=1的数据尽快接收<br>注意一下，如果没有PSH，一般都是接收方缓存满了之后再将数据发送到主机<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630212045298-20210326000348980.png" alt="在这里插入图片描述"></p><h4 id="复位RST">复位RST</h4><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630212049447-20210326000256166.png" alt="在这里插入图片描述"></p><h4 id="同步位SYN">同步位SYN</h4><p>A和B主机要建立连接，就A先发一个报文，其中SYN=1<br>B收到之后也回复一个SYN=1的报文，代表接受连接<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630212152221-20210326000354761.png" alt="在这里插入图片描述"></p><h4 id="终止位FIN">终止位FIN</h4><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630212056958-20210326000358295.png" alt="在这里插入图片描述"></p><h2 id="3-3-TCP连接管理">3.3 TCP连接管理</h2><h3 id="3-3-1-TCP三次握手（建立连接）">3.3.1 TCP三次握手（建立连接）</h3><p>注释：<br>第一段的意思是<br>SYN=1：(A)要建立连接了！<br>seq=x（随机）：因为还没有数据，所以写什么都无所谓</p><p>第二段的意思是<br>SYN=1：我(B)同意你(A)建立连接！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=y（随机）：因为还没有数据，所以写什么都无所谓<br>ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据</p><p>第三段的意思是<br>SYN=0：SYN只有在建立连接时才为1，其他时候均设为0<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=x+1：我(A)发送的报文段的第一个字节就是x+1<br>ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据</p><p>注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630213814996-20210326000256905.png" alt="在这里插入图片描述"></p><h4 id="TCP三次握手特定导致的SYN洪泛攻击">TCP三次握手特定导致的SYN洪泛攻击</h4><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630214925395-20210326000257508.png" alt="在这里插入图片描述"></p><h3 id="3-3-2-TCP四次挥手（连接释放）">3.3.2 TCP四次挥手（连接释放）</h3><p>注释：<br>第一段的意思是<br>FIN=1：(A)要释放连接了！<br>seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的</p><p>第二段的意思是<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）</p><p>第三段的意思是<br>FIN=1：(B)要释放连接了！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）</p><p>第四段的意思是<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据<br>ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据</p><p>为什么需要等待计时2MSL？<br>因为这样可以保证B可以收到A的终止报文段进而进入关闭状态<br>比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630215522825-20210326000411360.png" alt="在这里插入图片描述"></p><h2 id="3-4-TCP可靠传输">3.4 TCP可靠传输</h2><p>TCP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630220542461-20210326000416149.png" alt="在这里插入图片描述"></p><h3 id="3-4-1-序号">3.4.1 序号</h3><p>就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630221424853-20210326000419451.png" alt="在这里插入图片描述"></p><h3 id="3-4-2-确认">3.4.2 确认</h3><p>发送方每一次发送数据之后都需要接收方进行确认。<br>TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中456丢失，78到达，但仍然请求发送的数据序号是4<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630221636424-20210326000258898.png" alt="在这里插入图片描述"></p><h3 id="3-4-3-重传">3.4.3 重传</h3><p>为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630222205619-20210326000259326.png" alt="在这里插入图片描述"></p><h2 id="3-5-TCP流量控制">3.5 TCP流量控制</h2><p>简单来说就是接收方可以动态的发送信息告诉发送方发送窗口的大小。<br>接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了<br>接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/202006302226272-20210326000259692.png" alt="在这里插入图片描述"></p><h3 id="3-5-1-计时器">3.5.1 计时器</h3><p>在本例子中，使用的累计确认机制（一次回复收到ack=201）和三次流量控制机制。<br>但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象<br>解决方法：使用计时器<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630223616929-20210326000300393.png" alt="在这里插入图片描述"></p><h2 id="3-6-TCP拥塞控制">3.6 TCP拥塞控制</h2><p>流量控制是对单独一个来说的，拥塞控制是一群<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630224242515-20210326000300833.png" alt="在这里插入图片描述"></p><h3 id="3-6-1-拥塞控制四种算法">3.6.1 拥塞控制四种算法</h3><p>这里虽然是四种算法，但是通常是两两结合进行使用<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630232411944-20210326000301265.png" alt="在这里插入图片描述"></p><h3 id="3-6-2-慢开始和拥塞避免">3.6.2 慢开始和拥塞避免</h3><p>这里开始时以<strong>指数形式增长</strong>，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。<br>之后一段都是<strong>线性增长</strong>，每次增加1，直至达到网络拥塞状态<br>瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1/2,（这里是24降到12）<br>重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630232910475-20210326000301703.png" alt="在这里插入图片描述"></p><h3 id="3-6-3-快重传和快恢复">3.6.3 快重传和快恢复</h3><p>这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。<br>不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630233701386-20210326000302294.png" alt="在这里插入图片描述"></p><h1>4. 本章思维导图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200630234217765-20210326000303062.png" alt="在这里插入图片描述"></p><h1>本文常用名词中英文对照</h1><p>Multiplexing and demultiplexing 复用与分用<br>Positive acknowledgments 肯定确认<br>Negative acknowledgments 否定确认<br>Countdown timer （倒数）计时器<br>Cumulative acknowledgment 累积确认<br>Receive buffer 接收缓冲区，或接收缓存<br>Resource-management cells 资源管理单元<br>Source (port number) 源端口号<br>Destination (port number) 目的端口号<br>Checksum 校验和<br>Pipelined protocols 流水线（型）协议<br>Go-back-N 回退N<br>Selective Repeat 选择重传<br>Timeout （定时器）超时<br>Fast Retransmit 快速重传<br>Flow Control 流量控制<br>Three way handshake 三次握手<br>sequence number 序列号（简写为seq）<br>acknowledgement number 确认号（简写为ack；注意与大小的ACK不同）<br>Congestion Control 拥塞控制<br>additive increase, multiplicative decrease 加性增乘性减<br>Slow Start 慢启动<br>congestion-avoidance 拥塞避免<br>fast recovery 快速恢复<br>duplicate (ACK) 冗余（ACK）<br>Random Early Detection 随机早期检测</p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
            <tag> 拥塞避免 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 | 第四章 网络层</title>
      <link href="2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>2020/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1>1. 概述</h1><p>注释：<br>数据报和分组的关系：分组是一段比较长的数据，将它进行切割成一段段之后就得到数据报<br>功能一就是让数据在路由器之间走最佳的路径<br>功能二就是让不同的设备（手机，电脑，平板等）都能正常连接<br>功能三见图中解释<br>开环控制就是在拥塞之前就提前设计解决<br>闭环控制就是在拥塞时自动调整解决问题<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628100232914.png" alt="在这里插入图片描述"></p><table><thead><tr><th>OSI参考模型</th><th>各层次的传输单元</th></tr></thead><tbody><tr><td>应用层</td><td>报文</td></tr><tr><td>传输层</td><td>报文段</td></tr><tr><td>网络层</td><td>IP数据报，分组（如果IP数据报太大就切割成分组）</td></tr><tr><td>数据链路层</td><td>帧</td></tr><tr><td>物理层</td><td>比特流</td></tr></tbody></table><h1>2. 数据交换方式</h1><p>为什么要进行数据交换？因为每个节点之间都拉网线太麻烦了也不实际，所以通过大量交换设备互联进行数据交换<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628101240749.png" alt="在这里插入图片描述"></p><h2 id="2-1-电路交换">2.1 电路交换</h2><p>常见的例子：打电话<br>注释：<br>链路支持多路复用（可参考数据链路层的TDM等）<br>特点是独占资源，因为两者建立了连接<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628134105730.png" alt="在这里插入图片描述"></p><h2 id="2-2-报文交换">2.2 报文交换</h2><p>注释：报文发送的过程<br>1.源先根据报文加上ip地址，物理地址等，通过物理层发送<br>2.交换机收到报文之后，先进行存储，等待链路空闲之后进行转发，但是转发的路径不是固定的，是比较随机的<br>3.最后通过许多交换机最终到达目的地<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628134558218.png" alt="在这里插入图片描述"></p><h2 id="2-3-分组交换">2.3 分组交换</h2><p>分组交换和报文交换基本相同，就是将报文切割之后再进行发送<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628135456570.png" alt="在这里插入图片描述"></p><h2 id="2-4-分组交换和报文交换的具体计算对比">2.4 分组交换和报文交换的具体计算对比</h2><p>注释：是怎么计算的？<br>报文交换：一共三段，每段都需要10000bit/1000bps=10s，三段就是3x10=30s<br>分组交换：可以分为两段，一个是第一个数据开始发到最后一个数据从源发出，一段是最后一个数据到达目的地。第一段总时间是10000bit/1000bps=10s，第二段总时间是（10/1000）*2=0.02s，所以总时间是10.02s。<br>理解一下，这里就是报文交换的时候，由于报文没有分割，所以即使先到的数据也不能先发走，只能等到最后一段报文全部到了之后才能一起走，相对于分组交换明显拖慢了前面数据的速度，所以导致报文交换明显慢于分组交换<br>可以看到分组交换明显快于报文交换，所以我们通常使用分组交换<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628140059520.png" alt="在这里插入图片描述"></p><h3 id="2-4-1-分组传输的两种传输方式-数据报与虚电路">2.4.1 分组传输的两种传输方式-数据报与虚电路</h3><h4 id="综述">综述</h4><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628141302754.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628151011994.png" alt="在这里插入图片描述"></p><h4 id="数据报">数据报</h4><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628150810177.png" alt="在这里插入图片描述"></p><h4 id="虚电路">虚电路</h4><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628150941414.png" alt="在这里插入图片描述"></p><h1>3. 路由算法和路由协议概述</h1><p>路由算法就是让路由知道收到报文之后下一步怎么走<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062815165630.png" alt="在这里插入图片描述"><br>AS就是多个路由器之间构成的单独的小圈子，圈子内使用自己的协议，圈子和圈子之间用的是BGP协议<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062815185760.png" alt="在这里插入图片描述"></p><h2 id="3-1-RIP协议和距离向量算法">3.1 RIP协议和距离向量算法</h2><h3 id="3-1-1-RIP协议概述">3.1.1 RIP协议概述</h3><p>通过交换信息构建路由表<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629105637285.png" alt="在这里插入图片描述"></p><h3 id="3-1-2-如何建立路由表">3.1.2 如何建立路由表</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629105916914.png" alt="在这里插入图片描述"></p><h3 id="3-1-3-RIP协议报文格式">3.1.3 RIP协议报文格式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629111259211.png" alt="在这里插入图片描述"></p><h3 id="3-1-4-RIP协议特点">3.1.4 RIP协议特点</h3><p>就是来回更新路由表，错误信息被覆盖，导致直至达到距离上限强制错误时才可以得知出错<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629111526974.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629111637786.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629111700886.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629111718198.png" alt="在这里插入图片描述"></p><h3 id="3-1-5-距离向量算法">3.1.5 距离向量算法</h3><p>注释：<br>为什么改地址？因为图中是从x得到的信息<br>为什么距离固定+1？因为路由器只从相邻路由器之间获取RIP报文，举例只会是1<br>为什么下一跳是x就要替换？因为网络环境不断变化，可能这次某个节点挂掉，所以保持最新的<br>为什么下一跳不是x时有更新和不处理两种手段？因为这样可以提高效率，比原来快就换，比原来慢就保留原来的，也可以理解<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629110232985.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062911085927.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629111155473.png" alt="在这里插入图片描述"></p><h2 id="3-2-OSPF协议和链路状态算法">3.2 OSPF协议和链路状态算法</h2><h3 id="3-2-1-OSPF协议概述">3.2.1 OSPF协议概述</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629111933218.png" alt="在这里插入图片描述"></p><h3 id="3-2-2-OSPF的其他特点">3.2.2 OSPF的其他特点</h3><p>为什么OSPF收敛速度快？因为它只是刷新一下链路状态，得知其是否连通，不需要和RIP一样进行对照，而是直接通过Dijilstra算法来自己算出路径<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629115353647.png" alt="在这里插入图片描述"></p><h3 id="3-2-3-链路状态路由算法">3.2.3 链路状态路由算法</h3><p>了解即可<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629115012290.png" alt="在这里插入图片描述"></p><h3 id="3-2-4-OSPF区域">3.2.4 OSPF区域</h3><p>了解即可<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629115212801.png" alt="在这里插入图片描述"></p><h3 id="3-2-5-OSPF分组">3.2.5 OSPF分组</h3><p>了解即可<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629115305114.png" alt="在这里插入图片描述"></p><h2 id="3-3-BGP协议">3.3 BGP协议</h2><h3 id="3-3-1-BGP协议简介">3.3.1 BGP协议简介</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629202605883.png" alt="在这里插入图片描述"></p><h3 id="3-3-2-BGP协议交换信息的过程">3.3.2 BGP协议交换信息的过程</h3><p>了解即可，只需要知道BGP交换协议里面交换的是一组路径向量<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629203846439.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629202751648.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629202816442.png" alt="在这里插入图片描述"></p><h3 id="3-3-3-BGP协议报文格式">3.3.3 BGP协议报文格式</h3><p>BGP是应用层协议<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062920290996.png" alt="在这里插入图片描述"></p><h3 id="3-3-4-BGP协议特点">3.3.4 BGP协议特点</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629203255760.png" alt="在这里插入图片描述"></p><h3 id="3-3-5-BGP的四种报文">3.3.5 BGP的四种报文</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629203720460.png" alt="在这里插入图片描述"></p><h2 id="3-4-三种路由协议的比较">3.4 三种路由协议的比较</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629204214191.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629204241177.png" alt="在这里插入图片描述"></p><h1>4. IP数据报</h1><h2 id="4-1-IP数据报格式">4.1 IP数据报格式</h2><p>注释：</p><table><thead><tr><th>名称</th><th>注释</th><th>大小</th></tr></thead><tbody><tr><td>版本 Version</td><td>ipv4或者ipv6</td><td>4位</td></tr><tr><td>首部长度 IHL</td><td>此处数值再乘以4才是真正大小，同时因为IP数据报固定长度为20字节，所以此处最小值为5，即二进制的0101</td><td>4位</td></tr><tr><td>区分服务 DSCP + ECN</td><td>希望获得哪种服务，用的比较少</td><td>8位</td></tr><tr><td>总长度 Total Length</td><td>首部+数据的长度，最大为2^16-1=65535</td><td>16位</td></tr><tr><td>标识 Identification</td><td>用来表示是哪一个数据报的分片，不同的分片标识各不相同</td><td>8位</td></tr><tr><td>标志 Flags</td><td>用来表示是否分片和分片是否结束</td><td>3位，但实际有用的只有后两位</td></tr><tr><td>片偏移 Fragment Offset</td><td>用来标记分片之后，该分片在原来的数据报的位置，以8字节为单位</td><td>13位</td></tr><tr><td>生存时间 Time To Live</td><td>即TTL，没经过一个路由器TTL-1,0时自动放弃，根据系统不同默认的TTL不同</td><td>8位</td></tr><tr><td>协议 Protocol</td><td>用来标记协议名的字段值，如TCP,UDP,ICMP等等</td><td>8位</td></tr><tr><td>首部检验和 Header Checksum</td><td>检验首部的字段是否出错，出错就丢弃此数据报</td><td></td></tr><tr><td>源地址 Source IP Address</td><td>发送方ip地址</td><td>32位</td></tr><tr><td>目的地址 Destination IP Address</td><td>接收方ip地址</td><td>32位</td></tr><tr><td>可选字段 Options</td><td>用来排错等安全检测</td><td>未知，可在0-40位之间</td></tr><tr><td>填充</td><td>将数据报对齐成4字节的整数倍，数值全部为0</td><td>未知，根据可选字段来定</td></tr></tbody></table><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628163753975.png" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628163922707.png" alt="在这里插入图片描述"><br>计算偏移量时记住是以0开始的就行，以每一篇最开始的除以8得到的数值就是偏移量<br>MF和DF的定义见上图<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628164237523.png" alt="在这里插入图片描述"></p><h1>5. IP</h1><h2 id="5-1-ipv4地址">5.1 ipv4地址</h2><p><strong>全球唯一的</strong>表示某一个主机或者路由器接口的编码</p><h3 id="5-1-1-ip地址分类">5.1.1 ip地址分类</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628165300355.png" alt="在这里插入图片描述"></p><h3 id="5-1-2-特殊ip地址">5.1.2 特殊ip地址</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062816534040-20210325235932370.png" alt="在这里插入图片描述"></p><h3 id="5-1-3-私有ip地址">5.1.3 私有ip地址</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628165703918-20210325235935325.png" alt="在这里插入图片描述"><br>解释一下<br><a href="http://xn--A126-uh5f0ct5b022d3z0axybi60i.xxx.xxx.xxx">为什么A类最大是126.xxx.xxx.xxx</a>？<br>因为网络号最开始第一位是0，一共八位，所以二进制表示位0xxxxxxx，最大就是2^7-1=127，但是因为127.xxx.xxx.xxx是特殊ip地址，所以将其去掉<br><a href="http://xn--B191-uh5f0ct5b022d3z0axybi60i.255.xxx.xxx">为什么B类最大是191.255.xxx.xxx</a>？<br>因为网络号最开始第一位是10，一共八位，所以二进制表示位10xxxxxx，最大就是10111111=191，最小就是10000000=128，无特殊ip地址<br><a href="http://xn--C223-uh5f0ct5b022d3z0axybi60i.255.xxx.xxx">为什么C类最大是223.255.xxx.xxx</a>？<br>因为网络号最开始第一位是110，一共八位，所以二进制表示位110xxxxx，最大就是11011111=223，最小就是10000000=192，无特殊ip地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628173140760.png" alt="在这里插入图片描述"></p><h2 id="5-2-网络地址转换NAT">5.2 网络地址转换NAT</h2><p>注释：连接内网和外网，就是找个代理的用它的ip地址与外面收发数据<br>NAT需要构建NAT转换表，既要存广域网（WAN，外网）也要存局域网（LAN，内网）的ip地址和端口号<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628203040212.png" alt="在这里插入图片描述"></p><h2 id="5-3-子网划分和子网掩码">5.3 子网划分和子网掩码</h2><h3 id="5-3-1-为什么需要子网划分">5.3.1 为什么需要子网划分</h3><p>总结一下，就是ip不够用，所以需要额外整个子网扩展ip<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628203445257.png" alt="在这里插入图片描述"><br>注释：<br>为什么子网好能全0或者全1：因为CIDR编址（可见下一段）<br>为什么主机号不能全0或者全1：因为全0代表本网络，全1代表广播分组<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628203628674.png" alt="在这里插入图片描述"></p><h3 id="5-3-2-子网掩码">5.3.2 子网掩码</h3><p>子网掩码就是用来和ip地址一起计算子网的地址的<br>方法就是讲子网掩码逐位写成二进制然后而原来ip地址进行与运算，就可以得到子网ip地址<br>因为255是11111111，所以如果写着255的话，ip地址和子网ip地址对应的地方的数值就相同<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628204154511.png" alt="在这里插入图片描述"><br>这道题可以看出来，即使子网掩码不同，相同ip地址对应的子网ip地址也可能相同<br>但是子网掩码不同，划分的<strong>子网数目不同</strong><br>为什么划分的子网数目不同？或者说怎么算划分的子网位数目？<br>以255.255.192.0为例，255是11111111即八个1,192是11000000即2个1，一共是8<em>2+2=18个1，一共有32位地址，所以剩余有32-18=14位<br>以255.255.224.0为例，255是11111111即八个1,224是11100000即3个1，一共是8</em>2+3=19个1，一共有32位地址，所以剩余有32-19=13位<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628204442714.png" alt="在这里插入图片描述"><br>这道题先将255.255.252.0计算出一共有8+8+6=22位网络号位<br>所以就有32-22=10位主机号位<br>将180.80.77.55解析，可以知道在77部分某部分开始会用来表示主机号位<br>77的二进制是0100 1101，因为一共有22位网络号位，所以010011 （此处分开） 01，从这个01开始是主机号位。<br>所以用来表示子网ip地址的应该是180.80.76（010011 00）.xxx PS注意76括号内后两位二进制00<br>但是本体是发布广播地址，所以主机号全部都要是1<br>所以应该是180.80.79（010011 11）.255（11111111）注意79括号内后两位二进制11<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062821061359.png" alt="在这里插入图片描述"><br>注释：<br>1.这里特定主机路由就是指找特定的处理这里这个ip地址的路由<br>2.默认路由会将这个数据报发给另一个路由，直至找到对应的路由，或者TTL耗尽被丢弃<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628212251576.png" alt="在这里插入图片描述"></p><h2 id="5-4-无分类编制CIDR">5.4 无分类编制CIDR</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628213057516.png" alt="在这里插入图片描述"><br>使用CIDR可以聚合网络<br>如图，通过缩短前缀，R1和R2就可以合并在206.1.0.0/16的子网下<br>但是这样转发表之中就会有多个匹配结果，所以我们使用<strong>最长前缀匹配</strong><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628214310460.png" alt="在这里插入图片描述"><br>最长前缀匹配就是在计算后符合同一子网的时候，选前缀越长的<br>这道题选B<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628214654941.png" alt="在这里插入图片描述"><br>因为本网络是192.168.5.0/24，就是192.168.5.（0000 0000）/24，将248写成二进制是11111 000，有五个1，所以前五位都可以作为子网的编号，剩下的三位就是用来分配子网内剩余的地址了，因为不能全0或者全1，所以还要减2<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628220204999.png" alt="在这里插入图片描述"></p><h2 id="5-5-ARP协议">5.5 ARP协议</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062822274549.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628222947367.png" alt="在这里插入图片描述"></p><h2 id="5-6-DHCP协议">5.6 DHCP协议</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628223418552.png" alt="在这里插入图片描述"></p><h2 id="5-7-ICMP协议">5.7 ICMP协议</h2><h3 id="5-7-1-ICMP协议概述">5.7.1 ICMP协议概述</h3><p>ICMP，IGMP处于网络层和传输层之间，就是为了更好地转发ip数据报和提高交互成功的几率<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628223751853.png" alt="在这里插入图片描述"></p><h3 id="5-7-2-ICMP差错报告报文">5.7.2 ICMP差错报告报文</h3><h4 id="ICMP差错报告报文如何与IP数据报结合">ICMP差错报告报文如何与IP数据报结合</h4><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629094024680.png" alt="在这里插入图片描述"></p><h4 id="五种ICMP差错报文">五种ICMP差错报文</h4><p>其中源点抑制已废弃不用<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629083834897.png" alt="在这里插入图片描述"></p><h4 id="四种不发送ICMP差错报文的情况">四种不发送ICMP差错报文的情况</h4><p>注释：组播是指由一点到多点，但不是无脑发到所有点，无脑发到所有点的是广播，组播有筛选条件</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629094235772.png" alt="在这里插入图片描述"></p><h3 id="5-7-3-ICMP询问报文">5.7.3 ICMP询问报文</h3><h4 id="四种ICMP询问报文">四种ICMP询问报文</h4><p>后两种是掩码地址请求和回答报文，路由器询问和通告报文，这两个已经废弃不再使用<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629094521489.png" alt="在这里插入图片描述"></p><h3 id="5-7-4-ICMP的应用">5.7.4 ICMP的应用</h3><p>1.ping命令：测试两个主机之间连通性，使用了<strong>ICMP回送请求和回答报文</strong><br>2.traceroute命令：跟踪一个分组从原点到终点的路径，使用了<strong>ICMP时间超过差错报告报文</strong><br><a href="https://blog.csdn.net/llq_200/article/details/81034345">traceroute命令讲解</a></p><h1>6. IPV6</h1><h2 id="6-1-为什么会有IPV6">6.1 为什么会有IPV6</h2><p>就是IPV4地址用完了，从根本上增加ip地址数目，之前讲的NAT和CIDR也只是在IPV4的基础上扩展了IPV4地址数目，治标不治本<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629095311686-20210326000014538.png" alt="在这里插入图片描述"></p><h2 id="6-2-IPV6地址表示形式">6.2 IPV6地址表示形式</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629102621942-20210326000018625.png" alt="在这里插入图片描述"></p><h2 id="6-3-IPV6数据报格式">6.3 IPV6数据报格式</h2><table><thead><tr><th>名称</th><th>作用</th><th>位数</th></tr></thead><tbody><tr><td>版本 Version</td><td>知名协议版本，此处因为是ipv6所以总是6</td><td>4位</td></tr><tr><td>优先级 Traffic Class</td><td>又来区分数据报的类型和优先级</td><td>8位</td></tr><tr><td>流标签 Flow Label</td><td>和ipv4标识某个数据报分片不同，这是对于一整个数据报流的标记</td><td>19位</td></tr><tr><td>有效载荷长度 Payload Length</td><td>指的是扩展首部+数据部分的大小，和ipv4的总长度和首部长度都不同，ipv6的首部长度是固定的40字节</td><td>16位</td></tr><tr><td>下一个首部 Next Header</td><td>基本首部的下一个首部指的是有效载荷里标记的的扩展首部，有效载荷里的扩展首部再指向有效载荷里标记的的扩展首部，直至最后指向数据</td><td>8位</td></tr><tr><td>跳数限制 Hop Limit</td><td>基本相当于ipv4当中的TTL，每到一个路由器-1.减到0时丢弃</td><td>7位</td></tr><tr><td>源地址 Source Address</td><td>发送方ipv6地址</td><td>128位</td></tr><tr><td>目标地址 Destination Address</td><td>接收方ipv6地址</td><td>128位</td></tr></tbody></table><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629095626140.png" alt="在这里插入图片描述"></p><h2 id="6-4-IPV4和IPV6的区别">6.4 IPV4和IPV6的区别</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629102457217.png" alt="在这里插入图片描述"></p><h2 id="6-5-IPV6基本地址类型">6.5 IPV6基本地址类型</h2><table><thead><tr><th>名称</th><th>作用</th><th>要求</th></tr></thead><tbody><tr><td>单播</td><td>一对一通信</td><td>可做源地址，目的地址</td></tr><tr><td>多播</td><td>一对多通信，以前的广播地址当做覆盖所有主机的多播</td><td>可做目的地址</td></tr><tr><td>任播</td><td>一对多当中的一个通信，看似一对多，实则一对一</td><td>可做目的地址</td></tr></tbody></table><h2 id="6-6-IPV4和IPV6之间的过渡">6.6 IPV4和IPV6之间的过渡</h2><p>如果是ipv6的数据报到了ipv4，就用ipv4重新封装，把ipv6数据报前面加上ipv4伪装成ipv4数据报继续传输，直至到了ipv6路由再解开ipv4伪装<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629103250467.png" alt="在这里插入图片描述"></p><h1>7. IP组播（多播）</h1><h2 id="7-1-什么是组播">7.1 什么是组播</h2><p>单播只能一对一，广播必须一对全部，组播就可以是一对全部中的一部分<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629205037734.png" alt="在这里插入图片描述"><br>辅助理解：单播所占资源多<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629210027661.png" alt="在这里插入图片描述"><br>组播明显减轻了压力<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629210108353.png" alt="在这里插入图片描述"></p><h2 id="7-2-IP组播地址">7.2 IP组播地址</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629210330405.png" alt="在这里插入图片描述"></p><h2 id="7-3-硬件组播">7.3 硬件组播</h2><p>就像全F的mac地址代表广播一样，00-10-5E打头的MAC地址就代表组播<br>7为什么最大是00-10-5E-7F-FF-FF？因为只有最后23位决定</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629210827844.png" alt="在这里插入图片描述"></p><h2 id="7-4-IGMP协议与组播路由选择协议">7.4 IGMP协议与组播路由选择协议</h2><h3 id="7-4-1-IGMP协议">7.4.1 IGMP协议</h3><p>注释：IGMP只能知道有没有组播组成员，对有几个组播组成员，成员在哪个地方都不知道<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629211352630.png" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629211613284.png" alt="在这里插入图片描述"></p><h3 id="7-4-2-组播路由选择协议">7.4.2 组播路由选择协议</h3><p>有了这个，成员可以自行找到转发组，自行决定参加哪个组播（就像电视机选台一样）<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629211740525.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629211913501.png" alt="在这里插入图片描述"></p><h1>8. 移动IP</h1><p>移动IP<strong>不等于</strong>动态IP（DHCP获得的）<br>移动IP的可以让用户因为地理原因等等，即使不在内网也可以访问内网的东西</p><h2 id="8-1-移动IP的相关术语">8.1 移动IP的相关术语</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629212218336.png" alt="在这里插入图片描述"></p><h2 id="8-2-移动IP通信过程">8.2 移动IP通信过程</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629212604875.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629220550874.png" alt="在这里插入图片描述"></p><h1>9. 网络层设备</h1><h2 id="9-1-路由器">9.1 路由器</h2><h3 id="9-1-1-路由器的构造">9.1.1 路由器的构造</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629220712123-20210326000053365.png" alt="在这里插入图片描述"></p><h3 id="9-1-2-路由器的输入输出端口构造">9.1.2 路由器的输入输出端口构造</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629221015438-20210326000058634.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629221022561.png" alt="在这里插入图片描述"></p><h3 id="9-1-3-集线器，网桥，路由表几层设备比较">9.1.3 集线器，网桥，路由表几层设备比较</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629221130818.png" alt="在这里插入图片描述"></p><h3 id="9-1-4-路由器的路由表和转发表">9.1.4 路由器的路由表和转发表</h3><p>这里实际上就是对前面知识的复习了<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629221253590.png" alt="在这里插入图片描述"></p><h1>10. 本章思维导图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200629221414448.png" alt="在这里插入图片描述"></p><h1>本章常用名词中英文对照</h1><p>Forwarding table 转发表<br>Virtual-circuit networks 虚电路网络<br>Datagram networks 数据报网络<br>Signaling message 信令报文<br>Active queue management 主动队列管理<br>Head-of-the-line 队头<br>Classless interdomain routing (CIDR) 无类域间路由<br>Plug-and-play 即插即用<br>Anycast 任播<br>Interior gateway protocols 内部网关协议<br>Routing information Protocol 路由信息协议（RIP）<br>Open shortest Path First OSPF 开放最短路径优先<br>Area border routers 区域边界路由器<br>Circuit Switching 电路转换<br>Packet Switching 分组交换</p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
            <tag> IP </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 | 第三章 数据链路层</title>
      <link href="2020/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>2020/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1>1. 基本概念</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627112630722-20210325235642846.png" alt="在这里插入图片描述"></p><h1>2. 封装成帧与透明传输</h1><p><strong>封装成帧</strong>就是加将数据加头加尾，相当于将数据打包<br><strong>透明传输</strong>就是为了防止<strong>特殊的数据无法正常传输</strong>的的情况的发生，比如说在封装成帧的过程中出现数据中的某些标记符与开始/结束标记符恰巧重复等等情况<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627121353485-20210325235635268.png" alt="在这里插入图片描述"></p><h2 id="2-1-透明传输的应用">2.1 透明传输的应用</h2><h3 id="2-1-1-字符计数法">2.1.1 字符计数法</h3><p>就是在帧的首部做<strong>计数</strong>，看看数据是否错误<br>缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧<br>比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627122122260-20210325235631989.png" alt="在这里插入图片描述"></p><h3 id="2-1-2-字符填充法">2.1.2 字符填充法</h3><p>就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，<strong>开始和结束的对应的字符不一样</strong><br>但有可能出现数据内某段比特流数据正好<strong>与标记字段重复</strong>，从而导致误判断的情况<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627122415229-20210325235625160.png" alt="在这里插入图片描述"><br><strong>解决方法：添加转义字符</strong><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627122642435-20210325235622175.png" alt="在这里插入图片描述"></p><h3 id="2-1-3-零比特填充法">2.1.3 零比特填充法</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627122934743-20210325235617030.png" alt="在这里插入图片描述"></p><h3 id="2-1-4-违规编码法">2.1.4 违规编码法</h3><p>因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就<strong>不会与数据冲突</strong><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627123050151-20210325235614510.png" alt="在这里插入图片描述"></p><h1>3. 差错控制</h1><h2 id="3-1-差错是什么，从哪来的">3.1 差错是什么，从哪来的</h2><p>数据链路层的差错检测的是<strong>比特</strong>的错误<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062712365377-20210325235609895.png" alt="在这里插入图片描述"></p><h2 id="3-2-为什么要在数据链路层进行差错控制？">3.2 为什么要在数据链路层进行差错控制？</h2><p>因为错误可以尽早发现，不会让一个错误的数据包发送了很长时间到达最终目的地之后才被发现，从而导致网络资源的浪费</p><h2 id="3-3-检错编码（奇偶校验码，循环冗余码CRC）">3.3 检错编码（奇偶校验码，循环冗余码CRC）</h2><h3 id="3-3-1-奇偶校验码">3.3.1 奇偶校验码</h3><p>缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50%<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627130921199-20210325235605760.png" alt="在这里插入图片描述"></p><h3 id="3-3-2-循环冗余码CRC">3.3.2 循环冗余码CRC</h3><p>就是用传输数据除以生成多项式得到冗余码<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062713153254-20210325235602131.png" alt="在这里插入图片描述"><br>实际例子<br>注释：<br>1.阶数就是最高位是哪位，然后位数-1，如10011就是5-1=4,1011就是4-1=3<br>2.异或运算就是相同得0，不同得1，比如100和101做异或，结果就是001<br>3.出书和最后的余数添加到要发送的数据后面，称为<strong>帧检验序列FCS</strong><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627131633434-20210325235559760.png" alt="在这里插入图片描述"><br>接收方收到数据后进行检测<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627132107709-20210325235553969.png" alt="在这里插入图片描述"><br>需要注意的地方<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627132214691-20210325235551622.png" alt="在这里插入图片描述"></p><h2 id="3-4-纠错编码（海明码）">3.4 纠错编码（海明码）</h2><p>分为四步</p><h3 id="第一步-确认校验码位数r">第一步 确认校验码位数r</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627132546766-20210325235547492.png" alt="在这里插入图片描述"></p><h3 id="第二步-确定校验码和数据的位置">第二步 确定校验码和数据的位置</h3><p>注释：<br>1.为什么是10为数据位？因为4位校验码+6位信息位=10位<br>2.校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627132725336-20210325235544117.png" alt="在这里插入图片描述"></p><h3 id="第三步-求出校验码的值">第三步 求出校验码的值</h3><p>注释<br>1.先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4为，将其标注<br>2.然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位<br>这里有点难理解，这里以p1为例辅助理解，这里找出来的就是P1,D1,D2,D4,D5<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627133356420-20210325235533248.png" alt="在这里插入图片描述"><br>然后计算异或值，比如说这里D1=1,D2=0,D4=1,D5=0,就是p1要同时和<strong>0</strong>,<strong>1</strong>，<strong>0</strong>,<strong>1</strong>进行异或之后得到0，为了标识我加粗原始计算数据<br>举例：<strong>0</strong>和<strong>1</strong>异或得1,1和<strong>0</strong>异或得1,1和<strong>1</strong>异或得0，那么p1和0异或得0，p1就是0了<br>3.其他同理，按顺序计算出P2,P3,P4,然后填入表格<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627133056623-20210325235529785.png" alt="在这里插入图片描述"></p><h3 id="第四步-检测并纠错">第四步 检测并纠错</h3><p>就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627134416184-20210325235524254.png" alt="在这里插入图片描述"></p><h1>4. 数据链路层的流量控制和可靠传输</h1><h2 id="4-1-流量控制与可靠传输">4.1 流量控制与可靠传输</h2><p>流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费<br>可靠传输是发送端发送什么，接收端就要受到什么</p><p>数据链路层流量控制手段：接收方接收不下就不回复确认</p><p>传输层流量控制手段：接收端给发送端一个窗口公告</p><h3 id="4-1-1-停止等待协议（Stop-and-Wait）">4.1.1 停止等待协议（Stop-and-Wait）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627150624453-20210325235518522.png" alt="在这里插入图片描述"><br>停止等待协议的<strong>无差错</strong>情况<br>注释：因为一次就一个，所以用0和1标记ack就行<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627150810912-20210325235515592.png" alt="在这里插入图片描述"><br>停止等待协议的<strong>有差错</strong>情况<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627151008798-20210325235510305.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627151301222-20210325235503771.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627151343650-20210325235459802.png" alt="在这里插入图片描述"><br>停止等待协议的特点<br>1.简单<br>2.信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627151529667-20210325235455096.png" alt="在这里插入图片描述"><img src= "/img/loading.gif" data-lazy-src="http://bloginfo.lebronchao.com/doc-image/20200627151615649-20210325235451725.png" alt="在这里插入图片描述"></p><h3 id="4-1-2-后退N帧协议（GBN）">4.1.2 后退N帧协议（GBN）</h3><p>因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率<br>注释：<br>累计确认：就是收到一个确认帧，那么<strong>它和它之前的所有帧</strong>都默认已收到，反之，如果某个确认帧没收到，那么<strong>它和它之后的所有帧</strong>都默认丢失（即使收到了也丢掉），进行重传</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062715251276-20210325235447954.png" alt="在这里插入图片描述"><br>下图是一个实例<br>注释：此图发送2帧时丢失，所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK，直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627153111466-20210325235440092.png" alt="在这里插入图片描述"><br>发送窗口不能无限大，与使用的编号的比特数有关  Wmax=2^n-1<br>很简单，就是1比特编号0和1,同理2比特编号0-3，如果用1比特编号，却要4个窗口长度，那么窗口内数据编号都编不过来，直接乱套了<br>GBN的优缺点也显而易见，优点是提高了信道利用率，缺点是因为重传机制的原因导致已经收到数据却需要强行丢弃而造成浪费</p><p><strong>GBN协议重点总结</strong></p><ul><li>累计确认（偶尔捎带确认）</li><li>接收方只按顺序接收帧，不按序无情丢弃。</li><li>确认序列号最大的、按序到达的帧</li><li>发送窗口最大为 WTmax=2^n-1，接收窗口WRmax为1</li></ul><h3 id="4-1-3-选择重传协议（SR）">4.1.3 选择重传协议（SR）</h3><p>为了解决GBN的缺点，我们打算尝试只重传错误的帧，这样的话就不用浪费资源吧已经收到的帧再重传一次了。<br>和GBN相比，两者都有窗口了，和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（PS，缓存咋可能无限大）<br>SR运行过程<br>注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口，直至最后2帧收到后一次性确认2-5帧<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627155019851-20210325235435191.png" alt="在这里插入图片描述"><br>同样的，因为编号的问题，发送窗口不能无限大<br>发送窗口最后和接受窗口<strong>大小相同</strong>，这样利用率比较高   Wmax=Tmax=2^(n-1)</p><p><strong>SR协议重点</strong></p><ul><li>对数据帧逐一确认</li><li>只重传出错帧</li><li>接收方有缓存</li><li>WTmax=WRmax=2^(n-1)</li></ul><h1>5. 介质访问控制技术</h1><p>就是让节点之间的通信不会进行相互干扰<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627160903721-20210325235430992.png" alt="在这里插入图片描述"></p><h2 id="5-1-信道划分介质访问控制">5.1 信道划分介质访问控制</h2><p>虽然使用一条共享信道，但是通过多路复用技术组合进行传输，提高了信道的利用率</p><h3 id="5-1-1-频分多路复用FDM">5.1.1 频分多路复用FDM</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062716134134-20210325235427328.png" alt="在这里插入图片描述"></p><h3 id="5-1-2-时分多路复用TDM">5.1.2 时分多路复用TDM</h3><p>TDM的缺点就是利用率低，所以又衍生出了STDM<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627161416465-20210325235423683.png" alt="在这里插入图片描述"></p><h3 id="5-1-3-统计时分复用STDM">5.1.3 统计时分复用STDM</h3><p>STDM的原则是先到先走，满了就发，相对于TDM提高了利用率<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627161525107-20210325235421005.png" alt="在这里插入图片描述"></p><h3 id="5-1-4-码分多路复用CDM">5.1.4 码分多路复用CDM</h3><p>CDM只是做一下记录，暂时还用不到，有需要请自行查找资料<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627161726662-20210325235417707.png" alt="在这里插入图片描述"></p><h3 id="5-1-5波分多路复用WDM">5.1.5波分多路复用WDM</h3><p>光的波长不同，即光的频分多路复用</p><h2 id="5-2-随机访问介质访问控制">5.2 随机访问介质访问控制</h2><p>所有用户都可以随机发送信息，发送时可以占用全部带宽，理论上个人使用时比静态分配信道的速度更快</p><h3 id="5-2-1-ALOHA协议">5.2.1 ALOHA协议</h3><p>纯ALOHA协议缺点：太随性，导致效率低<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627162357969-20210325235412894.png" alt="在这里插入图片描述"><br>时隙ALOHA协议<br>相对于纯ALOHA协议就是固定了发送的时间（只能在一个时间片的开始），提高了效率<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627162650471-20210325235406780.png" alt="在这里插入图片描述"></p><h3 id="5-2-2-CSMA协议">5.2.2 CSMA协议</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627163031462-20210325235403842.png" alt="在这里插入图片描述"></p><table><thead><tr><th>名称</th><th>描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1-坚持CSMA</td><td>发送信息时监听信道，一空闲下来就立即传输，信道忙也一直监听，如果发送时冲突就等待随机时长之后再监听</td><td>立即发送，利用率高</td><td>如果多台设备同时监听，那么会发生冲突</td></tr><tr><td>非坚持CSMA</td><td>发送信息时监听信道，如果空闲就立即传输，信道忙就随机等待一段时间后再监听</td><td>冲突发生的几率减少</td><td>因为需要等待，所以利用率不高</td></tr><tr><td>p-坚持CSMA</td><td>发送信息时监听信道，空闲时以概率p进行传输，概率1-p不传输。信道忙就随机等待一段时间后再监听</td><td>冲突减少的同时效率也比较高</td><td>即使发生冲突也要坚持发送数据，资源被浪费</td></tr></tbody></table><h3 id="5-2-3-CSMA-CD协议">5.2.3 CSMA/CD协议</h3><h4 id="概述">概述</h4><p>就是因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞<br>知道自己发生碰撞的最长时间是2τ（两倍的<strong>传播时延</strong>），就是一去一回<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627172333977-20210325235355847.png" alt="在这里插入图片描述"><br>图示传播时延对载波监听的影响<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627181945643-20210325235353336.png" alt="在这里插入图片描述"><img src= "/img/loading.gif" data-lazy-src="http://bloginfo.lebronchao.com/doc-image/20200627183458233.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627182153577-20210325235253009.png" alt="在这里插入图片描述"><br>由此我们可以想到最小帧长的问题，因为如果帧太短，帧都发送完了才检测到碰撞导致停止，导致无法停止碰撞<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062718350424-20210325235248407.png" alt="在这里插入图片描述"></p><h3 id="5-2-4-CSMA-CA协议">5.2.4 CSMA/CA协议</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627184714796-20210325235239437.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627184823659-20210325235236260.png" alt="在这里插入图片描述"></p><h3 id="5-2-5-CSMA-CD-与-CSMA-CA的区别">5.2.5 CSMA/CD 与 CSMA/CA的区别</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062718532038-20210325235232474.png" alt="在这里插入图片描述"></p><h2 id="5-3-轮询访问介质访问控制">5.3 轮询访问介质访问控制</h2><p>主要包括两大类，一个是<strong>轮询协议</strong>，另一个是<strong>令牌传递协议</strong></p><h3 id="5-3-1-轮询协议">5.3.1 轮询协议</h3><p>就是选出一个代表，让他控制所有的传输<br>注释：<br>轮询开销在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销<br>等待延迟就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应<br>单点故障很好理解，就是代表挂了</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627190229529-20210325235228118.png" alt="在这里插入图片描述"></p><h3 id="5-3-2-令牌传递协议">5.3.2 令牌传递协议</h3><p>注释：在节点之间没有收发数据的需求时，令牌在节点之间循环。<br>发送数据的流程<br>》当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲-&gt;占用）<br>》再将令牌与数据帧结合，让其在节点构成的环之间流动<br>》不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌<br>》最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍<br>问题基本和轮询协议相同</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627205055826-20210325235223271.png" alt="在这里插入图片描述"></p><h1>6.局域网</h1><h2 id="6-1-局域网的概念">6.1 局域网的概念</h2><p>概括：范围大小，速度快，延迟低，节点平等<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627210439299-20210325235219036.png" alt="在这里插入图片描述"></p><h3 id="6-1-1-局域网的网络拓扑结构">6.1.1 局域网的网络拓扑结构</h3><p>常用的是<strong>总线型拓扑</strong><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627210700283-20210325235214861.png" alt="在这里插入图片描述"></p><h3 id="6-1-2-局域网的传播介质">6.1.2 局域网的传播介质</h3><table><thead><tr><th>局域网</th><th>常用介质</th></tr></thead><tbody><tr><td>有线局域网</td><td>双绞线，同轴电缆，光纤</td></tr><tr><td>无线局域网</td><td>电磁波</td></tr></tbody></table><h3 id="6-1-3-局域网介质访问方法">6.1.3 局域网介质访问方法</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627210926529-20210325235209860.png" alt="在这里插入图片描述"></p><h2 id="6-2-局域网的分类">6.2 局域网的分类</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627211026206-20210325235203538.png" alt="在这里插入图片描述"></p><h2 id="6-3-IEEE802标准">6.3 IEEE802标准</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627211306397-20210325235159285.png" alt="在这里插入图片描述"></p><h3 id="6-3-1-IEEE802描述的局域网参考模型">6.3.1 IEEE802描述的局域网参考模型</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627211401404-20210325235156423.png" alt="在这里插入图片描述"></p><h2 id="6-4以太网">6.4以太网</h2><h3 id="6-4-1-以太网概念">6.4.1 以太网概念</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627211606200-20210325235153574.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627211721247-20210325235150337.png" alt="在这里插入图片描述"></p><h3 id="6-4-2-以太网的发展">6.4.2 以太网的发展</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627224030441-20210325235148469.png" alt="在这里插入图片描述"></p><h3 id="6-4-3-适配器和MAC地址">6.4.3 适配器和MAC地址</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627224149350-20210325235145687.png" alt="在这里插入图片描述"></p><h3 id="6-4-4-以太网MAC帧">6.4.4 以太网MAC帧</h3><p>注释：<br>1.这里的mac层指的是数据链路层<br>2.之前说过数据链路层将上一层ip数据包加头加尾<br>头就是目标地址（6字节），源地址（6字节），类型（2字节）<br>尾就是FCS（帧检验序列），（4字节）<br>3.前导码<strong>不是MAC帧的一部分</strong>，目的是使时钟同步<br>4.为什么数据长度时46~1500？<br>因为有最小传输字节64字节，mac占用6+6+2+4=18，所以数据最小为64-18=46，1500则是规定的默认最大字节，没有理由</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627224520210-20210325235142277.png" alt="在这里插入图片描述"></p><h3 id="6-4-5-10BASE-T以太网">6.4.5 10BASE-T以太网</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627225136362-20210325235139098.png" alt="在这里插入图片描述"></p><h3 id="6-4-6-高速以太网">6.4.6 高速以太网</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627224252903-20210325235136465.png" alt="在这里插入图片描述"></p><h2 id="6-5-无线局域网">6.5 无线局域网</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627230045240-20210325235132699.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627230109894-20210325235122955.png" alt="在这里插入图片描述"></p><h3 id="6-5-1-两种无线局域网">6.5.1 两种无线局域网</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627230151259.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627230158897-20210325235119837.png" alt="在这里插入图片描述"></p><h1>7.广域网</h1><h2 id="7-1-广域网的概述">7.1 广域网的概述</h2><p>概括一下，一个字大<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627230316639-20210325235115394.png" alt="在这里插入图片描述"></p><h2 id="7-2-PPP协议（Point-to-Point-Protocol）">7.2 PPP协议（Point-to-Point Protocol）</h2><p>PPP协议是目前<strong>使用最广泛</strong>的数据链路层协议，拨号基本都是PPP协议<br>PPP协议<strong>仅支持全双工</strong>链路</p><h3 id="7-2-1-PPP协议需要满足的要求">7.2.1 PPP协议需要满足的要求</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627230948785-20210325235110701.png" alt="在这里插入图片描述"></p><h3 id="7-2-2-PPP协议不需要满足的要求">7.2.2 PPP协议不需要满足的要求</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627230916385-20210325235106985.png" alt="在这里插入图片描述"></p><h3 id="7-2-3-PPP协议组成成分以及功能">7.2.3 PPP协议组成成分以及功能</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627231054259-20210325235103914.png" alt="在这里插入图片描述"></p><h3 id="7-2-4-PPP协议的帧格式">7.2.4 PPP协议的帧格式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062723121486-20210325235058310.png" alt="在这里插入图片描述"></p><h2 id="7-3-HDLC协议（High-Level-Data-Link-Control）">7.3 HDLC协议（High-Level Data Link Control）</h2><h3 id="7-3-1-HDLC协议概述">7.3.1 HDLC协议概述</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627231345512.png" alt="在这里插入图片描述"></p><h3 id="7-3-2-HDLC的三种站">7.3.2 HDLC的三种站</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/202006272314286-20210325235053240.png" alt="在这里插入图片描述"></p><h3 id="7-3-3-HDLC的帧格式">7.3.3 HDLC的帧格式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627231635817-20210325235050451.png" alt="在这里插入图片描述"></p><h2 id="7-4-PPP协议和HDLC协议对比">7.4 PPP协议和HDLC协议对比</h2><p>为什么HDLC协议更可靠，但是我们使用PPP协议？<br>因为现在网络要求高，数据链路层本来就是不可靠的尽力传输，差错控制这些复杂的交给了TCP等<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062723171761-20210325235046889.png" alt="在这里插入图片描述"></p><h1>8. 链路层设备</h1><h2 id="8-1-集线器（Hub）">8.1 集线器（Hub）</h2><p>可以扩展以太网，但是集线器会无脑将一个设备的所有消息转发到集线器所连的所有设备，故会将所连接的<strong>所有设备</strong>变成一个大的冲突域，同时只能有两台设备进行通信，且设备越多，冲突越多。由此诞生了网桥</p><h2 id="8-2-网桥（Bridge）">8.2 网桥（Bridge）</h2><p>使用网桥时，由于网桥会根据mac地址进行过滤，所以<strong>不会形成冲突域</strong><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628000638789-20210325235042775.png" alt="在这里插入图片描述"></p><h3 id="8-2-1-两种网桥">8.2.1 两种网桥</h3><h4 id="透明网桥">透明网桥</h4><p>通过自学习来构建转发表。每一个通过网桥的数据包都会被记录下网桥收到数据时<strong>数据对应的地址</strong>和<strong>网桥自己的接口</strong>，通过许许多多的数据包的构造的缓存，网桥就可以知道哪个数据包在哪个接口，以后如果要穿数据包就知道要往哪个接口发送数据包了</p><h4 id="源路由网桥">源路由网桥</h4><p>在发送时，直接将最佳路径放到帧首部。那么网桥如何获得最佳路径？通过广播方式想目标地址发送广播，此时可能会经过不同路由产生不同的路径，目标地址收到后再将每一条路径都发一个响应帧给网桥，网桥经过对比就知道哪个接口最快了</p><h2 id="8-3-交换机">8.3 交换机</h2><p>网桥接口越来越多，网桥就变成了交换机<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/2020062800263617-20210325235038938.png" alt="在这里插入图片描述"></p><h2 id="8-4-冲突域和广播域">8.4 冲突域和广播域</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628001124492-20210325235035588.png" alt="在这里插入图片描述"></p><h1>9. 本章总结思维导图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200628002730615-20210325235032583.png" alt="在这里插入图片描述"></p><h1>本章常用中英文对照</h1><p>End system 端系统<br>Modem 调制解调器（俗称：猫）<br>Base station 基站<br>Communication link 通信链路<br>Physical media 物理介质<br>Coaxial cable 同轴电缆<br>Fiber optics 光纤<br>Radio spectrum 射频频谱<br>Transmission rate 传输速率<br>Packets （数据）包，或分组<br>Routers 路由器<br>Path 路径<br>ISP (Internet Service Provider) 网络服务提供商<br>FDM (frequency-division multiplexing) 频分多路复用<br>TDM (time-division multiplexing) 时分多路复用<br>Statistical Multiplexing 统计复用<br>Store-and-forward 存储转发<br>Queuing delays 排队延迟<br>Transmission delay 传输延迟，或发送延迟<br>Propagation delay 传播延迟<br>Throughput 吞吐量<br>Internet backbone 骨干网<br>Delay 延迟，或时延<br>Loss 丢包<br>Message 消息，或报文<br>Segment （报文）段<br>Datagram 数据报<br>Frames 帧</p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 数据链路层 </tag>
            
            <tag> 中继器 </tag>
            
            <tag> 交换机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 | 第二章 物理层</title>
      <link href="2020/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>2020/12/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1>1. 基本概念</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626212252286-20210325234741966.png" alt="在这里插入图片描述"></p><h1>2. 数据通信基本知识</h1><h2 id="2-1-一个数据通信例子">2.1 一个数据通信例子</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626212614182-20210325234739329.png" alt="在这里插入图片描述"></p><h2 id="2-2-相关术语">2.2 相关术语</h2><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626212816152-20210325234723091.png" alt="在这里插入图片描述"></p><h2 id="2-3-三种通讯方式">2.3 三种通讯方式</h2><table><thead><tr><th>名称</th><th>英文</th><th>定义</th><th>需要信道条数</th></tr></thead><tbody><tr><td>单工通信</td><td>Simplex</td><td>只能一个发一个收</td><td>一条</td></tr><tr><td>半双工通信</td><td>half-duplex</td><td>都可以发或者收，但是同一时间只能进行一个</td><td>两条</td></tr><tr><td>全双工通信</td><td>duplex</td><td>都可以同时收发数据</td><td>两条</td></tr></tbody></table><h2 id="2-4-两种数据传输方式">2.4 两种数据传输方式</h2><table><thead><tr><th>传输方式</th><th>特点</th></tr></thead><tbody><tr><td>串行传输</td><td>速度慢，省钱，适合远距离</td></tr><tr><td>并行传输</td><td>速度快，耗钱，适合近距离</td></tr></tbody></table><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626213810764-20210325234443821.png" alt="在这里插入图片描述"></p><h2 id="2-5-码元（Symbol）">2.5 码元（Symbol）</h2><p>定义：码元是指用一个固定时长的信号波形（数字脉冲），代表离散数值的基本波形。当有多个离散状态时，成为M进制码元<br>一个码元可以携带多个比特的信息<br>个人理解：码元就是在网线上传输的一个个信号段。码元的不同进制就是用来表示不同的数值的</p><h2 id="2-6-波特（Baud）">2.6 波特（Baud）</h2><p>用来指一秒可以传输多少个码元</p><h2 id="2-7-速率">2.7 速率</h2><p>分为<strong>码元传输速率</strong>和<strong>信息传输速率</strong><br>信息传输速率就是b/s，就是我们平常说的<strong>网速</strong><br>码元可以理解为几个比特的<strong>集合</strong>，所以信息传输速率（网速）=码元传输速率x码元所带信息量（多少比特）<br>码元所带信息量（比特数）=log2（码元进制数）</p><h2 id="2-8-带宽（Band-Width）">2.8 带宽（Band Width）</h2><p>用来表示最高数据速率</p><h2 id="2-9-奈式准则（Nyquist）">2.9 奈式准则（Nyquist）</h2><p><strong>影响失真的因素：</strong></p><ul><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量</li></ul><p>是在<strong>理想状态下</strong>得出的结论<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626222053679-20210325234715370.png" alt="在这里插入图片描述"></p><h2 id="2-10-香农公式（Shannon）">2.10 香农公式（Shannon）</h2><p>是在<strong>有噪声的信道中</strong>得出的结论<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626225409541-20210325234712403.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626225547833-20210325234709585.png" alt="在这里插入图片描述"></p><h2 id="2-11-基带信号和宽带-带通信号（Base-band，pass-band）">2.11 基带信号和宽带/带通信号（Base band，pass band）</h2><p>计算机网络中用的基带信号是<strong>数字信号</strong><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626225921565-20210325234706296.png" alt="在这里插入图片描述"></p><h2 id="2-12-编码">2.12 编码</h2><p>将数据转化为<strong>数字信号</strong><br>数字数据(digtal data)通过 数字发送器(digit emitter) 转化为 数字信号(digtal signal)<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626154459852-20210325234546619.png" alt="在这里插入图片描述"><br>模拟数据(analog data)通过 PCM编码器(PCM coder) 转化为 数字信号 (digtal signal)<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626154431937-20210325234551135.png" alt="在这里插入图片描述"></p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/IMG_0263.jpg" alt="在这里插入图片描述" style="zoom:200%;" /><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/1609077210240-20210325234444429.jpg" alt="在这里插入图片描述"></p><h2 id="2-13-调制：数据转化为模拟信号（了解）">2.13 调制：数据转化为模拟信号（了解）</h2><p>常用的调制方法：调频(AM)，调频(FM)，调相(PM)<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626165059865-20210325234533500.png" alt="在这里插入图片描述"><br>模拟数据(analog data)通过 放大器、调制器(modulaotr) 转化为 模拟信号 (analog signal)<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626154409879-20210325234527254.png" alt="在这里插入图片描述"></p><p>数字数据(digtal data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal)<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626154455793.png" alt="在这里插入图片描述"></p><h1>3. 物理层传输介质</h1><p>传输介质分为<strong>导向性</strong>传输介质和<strong>非导向性</strong>传输介质</p><table><thead><tr><th>导向性传输介质</th><th>电磁波沿着固体媒介（铜线or光纤）被导向传播</th></tr></thead><tbody><tr><td>非导向性传输介质</td><td>自由空间，如空气，水等等</td></tr></tbody></table><h2 id="3-1-常见的导向性传输介质">3.1 常见的导向性传输介质</h2><h3 id="3-1-1-双绞线">3.1.1 双绞线</h3><p>根据有无屏蔽层分为**屏蔽双绞线（STP）*<em>和*<em>无屏蔽双绞线（UTP）</em></em><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627110148375-20210325234522462.png" alt="在这里插入图片描述"></p><h3 id="3-1-2-同轴电缆（Coaxial-Cable）">3.1.2 同轴电缆（Coaxial Cable）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627110353962-20210325234517608.png" alt="在这里插入图片描述"></p><h3 id="3-1-3-光纤（Optical-fiber）">3.1.3 光纤（Optical fiber）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627110509407-20210325234513877.png" alt="在这里插入图片描述"><br>根据<strong>入射角</strong>不同，又分为单模光纤和多模光纤<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627110700437-20210325234509517.png" alt="在这里插入图片描述"></p><p><strong>光纤的特点：</strong></p><ul><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性好。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。</li></ul><h2 id="3-2-常见的非导向性传输介质">3.2 常见的非导向性传输介质</h2><p>包括<strong>无线电波</strong>，<strong>微波</strong>，<strong>红外线</strong>和<strong>激光</strong>等<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627110843264-20210325234504252.png" alt="在这里插入图片描述"></p><h1>4. 物理层设备</h1><h2 id="4-1-中继器（RP-repeater）">4.1 中继器（RP repeater）</h2><p>注释：5-4-3规则是为了限制中继器使用次数的，理由可见图<br>5是指不能超过5个网段<br>4是指在这些网段中的物理层网络设备（中继器，集线器）最多不超过4个<br>3是指这些网段中最多只有三个网段挂有计算机<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627111139163-20210325234459419.png" alt="在这里插入图片描述"></p><h2 id="4-2-集线器（Hub）">4.2 集线器（Hub）</h2><p>集线器是个大的冲突域，同时<strong>只能有两个设备进行通讯</strong>，只会传输信号，没有智能。<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627111545392-20210325234455022.png" alt="在这里插入图片描述"></p><h1>5. 本章思维导图</h1><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200627112018411-20210325234450943.png" alt="在这里插入图片描述"></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 物理层 </tag>
            
            <tag> 双绞线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 | 第一章 概述</title>
      <link href="2020/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"/>
      <url>2020/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1>计算机网络概念</h1><h3 id="计算机网络是互连的、自治的计算机集合。">计算机网络是互连的、自治的计算机集合。</h3><h1>第一章 概念、组成、功能和分类</h1><h2 id="计算机网络的功能">计算机网络的功能</h2><h3 id="1-数据通信">1. 数据通信</h3><ul><li>连通性</li></ul><h3 id="2-资源共享">2. 资源共享</h3><ul><li>硬件、软件、数据</li></ul><h3 id="3-分布式处理">3. 分布式处理</h3><ul><li>多台计算机各自承担统一工作任务的不同部分</li></ul><h3 id="4-提高可靠性">4. 提高可靠性</h3><ul><li>替代机</li></ul><h3 id="5-负载均衡">5.负载均衡</h3><h2 id="计算机网路的组成">计算机网路的组成</h2><h3 id="1-组成部分">1. 组成部分</h3><ul><li>硬件</li><li>软件</li><li>协议</li></ul><h3 id="2-工作方式">2. 工作方式</h3><ul><li><p>边缘部分</p><p>用户直接使用，例如主机、服务器，有C/S  P2P方式</p></li><li><p>核心部分</p><p>为边缘部分服务，路由器、交换机、网络等。</p></li></ul><h3 id="3-功能组成">3. 功能组成</h3><ul><li><p>通信子网</p><p>各种传输介质、通信设备、相应的网络协议组成，集线器、中继器（物理层），交换机、网桥（数据链路层），和路由器（网络层）组成，实现数据通信</p></li><li><p>资源子网</p><p>实现资源共享功能 的设备和软件的集合，主要是会话层、表示层和应用层。</p></li></ul><h2 id="计算机网络的分类">计算机网络的分类</h2><h3 id="1-按分布范围分类">1.按分布范围分类</h3><ul><li><p>广域网WAN</p><p>交换技术</p></li><li><p>城域网MAN</p></li><li><p>局域网LAN</p><p>广播技术</p></li><li><p>个人区域网PAN</p></li></ul><h3 id="2-按使用者分类">2. 按使用者分类</h3><ul><li><p>公用网</p><p>供应商提供公用网络，例如中国电信、联通、移动。</p></li><li><p>专用网</p><p>例如军事专用网，政府专用网。</p></li></ul><h3 id="3-按交换技术分类">3. 按交换技术分类</h3><ul><li>电路交换</li><li>报文交换</li><li>分组交换</li></ul><h3 id="4-按拓扑结构分类">4. 按拓扑结构分类</h3><ul><li>总线型</li><li>星型</li><li>环形</li><li>网状型</li></ul><h3 id="5-按传输技术分类">5. 按传输技术分类</h3><ul><li><p>广播式网络</p><p>共享公共通信信道</p></li><li><p>点对点网络</p><p>使用分组存储转发和路由选择机制</p></li></ul><h2 id="标准化工作">标准化工作</h2><ul><li><p>法定标准</p><p>由权威机构制定的正式的、合法的标准。例如OSI</p></li><li><p>事实标准</p><p>某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准。例如TCP/IP</p></li></ul><h3 id="RFC（Request-For-Comment）-因特网标准的形式">RFC（Request For Comment）-----因特网标准的形式</h3><p>RFC要上升为因特网正式标准的四个阶段：</p><ol><li>因特网草案，这个阶段还不是RFC文档。</li><li>建议标准，从这个阶段开始成为RFC文档。</li><li>草案标准</li><li>因特网标准</li></ol><h3 id="标准化工作的相关组织">标准化工作的相关组织</h3><ul><li><p>国际标准化组织ISO</p><p>例如OSI参考模型、HDLC协议等</p></li><li><p>国际电信联盟ITU</p><p>例如指定通信规则</p></li><li><p>国际电器电子工程师协会IEEE</p><p>学术机构、IEEE802系列标准、5G</p></li><li><p>Internet工程任务组IETF</p><p>负责因特网相关标准的指定  RFC XXXX</p></li></ul><h2 id="1-速率相关性能指标">1. 速率相关性能指标</h2><h3 id="1-1-速率">1.1 速率</h3><p>定义：连接在计算机网络上的主机在数字信道上传送数据位数的速率<br>单位:b/s,Kb/s,Mb/s,Tb/s，<br>如果用字节表示，则是B/s,KB/s,MB/s,TB/s<br>1Byte=8Bit</p><h3 id="1-2-带宽">1.2 带宽</h3><p>在计算机网络中，指的是网络设备所支持的最高速度，单位同速率，是<strong>理想条件下最高速率</strong></p><h3 id="1-3-吞吐量">1.3 吞吐量</h3><p>指的是单位时间内通过某个网络的数据<strong>总</strong>量</p><h3 id="个人理解">个人理解</h3><p>速率就是实际网速，带宽是理论网速（长城宽带警告），吞吐量是一个或多个设备的综合速率，比如说1000m宽带的路由器连着三部手机，每部手机都是10mb/s看片，那么速率就是10mb/s，带宽是宽带的1000m，路由器吞吐量是30mb/s，即三者之和</p><h2 id="2-时延相关指标">2.时延相关指标</h2><h3 id="2-1-时延">2.1 时延</h3><p>时延包括四大类</p><table><thead><tr><th>名称</th><th>描述</th><th>计算公式</th></tr></thead><tbody><tr><td>发送时延</td><td>数据从主机到信道上所用的时间</td><td>发送的数据长度/发送速率</td></tr><tr><td>传播时延</td><td>数据在信道上传播所花费的时间</td><td>信道长度/电磁波在信道上传播的速率</td></tr><tr><td>排队时延</td><td>数据在路由器前等待前面数据处理的时间</td><td>无计算方式</td></tr><tr><td>处理时延</td><td>数据在路由器中处理需求的时间</td><td>无计算方式</td></tr></tbody></table><p>使用高速链路(提高网速)，只能减小发送时延，无法减少其他三个时延</p><h3 id="2-2-时延带宽积">2.2 时延带宽积</h3><p>公式：时延带宽积=传播时延x带宽<br>意思是链路上有多少比特的数据</p><h3 id="2-3往返时延RTT">2.3往返时延RTT</h3><p>从发送方发送数据开始，到接收方确认收到为止所花费的时间<br>RTT=<strong>传播时延</strong>x2+处理时间(有时可能直接忽略)</p><h3 id="2-4-利用率">2.4 利用率</h3><h4 id="2-4-1-信道利用率">2.4.1 信道利用率</h4><p>信道利用率=有数据通过<strong>时间</strong>/有+无数据通过<strong>时间</strong></p><h4 id="2-4-2-网络利用率">2.4.2 网络利用率</h4><p>网络利用率=所有信道利用率加权求平均值</p><h4 id="2-4-3-时延和利用率的关系图">2.4.3 时延和利用率的关系图</h4><p>利用率越高，延迟越大<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626203643244-20210326000457901.png" alt="在这里插入图片描述"></p><h2 id="3-分层结构">3. 分层结构</h2><h3 id="3-1-为什么要分层，分层要做什么">3.1 为什么要分层，分层要做什么</h3><p>（1）发起通信的计算机必须将数据通信的通路进行激活。<br>（2）要告诉网络如何识别目的主机。<br>（3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。<br>（4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。<br>（5）确保差错和意外可以解决。</p><h3 id="3-2分层基本原则">3.2分层基本原则</h3><ul><li>各层之间相互独立，每层只实现一种相对独立的功能。</li><li>每层之间界面自然清晰，易于理解，相互交流尽可能少。</li><li>结构上可分割开。每层都采用最合适的技术来实现。</li><li>保持下层对上册的独立性，上册单向使用下层提供的服务。</li></ul><h3 id="3-3-正式认识分层结构">3.3 正式认识分层结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626204724293-20210326000458258.png" alt="在这里插入图片描述"></p><p><strong>PDU为下一层的SDU</strong></p><h2 id="4-参考模型">4. 参考模型</h2><table><thead><tr><th>名称</th><th>英文</th><th>作用</th></tr></thead><tbody><tr><td>应用层</td><td>Application Layer</td><td>直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等</td></tr><tr><td>表示层</td><td>Presentation Layer</td><td>把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息</td></tr><tr><td>会话层</td><td>Session Layer</td><td>负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接</td></tr><tr><td>传输层</td><td>Transport Layer</td><td>负责端到端通讯，可靠传输，不可靠传输 ，流量控制，复用分用</td></tr><tr><td>网络层</td><td>Network Layer</td><td>负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制</td></tr><tr><td>数据链路层</td><td>Data Link Layer</td><td>帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决)</td></tr><tr><td>物理层</td><td>Physical Layer</td><td>定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快</td></tr></tbody></table><h3 id="4-1-OSI流程简介">4.1 OSI流程简介</h3><p>网络层及以上，每一层都要对上一层发送的数据进行处理（加个头部）<br>数据链路层不仅需要加头部，还需要加尾部<br>物理层什么都不加，只管发送数据（比特流）<br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626205152756-20210326000458685.png" alt="在这里插入图片描述"></p><h4 id="各层次功能：">各层次功能：</h4><ul><li><p>应用层</p><p>功能：应用程序使用，如QQ，右键（SMTP），文件传输(FTP)，万维网（HTTP）</p></li><li><p>表示层</p><p>功能：数据格式交换、数据加解密、数据压缩和恢复</p></li><li><p>会话层</p><p>向表示层实体实体/用户进程提供建立连接并在连接上有序地传输数据，是会话也是建立同步（SYN）</p><p>功能：</p><p>1.建立、管理、终止会话</p><p>2.使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。适用于传输大文件。</p></li><li><p>传输层</p><p>负责主机中两个进程的通信，即端到端（端口）的通信。传输单位是报文段或用户数据报。</p><p>功能：</p><p>1.可靠传输、不可靠传输</p><p>2.差错控制</p><p>3.流量控制</p><p>4.复用分用</p><p>复用：多个应用层进程可同时使用下面运输层的服务。</p><p>分用：运输层把收到的信息分别交付给上面应用层中相应的进程。</p></li><li><p>网络层</p><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。</p><p>功能：</p><p>1.路由选择</p><ul><li>选择最佳路径</li></ul><p>2.流量控制</p><p>3.差错控制</p><p>4.拥塞控制</p></li><li><p>数据链路层</p><p>主要任务是把网络层传下来的数据报组装成帧，传输单位是帧。</p><p>功能:</p><p>1.成帧：定义帧的开始和结束</p><p>2.差错控制（帧错+位错）</p><p>3.流量控制</p><p>4.访问（接入）控制，控制对信道的访问</p></li><li><p>物理层</p><p>主要任务是在物理媒体上实现比特流的透明传输，传输单位是比特。</p><p>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送。</p><p>比特流-&gt;电信号</p><p>功能：</p><p>1.定义接口特性（接口类型、引脚等）</p><p>2.定义传输模式（单工、半双工、全双工）</p><p>3.定义传输速率</p><p>4.比特同步</p><p>5.比特编码</p></li></ul><h3 id="4-2-TCP-IP参考模型">4.2 TCP/IP参考模型</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626205911885-20210326000459018.png" alt="在这里插入图片描述"></p><h3 id="4-3TCP-IP和OSI的异同点">4.3TCP/IP和OSI的异同点</h3><h4 id="相同点：">相同点：</h4><ul><li>都分层</li><li>基于独立的协议栈的概念</li><li>可以实现异构网络互联</li></ul><h4 id="不同点：">不同点：</h4><ul><li><p>OSI定义三点：服务、协议、接口</p></li><li><p>OSI先出现，参考模型先于协议发明，不偏向特定协议</p></li><li><p>TCP/IP设计之初就考虑到异构网互联问题，将IP作为重要层次</p></li><li><p>OSI参考模型网络层：无连接+面向连接，传输层面向连接</p><p>TCP/IP模型：网络层无连接，传输层无连接+面向连接</p></li></ul><h3 id="4-4-五层参考模型及其传输过程简介">4.4 五层参考模型及其传输过程简介</h3><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626210125977-20210326000459422.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/20200626210211625-20210326000459681.png" alt="在这里插入图片描述"></p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React进阶 服务端渲染 Next | 学习笔记</title>
      <link href="2020/11/29/Next-SSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/29/Next-SSR-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Next简介">Next简介</h2><p>Next.js 是一个轻量级的 React 服务端渲染应用框架。有了它我们可以简单轻松的实现React的服务端渲染，从而加快首屏打开速度，也可以作SEO（收索引擎优化了）。在没有Next.js的时候，用React开发需要配置很多繁琐的参数，如Webpack配置，Router配置和服务器端配置等…。如果需要作SEO，要考虑的事情就更多了，怎么样服务端渲染和客户端渲染保持一致就是一件非常麻烦的事情，需要引入很多第三方库。但有了Next.js，这些问题都解决了，使开发人员可以将精力放在业务逻辑上，从繁琐的配置中解放出来。</p><h2 id="Next-js简介和创建项目">Next.js简介和创建项目</h2><blockquote><p>Next.js 是一个轻量级的 React 服务端渲染应用框架。</p></blockquote><p>用一个框架，就要知道它的优点（或者是解决了我们什么问题）:</p><ul><li>完善的React项目架构，搭建轻松。比如：Webpack配置，服务器启动，路由配置，缓存能力，这些在它内部已经完善的为我们搭建完成了。</li><li>自带数据同步策略，解决服务端渲染最大难点。把服务端渲染好的数据，拿到客户端重用，这个在没有框架的时候，是非常复杂和困难的。有了Next.js，它为我们提供了非常好的解决方法，让我们轻松的就可以实现这些步骤。</li><li>丰富的插件帮开发人员增加各种功能。每个项目的需求都是不一样的，包罗万象。无所不有，它为我们提供了插件机制，让我们可以在使用的时候按需使用。你也可以自己写一个插件，让别人来使用。</li><li>灵活的配置，让开发变的更简单。它提供很多灵活的配置项，可以根据项目要求的不同快速灵活的进行配置。</li></ul><p>目前Next.js是React服务端渲染的最佳解决方案，所以如果你想使用React来开发需要SEO的应用，基本上就要使用Next.js。</p><h3 id="手动创建Next-js项目">手动创建Next.js项目</h3><p><strong>第一步： 建立文件夹</strong></p><p>创建一个<code>Next.js</code>项目，可以有两种方法进行，一种是手动创建，另一种是用<code>create-next-app</code>（脚手架）来创建。这节课我们先来进行手动创建，这样虽然麻烦点，但是可以更容易让新手了解过程和原理。</p><p>先在你喜欢的位置新建一个文件夹，名称你也可以自己起，我这里是在D盘里建立了一个叫<code>NextDemo</code>文件夹。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:</span><br><span class="line">mkdir NextDemo</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><p>这里的<code>npm init</code> 是用来把文件夹初始化成可管理的项目的，其实就是在根目录里给你添加了一个<code>package.json</code>的文件。</p><p><strong>第二步：安装所需要的依赖包</strong></p><p>接下来可以使用yarn来安装所需要的项目依赖包，先来安装下面三个<code>react</code>、<code>react-dom</code>和<code>next</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom next</span><br></pre></td></tr></table></figure><p>当让你也可以使用npm来进行安装，npm安装时记得要使用–save</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save react react-dom next</span><br></pre></td></tr></table></figure><p>安装完可以打开<code>package.json</code>文件查看一下<code>dependencies</code>的版本。</p><p><strong>第三步：增加快捷命令</strong></p><p>为了开发时简便的使用Next.js中的操作命令行工具，所以把常用的配置到<code>package.json</code>中，代码如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">   &quot;dev&quot; : &quot;next&quot; ,</span><br><span class="line">   &quot;build&quot; : &quot; next build&quot;,</span><br><span class="line">   &quot;start&quot; : &quot;next start&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p><strong>第四步：创建pages文件夹和文件</strong></p><p>在根目录下，创建一个<code>pages</code>文件夹，这个文件夹是Next规定的，在这个文件夹下写入的文件，Next.js会自动创建对应的路由。有了文件夹以后，在文件下面创建一个<code>index.js</code>文件，这就是我们的首页了,然后用<code>React Hooks</code>的写法，写个最简单的<code>Hello World</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;Hello Next.js&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index</span><br></pre></td></tr></table></figure><p>写好后在终端中使用<code>yarn dev</code>来打开预览，在浏览器中可以看到输出了正确的结果。这节课就到这里，你可以试着去联系一下这种Next.js项目的搭建方法，因为这会让我们更明白Next项目的来龙去脉。</p><h2 id="creact-next-app快速创建Next-js项目">creact-next-app快速创建Next.js项目</h2><p><code>create-next-app</code>可以快速的创建<code>Next.js</code>项目，它就是一个脚手架，有了它只要一句命令就可以把项目需要的依赖包和基本目录都生成，工作中我基本不用手动的形式自己创建，全部使用<code>create-next-app</code>来创建。</p><p>使用脚手架前，需要先进行全局安装。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g create-next-app</span><br></pre></td></tr></table></figure><p>安装完成后，就可以通过<code>create-next-app</code>命令来创建一个Next.js的项目了。</p><h3 id="创建Next-js项目">创建Next.js项目</h3><p>目前可以支持三种方式的创建，分别是用<code>npx</code>,<code>yarn</code>和<code>create-next-app</code>命令来进行安装，安装的结构都是完全一样的，所以就给大家演示其中的一种<code>npx</code>的形式。</p><blockquote><p>npx 是Node自带的npm模块，所以你只要安装了Node都是可以直接使用npx命令的。</p></blockquote><p>但低版本的Node是不带这个命令的，所以你需要手都安装一下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g npx</span></span><br></pre></td></tr></table></figure><p>打开命令提示符工具，然后进入D盘，然后直接用下面的npx命令创建项目。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npx create-next-app next-create</span></span><br></pre></td></tr></table></figure><p>输入后按回车，就会自动给我们进行安装项目需要的依赖。并且会给我们添加好命令。 稍等一会，全部安装完成后，可以进入项目母乳，执行<code>yarn dev</code>来测试项目。</p><p>在浏览器中输入<code>http://localhost:3000/</code>,看到下面的内容，说明项目生成成功. <img src= "/img/loading.gif" data-lazy-src="https://jspang.com/images/nextjs-01.png" alt="Next.js"></p><h3 id="项目结构介绍">项目结构介绍</h3><p>看到结果后，用VSCode打开目录，可以看到已经有了很多自动建立好的文件和文件夹，下面就简单的介绍一下这些它们的用处：</p><ul><li>components文件夹:这里是专门放置自己写的组件的，这里的组件不包括页面，指公用的或者有专门用途的组件。</li><li>node_modules文件夹：Next项目的所有依赖包都在这里，一般我们不会修改和编辑这里的内容。</li><li>pages文件夹：这里是放置页面的，这里边的内容会自动生成路由，并在服务器端渲染，渲染好后进行数据同步。</li><li>static文件夹： 这个是静态文件夹，比如项目需要的图片、图标和静态资源都可以放到这里。</li><li>.gitignore文件： 这个主要是控制git提交和上传文件的，简称就是忽略提交。</li><li>package.json文件：定义了项目所需要的文件和项目的配置信息（名称、版本和许可证），最主要的是使用<code>npm install</code> 就可以下载项目所需要的所有包。</li></ul><p>当你了解项目目录和文件后就可以试着修改一下项目，简单的尝试一下了。这节课就到这里了，主要讲解的就是利用<code>create-next-app</code>来创建项目和生成项目的基本结构介绍。</p><h2 id="Next-js的Page和Component的使用">Next.js的Page和Component的使用</h2><p>上节课已经利用<code>create-next-app</code>创建了项目，也简单的介绍了一下创建后的项目结构。这节课就来看看如何新建页面和新建组件。</p><h3 id="新建页面和访问路径">新建页面和访问路径</h3><p>直接在根目录下的<code>pages</code>文件夹下，新建一个<code>jspang.js</code>页面。然后写入下面的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jspang</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>技术胖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  Jspang;</span><br></pre></td></tr></table></figure><p>只要写完上面的代码，<code>Next</code>框架就自动作好了路由，这个也算是Next的一个重要优点，给我们节省了大量的时间。</p><p>现在要作一个更深的页面，比如把有关博客的界面都放在这样的路径下<code>http://localhost:3000/blog/nextBlog</code>,其实只要在<code>pages</code>文件夹下再建立一个新的文件夹<code>blog</code>，然后进入<code>blog</code>文件夹，新建一个<code>nextBlog.js</code>文件，就可以实现了。</p><p>nextBlog.js文件内容,我们这里就用最简单的写法了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>nextBlog page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>写完后，就可以直接在浏览器中访问了，是不是发现Next框架真的减轻了我们大量的工作。</p><h3 id="Component组件的制作">Component组件的制作</h3><p>制作组件也同样方便，比如要建立一个jspang组件，直接在<code>components</code>目录下建立一个文件<code>jspang.js</code>,然后写入下面代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;children&#125;)=&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>组件写完后需要先引入，比如我们在Index页面里进行引入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Jspang <span class="keyword">from</span> <span class="string">&#x27;../components/jspang&#x27;</span></span><br></pre></td></tr></table></figure><p>使用就非常简单了，直接写入标签就可以。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Jspang&gt;按钮&lt;/Jspang&gt;</span><br></pre></td></tr></table></figure><p>一个自定义组件的创建和使用也是这么简单， 如果你React的基础很好，那这节课的内容对你来说就更加简单了。也就是说Next框架并没有给我们带来太多的学习成本，但是为我们减轻了很多配置工作。</p><h2 id="路由-基础和基本跳转">路由-基础和基本跳转</h2><p>学会编写组件和页面后，下一步应该了解的就是路由体系，每个框架都有着不同的路由体系，这节先学习最基础的页面如何跳转。页面跳转一般有两种形式，第一种是利用标签<code>&lt;Link&gt;</code>,第二种是用js编程的方式进行跳转，也就是利用<code>Router</code>组件。先来看一下标签的形式如何跳转。</p><h3 id="标签式导航">标签式导航</h3><p>在编写代码之前，先删除<code>index.js</code>中的代码，保证代码的最小化。使用标签式导航需要先进行引入，代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br></pre></td></tr></table></figure><p>然后新建两个页面<code>jspangA.js</code>和<code>jspangB.js</code>，新建后写个最简单的页面，能标识出来A、B两个页面就好。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jspangA.js</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">        &lt;div&gt;Jspang-A page .  &lt;/div&gt;</span><br><span class="line">        &lt;Link href=<span class="string">&quot;/&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>返回首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>写完A页面后，可以直接复制A页面的内容，然后修改一下就是B页面。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jspangB.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">        &lt;div&gt;Jspang-B page .  &lt;/div&gt;</span><br><span class="line">        &lt;Link href=<span class="string">&quot;/&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>返回首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>有了两个页面后，可以编写首页的代码，实现跳转了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;div&gt;我是首页&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/jspangA&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>去JspangA页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/jspangB&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>去JspangB页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure><p>用<code>&lt;Link&gt;</code>标签进行跳转是非常容易的，但是又一个小坑需要你注意一下，就是他不支持兄弟标签并列的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;div&gt;</span><br><span class="line">  &lt;Link href=<span class="string">&quot;/jspangA&quot;</span>&gt;</span><br><span class="line">    &lt;span&gt;去JspangA页面&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;前端博客&lt;/span&gt;</span><br><span class="line">  &lt;/Link&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果这样写会直接报错，报错信息如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client pings, but there&#39;s no entry for page: &#x2F;_error</span><br><span class="line">Warning: You&#39;re using a string directly inside &lt;Link&gt;. This usage has been deprecated. Please add an &lt;a&gt; tag as child of &lt;Link&gt;</span><br></pre></td></tr></table></figure><p>但是你可以把这两个标签外边套一个父标签，就可以了，比如下面的代码就没有错误。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Link href=<span class="string">&quot;/jspangA&quot;</span>&gt;</span><br><span class="line">  &lt;a&gt;</span><br><span class="line">    &lt;span&gt;去JspangA页面&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;前端博客&lt;/span&gt;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>通过标签跳转非常的简单，跟使用<code>&lt;a&gt;</code>标签几乎一样。那再来看看如何用编程的方式进行跳转。</p><h3 id="Router模块进行跳转">Router模块进行跳转</h3><p>在<code>Next</code>框架中还可以使用Router模块进行编程式的跳转，使用前也需要我们引入<code>Router</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span></span><br></pre></td></tr></table></figure><p>然后在<code>Index.js</code>页面中加入，直接使用Router进行跳转就可以了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">   &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;Router.push(<span class="string">&#x27;/jspangA&#x27;</span>)&#125;&#125;&gt;去JspangA页面&lt;/button&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样写只是简单，但是还是耦合性太高，跟Link标签没什么区别，你可以修改一下代码，把跳转放到一个方法里，然后调用方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">gotoA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Router.push(<span class="string">&#x27;/jspangA&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;我是首页&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link href=<span class="string">&quot;/jspangA&quot;</span>&gt;</span><br><span class="line">          &lt;a&gt;</span><br><span class="line">            &lt;span&gt;去JspangA页面&lt;/span&gt;</span><br><span class="line">            &lt;span&gt;前端博客&lt;/span&gt;</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">        &lt;/Link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/jspangB&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>去JspangB页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;gotoA&#125;&gt;去JspangA页面&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure><p>这样也是可以实现跳转的，而且耦合性也降低了,所以个人更喜欢这种跳转方式。这节课主要学习了Next的两种跳转方式，第一种是标签式跳转，第二种是编程式跳转。</p><h2 id="路由-跳转时用query传递和接受参数">路由-跳转时用query传递和接受参数</h2><p>项目开发中一般都不是简单的静态跳转，而是需要动态跳转的。动态跳转就是跳转时需要带一个参数或几个参数过去，然后在到达的页面接受这个传递的参数，并根据参数不同显示不同的内容。比如新闻列表，然后点击一个要看的新闻就会跳转到具体内容。这些类似这样的需求都都是通过传递参数实现的。</p><h3 id="只能用query传递参数">只能用query传递参数</h3><p>这节课作一个例子，通过这个例子来通俗易懂的讲解一下路由带参数的知识。在<code>Next.js</code>中只能通过通过query（<code>?id=1</code>）来传递参数，而不能通过(<code>path:id</code>)的形式传递参数，这个一定要记住，在工作中很容易就容易记混。</p><p>现在我们改写一下pages文件夹下的<code>index.js</code>文件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;我是首页&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link href=<span class="string">&quot;/nba?name=Kobe&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>Kobe牛<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/Link&gt;&lt;br/</span>&gt;</span><br><span class="line">        &lt;Link href=<span class="string">&quot;/nba?name=LeBron&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>LeBorn牛<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure><p>这样编写query参数就可以进行传递过去了，接下来就是要接受参数了。</p><h3 id="接收传递过来的参数">接收传递过来的参数</h3><p>现在还没有小姐姐对应的页面，所以我们要创建<code>nba.js</code>页面，并写下下面的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Nba = <span class="function">(<span class="params">&#123;router&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;&#123;router.query.name&#125;,牛皮 .&lt;/div&gt;</span><br><span class="line">            &lt;Link href=<span class="string">&quot;/&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>返回首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Xiaojiejie)</span><br></pre></td></tr></table></figure><p><code>withRouter</code>是Next.js框架的高级组件，用来处理路由用的，这里先学简单用法，以后还会学习的。通过这种方式就获得了参数，并显示在页面上了。</p><h3 id="编程式跳转传递参数">编程式跳转传递参数</h3><p>回了<code>&lt;Link&gt;</code>这种标签式跳转传递参数的形式，那编程式跳转如何传递那，其实也可以简单使用<code>?加参数</code>的形式，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;div&gt;</span><br><span class="line">  &lt;button onClick=&#123;gotoXiaojiejie&#125;&gt;Kobe&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// gotoNba</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotoNba</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Router.push(<span class="string">&#x27;/nba?name=Kobe&#x27;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这种形式跳转和传递参数是完全没有问题的，但是不太优雅（优雅这东西很难界定，其实你完全可以看成一种装X，这太简单了，我需要装个X），所以也可以写成<code>Object</code>的形式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotoNba</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   Router.push(&#123;</span><br><span class="line">     pathname:<span class="string">&#x27;/nba&#x27;</span>,</span><br><span class="line">     query:&#123;</span><br><span class="line">       name:<span class="string">&#x27;Kobe&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>嗯，这样写确实优雅很多(我们一定要面向对象编程，有对象比没对象要好)。</p><p>其实<code>&lt;Link&gt;</code>标签也可以写成这种形式，比如我们把第一个修改成这种形式.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Link href=&#123;&#123;<span class="attr">pathname</span>:<span class="string">&#x27;/nba&#x27;</span>,<span class="attr">query</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;Kobe&#x27;</span>&#125;&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>选Kobe<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/Link&gt;&lt;br/</span>&gt;</span><br></pre></td></tr></table></figure><p>在浏览器中预览一下，如果一切正常是可以顺利进行跳转，并接收到传递的值。这节课主要讲解了Next框架的路由跳转时带参数过去，然后用<code>withRouter</code>进行接收。</p><h2 id="路由-六个钩子事件的讲解">路由-六个钩子事件的讲解</h2><p>路由的钩子事件，也就是当路由发生变化时，可以监听到这些变化事件，执行对应的函数,它一共有六个钩子事件.</p><h3 id="routerChangeStart">routerChangeStart</h3><p>在监听路由发生变化时，我们需要用Router组件，然后用<code>on</code>方法来进行监听,在<code>pages</code>文件夹下的<code>index.js</code>，然后写入下面的监听事件，这里我们只打印一句话，就不作其他的事情了。代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> Router.events.on(<span class="string">&#x27;routeChangeStart&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1.routeChangeStart-&gt;路由开始变化,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个时路由发生变化时，时间第一时间被监听到，并执行了里边的方法。</p><h3 id="routerChangeComplete">routerChangeComplete</h3><p>路由变化开始时可以监听到，那结束时也时可以监听到的，这时候监听的事件是<code>routerChangeComplete</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Router.events.on(<span class="string">&#x27;routeChangeComplete&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;routeChangeComplete-&gt;路由结束变化,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="beforeHistoryChange-浏览器history触发前">beforeHistoryChange  浏览器history触发前</h3><p>history就是HTML中的API，如果这个不了解可以百度了解一下，<code>Next.js</code>路由变化默认都是通过history进行的，所以每次都会调用。 不适用history的话，也可以通过hash</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Router.events.on(<span class="string">&#x27;beforeHistoryChange&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;3,beforeHistoryChange-&gt;在改变浏览器 history之前触发,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="routeChangeError路由跳转发生错误时">routeChangeError路由跳转发生错误时</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Router.events.on(<span class="string">&#x27;routeChangeError&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;4,routeChangeError-&gt;跳转发生错误,参数为:&#x27;</span>,...args)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是404找不到路由页面不算错误，这个我们就不演示了。</p><h3 id="转变成hash路由模式">转变成hash路由模式</h3><p>还有两种事件，都是针对hash的，所以现在要转变成hash模式。hash模式下的两个事件<code>hashChangeStart</code>和<code>hashChangeComplete</code>,就都在这里进行编写了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Router.events.on(<span class="string">&#x27;hashChangeStart&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;5,hashChangeStart-&gt;hash跳转开始时执行,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Router.events.on(<span class="string">&#x27;hashChangeComplete&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;6,hashChangeComplete-&gt;hash跳转完成时,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在下面的jsx语法部分，再增加一个链接,使用hash来进行跳转，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;Link href=<span class="string">&quot;#jspang&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>选JSPang<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>为了方便你学习，我这里给出<code>index.js</code>的全部代码，你可以在练习时进行参考。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">gotoNba</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Router.push(&#123;</span><br><span class="line">      pathname:<span class="string">&#x27;/nba&#x27;</span>,</span><br><span class="line">      query:&#123;</span><br><span class="line">        name:<span class="string">&#x27;Kobe&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Router.events.on(<span class="string">&#x27;routeChangeStart&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1.routeChangeStart-&gt;路由开始变化,参数为:&#x27;</span>,...args)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Router.events.on(<span class="string">&#x27;routeChangeComplete&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2.routeChangeComplete-&gt;路由结束变化,参数为:&#x27;</span>,...args)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Router.events.on(<span class="string">&#x27;beforeHistoryChange&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3,beforeHistoryChange-&gt;在改变浏览器 history之前触发,参数为:&#x27;</span>,...args)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Router.events.on(<span class="string">&#x27;routeChangeError&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4,routeChangeError-&gt;跳转发生错误,参数为:&#x27;</span>,...args)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Router.events.on(<span class="string">&#x27;hashChangeStart&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;5,hashChangeStart-&gt;hash跳转开始时执行,参数为:&#x27;</span>,...args)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Router.events.on(<span class="string">&#x27;hashChangeComplete&#x27;</span>,<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6,hashChangeComplete-&gt;hash跳转完成时,参数为:&#x27;</span>,...args)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;我是首页&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link href=&#123;&#123;<span class="attr">pathname</span>:<span class="string">&#x27;/nba&#x27;</span>,<span class="attr">query</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;Kobe&#x27;</span>&#125;&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>选Kobe<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/Link&gt;&lt;br/</span>&gt;</span><br><span class="line">        &lt;Link href=<span class="string">&quot;/nba?name=Kobe&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>选Kobe<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;gotoNba&#125;&gt;选Kobe&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">         &lt;Link href=<span class="string">&quot;#jspang&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>选JSPang<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure><h2 id="在getInitialProps中用Axios获取远端数据">在getInitialProps中用Axios获取远端数据</h2><p>在<code>Next.js</code>框架中提供了<code>getInitialProps</code>静态方法用来获取远端数据，这个是框架的约定，所以你也只能在这个方法里获取远端数据。不要再试图在声明周期里获得，虽然也可以在<code>ComponentDidMount</code>中获得，但是用了别人的框架，就要遵守别人的约定。</p><h3 id="安装和引入Axios插件">安装和引入Axios插件</h3><p><code>Axios</code>是目前最或的前端获取数据的插件了，也是由大神首推的数据接口请求插件，我在工作中也是一直在使用它，所以这里依然使用<code>Axios</code>来进行远端数据请求。在请求前需要先安装<code>Axios</code>插件。</p><p>打开终端，直接使用yarn命令进行安装。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add axios</span><br></pre></td></tr></table></figure><p>我使用的版本是<code>0.19.0</code>,可能你学习的时候会稍有变化。安装完成后，在需要的页面中用<code>import</code>引入<code>axios</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br></pre></td></tr></table></figure><p>引入后，就可以使用<code>getInitialProps</code>进行获取后端接口数据了。</p><h3 id="getInitialProps中获取数据">getInitialProps中获取数据</h3><p>在<code>xiaojiejie.js</code>页面中使用<code>getInitialProps</code>，因为是远程获取数据，所以我们采用异步请求的方式。数据存在了<code>Easy Mock</code>中，地址如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.easy-mock.com&#x2F;mock&#x2F;5cfcce489dc7c36bd6da2c99&#x2F;xiaojiejie&#x2F;getList</span><br></pre></td></tr></table></figure><p>(你可以自己作一个数据源，因为这个可能也不稳定，不过半年内应该是可以的)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Xiaojiejie.getInitialProps = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> promise =<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">            axios(<span class="string">&#x27;https://www.easy-mock.com/mock/5cfcce489dc7c36bd6da2c99/xiaojiejie/getList&#x27;</span>).then(</span><br><span class="line">                (res)=&gt;&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;远程数据结果：&#x27;</span>,res)</span><br><span class="line">                    resolve(res.data.data)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得数据后，我们需要把得到的数据传递给页面组件，用<code>&#123;&#125;</code>显示出来就可以了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Xiaojiejie = <span class="function">(<span class="params">&#123;router,list&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;&#123;router.query.name&#125; .&lt;br/&gt;&#123;list&#125;&lt;/div&gt;</span><br><span class="line">            &lt;Link href=<span class="string">&quot;/&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>返回首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就利用Axios从远端获取了数据，这里给出<code>xiaojiejie.js</code>的所有代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Xiaojiejie = <span class="function">(<span class="params">&#123;router,list&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;&#123;router.query.name&#125;.&lt;br/&gt;&#123;list&#125;&lt;/div&gt;</span><br><span class="line">            &lt;Link href=<span class="string">&quot;/&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>返回首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Xiaojiejie.getInitialProps = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> promise =<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">            axios(<span class="string">&#x27;https://www.easy-mock.com/mock/5cfcce489dc7c36bd6da2c99/xiaojiejie/getList&#x27;</span>).then(</span><br><span class="line">                (res)=&gt;&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;远程数据结果：&#x27;</span>,res)</span><br><span class="line">                    resolve(res.data.data)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Xiaojiejie)</span><br></pre></td></tr></table></figure><p>这节课主要学习了在<code>Next.js</code>框架下在<code>getInitialProps</code>方法中利用<code>Axios</code>来获取远端数据的的操作，这个在实际项目中是必备技能，所以需要多练习几遍。</p><h2 id="使用Style-JSX编写页面的CSS样式">使用Style JSX编写页面的CSS样式</h2><p>在<code>Next.js</code>中引入一个CSS样式是不可以用的，如果想用，需要作额外的配置。因为框架为我们提供了一个<code>style jsx</code>特性，也就是把CSS用JSX的语法写出来。如果你以前学过Vue，那这种写法你是非常熟悉的。</p><h3 id="初识Style-JSX语法-把字体设成蓝色">初识<code>Style JSX</code>语法 把字体设成蓝色</h3><p>在<code>pages</code>文件夹下，新建一个<code>jspang.js</code>文件。然后写入下面的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jspang.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jspang</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;技术胖免费前端教程&lt;/div&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Jspang</span><br></pre></td></tr></table></figure><p>这个是一个最简单的页面，只在层中写了一句话。这时候我们想把页面中字的颜色变成蓝色，就可以使用<code>Style JSX</code>语法。直接在<code>&lt;&gt;&lt;/&gt;</code>之间写下如下的代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style jsx&gt;</span><br><span class="line">    &#123;<span class="string">`</span></span><br><span class="line"><span class="string">        div&#123;color:blue;&#125;</span></span><br><span class="line"><span class="string">    `</span>&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>主要所有的css样式需要用<code>&#123;&#125;</code>进行包裹，否则就会报错。这时候你打开浏览器进行预览，字体的颜色就变成了蓝色。</p><h3 id="自动加随机类名-不会污染全局CSS">自动加随机类名 不会污染全局CSS</h3><p>加入了<code>Style jsx</code>代码后，<code>Next.js</code>会自动加入一个随机类名，这样就防止了CSS的全局污染。比如我们把代码写成下面这样，然后在浏览器的控制台中进行查看，你会发现自动给我们加入了类名，类似<code>jsx-xxxxxxxx</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jspang</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;技术胖免费前端教程&lt;/div&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;jspang&quot;</span>&gt;技术胖免费前端教程&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;style jsx&gt;</span><br><span class="line">                &#123;<span class="string">`</span></span><br><span class="line"><span class="string">                    div &#123; color:blue;&#125;</span></span><br><span class="line"><span class="string">                    .jspang &#123;color:red;&#125;</span></span><br><span class="line"><span class="string">                `</span>&#125;</span><br><span class="line">            &lt;/style&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Jspang</span><br></pre></td></tr></table></figure><h3 id="动态显示样式">动态显示样式</h3><p><code>Next.js</code>使用了<code>Style jsx</code>,所以定义动态的CSS样式就非常简单，比如现在要作一个按钮，点击一下，字体颜色就由蓝色变成了红色。下面是实现代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jspang</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//关键代码----------start-------</span></span><br><span class="line">    <span class="keyword">const</span> [color,setColor] = useState(<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changeColor=<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        setColor(color==<span class="string">&#x27;blue&#x27;</span>?<span class="string">&#x27;red&#x27;</span>:<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//关键代码----------end-------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;技术胖免费前端教程&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;changeColor&#125;</span>&gt;</span>改变颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">            &lt;style jsx&gt;</span><br><span class="line">                &#123;<span class="string">`</span></span><br><span class="line"><span class="string">                    div &#123; color:<span class="subst">$&#123;color&#125;</span>;&#125;</span></span><br><span class="line"><span class="string">                `</span>&#125;</span><br><span class="line">            &lt;/style&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Jspang</span><br></pre></td></tr></table></figure><p>这样就完成了CSS的动态显示，是不是非常容易。有了这些知识，可以让我们的页面开始漂亮起来了。</p><h2 id="Lazy-Loading实现模块懒加载">Lazy Loading实现模块懒加载</h2><p>当项目越来越大的时候，模块的加载是需要管理的，如果不管理会出现首次打开过慢，页面长时间没有反应一系列问题。这时候可用<code>Next.js</code>提供的<code>LazyLoading</code>来解决这类问题。让模块和组件只有在用到的时候在进行加载，一般我把这种东西叫做“懒加载”.它一般分为两种情况，一种是懒加载（或者说是异步加载）模块，另一种是异步加载组件。他们使用的方法也稍有不同，下面我们就来分别学习一下。</p><h3 id="懒加载模块">懒加载模块</h3><p>这里使用一个在开发中常用的模块<code>Moment.js</code>，它是一个JavaScript日期处理类库，使用前需要先进行安装，这里使用<code>yarn</code>来进行安装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add momnet</span><br></pre></td></tr></table></figure><p>然后在<code>pages</code>文件夹下，新建立一个<code>time.js</code>文件，并使用刚才的<code>moment</code>库来格式化时间，代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Time</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [nowTime,setTime] = useState(<span class="built_in">Date</span>.now())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changeTime=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        setTime(moment(<span class="built_in">Date</span>.now()).format())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;显示时间为:&#123;nowTime&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;changeTime&#125;</span>&gt;</span>改变时间格式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Time</span><br></pre></td></tr></table></figure><p>这个看起来很简单和清晰的案例，缺存在着一个潜在的风险，就是如何有半数以上页面使用了这个<code>momnet</code>的库，那它就会以公共库的形式进行打包发布，就算项目第一个页面不使用<code>moment</code>也会进行加载，这就是资源浪费，对于我这样有代码洁癖的良好程序员是绝对不允许的。下面我们就通过<code>Lazy Loading</code>来进行改造代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">//删除import moment</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Time</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [nowTime,setTime] = useState(<span class="built_in">Date</span>.now())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changeTime= <span class="keyword">async</span> ()=&gt;&#123; <span class="comment">//把方法变成异步模式</span></span><br><span class="line">        <span class="keyword">const</span> moment = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;moment&#x27;</span>) <span class="comment">//等待moment加载完成</span></span><br><span class="line">        setTime(moment.default(<span class="built_in">Date</span>.now()).format()) <span class="comment">//注意使用defalut</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;显示时间为:&#123;nowTime&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;changeTime&#125;</span>&gt;</span>改变时间格式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Time</span><br></pre></td></tr></table></figure><p>这时候就就是懒加载了，可以在浏览器中按F12，看一下<code>Network</code>标签，当我们点击按钮时，才会加载<code>1.js</code>,它就是<code>momnet.js</code>的内容。</p><h3 id="懒加载自定义组件">懒加载自定义组件</h3><p>懒加载组件也是非常容易的，我们先来写一个最简单的组件，在<code>components</code>文件夹下建立一个<code>one.js</code>文件，然后编写如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Lazy Loading Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>有了自定义组件后，先要在懒加载这个组件的文件中引入<code>dynamic</code>,我们这个就在上边新建的<code>time.js</code>文件中编写了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">&#x27;next/dynamic&#x27;</span></span><br></pre></td></tr></table></figure><p>引入后就可以懒加载自定义模块了，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">&#x27;next/dynamic&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> One = dynamic(<span class="keyword">import</span>(<span class="string">&#x27;../components/one&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Time</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [nowTime,setTime] = useState(<span class="built_in">Date</span>.now())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changeTime= <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> moment = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        setTime(moment.default(<span class="built_in">Date</span>.now()).format())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;显示时间为:&#123;nowTime&#125;&lt;/div&gt;</span><br><span class="line">            &lt;One/&gt;</span><br><span class="line">            &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;changeTime&#125;</span>&gt;</span>改变时间格式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Time</span><br></pre></td></tr></table></figure><p>写完代码后，可以看到自定义组件是懒加载的，只有在<code>jsx</code>里用到<code>&lt;One/&gt;</code>时，才会被加载进来，如果不使用就不会被加载。</p><p>当我们作的应用存在首页打开过慢和某个页面加载过慢时，就可以采用<code>Lazy Loading</code>的形式，用懒加载解决这些问题。</p><h2 id="自定义Head-更加友好的SEO操作">自定义Head 更加友好的SEO操作</h2><p>既然用了<code>Next.js</code>框架，你就是希望服务端渲染，进行SEO操作。那为了更好的进行SEO优化，可以自己定制<code>&lt;Head&gt;</code>标签，定义<code>&lt;Head&gt;</code>一般有两种方式，这节课都学习一下。</p><h3 id="方法1：在各个页面加上Head标签">方法1：在各个页面加上Head标签</h3><p>先在<code>/pages</code>文件夹下面建立一个<code>header.js</code>文件，然后写一个最简单的<code>Hooks</code>页面，代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header</span><br></pre></td></tr></table></figure><p>写完后到浏览器中预览一下，可以发现title部分并没有任何内容，显示的是<code>localhost:3000/header</code>,接下来就自定义下<code>&lt;Head&gt;</code>。自定义需要先进行引入<code>next/head</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span></span><br></pre></td></tr></table></figure><p>引入后你就可以写一些列的头部标签了，全部代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;Head&gt;</span><br><span class="line">                &lt;title&gt;技术胖是最胖的！&lt;/title&gt;</span><br><span class="line">                &lt;meta charSet=<span class="string">&#x27;utf-8&#x27;</span> /&gt;</span><br><span class="line">            &lt;/Head&gt;</span><br><span class="line">            &lt;div&gt;JSPang.com&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/&gt; </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header</span><br></pre></td></tr></table></figure><p>这时候再打开浏览器预览，你发现已经有了<code>title</code>。</p><h3 id="方法2：定义全局的Header">方法2：定义全局的Header</h3><p>这种方法相当于自定义了一个组件，然后把<code>&lt;Head&gt;</code>在组件里定义好，以后每个页面都使用这个组件,其实这种方法用处不大，也不灵活。因为<code>Next.js</code>已经把<code>&lt;Head&gt;</code>封装好了，本身就是一个组件，我们再次封装的意义不大。</p><p>比如在<code>components</code>文件夹下面新建立一个<code>myheader.js</code>,然后写入下面的代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyHeader = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;Head&gt;</span><br><span class="line">                &lt;title&gt; jspang.com &lt;/title&gt;   </span><br><span class="line">            &lt;/Head&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyHeader</span><br></pre></td></tr></table></figure><p>这时候把刚才编写的<code>header.js</code>页面改写一下，引入自定义的<code>myheader</code>，在页面里进行使用，最后在浏览器中预览，也是可以得到<code>title</code>的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Myheader <span class="keyword">from</span> <span class="string">&#x27;../components/myheader&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;Myheader /&gt;</span><br><span class="line">            &lt;div&gt;JSPang.com&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/&gt; </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header</span><br></pre></td></tr></table></figure><p>这节课讲解了一下<code>Next.js</code>的<code>&lt;Head&gt;</code>标签如何使用和自定义，这个在工作中的每个页面都会用到，所以你一定要学会哦。</p><h2 id="Next-js框架下使用Ant-Design-UI">Next.js框架下使用Ant Design UI</h2><p>在Next.js框架下使用 <code>Ant Design</code>，是最近小伙伴们问我最多的一个问题，所以决定单独拿出一节课来讲一下。Ant Design是一款阿里开源的前端组件库，我在工作中也一直在使用，我觉的它是目前阿里开源的前端项目是最成功的,使用人数也是最多的一个。不过它的初心是用来搭建项目的中后台系统，比如后台的管理系统。从React的角度来讲，它就是一个组件库，里边封装了开发中最常用的一些组件，让我们可以通过简单的配置就可以使用他们。</p><h3 id="让Next-js支持CSS文件">让Next.js支持CSS文件</h3><p>在前面的课程中我讲过<code>Next.js</code>默认是不支持CSS文件的，它用的是<code>style jsx</code>，也就是说它是不支持直接用<code>import</code>进行引入<code>css</code>的。</p><p>比如在根目录下新建一个文件夹<code>static</code>（其实正常情况下你应该已经有这个文件了），然后在文件夹下建立一个<code>test.css</code>文件，写入一些<code>CSS Style</code>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用<code>import</code>在<code>header.js</code>里引入。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../static/test.css&#x27;</span></span><br></pre></td></tr></table></figure><p>写完这些后到浏览器中进行预览，没有任何输出结果而且报错了。这说明<code>Next.js</code>默认是不支持CSS样式引入的，要进行一些必要的设置，才可以完成。</p><p><strong>开始进行配置，让Next.js支持CSS文件</strong></p><p>先用<code>yarn</code>命令来安装<code>@zeit/next-css</code>包，它的主要功能就是让<code>Next.js</code>可以加载CSS文件，有了这个包才可以进行配置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @zeit&#x2F;next-css</span><br></pre></td></tr></table></figure><p>包安装好以后就可以进行配置文件的编写了，建立一个<code>next.config.js</code>.这个就是<code>Next.js</code>的总配置文件（如果感兴趣可以自学一下）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> withCss = <span class="built_in">require</span>(<span class="string">&#x27;@zeit/next-css&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">require</span> !== <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.extensions[<span class="string">&#x27;.css&#x27;</span>]=<span class="function"><span class="params">file</span>=&gt;</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = withCss(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>这段代码你有兴趣是可以看看的，其实我对配置文件基本不记忆的，因为配置文件就是别人规定的配置，你写就好。比如要使用CSS就可以把上面这段代码输入到放入到里边的就好了。</p><p>修改配置文件需要重新启一下服务，重启服务可以让配置生效，这时候你到浏览器中可以发现CSS文件已经生效了，字变成了绿色。</p><h3 id="按需加载Ant-Design">按需加载Ant Design</h3><p>加载<code>Ant Design</code>在我们打包的时候会把<code>Ant Design</code>的所有包都打包进来，这样就会产生性能问题，让项目加载变的非常慢。这肯定是不行的，现在的目的是只加载项目中用到的模块，这就需要我们用到一个<code>babel-plugin-import</code>文件。</p><p>**先来安装<code>Ant Design</code>库 **</p><p>直接使用yarn来安装就可以。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add antd</span><br></pre></td></tr></table></figure><p><strong>安装和配置<code>babel-plugin-import</code> 插件</strong></p><p>其实<code>babel-plugin-import</code>我讲Vue.js和Webpack.js的时候都一次讲过这个插件，这里我们就再来讲一下，先进行安装。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add babel-plugin-import</span><br></pre></td></tr></table></figure><p>安装完成后，在项目根目录建立<code>.babelrc</code>文件，然后写入如下配置文件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>:[<span class="string">&quot;next/babel&quot;</span>],  <span class="comment">//Next.js的总配置文件，相当于继承了它本身的所有配置</span></span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>:[     <span class="comment">//增加新的插件，这个插件就是让antd可以按需引入，包括CSS</span></span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;import&quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;libraryName&quot;</span>:<span class="string">&quot;antd&quot;</span>,</span><br><span class="line">                <span class="string">&quot;style&quot;</span>:<span class="string">&quot;css&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置好了以后，<code>webpack</code>就不会默认把整个<code>Ant Design</code>的包都进行打包到生产环境了，而是我们使用那个组件就打包那个组件,同样CSS也是按需打包的。</p><p>通过上面的配置，就可以愉快的在<code>Next.js</code>中使用<code>Ant Desgin</code>，让页面变的好看起来。</p><p>可以在<code>header.js</code>里，引入<code>&lt;Button&gt;</code>组件，并进行使用，代码如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Myheader <span class="keyword">from</span> <span class="string">&#x27;../components/myheader&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;Button&#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../static/test.css&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;Myheader /&gt;</span><br><span class="line">            &lt;div&gt;JSPang.com&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>我是按钮<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/&gt; </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header</span><br></pre></td></tr></table></figure><p>然后到浏览器中查看一下结果，这时候<code>Ant Design</code>已经起作用了，我们也完成了在<code>Next.js</code>中，使用<code>Ant Design</code>的目的。</p><h2 id="Next-js生产环境打包">Next.js生产环境打包</h2><p>大部分的Next.js基础知识都作了讲解，我相信你通过11集视频的学习，也一定能入门<code>Next.js</code>这个框架了，但就在小伙伴准备进行打包项目时，遇到了问题，所谓这节课讲一下如何进行打包和打包中的一些坑。</p><p>其实Next.js大打包时非常简单的，只要一个命令就可以打包成功。但是当你使用了<code>Ant Desgin</code>后，在打包的时候会遇到一些坑。</p><blockquote><p>打包 ：next build</p></blockquote><blockquote><p>运行：next start -p 80</p></blockquote><p>先把这两个命令配置到<code>package.json</code>文件里，比如配置成下面的样子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;next dev&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;next build&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;next start -p 80&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后在终端里运行一下<code>yarn build</code>，如果这时候报错，其实是我们在加入<code>Ant Design</code>的样式时产生的，这个已经在<code>Ant Design</code>的Github上被提出了，但目前还没有被修改，你可以改完全局引入CSS解决问题。</p><p>在page目录下，新建一个<code>_app.js</code>文件，然后写入下面的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;next/app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;antd/dist/antd.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>这样配置一下，就可以打包成功了，然后再运行<code>yarn start</code>来运行服务器，看一下我们的<code>header</code>页面，也是有样式的。说明打包已经成功了。</p><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> React </tag>
            
            <tag> Front End </tag>
            
            <tag> 服务端渲染 </tag>
            
            <tag> SSR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Less 预处理器 | 学习笔记</title>
      <link href="2020/11/28/Less-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/28/Less-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>Less</h1><h3 id="Less">Less</h3><ul><li>Less是一种动态样式语言，属于CSS预处理器的范畴，它扩展了CSS语言，增加了变量、Mixin、函数等特性，使CSS更易维护和扩展</li><li>Less即可以在客户端上运行，也可以借助Node.js在服务端运行。</li></ul><p>Less中文官网：<a href="http://lesscss.cn">http://lesscss.cn</a></p><p>bootstrap中的Less教程:<a href="http://www.bootcss.com/lesscss/">http://www.bootcss.com/lesscss/</a></p><h3 id="Less编译工具">Less编译工具</h3><ul><li>koala官网：<a href="http://www.koala-app.com">www.koala-app.com</a></li></ul><h3 id="Less中的注释">Less中的注释</h3><ul><li>以//开头的注释，不会被编译到CSS文件中（给开发者看）</li><li>以/**/包裹的注释会被编译到CSS文件中（给用户看）</li></ul><h3 id="Less中的变量">Less中的变量</h3><ul><li>用@来声明一个变量 ： @pink:pink;  @selector:#wrap</li><li>作为普通属性值来使用：直接使用@pink</li><li>作为选择器和属性名：@{selector}的形式</li><li>作为URL：@{url}</li><li>变量的延迟加载<ul><li>块级作用域</li><li>先加载所有变量再给属性、属性名、选择器等赋值</li></ul></li></ul><h3 id="Less中的嵌套规则">Less中的嵌套规则</h3><ul><li>基本的嵌套规则</li><li>&amp;的使用<ul><li>使用&amp;表示与父代码块同级（伪类  例如hover）&amp;:hover写在需要描述的选择器的代码块内部</li></ul></li></ul><h3 id="Less中的混合">Less中的混合</h3><ul><li>混合就是将一系列属性从一个规则集引入到另一个规则集的方式</li></ul><h4 id="普通混合">普通混合</h4><ul><li>以类名方式书写和引用（会输出到CSS）</li></ul><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jz为混合</span></span><br><span class="line"><span class="selector-class">.jz</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>:row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="selector-class">.jz</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不带输出的混合">不带输出的混合</h4><ul><li><p>不输出到CSS</p></li><li><p>普通混合的写法+（）</p></li></ul><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jz为混合</span></span><br><span class="line"><span class="selector-class">.jz</span>()&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>:row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="selector-class">.jz</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带参数的混合">带参数的混合</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jz为混合</span></span><br><span class="line"><span class="selector-class">.jz</span>(<span class="variable">@w</span>,<span class="variable">@h</span>,<span class="variable">@c</span>)&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>:row;</span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">@w</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="variable">@h</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">@c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="selector-class">.jz</span>(<span class="number">100px</span>,<span class="number">200px</span>,pink);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带参数并且有默认值的混合">带参数并且有默认值的混合</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jz为混合</span></span><br><span class="line"><span class="selector-class">.jz</span>(<span class="variable">@w</span>:<span class="number">10px</span>,<span class="variable">@h</span>:<span class="number">10px</span>,<span class="variable">@c</span>:white)&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>:row;</span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">@w</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="variable">@h</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">@c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="selector-class">.jz</span>(<span class="number">100px</span>,<span class="number">200px</span>,pink);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命名参数">命名参数</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jz为混合</span></span><br><span class="line"><span class="selector-class">.jz</span>(<span class="variable">@w</span>:<span class="number">10px</span>,<span class="variable">@h</span>:<span class="number">10px</span>,<span class="variable">@c</span>:white)&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>:row;</span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">@w</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="variable">@h</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">@c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="comment">//命名参数</span></span><br><span class="line">    <span class="selector-class">.jz</span>(<span class="variable">@c</span>:pink);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配模式">匹配模式</h4><ul><li>重载思想（函数）</li></ul><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jz为混合</span></span><br><span class="line"><span class="selector-class">.jz</span>(L,<span class="variable">@w</span>:<span class="number">10px</span>,<span class="variable">@h</span>:<span class="number">10px</span>,<span class="variable">@c</span>:white)&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>:row;</span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">@w</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="variable">@h</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">@c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.jz</span>(R,<span class="variable">@w</span>:<span class="number">10px</span>,<span class="variable">@h</span>:<span class="number">10px</span>,<span class="variable">@c</span>:white)&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">width</span>:<span class="variable">@w</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="variable">@h</span>;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">@c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="comment">//命名参数</span></span><br><span class="line">    <span class="selector-class">.jz</span>(L,<span class="variable">@c</span>:pink);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="arguments变量">arguments变量</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.border</span>(<span class="variable">@1</span>,<span class="variable">@2</span>,<span class="variable">@3</span>)&#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="variable">@arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.index</span>&#123;</span><br><span class="line">  <span class="selector-class">.border</span>(<span class="number">1px</span>,solid,black);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Less运算">Less运算</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.width</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:(<span class="number">100</span>+<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Less继承">Less继承</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被继承的类 不能有参数</span></span><br><span class="line"><span class="selector-class">.juzhong</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">  <span class="selector-class">.inner</span>:<span class="selector-tag">extend</span>(.juzhong)&#123;</span><br><span class="line">    <span class="comment">//or &amp;:extend(.juzhong);</span></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">background</span>:pink;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">background</span>:yellow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Less避免编译">Less避免编译</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  <span class="attribute">margin</span>:(<span class="number">10</span>*<span class="number">100px</span>);<span class="comment">//Less运算</span></span><br><span class="line">  <span class="attribute">padding</span>:<span class="string">~&quot;calc(100px+100)&quot;</span>;  <span class="comment">//避免编译  ~&quot;xxx&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> CSS </tag>
            
            <tag> 预处理器 </tag>
            
            <tag> Less </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React进阶 React Hooks | 学习笔记</title>
      <link href="2020/10/21/React%E8%BF%9B%E9%98%B6-React-Hooks-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/10/21/React%E8%BF%9B%E9%98%B6-React-Hooks-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Hooks">React Hooks</h2><h3 id="useState">useState</h3><blockquote><p><code>useState</code>是react自带的一个hook函数，它的作用是用来声明状态变量。</p></blockquote><ul><li>那我们从三个方面来看<code>useState</code>的用法，分别是声明、读取、使用（修改）。这三个方面掌握了，你基本也就会使用<code>useState</code>了.</li><li>先来看一下声明的方式，上节课的代码如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>这种方法是ES6语法中的数组解构，这样看起来代码变的简单易懂。现在ES6的语法已经在工作中频繁使用，所以如果你对ES6的语法还不熟悉，我觉的有必要拿出2天时间学习一下。 如果不写成数组解构，上边的语法要写成下面的三行:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _useState = useState(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> count = _useState[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> setCount = _useState[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li><p><code>useState</code>这个函数接收的参数是状态的初始值(Initial state)，它返回一个数组，这个数组的第0位是当前的状态值，第1位是可以改变状态值的方法函数。 所以上面的代码的意思就是声明了一个状态变量为count，并把它的初始值设为0，同时提供了一个可以改变<code>count</code>的状态值的方法函数。</p></li><li><p>这时候你已经会声明一个状态了，接下来我们看看如何读取状态中的值。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure><ul><li><p>你可以发现，我们读取是很简单的。只要使用<code>&#123;count&#125;</code>就可以，因为这时候的count就是JS里的一个变量，想在<code>JSX</code>中使用，值用加上<code>&#123;&#125;</code>就可以。</p></li><li><p>最后看看如果改变<code>State</code>中的值,看下面的代码:</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure><ul><li><p>直接调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给<code>React</code>,他会重新渲染组件。<code>React</code>自动帮助我们记忆了组件的上一次状态值，但是这种记忆也给我们带来了一点小麻烦，但是这种麻烦你可以看成规则，只要准守规则，就可以愉快的进行编码。</p></li><li><p>比如现在我们要声明多个状态，有年龄（age）、性别(sex)和工作(work)。代码可以这么写.</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ age , setAge ] = useState(<span class="number">18</span>)</span><br><span class="line">    <span class="keyword">const</span> [ sex , setSex ] = useState(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [ work , setWork ] = useState(<span class="string">&#x27;前端程序员&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;JSPang 今年:&#123;age&#125;岁&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;性别:&#123;sex&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;工作是:&#123;work&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example2;</span><br></pre></td></tr></table></figure><ul><li><p>其实细心的小伙伴一定可以发现，在使用<code>useState</code>的时候只赋了初始值，并没有绑定任何的<code>key</code>,那React是怎么保证这三个useState找到它自己对应的state呢？</p></li><li><p><strong>答案是：React是根据useState出现的顺序来确定的</strong></p></li><li><p>比如我们把代码改成下面的样子：</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> showSex = <span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ age , setAge ] = useState(<span class="number">18</span>)</span><br><span class="line">    <span class="keyword">if</span>(showSex)&#123;</span><br><span class="line">        <span class="keyword">const</span> [ sex , setSex ] = useState(<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">        showSex=<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [ work , setWork ] = useState(<span class="string">&#x27;前端程序员&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;JSPang 今年:&#123;age&#125;岁&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;性别:&#123;sex&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;工作是:&#123;work&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example2;</span><br></pre></td></tr></table></figure><ul><li>这时候控制台就会直接给我们报错，错误如下：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">React Hook &quot;useState&quot; is called conditionally. React Hooks must be called in the exact same order in every component render </span><br></pre></td></tr></table></figure><ul><li>意思就是useState不能在<code>if...else...</code>这样的条件语句中进行调用，必须要按照相同的顺序进行渲染。如果你还是不理解，你可以记住这样一句话就可以了：<strong>就是React Hooks不能出现在条件判断语句中，因为它必须有完全一样的渲染顺序</strong>。</li></ul><h3 id="useEffect">useEffect</h3><ul><li>为了让你更好的理解<code>useEffect</code>的使用，先用原始的方式把计数器的Demo增加两个生命周期函数<code>componentDidMount</code>和<code>componentDidUpdate</code>。分别在组件第一次渲染后在浏览器控制台打印出计数器结果和在每次计数器状态发生变化后打印出结果。代码如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example3</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123; <span class="attr">count</span>:<span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`ComponentDidMount=&gt;You clicked <span class="subst">$&#123;<span class="built_in">this</span>.state.count&#125;</span> times`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`componentDidUpdate=&gt;You clicked <span class="subst">$&#123;<span class="built_in">this</span>.state.count&#125;</span> times`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;You clicked &#123;<span class="built_in">this</span>.state.count&#125; times&lt;/p&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.addCount.bind(<span class="built_in">this</span>)&#125;&gt;Chlick me&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">addCount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example3;</span><br></pre></td></tr></table></figure><ul><li>这就是在不使用Hooks情况下的写法，那如何用Hooks来代替这段代码，并产生一样的效果那。</li><li>在使用<code>React Hooks</code>的情况下，我们可以使用下面的代码来完成上边代码的生命周期效果，代码如下（修改了以前的diamond）： 记得要先引入<code>useEffect</code>后，才可以正常使用。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//---关键代码---------start-------</span></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`useEffect=&gt;You clicked <span class="subst">$&#123;count&#125;</span> times`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//---关键代码---------end-------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example;</span><br></pre></td></tr></table></figure><ul><li><p>写完后，可以到浏览器中进行预览一下，可以看出跟<code>class</code>形式的生命周期函数是完全一样的，这代表第一次组件渲染和每次组件更新都会执行这个函数。 那这段代码逻辑是什么？我们梳理一下:首先，我们生命了一个状态变量<code>count</code>,将它的初始值设为0，然后我们告诉react，我们的这个组件有一个副作用。给<code>useEffecthook</code>传了一个匿名函数，这个匿名函数就是我们的副作用。在这里我们打印了一句话，当然你也可以手动的去修改一个<code>DOM</code>元素。当React要渲染组件时，它会记住用到的副作用，然后执行一次。等Reat更新了State状态时，它再一词执行定义的副作用函数。</p></li><li><p>useEffect两个注意点</p></li><li><ol><li>React首次渲染和之后的每次渲染都会调用一遍<code>useEffect</code>函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。</li></ol></li><li><ol start="2"><li>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而<code>componentDidMonut</code>和<code>componentDidUpdate</code>中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。</li></ol></li><li><p>在写React应用的时候，在组件中经常用到<code>componentWillUnmount</code>生命周期函数（组件将要被卸载时执行）。比如我们的定时器要清空，避免发生内存泄漏;比如登录状态要取消掉，避免下次进入信息出错。所以这个生命周期函数也是必不可少的，这节课就来用<code>useEffect</code>来实现这个生命周期函数,并讲解一下<code>useEffect</code>容易踩的坑。</p></li><li><p>学习<code>React Hooks</code> 时，我们要改掉生命周期函数的概念（人往往有先入为主的毛病，所以很难改掉），因为<code>Hooks</code>叫它副作用，所以<code>componentWillUnmount</code>也可以理解成解绑副作用。这里为了演示用<code>useEffect</code>来实现类似<code>componentWillUnmount</code>效果，先安装<code>React-Router</code>路由,进入项目根本录，使用<code>npm</code>进行安装。</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save react-router-dom</span><br></pre></td></tr></table></figure><ul><li>然后打开<code>Example.js</code>文件，进行改写代码，先引入对应的<code>React-Router</code>组件。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br></pre></td></tr></table></figure><ul><li>在文件中编写两个新组件，因为这两个组件都非常的简单，所以就不单独建立一个新的文件来写了。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>List-Page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有了这两个组件后，接下来可以编写路由配置，在以前的计数器代码中直接增加就可以了。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;click me&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt; <span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> &lt;/li&gt;</span><br><span class="line">                &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/list/&quot;</span>&gt;</span>列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;Route path=<span class="string">&quot;/&quot;</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">&quot;/list/&quot;</span> component=&#123;List&#125; /&gt;</span><br><span class="line">        &lt;/Router&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>然后到浏览器中查看一下，看看组件和路由是否可用。如果可用，我们现在可以调整<code>useEffect</code>了。在两个新组件中分别加入<code>useEffect()</code>函数:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;useEffect=&gt;老弟，你来了！Index页面&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;useEffect=&gt;老弟，你来了！List页面&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>List-Page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这时候我们点击<code>Link</code>进入任何一个组件，在浏览器中都会打印出对应的一段话。这时候可以用<strong>返回一个函数的形式进行解绑</strong>，代码如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;useEffect=&gt;老弟你来了！Index页面&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;老弟，你走了!Index页面&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>这时候你在浏览器中预览，我们仿佛实现了<code>componentWillUnmount</code>方法。但这只是好像实现了，当点击计数器按钮时，你会发现<code>老弟，你走了!Index页面</code>，也出现了。这到底是怎么回事那？其实每次状态发生变化，<code>useEffect</code>都进行了解绑。</p></li><li><p><a href="https://jspang.com/detailed?id=50#toc314">useEffect的第二个参数</a></p></li><li><p>那到底要如何实现类似<code>componentWillUnmount</code>的效果那?这就需要请出<code>useEffect</code>的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组<code>[]</code>时，就是当组件将被销毁时才进行解绑，这也就实现了<code>componentWillUnmount</code>的生命周期函数。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;useEffect=&gt;老弟你来了！Index页面&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;老弟，你走了!Index页面&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了更加深入了解第二个参数的作用，把计数器的代码也加上<code>useEffect</code>和解绑方法，并加入第二个参数为空数组。代码如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`useEffect=&gt;You clicked <span class="subst">$&#123;count&#125;</span> times`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;====================&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;click me&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt; <span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> &lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/list/&quot;</span>&gt;</span>列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> &lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/&quot;</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/list/&quot;</span> component=&#123;List&#125; /&gt;</span><br><span class="line">            &lt;/Router&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这时候的代码是不能执行解绑副作用函数的。但是如果我们想每次<code>count</code>发生变化，我们都进行解绑，只需要在第二个参数的数组里加入<code>count</code>变量就可以了。代码如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`useEffect=&gt;You clicked <span class="subst">$&#123;count&#125;</span> times`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;====================&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[count])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;click me&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt; <span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> &lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/list/&quot;</span>&gt;</span>列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span> &lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/&quot;</span> exact component=&#123;Index&#125; /&gt;</span><br><span class="line">                &lt;Route path=<span class="string">&quot;/list/&quot;</span> component=&#123;List&#125; /&gt;</span><br><span class="line">            &lt;/Router&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这时候只要<code>count</code>状态发生变化，都会执行解绑副作用函数，浏览器的控制台也就打印出了一串<code>=================</code>。</li></ul><p>这节课学完我们就对<code>useEffect</code>函数有了一个比较深入的了解，并且可以通过<code>useEffect</code>实现生命周期函数了，也完成了本节课学习的目的，现在用<code>React Hooks</code>这种函数的方法编写组件，对比以前用<code>Class</code>编写组件几乎一样了。但这并不是<code>Hooks</code>的所有东西，它还有一些让我们惊喜的新特性。</p><h3 id="useContext">useContext</h3><ul><li>有了<code>useState</code>和<code>useEffect</code>已经可以实现大部分的业务逻辑了，但是<code>React Hooks</code>中还是有很多好用的<code>Hooks</code>函数的，比如<code>useContext</code>和<code>useReducer</code>。</li><li>在用类声明组件时，父子组件的传值是通过组件属性和<code>props</code>进行的，那现在使用方法(Function)来声明组件，已经没有了<code>constructor</code>构造函数也就没有了props的接收，那父子组件的传值就成了一个问题。<code>React Hooks</code> 为我们准备了<code>useContext</code>。这节课就学习一下<code>useContext</code>，它可以帮助我们跨越组件层级直接传递变量，实现共享。需要注意的是<code>useContext</code>和<code>redux</code>的作用是不同的，一个解决的是组件之间值传递的问题，一个是应用中统一管理状态的问题，但通过和<code>useReducer</code>的配合使用，可以实现类似<code>Redux</code>的作用。☆☆☆☆☆</li></ul><p>这就好比玩游戏时有很多英雄，英雄的最总目的都是赢得比赛，但是作用不同，有负责输出的，有负责抗伤害的，有负责治疗的。</p><blockquote><p><code>Context</code>的作用就是对它所包含的组件树提供全局共享数据的一种技术。</p></blockquote><ul><li><a href="https://jspang.com/detailed?id=50#toc316">createContext 函数创建context</a></li><li>直接在<code>src</code>目录下新建一个文件<code>Example4.js</code>,然后拷贝<code>Example.js</code>里的代码，并进行修改，删除路由部分和副作用的代码，只留计数器的核心代码就可以了。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example4;</span><br></pre></td></tr></table></figure><ul><li>然后修改一下<code>index.js</code>让它渲染这个<code>Example4.js</code>组件，修改的代码如下。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Example <span class="keyword">from</span> <span class="string">&#x27;./Example4&#x27;</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Example</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><ul><li>之后在<code>Example4.js</code>中引入<code>createContext</code>函数，并使用得到一个组件，然后在<code>return</code>方法中进行使用。先看代码，然后我再解释。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">//===关键代码</span></span><br><span class="line"><span class="keyword">const</span> CountContext = createContext()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">            &#123;<span class="comment">/*======关键代码 */</span>&#125;</span><br><span class="line">            &lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class="line">            &lt;/CountContext.Provider&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example4;</span><br></pre></td></tr></table></figure><ul><li>这段代码就相当于把<code>count</code>变量允许跨层级实现传递和使用了（也就是实现了上下文），当父组件的<code>count</code>变量发生变化时，子组件也会发生变化。接下来我们就看看一个<code>React Hooks</code>的组件如何接收到这个变量。</li></ul><p><a href="https://jspang.com/detailed?id=50#toc317">useContext 接收上下文变量</a></p><ul><li>已经有了上下文变量，剩下的就时如何接收了，接收这个直接使用useContext就可以，但是在使用前需要新进行引入<code>useContext</code>（不引入是没办法使用的）。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , createContext , useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>引入后写一个<code>Counter</code>组件，只是显示上下文中的<code>count</code>变量代码如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useContext(CountContext)  <span class="comment">//一句话就可以得到count</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>得到后就可以显示出来了，但是要记得在<code>&lt;CountContext.Provider&gt;</code>的闭合标签中,代码如下。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class="line">    &lt;Counter /&gt;</span><br><span class="line">&lt;/CountContext.Provider&gt;</span><br></pre></td></tr></table></figure><h3 id="useReducer">useReducer</h3><ul><li><p><a href="https://jspang.com/detailed?id=50#toc319">reducer到底是什么？</a></p></li><li><p>为了更好的理解<code>useReducer</code>，所以先要了解JavaScript里的<code>Redcuer</code>是什么。它的兴起是从<code>Redux</code>广泛使用开始的，但不仅仅存在<code>Redux</code>中，可以使用冈的JavaScript来完成<code>Reducer</code>操作。那<code>reducer</code>其实就是一个函数，这个函数接收两个参数，一个是状态，一个用来控制业务逻辑的判断参数。我们举一个最简单的例子。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;sub&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上面的代码就是Reducer，你主要理解的就是这种形式和两个参数的作用，一个参数是状态，一个参数是如何控制状态。</p></li><li><p><a href="https://jspang.com/detailed?id=50#toc320">useReducer的使用</a></p></li><li><p>了解reducer的含义后，就可以讲useReducer了，它也是React hooks提供的函数，可以增强我们的<code>Reducer</code>，实现类似Redux的功能。我们新建一个<code>Example5.js</code>的文件，然后用useReducer实现计数器的加减双向操作。（此部分代码的介绍可以看视频来学习）</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReducerDemo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , dispatch ] =useReducer(<span class="function">(<span class="params">state,action</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(action)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> state+<span class="number">1</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;sub&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> state-<span class="number">1</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">           &lt;h2&gt;现在的分数是&#123;count&#125;&lt;/h2&gt;</span><br><span class="line">           &lt;button onClick=&#123;<span class="function">()=&gt;</span>dispatch(<span class="string">&#x27;add&#x27;</span>)&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line">           &lt;button onClick=&#123;<span class="function">()=&gt;</span>dispatch(<span class="string">&#x27;sub&#x27;</span>)&#125;&gt;Decrement&lt;/button&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReducerDemo</span><br></pre></td></tr></table></figure><ul><li><p>这段代码是useReducer的最简单实现了，这时候可以在浏览器中实现了计数器的增加减少。</p></li><li><p>修改<code>index.js</code>文件，让<code>ReducerDemo</code>组件起作用。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Example <span class="keyword">from</span> <span class="string">&#x27;./Example5&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Example</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="useReducer-useContext代替Redux小案例">useReducer+useContext代替Redux小案例</h3><ul><li><a href="https://jspang.com/detailed?id=50#toc322">理论上的可行性</a></li><li>我们先从理论层面看看替代<code>Redux</code>的可能性，其实如果你对两个函数有所了解，只要我们巧妙的结合，这种替代方案是完全可行的。</li><li><code>useContext</code>：可访问全局状态，避免一层层的传递状态。这符合<code>Redux</code>其中的一项规则，就是状态全局化，并能统一管理。</li><li><code>useReducer</code>：通过action的传递，更新复杂逻辑的状态，主要是可以实现类似<code>Redux</code>中的<code>Reducer</code>部分，实现业务逻辑的可行性。</li><li>经过我们在理论上的分析是完全可行的，接下来我们就用一个简单实例来看一下具体的实现方法。那这节课先实现<code>useContext</code>部分（也就是状态共享），下节再继续讲解<code>useReducer</code>部分（控制业务逻辑）。</li><li><a href="https://jspang.com/detailed?id=50#toc323">编写基本UI组件</a></li><li>既然是一个实例，就需要有些界面的东西，小伙伴们不要觉的烦。在<code>/src</code>目录下新建一个文件夹<code>Example6</code>，有了文件夹后，在文件夹下面建立一个<code>showArea.js</code>文件。代码如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShowArea</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">blue</span>&#x27;&#125;&#125;&gt;</span>字体颜色为blue<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ShowArea</span><br></pre></td></tr></table></figure><ul><li>显示区域写完后，新建一个<code>Buttons.js</code>文件，用来编写按钮，这个是两个按钮，一个红色一个黄色。先不写其他任何业务逻辑。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Buttons</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button&gt;红色&lt;/button&gt;</span><br><span class="line">            &lt;button&gt;黄色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Buttons</span><br></pre></td></tr></table></figure><ul><li>然后再编写一个组合他们的<code>Example6.js</code>组件，引入两个新编写的组件<code>ShowArea</code>和<code>Buttons</code>，并用<code>&lt;div&gt;</code>标签给包裹起来。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ShowArea <span class="keyword">from</span> <span class="string">&#x27;./ShowArea&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Buttons <span class="keyword">from</span> <span class="string">&#x27;./Buttons&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example6</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">                &lt;ShowArea /&gt;</span><br><span class="line">                &lt;Buttons /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example6</span><br></pre></td></tr></table></figure><ul><li>这步做完，需要到<code>/src</code>目录下的<code>index.js</code>中引入一下<code>Example6.js</code>文件，引入后React才能正确渲染出刚写的UI组件。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Example <span class="keyword">from</span> <span class="string">&#x27;./Example6/Example6&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Example</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><ul><li><p>做完这步可以简单的预览一下UI效果，虽然很丑，但是只要能满足学习需求就可以了。我们虽然都是前端，但是在学习时没必要追求漂亮的页面，关键时把知识点弄明白。我们写这么多文件，也就是要为接下来的知识点服务，其实这些组件都是陪衬罢了。</p></li><li><p>编写颜色共享组件</p></li><li><p>有了UI组件后，就可以写一些业务逻辑了，这节课我们先实现状态共享，这个就是利用<code>useContext</code>。建立一个<code>color.js</code>文件，然后写入下面的代码。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ColorContext = createContext(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Color = <span class="function"><span class="params">props</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ColorContext.Provider value=&#123;&#123;<span class="attr">color</span>:<span class="string">&quot;blue&quot;</span>&#125;&#125;&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">        &lt;/ColorContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代码中引入了<code>createContext</code>用来创建共享上下文<code>ColorContext</code>组件，然后我们要用<code>&#123;props.children&#125;</code>来显示对应的子组件。</p></li><li><p>有了这个组件后，我们就可以把<code>Example6.js</code>进行改写，让她可以共享状态。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ShowArea <span class="keyword">from</span> <span class="string">&#x27;./ShowArea&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Buttons <span class="keyword">from</span> <span class="string">&#x27;./Buttons&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Color &#125; <span class="keyword">from</span> <span class="string">&#x27;./color&#x27;</span>;   <span class="comment">//引入Color组件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example6</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Color&gt;</span><br><span class="line">                &lt;ShowArea /&gt;</span><br><span class="line">                &lt;Buttons /&gt;</span><br><span class="line">            &lt;/Color&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example6</span><br></pre></td></tr></table></figure><ul><li>然后再改写<code>showArea.js</code>文件，我们会引入<code>useContext</code>和在<code>color.js</code>中声明的<code>ColorContext</code>，让组件可以接收全局变量。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React , &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ColorContext &#125; <span class="keyword">from</span> <span class="string">&#x27;./color&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShowArea</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;color&#125; = useContext(ColorContext)</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:color&#125;&#125;</span>&gt;</span>字体颜色为&#123;color&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ShowArea</span><br></pre></td></tr></table></figure><ul><li><p>在color.js中添加Reducer</p></li><li><p>颜色（state）管理的代码我们都放在了<code>color.js</code>中，所以在文件里添加一个reducer，用于处理颜色更新的逻辑。先声明一个reducer的函数，它就是JavaScript中的普通函数，在讲<code>useReducer</code>的时候已经详细讲过了。有了reducer后，在Color组件里使用<code>useReducer</code>,这样Color组件就有了那个共享状态和处理业务逻辑的能力，跟以前使用的<code>Redux</code>几乎一样了。之后修改一下共享状态。我们来看代码：</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; createContext,useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ColorContext = createContext(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UPDATE_COLOR = <span class="string">&quot;UPDATE_COLOR&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer= <span class="function">(<span class="params">state,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> UPDATE_COLOR:</span><br><span class="line">            <span class="keyword">return</span> action.color</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Color = <span class="function"><span class="params">props</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [color,dispatch]=useReducer(reducer,<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ColorContext.Provider value=&#123;&#123;color,dispatch&#125;&#125;&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">        &lt;/ColorContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意，这时候我们共享出去的状态变成了color和dispatch,如果不共享出去dispatch，你是没办法完成按钮的相应事件的。</p></li><li><p>通过dispatch修改状态</p></li><li><p>目前程序已经有了处理共享状态的业务逻辑能力，接下来就可以在<code>buttons.js</code>使用<code>dispatch</code>来完成按钮的相应操作了。先引入<code>useContext</code>、<code>ColorContext</code>和<code>UPDATE_COLOR</code>，然后写<code>onClick</code>事件就可以了。代码如下:</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React ,&#123;useContext&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ColorContext,UPDATE_COLOR&#125; <span class="keyword">from</span> <span class="string">&#x27;./color&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Buttons</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch &#125; = useContext(ColorContext)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;dispatch(&#123;<span class="attr">type</span>:UPDATE_COLOR,<span class="attr">color</span>:<span class="string">&quot;red&quot;</span>&#125;)&#125;&#125;&gt;红色&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;dispatch(&#123;<span class="attr">type</span>:UPDATE_COLOR,<span class="attr">color</span>:<span class="string">&quot;yellow&quot;</span>&#125;)&#125;&#125;&gt;黄色&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Buttons</span><br></pre></td></tr></table></figure><h3 id="useMemo">useMemo</h3><ul><li><p><code>useMemo</code>主要用来解决使用React hooks产生的无用渲染的性能问题。使用function的形式来声明组件，失去了<code>shouldCompnentUpdate</code>（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分<code>mount</code>和<code>update</code>两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。<code>useMemo</code>和<code>useCallback</code>都是解决上述性能问题的，这节课先学习<code>useMemo</code>.</p></li><li><p>先编写一下刚才所说的性能问题，建立两个组件,一个父组件一个子组件，组件上由两个按钮，一个是小红，一个是志玲，点击哪个，那个就像我们走来了。在<code>/src</code>文件夹下，新建立一个<code>Example7</code>的文件夹，在文件夹下建立一个<code>Example7.js</code>文件.然后先写第一个父组件。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React , &#123;useState,useMemo&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example7</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [xiaohong , setXiaohong] = useState(<span class="string">&#x27;小红等待状态&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [zhiling , setZhiling] = useState(<span class="string">&#x27;志玲等待状态&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;setXiaohong(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())&#125;&#125;&gt;小红&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;setZhiling(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()+<span class="string">&#x27;,志玲向我们走来了&#x27;</span>)&#125;&#125;&gt;志玲&lt;/button&gt;</span><br><span class="line">            &lt;ChildComponent name=&#123;xiaohong&#125;&gt;&#123;zhiling&#125;&lt;/ChildComponent&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父组件调用了子组件，子组件我们输出两个姑娘的状态，显示在界面上。代码如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildComponent</span>(<span class="params">&#123;name,children&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeXiaohong</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;她来了，她来了。小红向我们走来了&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&#x27;,小红向我们走来了&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> actionXiaohong = changeXiaohong(name)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;&#123;actionXiaohong&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;&#123;children&#125;&lt;/div&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后再导出父组件，让<code>index.js</code>可以渲染。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example7</span><br></pre></td></tr></table></figure><ul><li><p>这时候你会发现在浏览器中点击<code>志玲</code>按钮，小红对应的方法都会执行，结果虽然没变，但是每次都执行，这就是性能的损耗。目前只有子组件，业务逻辑也非常简单，如果是一个后台查询，这将产生严重的后果。所以这个问题必须解决。当我们点击<code>志玲</code>按钮时，小红对应的<code>changeXiaohong</code>方法不能执行，只有在点击<code>小红</code>按钮时才能执行。</p></li><li><p>useMemo 优化性能</p></li><li><p>其实只要使用<code>useMemo</code>，然后给她传递第二个参数，参数匹配成功，才会执行。代码如下：</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildComponent</span>(<span class="params">&#123;name,children&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeXiaohong</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;她来了，她来了。小红向我们走来了&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&#x27;,小红向我们走来了&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> actionXiaohong = useMemo(<span class="function">()=&gt;</span>changeXiaohong(name),[name]) </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;&#123;actionXiaohong&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;&#123;children&#125;&lt;/div&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时在浏览器中点击一下<code>志玲</code>按钮，<code>changeXiaohong</code>就不再执行了。也节省了性能的消耗。案例只是让你更好理解，你还要从程序本身看到优化的作用。好的程序员对自己写的程序都是会进行不断优化的，这种没必要的性能浪费也是绝对不允许的，所以<code>useMemo</code>的使用在工作中还是比较多的。</p><h3 id="useRef">useRef</h3><ul><li><p><code>useRef</code>在工作中虽然用的不多，但是也不能缺少。它有两个主要的作用:</p></li><li><p>用<code>useRef</code>获取React JSX中的DOM元素，获取后你就可以控制DOM的任何东西了。但是一般不建议这样来作，React界面的变化可以通过状态来控制。</p></li><li><p>用<code>useRef</code>来保存变量，这个在工作中也很少能用到，我们有了<code>useContext</code>这样的保存其实意义不大，但是这是学习，也要把这个特性讲一下。</p></li><li><p>useRef获取DOM元素</p></li><li><p>界面上有一个文本框，在文本框的旁边有一个按钮，当我们点击按钮时，在控制台打印出<code>input</code>的DOM元素，并进行复制到DOM中的value上。这一切都是通过<code>useRef</code>来实现。</p></li><li><p>在<code>/src</code>文件夹下新建一个<code>Example8.js</code>文件，然后先引入useRef，编写业务逻辑代码如下:</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example8</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> onButtonClick=<span class="function">()=&gt;</span>&#123; </span><br><span class="line">        inputEl.current.value=<span class="string">&quot;Hello ,JSPang&quot;</span></span><br><span class="line">        <span class="built_in">console</span>.log(inputEl) <span class="comment">//输出获取到的DOM节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &#123;<span class="comment">/*保存input的ref到inputEl */</span>&#125;</span><br><span class="line">            &lt;input ref=&#123;inputEl&#125; type=<span class="string">&quot;text&quot;</span>/&gt;</span><br><span class="line">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;/button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example8</span><br></pre></td></tr></table></figure><ul><li><p>当点击按钮时，你可以看到在浏览器中的控制台完整的打印出了DOM的所有东西，并且界面上的<code>&lt;input/&gt;</code>框的value值也输出了我们写好的<code>Hello ,JSPang</code>。这一切说明我们可以使用useRef获取DOM元素，并且可以通过useRefu控制DOM的属性和值。</p></li><li><p>useRef保存普通变量</p></li><li><p>这个操作在实际开发中用的并不多，但我们还是要讲解一下。就是<code>useRef</code>可以保存React中的变量。我们这里就写一个文本框，文本框用来改变<code>text</code>状态。又用<code>useRef</code>把<code>text</code>状态进行保存，最后打印在控制台上。写这段代码你会觉的很绕，其实显示开发中没必要这样写，用一个state状态就可以搞定，这里只是为了展示知识点。</p></li><li><p>接着上面的代码来写，就没必要重新写一个文件了。先用<code>useState</code>声明了一个<code>text</code>状态和<code>setText</code>函数。然后编写界面，界面就是一个文本框。然后输入的时候不断变化。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef ,useState,useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example8</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> onButtonClick=<span class="function">()=&gt;</span>&#123; </span><br><span class="line">        inputEl.current.value=<span class="string">&quot;Hello ,useRef&quot;</span></span><br><span class="line">        <span class="built_in">console</span>.log(inputEl)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [text, setText] = useState(<span class="string">&#x27;jspang&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &#123;<span class="comment">/*保存input的ref到inputEl */</span>&#125;</span><br><span class="line">            &lt;input ref=&#123;inputEl&#125; type=<span class="string">&quot;text&quot;</span>/&gt;</span><br><span class="line">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;/button&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;input value=&#123;text&#125; onChange=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;setText(e.target.value)&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example8</span><br></pre></td></tr></table></figure><ul><li>这时想每次<code>text</code>发生状态改变，保存到一个变量中或者说是<code>useRef</code>中，这时候就可以使用<code>useRef</code>了。先声明一个<code>textRef</code>变量，他其实就是<code>useRef</code>函数。然后使用<code>useEffect</code>函数实现每次状态变化都进行变量修改，并打印。最后的全部代码如下。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef ,useState,useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example8</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> onButtonClick=<span class="function">()=&gt;</span>&#123; </span><br><span class="line">        inputEl.current.value=<span class="string">&quot;Hello ,useRef&quot;</span></span><br><span class="line">        <span class="built_in">console</span>.log(inputEl)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-----------关键代码--------start</span></span><br><span class="line">    <span class="keyword">const</span> [text, setText] = useState(<span class="string">&#x27;jspang&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> textRef = useRef()</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        textRef.current = text;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;textRef.current:&#x27;</span>, textRef.current)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//----------关键代码--------------end</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &#123;<span class="comment">/*保存input的ref到inputEl */</span>&#125;</span><br><span class="line">            &lt;input ref=&#123;inputEl&#125; type=<span class="string">&quot;text&quot;</span>/&gt;</span><br><span class="line">            &lt;button onClick = &#123;onButtonClick&#125;&gt;在input上展示文字&lt;/button&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;br/&gt;</span><br><span class="line">            &lt;input value=&#123;text&#125; onChange=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;setText(e.target.value)&#125;&#125; /&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example8</span><br></pre></td></tr></table></figure><ul><li>这时候就可以实现每次状态修改，同时保存到<code>useRef</code>中了。也就是我们说的保存变量的功能。那<code>useRef</code>的主要功能就是获得DOM和变量保存，我们都已经讲过了。</li></ul><h3 id="自定义Hooks和useCallback">自定义Hooks和useCallback</h3><ul><li><p>其实自定义Hooks函数和用Hooks创建组件很相似，跟我们平时用JavaScript写函数几乎一模一样，可能就是多了些<code>React Hooks</code>的特性，自定义Hooks函数偏向于功能，而组件偏向于界面和业务逻辑。由于差别不大，所以使用起来也是很随意的。如果是小型项目是可以的，但是如果项目足够复杂，这会让项目结构不够清晰。所以学习自定义Hooks函数还是很有必要的。</p></li><li><p>编写自定义函数</p></li><li><p>在实际开发中，为了界面更加美观。获取浏览器窗口的尺寸是一个经常使用的功能，这样经常使用的功能，就可以封装成一个自定义<code>Hooks</code>函数，记住一定要用use开头，这样才能区分出什么是组件，什么是自定义函数。</p></li><li><p>新建一个文件<code>Example9.js</code>,然后编写一个useWinSize,编写时我们会用到<code>useState</code>、<code>useEffect</code>和<code>useCallback</code>所以先用<code>import</code>进行引入。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState ,useEffect ,useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>然后编写函数，函数中先用useState设置<code>size</code>状态，然后编写一个每次修改状态的方法<code>onResize</code>，这个方法使用<code>useCallback</code>，目的是为了缓存方法(useMemo是为了缓存变量)。 然后在第一次进入方法时用<code>useEffect</code>来注册<code>resize</code>监听时间。为了防止一直监听所以在方法移除时，使用return的方式移除监听。最后返回size变量就可以了。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWinSize</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ size , setSize] = useState(&#123;</span><br><span class="line">        width:<span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">        height:<span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onResize = useCallback(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        setSize(&#123;</span><br><span class="line">            width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">            height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,[]) </span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>,onResize)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;resize&#x27;</span>,onResize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这就是一个自定义函数，其实和我们以前写的JS函数没什么区别，所以这里也不做太多的介绍。</p><ul><li><a href="https://jspang.com/detailed?id=50#toc336">编写组件并使用自定义函数</a></li><li>自定义<code>Hooks</code>函数已经写好了，可以直接进行使用，用法和<code>JavaScript</code>的普通函数用起来是一样的。直接在<code>Example9</code>组件使用<code>useWinSize</code>并把结果实时展示在页面上。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example9</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> size = useWinSize()</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;页面Size:&#123;size.width&#125;x&#123;size.height&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example9 </span><br></pre></td></tr></table></figure><h3 id="useImperativeHandle">useImperativeHandle</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure><ul><li><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。<code>useImperativeHandle</code> 应当与 <a href="https://react.docschina.org/docs/react-api.html#reactforwardref"><code>forwardRef</code></a> 一起使用：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeHandle(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    focus: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput = forwardRef(FancyInput);</span><br></pre></td></tr></table></figure><ul><li>在本例中，渲染 <code>&lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code> 的父组件可以调用 <code>inputRef.current.focus()</code>。</li></ul><h3 id="useLayoutEffect">useLayoutEffect</h3><ul><li><p>其函数签名与 <code>useEffect</code> 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 内部的更新计划将被同步刷新。</p></li><li><p>尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新。</p></li></ul><blockquote><p>提示</p><p>如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则需要注意 <code>useLayoutEffect</code> 与 <code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的。但是，我们推荐你<strong>一开始先用 <code>useEffect</code></strong>，只有当它出问题的时候再尝试使用 <code>useLayoutEffect</code>。</p><p>如果你使用服务端渲染，请记住，<em>无论</em> <code>useLayoutEffect</code> <em>还是</em> <code>useEffect</code> 都无法在 Javascript 代码加载完成之前执行。这就是为什么在服务端渲染组件中引入 <code>useLayoutEffect</code> 代码时会触发 React 告警。解决这个问题，需要将代码逻辑移至 <code>useEffect</code> 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（如果直到 <code>useLayoutEffect</code> 执行之前 HTML 都显示错乱的情况下）。</p><p>若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 <code>showChild &amp;&amp; &lt;Child /&gt;</code> 进行条件渲染，并使用 <code>useEffect(() =&gt; &#123; setShowChild(true); &#125;, [])</code> 延迟展示组件。这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。</p></blockquote><h3 id="useDebugValue">useDebugValue</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useDebugValue(value)</span><br></pre></td></tr></table></figure><ul><li><p><code>useDebugValue</code> 可用于在 React 开发者工具中显示自定义 hook 的标签。</p></li><li><p>例如，<a href="https://react.docschina.org/docs/hooks-custom.html">“自定义 Hook”</a> 章节中描述的名为 <code>useFriendStatus</code> 的自定义 Hook：</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在开发者工具中的这个 Hook 旁边显示标签  // e.g. &quot;FriendStatus: Online&quot;  useDebugValue(isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;);</span></span><br><span class="line">  <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>我们不推荐你向每个自定义 Hook 添加 debug 值。当它作为共享库的一部分时才最有价值。</p></blockquote><h4 id="延迟格式化-debug-值">延迟格式化 debug 值</h4><ul><li><p>在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。</p></li><li><p>因此，<code>useDebugValue</code> 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。</p></li><li><p>例如，一个返回 <code>Date</code> 值的自定义 Hook 可以通过格式化函数来避免不必要的 <code>toDateString</code> 函数调用：</p></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> React </tag>
            
            <tag> Front End </tag>
            
            <tag> SPA </tag>
            
            <tag> React Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React进阶 状态管理 Redux| 学习笔记</title>
      <link href="2020/10/10/Redux-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/10/10/Redux-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Redux">Redux</h2><p><strong>JavaScript提供的一个可预测性（给一个固定的输入 必定等到一个结果）的状态容器</strong></p><ul><li><p>集中地管理react中多个组件的状态</p><p>redux是一个专门的状态管理库 （在vue中也可以使用 但是在react中会比较多）</p></li><li><p>需求场景：</p><p>1、某个组建的状态需要共享的时候</p><p>2、一个组件需要改变另一个组件状态的时候</p><p>3、组件中的状态需要在任何地方都可以拿到</p></li><li><p>三大原则：</p><p>1、单一数据源 整个react中的状态都会被统一管理到store</p><p>2、state是只读的 我们不能直接改变state 而是要通过触发redux中特定的方法进行修改</p><p>3、使用纯函数来执行修改操作：action来改变redux中的state</p></li><li><p>构建store</p><ul><li>在src目录下建立store文件夹包含<ul><li>Store.js</li><li>Reducer.js</li><li>Action.js</li></ul></li></ul></li></ul><h3 id="Store-js-使用redux-devtools中间件">Store.js(使用redux-devtools中间件)</h3><ul><li>引入reducer</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&quot;./reducer&quot;</span></span><br><span class="line"><span class="comment">//第二个参数为使用redux-devtools中间件的操作</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore(reducer,<span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__)</span><br></pre></td></tr></table></figure><p><strong>使用多个中间件（compose强函数）</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore , applyMiddleware , compose&#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&quot;./reducer&quot;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> composeEnhancers=<span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?</span><br><span class="line">    <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;):compose</span><br><span class="line"><span class="keyword">const</span> enhancer=composeEnhancers(applyMiddleware(thunk))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore(reducer, enhancer);</span><br></pre></td></tr></table></figure><h3 id="Reducer-js">Reducer.js</h3><ul><li>引入方法名</li><li>定义默认数据</li><li>用于定义各种方法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;CHANGE_INPUT , ADD_EVENT , SUB_EVENT &#125; <span class="keyword">from</span> <span class="string">&#x27;./action&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    inputValue:<span class="string">&#x27;Write Something&#x27;</span>,</span><br><span class="line">    List:[</span><br><span class="line">        <span class="string">&#x27;早上学习Node&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;下午健身&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;晚上开发项目&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state=obj,action)=&gt;&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> CHANGE_INPUT:&#123;</span><br><span class="line">            <span class="keyword">let</span> newState=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state))</span><br><span class="line">            newState.inputValue=action.value</span><br><span class="line">            <span class="keyword">return</span> newState</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ADD_EVENT:&#123;</span><br><span class="line">            <span class="keyword">let</span> newState=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state))</span><br><span class="line">            newState.List.push(action.value)</span><br><span class="line">            newState.inputValue=<span class="string">&#x27;Write Something&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> newState</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SUB_EVENT:&#123;</span><br><span class="line">            <span class="keyword">let</span> newState=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state))</span><br><span class="line">            newState.List.splice(action.value,<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> newState</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> :<span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action-js">Action.js</h3><ul><li>引入store</li><li>export各方法名称（容易找bug）</li><li>export方法（用于操作store里的变量）触发函数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;store&#125; <span class="keyword">from</span> <span class="string">&quot;../redux/store&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_INPUT=<span class="string">&#x27;changeInput&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_EVENT=<span class="string">&#x27;addEvent&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SUB_EVENT=<span class="string">&#x27;subEvent&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getAction</span>(<span class="params">_type,_value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> action=&#123;</span><br><span class="line">        type:_type,</span><br><span class="line">      <span class="comment">//type为方法名</span></span><br><span class="line">        value:_value</span><br><span class="line">      <span class="comment">//value为传进来的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//触发</span></span><br><span class="line">    store.dispatch(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用redux的组件">使用redux的组件</h3><ul><li>引入store</li><li>引入各方法名（容易找bug）</li><li>引入构建action并触发的函数</li><li>组件方法提前绑定this</li><li>将store的值放入state对应位置，如果只有store的值则直接赋值给store</li><li>store订阅并绑定方法重新设置state</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Input, Button, List&#125; <span class="keyword">from</span> <span class="string">&quot;antd&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;store&#125; <span class="keyword">from</span> <span class="string">&quot;../redux/store&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;CHANGE_INPUT , ADD_EVENT , SUB_EVENT , getAction&#125; <span class="keyword">from</span> <span class="string">&#x27;../redux/action&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redux1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = store.getState();</span><br><span class="line">        <span class="built_in">this</span>.changeInputValue = <span class="built_in">this</span>.changeInputValue.bind(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">this</span>.storeChange=<span class="built_in">this</span>.storeChange.bind(<span class="built_in">this</span>)</span><br><span class="line">        store.subscribe(<span class="built_in">this</span>.storeChange)</span><br><span class="line">        <span class="built_in">this</span>.addEvent=<span class="built_in">this</span>.addEvent.bind(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">this</span>.subEvent=<span class="built_in">this</span>.subEvent.bind(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Redux&lt;/h1&gt;</span><br><span class="line">                &lt;div style=&#123;&#123;<span class="attr">margin</span>: <span class="string">&#x27;10px&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">                    &lt;Input</span><br><span class="line">                        placeholder=&#123;<span class="built_in">this</span>.state.inputValue&#125;</span><br><span class="line">                        style=&#123;&#123;<span class="attr">width</span>: <span class="string">&#x27;250px&#x27;</span>&#125;&#125;</span><br><span class="line">                        onChange=&#123;<span class="built_in">this</span>.changeInputValue&#125;</span><br><span class="line">                        value=&#123;<span class="built_in">this</span>.state.inputValue&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                    &lt;Button type=<span class="string">&#x27;primary&#x27;</span> style=&#123;&#123;<span class="attr">margin</span>: <span class="string">&#x27;0 0 0 10px&#x27;</span>&#125;&#125; onClick=&#123;<span class="built_in">this</span>.addEvent&#125;&gt;增加 &lt;/Button&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div style=&#123;&#123;<span class="attr">margin</span>: <span class="string">&#x27;10px&#x27;</span>, <span class="attr">width</span>: <span class="string">&#x27;300px&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">                    &lt;List</span><br><span class="line">                        bordered</span><br><span class="line">                        dataSource=&#123;<span class="built_in">this</span>.state.List&#125;</span><br><span class="line">                        renderItem=&#123;<span class="function">(<span class="params">item,index</span>) =&gt;</span> (</span><br><span class="line">                            &lt;List.Item onClick=&#123;<span class="built_in">this</span>.subEvent.bind(<span class="built_in">this</span>,index)&#125;&gt;</span><br><span class="line">                                &#123;item&#125;</span><br><span class="line">                            &lt;/List.Item&gt;)&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">changeInputValue</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">        getAction(CHANGE_INPUT,e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">addEvent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        getAction(ADD_EVENT,<span class="built_in">this</span>.state.inputValue)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">subEvent</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">        getAction(SUB_EVENT,index)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">storeChange</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(store.getState())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Redux1;</span><br></pre></td></tr></table></figure><h2 id="React-redux">React-redux</h2><ul><li><p>除了以下内容其他和普通Redux一样</p></li><li><p>index.js(入口)</p><ul><li>引入Provider并包裹要使用store的组件</li><li>引入store并在Provider标签的store属性中传入（提供store的值）</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> serviceWorker <span class="keyword">from</span> <span class="string">&#x27;./serviceWorker&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;antd/dist/antd.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;store&#125; <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;React.StrictMode&gt;</span><br><span class="line">        &lt;BrowserRouter&gt;</span><br><span class="line">            &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">                &lt;App/&gt;</span><br><span class="line">            &lt;/Provider&gt;</span><br><span class="line">        &lt;/BrowserRouter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/React.StrictMode&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you want your app to work offline and load faster, you can change</span></span><br><span class="line"><span class="comment">// unregister() to register() below. Note this comes with some pitfalls.</span></span><br><span class="line"><span class="comment">// Learn more about service workers: https://bit.ly/CRA-PWA</span></span><br><span class="line">serviceWorker.unregister();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用react-redux的组件">使用react-redux的组件</h3><ul><li>引入connect</li><li>引入方法名</li><li>底部export的不是原本的组件而是通过connect链接store后的组件</li><li>将store的值映射到props中（connect第一个参数）</li><li>将操作store的方法映射到props中（connect第二个参数）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Button, Input, List&#125; <span class="keyword">from</span> <span class="string">&quot;antd&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;CHANGE_INPUT , ADD_EVENT , SUB_EVENT , getAction&#125; <span class="keyword">from</span> <span class="string">&#x27;../redux/action&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactRedux</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;react-redux&lt;/h1&gt;</span><br><span class="line">                &lt;div style=&#123;&#123;<span class="attr">margin</span>: <span class="string">&#x27;10px&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">                    &lt;Input</span><br><span class="line">                        style=&#123;&#123;<span class="attr">width</span>: <span class="string">&#x27;250px&#x27;</span>&#125;&#125;</span><br><span class="line">                        value=&#123;<span class="built_in">this</span>.props.inputValue&#125;</span><br><span class="line">                        onChange=&#123;<span class="built_in">this</span>.props.inputChange&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                    &lt;Button type=<span class="string">&#x27;primary&#x27;</span> style=&#123;&#123;<span class="attr">margin</span>: <span class="string">&#x27;0 0 0 10px&#x27;</span>&#125;&#125; onClick=&#123;<span class="built_in">this</span>.props.addEvent.bind(<span class="built_in">this</span>)&#125;&gt;增加&lt;/Button&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div style=&#123;&#123;<span class="attr">margin</span>: <span class="string">&#x27;10px&#x27;</span>, <span class="attr">width</span>: <span class="string">&#x27;300px&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">                    &lt;List</span><br><span class="line">                        bordered</span><br><span class="line">                        dataSource=&#123;<span class="built_in">this</span>.props.List&#125;</span><br><span class="line">                        renderItem=&#123;<span class="function">(<span class="params">item,index</span>) =&gt;</span> (</span><br><span class="line">                            &lt;List.Item onClick=&#123;<span class="built_in">this</span>.props.subEvent.bind(<span class="built_in">this</span>,index)&#125;&gt;</span><br><span class="line">                                &#123;item&#125;</span><br><span class="line">                            &lt;/List.Item&gt;)&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storeToProps=<span class="function">(<span class="params">store</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        inputValue:store.inputValue,</span><br><span class="line">        List:store.List</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dispatchToProps=<span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="function"><span class="title">inputChange</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            getAction(CHANGE_INPUT,e.target.value)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">addEvent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            getAction(ADD_EVENT,<span class="built_in">this</span>.props.inputValue)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">subEvent</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">            getAction(SUB_EVENT,index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(storeToProps,dispatchToProps)(ReactRedux);</span><br></pre></td></tr></table></figure><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Redux </tag>
            
            <tag> React </tag>
            
            <tag> Front End </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 版本控制工具 | 学习笔记</title>
      <link href="2020/08/07/Git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/08/07/Git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>Git版本控制工具</h1><h2 id="各类版本控制工具">各类版本控制工具</h2><ul><li><p>集中式（svn）：</p><ul><li><p>svn因为每次存的都是差异 需要的磁盘空间会相对小一点 可是回滚速度会很慢</p></li><li><p>优点：</p><ul><li>代码存放在单一的服务器上便于项目的管理</li></ul></li><li><p>缺点：</p><ul><li>服务器宕机：员工写的代码无法实时更新到服务器得不到保障</li><li>服务器炸了：整个项目的历史记录都会丢失</li></ul></li></ul></li><li><p>分布式（git）：</p><ul><li>git每次存的都是项目的完整快照  需要的是硬盘空间会相对大一点</li><li>（Git团队对代码做了极致的压缩 最终需要的实际空间比svn大不了多少 可是Git的回滚速度极快）</li></ul></li></ul><h2 id="基本控制命令">基本控制命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> git --version查看当前git版本 </span><br><span class="line"></span><br><span class="line"> git config --gobal user.name &quot;自定义名称&quot; </span><br><span class="line"></span><br><span class="line"> git config --gobal user.email &quot;自定义邮箱&quot;</span><br><span class="line"></span><br><span class="line"> git config --list 检查基础配置信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">gobal代表本用户可替换为system（本操作系统）或者不填（本项目）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">优先级 本项目&gt;本用户&gt;本操作系统</span></span><br></pre></td></tr></table></figure><ul><li><p>区域：</p><ul><li>工作区：本地代码目录</li><li>暂存区：暂时存放上传的代码，负责记录修改但未提交的版本。</li><li>版本库：确认提交的代码版本</li></ul></li><li><p>对象：</p><ul><li>Git对象（存内容不存文件名）：</li><li>key ：value组成的键值对（key是value对应的hash）</li><li>键值对在git内部是一个blob类型</li><li>树对象</li><li>提交对象</li></ul></li><li><p>Git_linux基本命令：</p><ul><li>cd 文件夹名 ：进入某文件夹</li><li>clear:清除屏幕</li><li>echo ‘信息’往控制台输出信息（打印）</li><li>echo ‘信息’&gt; test.txt  新建txt文件内写入输出信息</li><li>ll：查看当前目录下的子文件&amp;子目录平铺在控制台</li><li>find 目录名 :将对应文件下的子孙文件&amp;子孙目录平铺在控制台</li><li>find 目录名-type f：将对应目录下的文件平铺在控制台</li><li>rm 文件名：删除文件</li><li>mv 源文件 重命名文件：重命名</li><li>cat 文件的url ：查看对应文件的内容</li><li>vim 文件的url（在英文模式下）</li><li>按i键插入模式  进行文件的编辑</li><li>按esc键&amp;按：键  进行命令的执行</li><li>q！   强制退出（不保存）</li><li>wq   保存退出</li><li>set nu 设置行号</li></ul></li><li><p>git init 初始化git仓库生成 .git文件夹（版本库）</p><p>.git文件夹内有</p><ul><li>hooks：目录包含客户端或服务端的钩子脚本</li><li>info：包含一个全局性排除文件（git不需要管理的文件）</li><li>logs：保存日志信息</li><li>objects：目录存储所有数据内容（数据库）</li><li>refs：目录存储指向数据（分支）的提交对象指针</li><li>config：文件包含项目的配置选项</li><li>description：用来显示对仓库的描述信息</li><li>HEAD：文件指示目前被检出的分支</li><li>index：文件保存暂存区信息</li></ul></li></ul><h2 id="Git连接Github">Git连接Github</h2><ul><li><p>首先在本地运行</p><ul><li><p><code> ssh-keygen -t rsa –C “youremail@example.com”</code>生成ssh key</p></li><li><p>在用户目录.ssh中Id_rsa为私钥不可对外发</p></li><li><p>Id_rsa.pub公钥可对外发</p></li></ul></li><li><p>在github的setting中打开ssh keys页面</p><ul><li>Add ssh key</li><li>tittle任填（主机名、用户标识）</li><li>key内复制公钥内容  即添加成功</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin url（github的）</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><ul><li><p>本地运行该命令即可把本地仓库分支master内容推送到元仓库去</p></li><li><p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p></li></ul><h2 id="Git操作">Git操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> git --version查看当前git版本 </span><br><span class="line"></span><br><span class="line"> git config --gobal user.name &quot;自定义名称&quot; </span><br><span class="line"></span><br><span class="line"> git config --gobal user.email &quot;自定义邮箱&quot;</span><br><span class="line"></span><br><span class="line"> git config --list 检查基础配置信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">gobal代表本用户可替换为system（本操作系统）或者不填（本项目）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">优先级 本项目&gt;本用户&gt;本操作系统</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>文本编辑器</strong></p><p>设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：:</p><p><code>$ git config --global core.editor emacs</code></p></li></ul><ul><li><p><strong>差异分析工具</strong></p><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p><p><code>$ git config --global merge.tool vimdiff</code></p></li></ul><h3 id="初始化基本操作">初始化基本操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> 进入某目录、文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir xxx  新建xxx文件夹（文件带后缀）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">pwd</span>显示当前目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat file 查看文件</span></span><br><span class="line"></span><br><span class="line"> git init #初始化一个git仓库</span><br><span class="line"></span><br><span class="line"> git init newrepo #使用指定目录作为git仓库</span><br><span class="line">  </span><br><span class="line"> git remote add origin url（github的url）</span><br><span class="line"></span><br><span class="line"> git add …  #添加文件到缓存</span><br><span class="line"><span class="meta"> #</span><span class="bash">… 可为文件和目录  为提交作准备</span></span><br><span class="line"> </span><br><span class="line"> git add ./</span><br><span class="line"> </span><br><span class="line"> git commit -m ‘注释’</span><br><span class="line"> </span><br><span class="line"> git push -u origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Git-命令">Git 命令</h2><h3 id="git-clone-url-diretcory">git clone url diretcory</h3><ul><li><p>克隆仓库url为仓库链接 directory为本地目录地址（默认当前目录可不填）</p></li><li><p>url分为ssh协议、git协议、https协议 其中常用ssh协议 速度较快</p></li></ul><h3 id="git-checkout-–b-dev-origin-dev">git checkout –b dev origin/dev</h3><ul><li>可以克隆分支并本地创建</li></ul><h3 id="git-status">git status</h3><ul><li><p>查看文件状态 是否有文件未提交、修改、添加、删除等</p></li><li><p>modified：文件名 为有修改的文件</p></li><li><p>单独文件名 为新增文件</p></li></ul><h3 id="git-diff">git diff</h3><p>xxx 查看某文件修改内容</p><h3 id="git-log">git log</h3><ul><li>查看历史提交记录 内容有版本号（hash）、作者、事件、增加的内容</li></ul><h3 id="git-log-pretty-online">git log -pretty=online</h3><ul><li><p>日志太多 只显示版本号和增加内容</p></li><li><p>–grahy 查看历史什么时候出现分支、合并</p></li><li><p>–reverse 逆向显示所有工作日志</p></li></ul><h3 id="git-log-author">git log --author</h3><ul><li><p>只查看当前作者日志</p></li><li><p>-no-merges选项以隐藏合并提交</p></li><li><p>指定日期 可以执行几个选项：-因为和–before，但是你也可以用–until和–after。</p></li><li><p><code>git log --oneline --before = &#123;3.weeks.ago&#125; --after = &#123;2010-04-18&#125; --no-merges</code></p></li></ul><h3 id="git-reflog">git reflog</h3><ul><li>查看历史提交记录（包括已回退）</li></ul><h3 id="git-reset-hard-HEAD">git reset --hard HEAD^</h3><ul><li>回退到上一个版本 <sup>的个数代表回退版本个数三个即</sup>^^</li></ul><h3 id="git-reset-hard-HEAD-100">git reset --hard HEAD~100</h3><ul><li>回退多个版本（此为100）</li></ul><h3 id="git-reset-hard-版本号">git reset --hard 版本号</h3><ul><li>回退到某个版本</li></ul><h3 id="git-checkout-–-file">git checkout – file</h3><ul><li><p>丢弃工作区的修改</p></li><li><p>当git status 显示有文件修改时可使用</p></li><li><p>rm file 删除文件 （删除后可以选择commit和恢复）</p></li><li><p>git commit 提交</p></li><li><p>git checkout – file 在commit前恢复刚删除的文件</p></li></ul><h3 id="git-checkout-b-分支名">git checkout -b 分支名</h3><ul><li><p>创建并切换分支</p></li><li><p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p></li></ul><h3 id="分支操作汇总：">分支操作汇总：</h3><ul><li>查看分支：git branch（当前分支前有*号）</li><li>创建分支：git branch name</li><li>切换分支：git checkout name</li><li>创建+切换分支：git checkout –b name</li><li>合并某分支到当前分支：git merge name</li><li>删除分支：git branch –d name</li></ul><h3 id="当合并分支冲突时查看文件会显示冲突">当合并分支冲突时查看文件会显示冲突</h3><ul><li><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</p></li><li><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。</p></li><li><p>合并dev分支，使用命令 git merge –no-ff -m “注释” dev</p></li><li><p>当工作未完成但要提交时先隐藏’工作现场‘再创建临时分支完成</p></li></ul><h3 id="git-stash">git stash</h3><ul><li>想要恢复</li></ul><h3 id="git-stash-list">git stash list</h3><ul><li><p>可用git stash apply/pop方法恢复</p></li><li><p>apply方法恢复stash内容并不删除，需要git stash drop删除</p></li><li><p>pop方法恢复的同时删除了stash</p></li></ul><h3 id="推送：">推送：</h3><h3 id="git-push-origin-master">git push origin master</h3><ul><li>推送主分支</li></ul><h3 id="git-push-origin-dev">git push origin dev</h3><ul><li>推送dev分支</li></ul><h3 id="git-checkout-–b-dev-origin-dev-2">git checkout –b dev origin/dev</h3><ul><li><p>克隆分支并本地创建</p></li><li><p>多人修改同一个文件会出现报错</p></li><li><p>通过git pull把最新提交的origin/dev抓下来解决冲突再推送</p></li><li><p>git pull报错可能是没有指定本地dev分支与远程origin/dev分支链接</p></li><li><p>通过命令建立链接</p></li><li><p><code>git branch --set-upstream dev origin/dev</code></p></li><li><p>然后再git pull</p></li><li><p>解决完冲突再提交、推送</p></li></ul><h3 id="标签">标签:</h3><h3 id="git-checkout-分支名">git checkout 分支名</h3><ul><li>切换到想要操作的分支</li><li>git tag 标签名 即可打上标签</li><li>想要给历史提交的打标签找到版本号（hash）</li></ul><h3 id="git-tag-标签名-版本号">git tag 标签名 版本号</h3><ul><li>即可打上标签</li></ul><h3 id="git-show-标签名">git show 标签名</h3><ul><li>查看当前标签的提交信息</li></ul><h3 id="git-tag-a-标签名-m“注释“-版本号">git tag -a 标签名 -m“注释“ 版本号</h3><ul><li>可添加注释信息</li></ul><h3 id="git-tag-d-标签名">git tag -d 标签名</h3><ul><li>删除标签</li></ul><h3 id="git-push-origin-标签名">git push origin 标签名</h3><ul><li>推送标签到远程</li></ul><h3 id="git-push-origin-tags">git push origin --tags</h3><ul><li>一次性推送全部未推送到远程的标签</li></ul><h3 id="git-tag-d-标签名-2">git tag -d 标签名</h3><ul><li><p>删除已推送的标签</p></li><li><p>删除本地标签后再执行</p></li></ul><h3 id="git-push-origin-：refs-tags-标签名">git push origin ：refs/tags/标签名</h3><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 开发技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> 团队协作 </tag>
            
            <tag> 工程化 </tag>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue进阶 状态管理 Vuex</title>
      <link href="2020/07/26/Vue%E8%BF%9B%E9%98%B6-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-Vuex/"/>
      <url>2020/07/26/Vue%E8%BF%9B%E9%98%B6-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-Vuex/</url>
      
        <content type="html"><![CDATA[<h2 id="Vuex-状态管理">Vuex 状态管理</h2><p><strong>Vuex 是实现组件全局状态(数据)管理的一种机制，可以方便的实现组件之间数据的共享。</strong></p><ul><li>使用 Vuex 统一管理状态的好处<ul><li>能够在 vuex 中集中管理共享的数据，易于开发和后期维护</li><li>能够高效地实现组件之间的数据共享，提高开发效率</li><li>存储在 vuex 中的数据都是响应式的，能够实时保持数据与页面的同步</li></ul></li></ul><h3 id="基本使用">基本使用</h3><ul><li>安装 vuex 依赖包</li></ul><p><code>npm install vuex --save</code></p><ul><li>导入 vuex 包</li></ul><p><code>import Vuex from 'vuex'</code></p><p><code>Vue.use(Vuex)</code></p><ul><li>创建 store 对象</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"> <span class="comment">// state 中存放的就是全局共享的数据 state: &#123; count: 0 &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>将 store 对象挂载到 vue 实例中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"> render: <span class="function"><span class="params">h</span> =&gt;</span> h(app),</span><br><span class="line"> router,</span><br><span class="line"> <span class="comment">// 将创建的共享数据对象，挂载到 Vue 实例中</span></span><br><span class="line"> <span class="comment">// 所有的组件，就可以直接从 store 中获取全局的数据了 store</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="State">State</h3><ul><li><p>State 提供唯一的公共数据源，所有共享的数据都要统一放到 Store 的 State 中进行存储。</p></li><li><p>创建store数据源，提供唯一公共数据</p><p>const store = new Vuex.Store({</p><p>state: { count: 0 }</p><p>})</p></li><li><p>组件访问 State 中数据的第一种方式:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.全局数据名称</span><br></pre></td></tr></table></figure></li><li><p>组件访问 State 中数据的第二种方式:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 vuex 中按需导入 mapState 函数 </span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过刚才导入的 mapState 函数，将当前组件需要的全局数据，映射为当前组件的 computed 计算属性:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将全局数据，映射为当前组件的计算属性 </span></span><br><span class="line">computed: &#123;</span><br><span class="line">...mapState([<span class="string">&#x27;count&#x27;</span>]) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Mutation">Mutation</h3><ul><li><p>Mutation 用于变更 Store中 的数据。</p></li><li><p>只能通过 mutation 变更 Store 数据，不可以直接操作 Store 中的数据。</p></li><li><p>通过这种方式虽然操作起来稍微繁琐一些，但是可以集中监控所有数据的变化。</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Mutation</span></span><br><span class="line"> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line">state: &#123;</span><br><span class="line"></span><br><span class="line">count: <span class="number">0</span> &#125;,</span><br><span class="line"></span><br><span class="line">mutations: &#123; </span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span> &#123; <span class="comment">// 变更状态</span></span><br><span class="line">state.count++ </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发mutation methods: &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">handle1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 触发 mutations 的第一种方式 </span></span><br><span class="line">  <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><ul><li>可以在触发 mutations 时传递参数:</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Mutation</span></span><br><span class="line"> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line">state: &#123;</span><br><span class="line"></span><br><span class="line">count: <span class="number">0</span> &#125;,</span><br><span class="line"></span><br><span class="line">mutations: &#123; </span><br><span class="line">  <span class="function"><span class="title">addN</span>(<span class="params">state, step</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 变更状态 </span></span><br><span class="line">    state.count += step</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发mutation </span></span><br><span class="line"> methods: &#123;</span><br><span class="line"><span class="function"><span class="title">handle2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 在调用 commit 函数，</span></span><br><span class="line"> <span class="comment">// 触发 mutations 时携带参数 </span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;addN&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.$store.commit() 是触发 mutations 的第一种方式</span></span><br><span class="line"><span class="comment">//触发 mutations 的第二种方式:</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1. 从 vuex 中按需导入 mapMutations 函数 </span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//通过刚才导入的 mapMutations 函数，将需要的 mutations 函数，映射为当前组件的 methods 方法:</span></span><br><span class="line"><span class="comment">// 2. 将指定的 mutations 函数，映射为当前组件的 methods 函数 </span></span><br><span class="line">methods: &#123;</span><br><span class="line">...mapMutations([<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;addN&#x27;</span>]) &#125;</span><br></pre></td></tr></table></figure><h3 id="Action">Action</h3><ul><li><p>Action 用于处理异步任务。</p></li><li><p>如果通过异步操作变更数据，必须通过 Action，而不能使用 Mutation，但是在 Action 中还是要通过触发 Mutation 的方式间接变更数据。</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Action</span></span><br><span class="line"> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略其他代码 </span></span><br><span class="line">   mutations: &#123;</span><br><span class="line"><span class="function"><span class="title">add</span>(<span class="params">state</span>)</span> &#123; </span><br><span class="line">  state.count++</span><br><span class="line">&#125; </span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">actions: &#123; </span><br><span class="line">  <span class="function"><span class="title">addAsync</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">      context.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>) &#125;</span><br><span class="line"></span><br><span class="line">&#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 Action methods: &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">handle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 触发 actions 的第一种方式 </span></span><br><span class="line">  <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addAsync&#x27;</span>)</span><br><span class="line">&#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>触发 actions 异步任务时携带参数:</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Action</span></span><br><span class="line"> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略其他代码 </span></span><br><span class="line">   mutations: &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">addN</span>(<span class="params">state, step</span>)</span> &#123; </span><br><span class="line">      state.count += step</span><br><span class="line">&#125; </span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">actions: &#123; </span><br><span class="line">  <span class="function"><span class="title">addNAsync</span>(<span class="params">context, step</span>)</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">      context.commit(<span class="string">&#x27;addN&#x27;</span>, step)</span><br><span class="line">&#125;, <span class="number">1000</span>) &#125;</span><br><span class="line">&#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 Action methods: &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">handle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 在调用 dispatch 函数，</span></span><br><span class="line"> <span class="comment">// 触发 actions 时携带参数 </span></span><br><span class="line">  <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addNAsync&#x27;</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this.$store.dispatch() 是触发 actions 的第一种方式</span></span><br><span class="line"><span class="comment">//触发 actions 的第二种方式:</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1. 从 vuex 中按需导入 mapActions 函数 </span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//通过刚才导入的 mapActions 函数，将需要的 actions 函数，映射为当前组件的 methods 方法:</span></span><br><span class="line"><span class="comment">// 2. 将指定的 actions 函数，映射为当前组件的 methods 函数 </span></span><br><span class="line">methods: &#123;</span><br><span class="line">...mapActions([<span class="string">&#x27;addASync&#x27;</span>, <span class="string">&#x27;addNASync&#x27;</span>]) &#125;</span><br></pre></td></tr></table></figure><h3 id="Getter">Getter</h3><ul><li><p>Getter 用于对 Store 中的数据进行加工处理形成新的数据。</p></li><li><p>Getter 可以对 Store 中已有的数据加工处理之后形成新的数据，类似 Vue 的计算属性。</p></li><li><p>Store 中数据发生变化，Getter 的数据也会跟着变化。</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Getter</span></span><br><span class="line"> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"></span><br><span class="line"> state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line"> &#125;, </span><br><span class="line"> getters: &#123;</span><br><span class="line">showNum: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;当前最新的数量是【&#x27;</span>+ state.count +<span class="string">&#x27;】&#x27;</span></span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用 getters 的第一种方式:</span></span><br><span class="line"><span class="built_in">this</span>.$store.getters.名称</span><br><span class="line"><span class="comment">//使用 getters 的第二种方式:</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">computed: &#123; </span><br><span class="line">  ...mapGetters([<span class="string">&#x27;showNum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Front End </tag>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
            <tag> 状态管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 春风十里</title>
      <link href="2020/05/05/%E6%91%84%E5%BD%B1-%E6%98%A5%E9%A3%8E%E5%8D%81%E9%87%8C/"/>
      <url>2020/05/05/%E6%91%84%E5%BD%B1-%E6%98%A5%E9%A3%8E%E5%8D%81%E9%87%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SOMY 24-70GM<br>出镜：云歌<br>地点：南山创意园</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08748-20210326002816649.JPG" alt="DSC08748"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08749.JPG" alt="DSC08749"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08808.JPG" alt="DSC08808"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08812.JPG" alt="DSC08812"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08827.JPG" alt="DSC08827"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08836.JPG" alt="DSC08836"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08849.JPG" alt="DSC08849"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08851.JPG" alt="DSC08851"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08852.JPG" alt="DSC08852"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08853.JPG" alt="DSC08853"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08862.JPG" alt="DSC08862"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08871.JPG" alt="DSC08871"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08882.JPG" alt="DSC08882"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08902.JPG" alt="DSC08902"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08926.JPG" alt="DSC08926"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08952.JPG" alt="DSC08952"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08958.JPG" alt="DSC08958"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08965.JPG" alt="DSC08965"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08979.JPG" alt="DSC08979"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09011.JPG" alt="DSC09011"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09113.JPG" alt="DSC09113"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09178.JPG" alt="DSC09178"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC09236.JPG" alt="DSC09236"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 人像 </tag>
            
            <tag> JK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 基础入门 | 学习笔记</title>
      <link href="2020/04/05/React-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/04/05/React-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="React原理和JSX">React原理和JSX</h2><p><strong>React是Facebook开发出的一款JS框架 Facebook认为MVC无法满足他们的扩展需求 React发布于2013年</strong></p><h2 id="特点：">特点：</h2><ul><li><p>react不使用模板</p></li><li><p>react不是一个MVC框架</p></li><li><p>响应式（数据更新）</p></li><li><p>一个轻量级的JS库</p></li></ul><h2 id="原理">原理</h2><ul><li><p>虚拟DOM react把DOM抽象成一个JS对象</p></li><li><p>diff算法</p></li><li><p>虚拟DOM确保对界面上真正发生的部分进行实际DOM操作（先更改虚拟DOM再将真正发生变化的部分进行实际DOM操作）（虚拟DOM的存在是因为每次都进行完整DOM操作非常浪费资源）</p></li><li><p>逐层次进行节点比较</p></li></ul><h2 id="React-开发环境的搭建">React 开发环境的搭建</h2><ul><li><p>react.js 核心文件  npm install --save react</p></li><li><p>react-dom.js /react-native.js 渲染页面中的DOM 当前文件依赖于react核心文件  npm install --save react-dom</p></li><li><p>babel.js  ES6转换为ES5 JSX语法转换为JavaScript 先进浏览器进行代码兼容 npm install --save babel-standalone</p></li><li><p>babel在script标签内引用时 一定要写 type=text/babel</p></li><li><p>一个页面中需要有一个根节点（div）  这个节点下的内容就会被react管理</p></li></ul><h2 id="JSX-JavaScript-XML-JavaScript的扩展语法">JSX:JavaScript XML  JavaScript的扩展语法</h2><h3 id="优点：">优点：</h3><ul><li>执行效率更快</li><li>类型安全，编译过程中能及时发现错误</li><li>在用JSX的时候编写模板会更加简单和快速</li></ul><h2 id="生命周期">生命周期</h2><p><a href="#1-%E6%8C%82%E8%BD%BD%E5%8D%B8%E8%BD%BD%E8%BF%87%E7%A8%8B">1. 挂载卸载过程</a></p><ul><li><a href="#11constructor">1.1.constructor()</a></li><li><a href="#12componentwillmount">1.2.componentWillMount()</a></li><li><a href="#13componentdidmount">1.3.componentDidMount()</a></li><li><a href="#14componentwillunmount">1.4.componentWillUnmount ()</a></li></ul><p><a href="#2-%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B">2. 更新过程</a></p><ul><li><a href="#21-componentwillreceiveprops-nextprops">2.1. componentWillReceiveProps (nextProps)</a></li><li><a href="#22shouldcomponentupdatenextpropsnextstate">2.2.shouldComponentUpdate(nextProps,nextState)</a></li><li><a href="#23componentwillupdate-nextpropsnextstate">2.3.componentWillUpdate (nextProps,nextState)</a></li><li><a href="#24componentdidupdateprevpropsprevstate">2.4.componentDidUpdate(prevProps,prevState)</a></li><li><a href="#25render">2.5.render()</a></li></ul><p><a href="#3-react%E6%96%B0%E5%A2%9E%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AA%E4%BA%BA%E8%A1%A5%E5%85%85">3. React新增的生命周期(个人补充)</a></p><ul><li><a href="#31-getderivedstatefrompropsnextprops-prevstate">3.1. getDerivedStateFromProps(nextProps, prevState)</a></li><li><a href="#32-getsnapshotbeforeupdateprevprops-prevstate">3.2. getSnapshotBeforeUpdate(prevProps, prevState)</a></li></ul><h3 id="语法：">语法：</h3><ul><li><p>注释：{/**/}</p></li><li><p>JSX中的HTML标签必须按照W3C标准规范  标签必须闭合</p></li><li><p>JSX写多行标签需要一个父标签包裹（div）最好用括号括起来</p></li><li><p>如果想在JSX中使用表达式只需把表达式放入{ }中</p></li><li><pre><code class="language-javascript">//例如：&lt;div id=&quot;reactDom&quot;&gt;&lt;/div&gt;let text = &quot;HELLOREACT!&quot;;let myDom = (&lt;div&gt;&#123;text&#125;&lt;/div&gt;)ReactDOM.render(myDom, document.getElementById(&quot;reactDom&quot;));//即可渲染成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 计算</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  let num &#x3D; 9527;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;mYDom里：</span><br><span class="line">  &lt;div&gt;&#123;num + 1&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>函数</p></li><li><pre><code class="language-javascript">function fun(obj) &#123;//return&quot;名字是：&quot;+obj.name+&quot;年龄是：&quot;+obj.age;    return `名字是：$&#123;obj.name&#125;年龄是：$&#123;obj.age&#125;`;（ES6写法）&#125;//myDom里：&lt;div&gt;&#123;fun(user)&#125;&lt;/div&gt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 三目运算</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  let phone &#x3D; 4999;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;myDom内：</span><br><span class="line">  </span><br><span class="line">  &lt;div&gt;手机的价格是&#123;phone&#125;--- ---&#123;phone &gt; 4000 ? &quot;很贵&quot; : &quot;很便宜&quot;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>渲染数组</p></li><li><pre><code class="language-javascript">var arr = [        &lt;p&gt;新闻列表&lt;/p&gt;,        &lt;p&gt;新闻列表&lt;/p&gt;,        &lt;p&gt;新闻列表&lt;/p&gt;,        &lt;p&gt;新闻列表&lt;/p&gt;,        &lt;p&gt;新闻列表&lt;/p&gt;,        &lt;p&gt;新闻列表&lt;/p&gt;    ]    //myDom里：    &lt; div &gt; &#123;arr&#125;&lt;/div&gt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 属性设置</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  let link &#x3D; &quot;点我去百度&quot;;</span><br><span class="line">  let linkUrl &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;;</span><br><span class="line">  &#x2F;&#x2F;myDom里：</span><br><span class="line">  &lt;a href&#x3D;&#123;linkUrl&#125;&gt;&#123;link&#125;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>样式设置</p></li><li><pre><code class="language-javascript">//注意style接收的是一个对象let modstyle = &#123;color: &quot;red&quot;, fontSize: 30, backgroundColor: &quot;pink&quot;&#125;;//myDom里：&lt;div style = &#123;modstyle&#125; &gt; 修改我的样式 &lt; /div&gt;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- class类设置</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F;注意在JSX中不能使用class  这个属性是js的关键字  所以用className</span><br><span class="line">  </span><br><span class="line">  &lt;div className&#x3D;&quot;class1&quot;&gt;class样式&lt;&#x2F;div&gt;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;&lt;style&gt;内</span><br><span class="line">  </span><br><span class="line">  .class1&#123;</span><br><span class="line">  </span><br><span class="line">  font-size:30px;</span><br><span class="line">  </span><br><span class="line">  background-color:pink;</span><br><span class="line">  </span><br><span class="line">  color:red;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h1>教程</h1><h2 id="遍历列表">遍历列表</h2><h3 id="map遍历">map遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//react数组遍历渲染map（）方法</span></span><br><span class="line"><span class="comment">//必须填入key值且独一无二建议index</span></span><br><span class="line"><span class="comment">//若要换行用（）</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;打豆豆&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> myDom = arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;p key = &#123;index&#125; &gt; &#123;item&#125;</span><br><span class="line">&lt;/p&gt;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="for-in-遍历">for in 遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;打豆豆&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newarr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        newarr.push( <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span> = <span class="string">&#123;index&#125;</span> &gt;</span> &#123;arr[index]&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历对象">遍历对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;LERONCHAO&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    sex: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDom = (</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;value&#125;:&#123;obj[value]&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ReactDOM.render(myDom, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="设置点击样式、点击事件onClick">设置点击样式、点击事件onClick</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;打豆豆&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myDom = arr.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> <span class="attr">i</span> == <span class="string">index</span> ? &#x27;<span class="attr">red</span>&#x27; <span class="attr">:</span> &#x27;&#x27;&#125;&#125; <span class="attr">key</span>=<span class="string">&#123;i&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">            index = i;</span></span><br><span class="line"><span class="xml">            render();</span></span><br><span class="line"><span class="xml">        &#125;&#125;&gt;&#123;v&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> myDom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDOM.render(fun(), <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render();</span><br></pre></td></tr></table></figure><h2 id="封装组件（组件名称第一个字母必须大写）">封装组件（组件名称第一个字母必须大写）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;这是一个无状态组件&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDom = (&lt;div&gt;</span><br><span class="line">    &lt;Com/&gt;</span><br><span class="line">&lt;/div&gt;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(myDom, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="父子组件嵌套渲染">父子组件嵌套渲染</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是子组件<span class="number">1</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是子组件<span class="number">2</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComC</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            我是子组件<span class="number">3</span></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyCom</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ComA/&gt;</span><br><span class="line">            &lt;ComB/&gt;</span><br><span class="line">            &lt;ComC/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDom = &lt;div&gt;</span><br><span class="line">    &lt;MyCom/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(myDom, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建类组件">创建类组件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    render()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;类组件&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDom = &lt;div&gt;</span><br><span class="line">    &lt;Com/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(myDom, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="Props传值（组件对外的接口）">Props传值（组件对外的接口）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无状态组件props传值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Com</span>(<span class="params">props</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            外部传入props的数据是：&#123;props.text&#125;:&#123;props.num&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类组件props传值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    render()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                外部传入props的数据是：&#123;<span class="built_in">this</span>.props.text&#125;:&#123;<span class="built_in">this</span>.props.num&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写法一</span></span><br><span class="line"><span class="keyword">let</span> myDom = &lt;div&gt;</span><br><span class="line">    &lt;Com text=<span class="string">&quot;LEBRONCHAO&quot;</span> num=<span class="string">&quot;20&quot;</span>/&gt;</span><br><span class="line">    &#123;<span class="comment">/*此处也可以通过&#123;&#125;写入变量*/</span>&#125;</span><br><span class="line">&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    text: <span class="string">&quot;LEBRONCHAO&quot;</span>,</span><br><span class="line">    num: <span class="string">&quot;20&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> myDom = &lt;div&gt;</span><br><span class="line">    &lt;Com &#123;...obj&#125;/&gt;</span><br><span class="line">    &#123;<span class="comment">/*ES6扩展运算符写法</span></span><br><span class="line"><span class="comment">...obj即text=&quot;LEBRONCHAO&quot;,num=&quot;20&quot;*/</span>&#125;</span><br><span class="line">&lt;/div&gt;;</span><br><span class="line">ReactDOM.render(myDom, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="Props默认值的编写">Props默认值的编写</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Com.defaultProps = &#123;</span><br><span class="line">    name: <span class="string">&quot;LEBRONCHAO&quot;</span>,</span><br><span class="line">    num: <span class="string">&quot;20&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//（类组件用法相同）</span></span><br><span class="line"><span class="comment">// 类组件第二种写法：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Static defaultProps</span><br><span class="line">    &#123;</span><br><span class="line">        name：“第二种方式<span class="string">&quot;，</span></span><br><span class="line"><span class="string">        num：20</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    render()&#123;</span></span><br><span class="line"><span class="string">        return (</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                外部传入props的数据是：&#123;this.props.name&#125;:&#123;this.props.num&#125;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//15.x  react版本写法</span></span><br><span class="line"><span class="string">function Com(props)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    props.name = props.name || &quot;</span>LEBRONCHAO<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    props.num = props.num || &quot;</span><span class="number">20</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">        &lt;div&gt;props的数据是：&#123;props.name&#125;:&#123;props.num&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Com(props)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">        &lt;div&gt;props的数据是：&#123;props.name&#125;:&#123;props.num&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">let myDom = &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;Com/&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;;</span></span><br><span class="line"><span class="string">ReactDOM.render(myDom, document.getElementById(&quot;</span>reactDom<span class="string">&quot;))</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="Props数据类型验证-上线模式请取消-大小写严格要求">Props数据类型验证  上线模式请取消 大小写严格要求</h2><ul><li>引用prop-types库  <code>npm install --save prop-types</code></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Com.propTypes=&#123;</span><br><span class="line"></span><br><span class="line">num:PropTypes.number  <span class="comment">//验证num是否为数字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//（类组件用法相同）</span></span><br></pre></td></tr></table></figure><ul><li><p>propstypes验证不会影响页面展示  控制台会报错</p></li><li><p>除了验证数据类型还可以设置 isRequired必须填写属性可串写</p></li><li><p>PropTypes.number.isRequired具体可检查类型见react官网</p></li></ul><h2 id="子组件遍历渲染父组件传入列表">子组件遍历渲染父组件传入列表</h2><p>制造不断点击LOL英雄列表消失、显示效果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bool = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> arrData = [<span class="string">&quot;寒冰&quot;</span>, <span class="string">&quot;盖伦&quot;</span>, <span class="string">&quot;蛮王&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> Father = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">        &lt;h1 onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            bool = !bool;</span><br><span class="line">            fun();</span><br><span class="line">        &#125;&#125;&gt;LOL英雄展示&lt;/h1&gt;</span><br><span class="line">        &lt;Son arr=&#123;arrData&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> Son = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">display</span>: bool ? <span class="string">&quot;block&quot;</span> : <span class="string">&quot;none&quot;</span>&#125;&#125;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                props.arr.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span>&#123;v&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Father</span>&gt;</span><span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun()</span><br></pre></td></tr></table></figure><h2 id="State状态">State状态</h2><ul><li>使用state不能使用无状态组件（函数式）</li></ul><h3 id="state和props的区别：">state和props的区别：</h3><ul><li><p>state可变  props只负责传递不可更改</p></li><li><p>props是组件对外的接口  state是组件队内的接口</p></li><li><p>组件内可以引用其他组件 组件之间的引用就形成了一个树状结构</p></li><li><p>下层组件需要使用上层组件的数据使用state</p></li><li><p>组件除了使用上层组件传递的数据外 自身有可能又需要管理的数据  state进行内部数据管理</p></li><li><p>react中我们只需要关心的是数据  当数据改变的时候页面就自动发生改变</p></li><li><p>状态等同于页面中的数据  状态/数据改变了页面中对应的数据绑定内容就会被react自动改变</p></li><li><p>声名式渲染  一切的数据改变操作都不用我们关心 只需要我们声明好数据  react自动对于数据的改变进行相应的改变</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCom</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line"><span class="comment">//ES6中不管子类写不写constructor在new实例的时候都会补上constructor</span></span><br><span class="line"><span class="comment">//我们可以不写constructor如果写了之后就必须在其中super（）就是指向父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line"><span class="comment">//如果想在constructor中使用props，super和constructor中必须写上props</span></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">&quot;LEBRONCHAO&quot;</span>,</span><br><span class="line">            tag: <span class="string">&quot;&lt;p&gt;我是一个标签&lt;/p&gt;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;<span class="comment">/*this.setState(&#123;key:value&#125;)异步的react就会自动触发render进行数据的渲染*/</span>&#125;</span><br><span class="line">                &lt;div&gt;我的名字是&#123;<span class="built_in">this</span>.state.name&#125;&lt;/div&gt;</span><br><span class="line">                &lt;button onClick=&#123;(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">&quot;JAMES&quot;</span>&#125;)</span><br><span class="line">                &#125;)&#125;&gt;点击我改变数据</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">                &lt;div&gt;&#123;<span class="built_in">this</span>.state.tag&#125;&lt;/div&gt;</span><br><span class="line">                &#123;<span class="comment">/*如果要插入的值是html，使用dangerouslySetInnerHTML=&#123;&#123;__html:&quot;&quot;&#125;&#125;属性*/</span>&#125;</span><br><span class="line">                &lt;div dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: <span class="built_in">this</span>.state.tag&#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDom = (&lt;div&gt;</span><br><span class="line">    &lt;MyCom/&gt;</span><br><span class="line">&lt;/div&gt;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(myDom, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="转发refs">转发refs</h2><ul><li><p>react当中提供了一个ref的数据（无状态组件无法使用）</p></li><li><p>表示当前组件真正的实例的引用 他会返回绑定当前属性的元素</p></li><li><p>标识内部组件方便查找</p></li></ul><h3 id="React中三种三种方式进行ref引用">React中三种三种方式进行ref引用</h3><ul><li><p>字符串的形式</p></li><li><p>回调函数</p><p>在dom节点上或组件上挂载函数 函数的入参形参 是dom节点 他的效果和字符串的方式一样都是获取值得引用</p></li><li><p>React.createRef() react16.3新提供的方式</p><p>把值赋给一个变量 通过ref挂载在节点或者组件上  使用ref的current属性拿到这个节点</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.myRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="comment">//console.log(this.refs.demo.value);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="comment">//console.log(this.textinput.value);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="comment">//console.log(this.myRef.current.value);</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;<span class="comment">/*1.字符串方法</span></span><br><span class="line"><span class="comment">&lt;input type=&quot;text&quot; ref=&quot;demo&quot; placeholder=&quot;请输入&quot;/&gt;</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line"></span><br><span class="line">                &#123;<span class="comment">/*2.挂载函数方法</span></span><br><span class="line"><span class="comment">&lt;input type=&quot;text&quot; ref=&#123;(input)=&gt;&#123;this.textinput=input&#125;&#125;/&gt;</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line">                &#123;<span class="comment">/*3.React.createRef()方法</span></span><br><span class="line"><span class="comment">&lt;input type=&quot;text&quot; ref=&#123;this.myRef&#125;/&gt;</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.fun&#125;&gt;点击我得到输入框的值&lt;/button&gt;</span><br><span class="line">                &lt;div&gt;&#123;<span class="built_in">this</span>.state.demo&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Com</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="React事件处理">React事件处理</h2><ul><li><p>react事件处理使用小驼峰命名法 在绑定函数的时候不能加（） 加了函数会立即执行</p></li><li><p>箭头函数默认指向当前类组件 其他函数需要通过以下方法更改this</p></li></ul><h3 id="修改this指向方法：">修改this指向方法：</h3><ul><li><p>bind方式原地 绑定</p></li><li><p>函数通过箭头函数进行创建</p></li><li><p>constructor中提前绑定</p></li><li><p>把时间的调用写成箭头函数的调用方式(加圆括号)</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.func = <span class="built_in">this</span>.func.bind(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">funa</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    funb = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">fund</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fune = <span class="function">(<span class="params">i, event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">        <span class="built_in">console</span>.log((event));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.funa.bind(<span class="built_in">this</span>)&#125;&gt;bind原地绑定&lt;/button&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.funb&#125;&gt;通过箭头函数创建&lt;/button&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.func&#125;&gt;<span class="title">constructor</span>中提前绑定&lt;/<span class="title">button</span>&gt;</span><br><span class="line">                &lt;<span class="title">button</span> <span class="title">onClick</span>=&#123;() =&gt; &#123;</span><br><span class="line">                    <span class="built_in">this</span>.fund()</span><br><span class="line">                &#125;&#125;&gt;事件写成箭头函数调用</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">                &lt;h1&gt;函数实参传递&lt;/h1&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.fune.bind(<span class="built_in">this</span>, <span class="string">&quot;我是参数1&quot;</span>)&#125;&gt;bind方法&lt;/button&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.fune(<span class="string">&quot;我是参数2&quot;</span>, event)</span><br><span class="line">                &#125;&#125;&gt;箭头函数方法</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Com</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="条件渲染">条件渲染</h2><ul><li><p>根据状态变化 只渲染其中一部分</p></li><li><p>JSX中不允许if语句</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state=&#123;</span><br><span class="line">            bool:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">bool</span>:!<span class="built_in">this</span>.state.bool&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> text;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.state.bool)&#123;</span><br><span class="line">            text=<span class="string">&quot;你好&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            text=<span class="string">&quot;你坏&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;三目运算符方法&lt;/h1&gt;</span><br><span class="line">                &lt;p&gt;&#123;<span class="built_in">this</span>.state.bool?<span class="string">&quot;你好&quot;</span>:<span class="string">&quot;你坏&quot;</span>&#125;&lt;/p&gt;</span><br><span class="line">                &lt;h1&gt;<span class="keyword">if</span>判断方法&lt;/h1&gt;</span><br><span class="line">                &lt;p&gt;&#123;text&#125;&lt;/p&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.fun.bind(<span class="built_in">this</span>)&#125;&gt;条件渲染&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Com</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="状态提升">状态提升</h2><ul><li><p>多个组件需要反映相同的变化数据 提升到他们最近的一个父组件中</p></li><li><p>多个子组件需要利用到对方状态的情况下</p></li><li><p>在父组件中声明状态变量和改变</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demoa</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                我是组件一：&#123;<span class="built_in">this</span>.props.text&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demob</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                我是组件二：&#123;<span class="built_in">this</span>.props.text&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            text: <span class="string">&quot;我是两个组件都需要的数据&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">fun</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">text</span>: <span class="string">&quot;数据已修改&quot;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                父组件</span><br><span class="line">                &lt;Demoa text=&#123;<span class="built_in">this</span>.state.text&#125;/&gt;</span><br><span class="line">                &lt;Demob text=&#123;<span class="built_in">this</span>.state.text&#125;/&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>.fun.bind(<span class="built_in">this</span>)&#125;&gt;修改数据&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Com</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;reactDom&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="React脚手架使用">React脚手架使用</h2><ul><li><p>npm install -g create-react-app 全局安装脚手架</p></li><li><p>create-react-app --version 查看版本</p></li><li><p>在需要创建项目的目录下 create-react-app 项目名（英文） 创建项目</p></li><li><p>npm start 启动项目</p></li></ul><h3 id="工程文件介绍：">工程文件介绍：</h3><ul><li><p><a href="http://readme.md">readme.md</a> --项目介绍自定义一些项目信息以及简单使用</p></li><li><p>package.json --dependencies下管理生产环境所用的包及版本</p><ul><li>devDependencies里得插件只用于开发环境，不用于生产环境</li><li>name项目名称</li><li>version项目版本</li><li>scripts项目启动等功能设置</li></ul></li><li><p>package.lock.json —上线锁定版本信息</p></li><li><p>gitignore  git的选择性上传的配置文件，比如一会要介绍的node_modules文件夹，就需要配置不上传。</p></li><li><p>public       —公共文件，里边有公用模板和图标等一些东西</p></li></ul><p><strong>public文件夹介绍</strong></p><p>这个文件都是一些项目使用的公共文件，也就是说都是共用的，我们就具体看一下有那些文件吧。</p><ul><li><p>favicon.ico : 这个是网站或者说项目的图标，一般在浏览器标签页的左上角显示。</p></li><li><p>index.html : 首页的模板文件，我们可以试着改动一下，就能看到结果。</p></li><li><p>mainifest.json：移动端配置文件。</p></li><li><p>src   主要代码编写文件，这个文件夹里的文件对我们来说最重要，都需要我们掌握</p></li></ul><p><strong>src文件夹介绍</strong></p><p>这个目录里边放的是我们开放的源代码，我们平时操作做最多的目录。</p><ul><li>index.js : 这个就是项目的入口文件。</li><li>index.css ：这个是index.js里的CSS文件。</li><li>app.js : 这个文件相当于一个方法模块，也是一个简单的模块化编程。</li><li>serviceWorker.js: 这个是用于写移动端开发的，PWA必须用到这个文件，有了这个文件，就相当于有了离线浏览的功能。</li></ul><h3 id="src内建立Components文件夹写组件">src内建立Components文件夹写组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component，Fragment&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>     <span class="comment">//此处引入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line"><span class="comment">//若不想建立div包裹可用&lt;&gt;&lt;/&gt;  或者&lt;Fragment&gt;&lt;Fragment/&gt;（要引入） </span></span><br><span class="line">            &lt;div&gt;内容&lt;div/&gt;) </span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片引用的三种方式">图片引用的三种方式</h2><h3 id="例如1-jpg">例如1.jpg</h3><ul><li><p>直接把图片放在public中 src=“1.jpg”</p></li><li><p>把图片通过引用方式引入</p></li></ul><p><code>Import ImgA from ‘路径’   src=&#123;ImgA&#125;</code></p><ul><li><p>src={require(“路径”)}</p><ul><li><p>props验证需引入 import PropTypes from ‘prop-types’</p></li><li><p>props父传子使用和state使用相同</p></li></ul></li></ul><h2 id="子传父写法">子传父写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子组件内：</span></span><br><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.fufun(<span class="built_in">this</span>.state.ziText)</span><br><span class="line">&#125;&#125;&gt;点我子传父&lt;/button&gt;</span><br><span class="line"><span class="comment">//父组件内：</span></span><br><span class="line">&lt;News fufun=&#123;<span class="function">(<span class="params">text</span>) =&gt;</span> <span class="built_in">this</span>.dataFun(text)&#125;/&gt;</span><br><span class="line">&lt;div&gt;&#123;<span class="built_in">this</span>.state.ziText&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">dataFun = <span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">ziText</span>: text&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="同级组件传值pubsub方法">同级组件传值pubsub方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受组件写法：</span></span><br><span class="line">PubSub.subscribe(<span class="string">&quot;eve&quot;</span>, <span class="function">(<span class="params">msg, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        phone: data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送组件写法：</span></span><br><span class="line">PubSub.publish(<span class="string">&quot;eve&quot;</span>, <span class="built_in">this</span>.state.num);</span><br></pre></td></tr></table></figure><h2 id="Json-server-和-axios">Json-server 和 axios</h2><ul><li>全局安装 npm install     json-server -g</li><li>启动 cd     到对应文件夹（含json的文件）下</li><li>控制台  json-server json文件名 --port 4000（修改端口，默认端口用作前端开发）</li></ul><h3 id="axios">axios</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局安装</span></span><br><span class="line"><span class="comment">//npm install --save axios</span></span><br><span class="line"><span class="comment">//在页面中引用axios</span></span><br><span class="line"><span class="comment">//方法不止于get</span></span><br><span class="line">axios.get(<span class="string">&quot;url&quot;</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">data:res.data</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="React解决跨域">React解决跨域</h2><ul><li><p>正向代理—开发环境</p><p>一个位于客户端和目标服务器之间的代理服务器  为了获取到目标服务器的内容客户端向代理服务器发送一个请求 代理服务器帮助我们去目标服务器里获取数据并返回给我们</p></li><li><p>反向代理—上线环境</p><p>可以通过代理服务器来接受网络上的请求连接  然后将这个请求转发给内部的网络服务器上并且把这个服务器上的得到的数据返回给请求的客户端</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Node/react-script/config/webpackDevServer.config.js下</span><br><span class="line"></span><br><span class="line">找到proxy</span><br><span class="line"></span><br><span class="line">proxy:&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;/api&quot;</span>:&#123;</span><br><span class="line"></span><br><span class="line">target:<span class="string">&quot;url&quot;</span>,</span><br><span class="line"></span><br><span class="line">chaneOrigin:<span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;pathRewrite&quot;</span>:&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;^api&quot;</span>:<span class="string">&quot;/&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">axios.get(<span class="string">&quot;/api&quot;</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//执行函数回调</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="React-路由">React 路由</h2><p><code>react-router</code>  只提供一些核心API</p><p><code>react-router-dom</code>  更多选项</p><h3 id="路由模式">路由模式</h3><ul><li><p>hash模式  HashRouter  带#号  刷新的时候页面不会丢失</p></li><li><p>browser  BrowserRouter  历史记录模式  无#号  他是通过历史记录api来进行路由切换刷新会丢失 本地模式不会</p></li><li><p>下载 npm install --save raect-router-dom</p></li><li><p>index.js中引用  import {BrowserRouter}/{HashRouter} from ‘react-router-dom’</p><ul><li><code>用BrowserRouter/HashRouter包裹APP标签</code></li></ul></li><li><p>使用路由的组件 引入路由 import {Route，Link，NavLink，Switch，Redirect} from ‘react-router-dom’</p></li><li><p>配置Route (通过Route组件 写 path 、component实现路由)</p></li><li><p>配置Link/NavLink 通过Link/NavLink组件写to路径  要和Route中的path相同</p></li><li><p>NavLink给动态地给选中的导航添加active类名  方便写样式</p></li><li><p>Redirect标签写默认首页  from”/“  to”/组件名“  并写exact属性精准匹配</p></li><li><p>path写入”/“每次都会默认渲染 <code>添加exact属性精准匹配可消除</code></p></li><li><p>多个相同的Route渲染 <code>用Switch标签</code>（从react-router-dom引入）包裹可避免重复</p></li><li><p>Route相当于路由页面</p></li><li><p>Link相当于链接按钮</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&quot;./Components/Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;NavLink, Redirect, Route&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Page1 <span class="keyword">from</span> <span class="string">&quot;./pages/Page1&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Page2 <span class="keyword">from</span> <span class="string">&quot;./pages/Page2&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Page3 <span class="keyword">from</span> <span class="string">&quot;./pages/Page3&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;NavLink to=<span class="string">&quot;/Page1&quot;</span>&gt;Page1&lt;/NavLink&gt;</span><br><span class="line">    &lt;NavLink to=<span class="string">&quot;/Page2&quot;</span>&gt;Page2&lt;/NavLink&gt;</span><br><span class="line">    &lt;NavLink to=<span class="string">&quot;/Page3&quot;</span>&gt;Page3&lt;/NavLink&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path=<span class="string">&quot;/Page1&quot;</span> component=&#123;Page1&#125;/&gt;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/Page2&quot;</span> component=&#123;Page2&#125;/&gt;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/Page3&quot;</span> component=&#123;Page3&#125;/&gt;</span><br><span class="line">&lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;/&quot;</span> to=<span class="string">&quot;/Page3&quot;</span> exact&gt;&lt;/Redirect&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//子路由配置（Page1下）</span></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Route, NavLink, Redirect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Child1 <span class="keyword">from</span> <span class="string">&quot;./childpages/Child1&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Child2 <span class="keyword">from</span> <span class="string">&quot;./childpages/Child2&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Child3 <span class="keyword">from</span> <span class="string">&quot;./childpages/Child3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Page1</span><br><span class="line">                &lt;NavLink to=<span class="string">&quot;/Page1/Child1&quot;</span>&gt;Child1&lt;/NavLink&gt;</span><br><span class="line">                &lt;NavLink to=<span class="string">&quot;/Page1/Child2&quot;</span>&gt;Child2&lt;/NavLink&gt;</span><br><span class="line">                &lt;NavLink to=<span class="string">&quot;/Page1/Child3&quot;</span>&gt;Child3&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">                &lt;Route component=&#123;Child1&#125; path=<span class="string">&quot;/Page1/Child1&quot;</span>&gt;&lt;/Route&gt;</span><br><span class="line">                &lt;Route component=&#123;Child2&#125; path=<span class="string">&quot;/Page1/Child2&quot;</span>&gt;&lt;/Route&gt;</span><br><span class="line">                &lt;Route component=&#123;Child3&#125; path=<span class="string">&quot;/Page1/Child3&quot;</span>&gt;&lt;/Route&gt;</span><br><span class="line">                &lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;/&quot;</span> to=<span class="string">&quot;/Page1/Child3&quot;</span>&gt;&lt;/Redirect&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Page1;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="高阶组件">高阶组件</h2><p>withRouter从react-router-dom中引入  用withRouter包裹App withRouter（App）（export 的地方）</p><p>（HOC 参数是一个组件 同时返回的也是一个组件  这类组件我们称为高阶组件 就是让不是路由切换的组件也具有路由切换的三个属性location history match）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监控路由变化 </span></span><br><span class="line"></span><br><span class="line">history.listen(<span class="function">(<span class="params">link</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">Cosole.log(link)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="编程式导航">编程式导航</h2><ul><li>APP组件参数写入props</li></ul><p><code>&lt;button onClick=&#123;()=&gt;&#123;props.history.push&quot;path&quot;&#125;&#125;&gt;点我去path&lt;button&gt; </code></p><ul><li>path替换路径例如/Home</li></ul><h3 id="编程式路由传参">编程式路由传参</h3><ul><li><p>params方式进行传参</p><ul><li><p>在Route组件中path属性路径后面写上  /:参数名</p></li><li><p>发送参数在NavLink/Link标签的to后写  /参数</p></li><li><p>在对应组件接收页面接收 props.match.params.参数名</p></li><li><p>优势：刷新地址，参数依然存在</p></li><li><p>缺点：只能传递字符串，并且参数过多的时候url会变得比较丑陋</p></li></ul></li><li><p>query方式传参</p><ul><li><p>不需要再Route组件中配置</p></li><li><p>直接在NavLink/Link标签的to属性中发送数据</p></li><li><p>对应组件中用this.props.location.query.参数名</p></li><li><p>NavLink/Link标签写法：</p><p><code>&lt;NavLink to=&#123;&#123;pathname:"路径",query:&#123;参数名：“参数”&#125;&#125;&#125;&gt;</code></p><p><code>此写法可尝试传多参 推荐</code></p></li></ul></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> React </tag>
            
            <tag> Front End </tag>
            
            <tag> SPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 户外打鸟</title>
      <link href="2020/03/14/%E6%91%84%E5%BD%B1-%E9%B8%9F%E7%B1%BB%E6%91%84%E5%BD%B1/"/>
      <url>2020/03/14/%E6%91%84%E5%BD%B1-%E9%B8%9F%E7%B1%BB%E6%91%84%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 24-70GM   SONY 24-240mm<br>出镜：无<br>地点：深圳湾公园</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08439.JPG" alt="DSC08439"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08347.JPG" alt="DSC08347"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08489.JPG" alt="DSC08489"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08558.JPG" alt="DSC08558"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08511.JPG" alt="DSC08511"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08473.JPG" alt="DSC08473"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08585-2.JPG" alt="DSC08585-2"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08657.JPG" alt="DSC08657"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 鸟类 </tag>
            
            <tag> 打鸟 </tag>
            
            <tag> 长焦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 基础入门 | 学习笔记</title>
      <link href="2020/03/06/Vue-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/03/06/Vue-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue使用总结">Vue使用总结</h2><p>组件化编程思想 在component文件夹内编写的组件可以通过import引入页面使用（标签）（引入页面components内注册）</p><h2 id="Vue模板语法">Vue模板语法</h2><ul><li><p>使用实现数据绑定，变量写在data中</p></li><li><p>v-once属性和const差不多  定义为常量、不可变   模板：v-once=‘变量名’</p></li><li><p>v-html属性可在data中写入html语句进行渲染     模板： v-html=‘变量名’</p></li><li><p><code>&#123;&#123;  &#125;&#125;</code>格式的数据绑定可写入</p><ul><li>数学计算式</li><li>三目运算</li><li>JS功能函数</li></ul></li><li><p>v-bind属性可给标签绑定属性</p><ul><li><p>模板语法： v-bind=:属性=‘变量名’  变量在data中定义、描述</p></li><li><p>缩写：  ：属性=‘变量名’</p></li><li><p>例：  :disabaled=‘msg’  data中 msg：true</p></li></ul></li><li><p>v-on属性给标签绑定事件 不止于click</p><ul><li>模板： v-on:事件名=‘函数名’  缩写： @事件名=‘函数名’</li><li>例： @click=‘change（）’</li><li>methods中写入函数</li></ul></li></ul><h2 id="Vue条件语句-遍历循环渲染">Vue条件语句 遍历循环渲染</h2><ul><li><p>v-if条件渲染</p><ul><li><p>模板： v-if=‘变量名’   v-if=“变量==条件”</p></li><li><p>此外还有v-else-if  v-else  语法相同</p></li><li><p>复用相同组件时绑定key属性重新渲染（包括v-for遍历）</p></li></ul></li><li><p>v-show属性条件渲染</p><ul><li>模板： v-show=“变量”  变量在data中定义</li><li>变量true显示，false不显示</li><li>和v-if不同的是  v-if中变量为false时不渲染  v-show渲染只是把disabled属性改为了true</li></ul></li><li><p>v-for循环属性实现条件渲染</p><ul><li>模板： v-for=“item in items”在data中写入 items清单（数组）</li><li>可传入多值  item替换为（属性1，属性2，属性3）即可</li></ul></li></ul><h2 id="Vue-computed-计算属性">Vue computed 计算属性</h2><ul><li><p>不同于methods中的方法，触发每次都会执行；</p></li><li><p>computed中的操作只要变量值没有改变，函数不会重新执行，依赖于缓存数据</p></li><li><p>计算属性一个函数分为getter函数（获取值）和setter函数（修改值）（再带value参数）</p></li></ul><h2 id="Vue-watch监听属性">Vue watch监听属性</h2><ul><li><p>可用v-model绑定数据  后台监听，一旦变量改变 执行函数</p></li><li><p>watch内写入函数  data内声明v-model绑定的变量</p></li><li><p>函数名和变量名相同自带newv和oldv参数为新值和旧值</p></li></ul><h2 id="Vue样式属性绑定">Vue样式属性绑定</h2><ul><li><p>使用v-bind绑定class</p><ul><li>模板：  ：class=“变量”</li><li>变量在data中声明 变量中写入style中定义好的样式</li><li>如  ：class=“a”    data中 a：“aclass”      style中  .aclass{fontSize:20px}</li><li>可通过：class={样式名：变量名，样式名：变量名}的形式绑定多样式</li><li>变量通过boolean值决定是否使用样式  函数中可实现动态改变样式</li></ul></li><li><p>使用v-bind绑定style</p><ul><li>模板： ﻿:style=&quot;{样式名:变量 , 样式名: 变量}</li></ul></li></ul><h2 id="Vue事件处理器">Vue事件处理器</h2><ul><li><p>在methods中写的函数可用@click绑定到标签上</p></li><li><p>v-bind绑定的事件可添加多种修饰符（以下有@click作为模板讲解）：</p><ul><li>@click.stop属性 防止向上一层传播<ul><li>例如 div中的p标签绑定@click.stop，p标签点击事件执行，div的点击事件不会执行</li></ul></li></ul><ul><li>@click.prevent属性  组织触发的函数执行</li><li>属性修饰符可以串联如@click.stop.prevent</li><li>其他修饰符：<ul><li>.passive 不阻止事件的默认行为（@scroll.passive=&quot;&quot;滑动时触发）</li><li>.once   只触发一次</li><li>.self    只有是当前元素时触发</li><li>.capture 添加事件监听器</li></ul></li></ul><ul><li><p>@keyup 监听键盘按键按下式调用</p><ul><li><p>如 @keyup.enter=‘’‘’</p></li><li><p>支持监听多按键 如 @keyup.enter.ctrl</p></li></ul></li><li><p>.exact修饰符表示只有按下当前按键时才触发（不能同时按下其他按键）</p><ul><li>如 @keyup.ctrl.exact</li><li>鼠标按键修饰符：.middle  .left  .right</li></ul></li></ul></li></ul><h2 id="Vue表单处理">Vue表单处理</h2><ul><li><p>input、textarea表单都可以用v-model实现双向数据绑定</p></li><li><p>复选框 绑定相同的v-model在data内定义数组即实现数据双向绑定</p></li><li><p>：value可实现绑定value值</p></li><li><p>.lazy修饰符每次选择后数据同步</p></li><li><p>.number修饰符只允许输入数字</p></li><li><p>.trim不允许输入空格</p></li></ul><h2 id="Vue脚手架安装">Vue脚手架安装</h2><ul><li><p>components内放入页面、组件</p></li><li><p>App.vue首页</p></li><li><p>只允许存在一个根目录如div</p></li><li><p>script内可用import引入组件</p></li><li><p>如  import MENU(组件名) from ‘路径’</p></li><li><p>Export default内必须写入name(当前组件名称)</p></li><li><p>Data(){}用方法写,return框内声明变量</p></li><li><p>Main.js内通过import引入Vue、App组件和使用到的插件（并用Vue.use方法使用插件)</p></li><li><p>并new Vue对象  并注册使用的插件例如router</p></li><li><p>Index.html写好div（id=app）作项目入口</p></li></ul><h2 id="父子组件传输数据">父子组件传输数据</h2><h3 id="方法一（父传子）">方法一（父传子）</h3><ul><li><p>传递页面在data内写好函数 在组件标签内写入  ：方法名=‘方法名’即可</p></li><li><p>被传递页面内script  写入props：[‘参数名’]进行接收</p></li><li><p>模板：</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//父组件 HTML  menus为父组件变量</span></span><br><span class="line">&lt;props :menus=<span class="string">&#x27;menus&#x27;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;menu&quot;</span> :addMenu=<span class="string">&quot;addMenu&quot;</span>&gt;&lt;/props&gt;</span><br><span class="line"><span class="comment">//子组件js</span></span><br><span class="line">props:&#123;</span><br><span class="line">menus:<span class="built_in">Object</span>,</span><br><span class="line">addMenu:<span class="built_in">Function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-（子传父）">方法二 （子传父）</h3><ul><li><p>通过在被引入页面标签上写入@引入量=“引入量”，在引入页面写入this.$emit(‘引入量’，形参)触发自定义事件引入  即可执行该函数   此时不能this.addMenu(未引入)</p></li><li><p>模板：</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父组件  addMenu为父组件变量</span></span><br><span class="line">&lt;props <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;menu&quot;</span> @addMenu=<span class="string">&quot;addMenu&quot;</span>&gt;&lt;/props&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件  menu为子组件变量</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;addMenu&#x27;</span>,menu)</span><br></pre></td></tr></table></figure><h3 id="方法三-（组件间）">方法三 （组件间）</h3><ul><li><p>使用引用ref属性写入标签索引量</p></li><li><p>引入页面mounted生命周期内写入this.$refs.menu(索引).$on(‘addMenu（引入量）’,this.addMenu（当前页面被引入量）)</p></li><li><p>在被引入页面写入this.$emit(‘引入量’，形参)触发自定义事件引入</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宿组件HTML、Js  this.addMenu为宿组件变量</span></span><br><span class="line">&lt;props <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;menu&quot;</span> ref=<span class="string">&quot;menu&quot;</span>&gt;&lt;/props&gt;</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.$refs.menu.$on(<span class="string">&#x27;addMenu&#x27;</span>,<span class="built_in">this</span>.addMenu)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源组件JS</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;addMenu&#x27;</span>,menu)</span><br></pre></td></tr></table></figure><h3 id="方法四（组件间）">方法四（组件间）</h3><ul><li><p>Pubsub方法(不止于父子组件)两个页面都要import Pubsub</p></li><li><p>在接参的页面（函数在此页面）mounted内写入Pubsub.subscribe(‘函数名’，（msg，形参）=&gt;{回调函数})</p></li><li><p>在传参页面使用的函数内写入Pubsub.publish（‘函数名’，形参）</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事先npm安装pubsub</span></span><br><span class="line"><span class="comment">//宿组件JS</span></span><br><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line">PubSub.subscribe(<span class="string">&#x27;add&#x27;</span>,<span class="function">(<span class="params">msg,data</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.addMenu(data);</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">//源组件JS</span></span><br><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line">PubSub.publish(<span class="string">&#x27;add&#x27;</span>,menu);</span><br></pre></td></tr></table></figure><h2 id="slot插槽">slot插槽</h2><ul><li><p>slot插槽用法 注册组件import，component 组件内div用slot标签写插槽标记好name</p></li><li><p>插槽页面使用div slot=“name” ，动态改写插槽</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//引用插槽组件HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;f&quot;</span>&gt;</span>默认内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">//插槽内容组件HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;f&quot;</span>&gt;</span>版权所有LeBronChao<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ajax框架通信">ajax框架通信</h2><h3 id="ajax框架vue-resource">ajax框架vue-resource</h3><ul><li><p>main.js里import，Vue.use(VueResource)</p></li><li><p>方法不止于get  详情：<a href="https://github.com/pagekit/vue-resource">https://github.com/pagekit/vue-resource</a></p></li><li><p>模板：</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueResource <span class="keyword">from</span> <span class="string">&#x27;vue-resource&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueResource)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;www.sdalkndal.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$http.get(url).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">    alert(<span class="string">&quot;请求成功&quot;</span>)</span><br><span class="line">  </span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">    alert(<span class="string">&quot;请求失败&quot;</span>)</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ajax框架axios方法">ajax框架axios方法</h3><ul><li><p>不可全局注册 所有使用页面内import</p></li><li><p>方法不止于get  详情：<a href="https://github.com/pagekit/vue-resource/blob/develop/docs/http.md">https://github.com/pagekit/vue-resource/blob/develop/docs/http.md</a></p><p>主页：<a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&quot;www.asdnkjansd.com&quot;</span></span><br><span class="line">axios.get(url).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;请求成功&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;请求失败ERROR&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        allert(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vue-router">Vue-router</h2><ul><li><p>路由基本用法：建立pages和router文件夹，配置好页面，路由js文件内引入vue、vuerouter和路由页面</p></li><li><p>使用vue.use（VueRouter）使用路由 export default new VueRouter({routes})</p></li><li><p>import路由页面并在routes内注册（path、component、name），children对象可写子路由，redirect可重定向写默认页面</p></li><li><p>使用路由的页面内写入router-link 和 router-view to属性写路由路径</p></li><li><p>Main.js内import引入路由js文件，vue对象内写入router</p></li><li><p>用keep-alive标签包裹的路由标签可以保留缓存</p></li></ul><h3 id="Router-js">Router.js:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">&#x27;../pages/index.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> menu1 <span class="keyword">from</span> <span class="string">&#x27;../pages/menu1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> subMenu1 <span class="keyword">from</span> <span class="string">&#x27;../pages/subMenu1.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> subMenu2 <span class="keyword">from</span> <span class="string">&#x27;../pages/subMenu2.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> menu2 <span class="keyword">from</span> <span class="string">&#x27;../pages/menu2.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> subMenu3 <span class="keyword">from</span> <span class="string">&#x27;../pages/subMenu3.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/index&#x27;</span>,</span><br><span class="line">            component: index</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/menu1&#x27;</span>,</span><br><span class="line">            component: menu1,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;/menu1/subMenu1&#x27;</span>,</span><br><span class="line">                    component: subMenu1</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;/menu1/subMenu2&#x27;</span>,</span><br><span class="line">                    component: subMenu2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                    redirect: <span class="string">&quot;/menu1/subMenu1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            redirect: <span class="string">&#x27;/index&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/menu2&#x27;</span>,</span><br><span class="line">            component: menu2,</span><br><span class="line">            children: [</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;/menu2/subMenu3&#x27;</span>,</span><br><span class="line">                    component: subMenu3</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                    redirect: <span class="string">&#x27;/menu2/subMenu3&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="main-js">main.js:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueResource <span class="keyword">from</span> <span class="string">&#x27;vue-resource&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/router.js&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueResource)</span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Vue组件">Vue组件:</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/index&quot;</span> <span class="attr">hover:</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/menu1&quot;</span>&gt;</span>页面一<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/menu2&quot;</span>&gt;</span>学生信息列表<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="路由组件传参">路由组件传参</h2><h3 id="路由组件传参分为param和query传参两种方式">路由组件传参分为param和query传参两种方式</h3><h3 id="param：">param：</h3><ul><li><p>在router-link标签内将to属性改为绑定属性 ：to并将路径和参数改为以下格式</p></li><li><p>以下student.id为传输参数</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(student,index) in students&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;student.id&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;`/menu2/subMenu3/$&#123;student.id&#125;`&quot;</span>&gt;</span>&#123;&#123;student.name&#125;&#125;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>将使用页面的router path属性后面加上/:id</p></li><li><p>如： path:‘subMenu3/:id’,</p></li><li><p>引入页面以此获取参数</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      Id:&#123;&#123;$route.params.id&#125;&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="query">query:</h3><ul><li>将上放path后面的/:id去掉</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源组件</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;`/menu2/subMenu3?id=$&#123;student.id&#125;`&quot;</span>&gt;&#123;&#123;student.name&#125;&#125;&lt;/router-link&gt;</span><br><span class="line"><span class="comment">//宿组件</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">      Id:&#123;&#123;$route.query.id&#125;&#125;&lt;br/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="编程式路由导航">编程式路由导航</h2><ul><li><p>主要有三个方法：</p><ul><li>push（压入栈)</li><li>repalce（替换）</li><li>back（回退）</li><li>push可退回</li><li>replace不可退回</li></ul></li><li><p>用法为绑定点击事件（执行函数）到标签</p><ul><li>执行函数（methods内）内编写</li><li>this.$router.push（or replace）(<code>路径</code>)</li></ul></li></ul><p>模板：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">`/menu2/subMenu3?id=<span class="subst">$&#123;id&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><h2 id="动画、过渡">动画、过渡</h2><ul><li>在进入/离开的过渡中，会有 6 个 class 切换。<ul><li>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li><li>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li><li>v-enter-to：2.1.8 版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</li><li>v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li><li>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li>v-leave-to：2.1.8 版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效     (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li></ul></li></ul><p>掘金：<a href="https://juejin.cn/user/3913917127467805">前端LeBron</a></p><p>知乎：<a href="https://www.zhihu.com/people/lebronchao">前端LeBron</a></p><p>持续分享技术博文，关注微信公众号👇🏻</p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/doc-image/v2-be6b9cd0588dddc0e39428cacf11f6a3_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Front End </tag>
            
            <tag> Vue </tag>
            
            <tag> SPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 古城风光</title>
      <link href="2019/10/05/%E6%91%84%E5%BD%B1-%E5%8F%A4%E5%9F%8E%E9%A3%8E%E5%85%89/"/>
      <url>2019/10/05/%E6%91%84%E5%BD%B1-%E5%8F%A4%E5%9F%8E%E9%A3%8E%E5%85%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 24-70GM   SONY 24-240mm<br>出镜：无<br>地点：绍兴</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06024.JPG" alt="DSC06024"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06028.JPG" alt="DSC06028"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06114.JPG" alt="DSC06114"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06000.JPG" alt="DSC06000"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC05999.JPG" alt="DSC05999"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC05984.JPG" alt="DSC05984"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06291-2.JPG" alt="DSC06291-2"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06020.JPG" alt="DSC06020"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06123.JPG" alt="DSC06123"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06136.JPG" alt="DSC06136"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06151.JPG" alt="DSC06151"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06257.JPG" alt="DSC06257"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 古城 </tag>
            
            <tag> 风光 </tag>
            
            <tag> 黑白 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 人文集锦</title>
      <link href="2019/10/05/%E6%91%84%E5%BD%B1-%E4%BA%BA%E6%96%87%E9%9B%86%E9%94%A6/"/>
      <url>2019/10/05/%E6%91%84%E5%BD%B1-%E4%BA%BA%E6%96%87%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 24-70GM<br>出镜：人民群众<br>地点：集锦</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC07265-20210326003357304.JPG" alt="DSC07265"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC07267.JPG" alt="DSC07267"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC07266.JPG" alt="DSC07266"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08339.JPG" alt="DSC08339"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06280.JPG" alt="DSC06280"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06265.JPG" alt="DSC06265"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06191.JPG" alt="DSC06191"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06157.JPG" alt="DSC06157"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06132.JPG" alt="DSC06132"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06076.JPG" alt="DSC06076"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人文 </tag>
            
            <tag> 摄影 </tag>
            
            <tag> 集锦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 校园一角</title>
      <link href="2019/07/11/%E6%91%84%E5%BD%B1-%E6%A0%A1%E5%9B%AD%E4%B8%80%E8%A7%92/"/>
      <url>2019/07/11/%E6%91%84%E5%BD%B1-%E6%A0%A1%E5%9B%AD%E4%B8%80%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 50mm F1.8<br>出镜：CC、朵朵奇、鑫哥、可爱的同学们…<br>地点：教学楼、图书馆、匠心坊</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03266.JPG" alt="DSC03266"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03187.JPG" alt="DSC03187"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03233.JPG" alt="DSC03233"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03243.JPG" alt="DSC03243"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03255.JPG" alt="DSC03255"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03285.JPG" alt="DSC03285"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03288.JPG" alt="DSC03288"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03291.JPG" alt="DSC03291"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03294.JPG" alt="DSC03294"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06357.JPG" alt="DSC06357"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01400.JPG" alt="DSC01400"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01409.JPG" alt="DSC01409"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01464.JPG" alt="DSC01464"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/%E5%A5%B34-1.JPG" alt="女4-1"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/%E5%A5%B34-2.JPG" alt="女4-2"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/%E5%A5%B35-1.JPG" alt="女5-1"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/%E5%A5%B35.JPG" alt="女5"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190625201841.JPG" alt="微信图片_20190625201841"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_201906252018411.JPG" alt="微信图片_201906252018411"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/819A9897.JPG" alt="819A9897"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 人像 </tag>
            
            <tag> JK </tag>
            
            <tag> 校园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 追逐光影</title>
      <link href="2019/06/16/%E6%91%84%E5%BD%B1-%E8%BF%BD%E9%80%90%E5%85%89%E5%BD%B1/"/>
      <url>2019/06/16/%E6%91%84%E5%BD%B1-%E8%BF%BD%E9%80%90%E5%85%89%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2 Canon EOS 750D<br>镜头：SONY 24-70GM Canon EF-S 18-138mm<br>出镜：无<br>地点：集锦</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC02085-3.JPG" alt="DSC02085-3"></p><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03320.JPG" alt="DSC03320"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06575.JPG" alt="DSC06575"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/IMG_5742.JPG" alt="IMG_5742"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/IMG_1455.JPG" alt="IMG_1455"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/IMG_4202.JPG" alt="IMG_4202"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/IMG_5664.JPG" alt="IMG_5664"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/WechatIMG1.JPG" alt="WechatIMG1"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 集锦 </tag>
            
            <tag> 光影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 芭蕾舞者</title>
      <link href="2019/04/26/%E6%91%84%E5%BD%B1-%E8%8A%AD%E8%95%BE%E8%88%9E%E8%80%85/"/>
      <url>2019/04/26/%E6%91%84%E5%BD%B1-%E8%8A%AD%E8%95%BE%E8%88%9E%E8%80%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 50mm F1.8<br>出镜：zys<br>地点：舞蹈室</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01393-20210326002336654.JPG" alt="DSC01393"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01386-20210326002331439.JPG" alt="DSC01386"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01330-20210326002326908.JPG" alt="DSC01330"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01370-20210326002318937.JPG" alt="DSC01370"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01299-20210326002315038.JPG" alt="DSC01299"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01304-20210326002303469.JPG" alt="DSC01304"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01310-20210326002257365.JPG" alt="DSC01310"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01314-20210326002252970.JPG" alt="DSC01314"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01373-20210326002248980.JPG" alt="DSC01373"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC01321-20210326002242660.JPG" alt="DSC01321"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 人像 </tag>
            
            <tag> 芭蕾 </tag>
            
            <tag> 舞者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影 | 风光集锦</title>
      <link href="2018/10/20/%E6%91%84%E5%BD%B1-%E9%A3%8E%E5%85%89%E9%9B%86%E9%94%A6/"/>
      <url>2018/10/20/%E6%91%84%E5%BD%B1-%E9%A3%8E%E5%85%89%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机身：SONY A7M2<br>镜头：SONY 24-70GM   SONY 24-240mm<br>出镜：无<br>地点：集锦</p></blockquote><div class="note info simple"><p>点击可看大图</p></div><div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08053.JPG" alt="DSC08053"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08027.JPG" alt="DSC08027"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03369.JPG" alt="DSC03369"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC07517.JPG" alt="DSC07517"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/IMG_0607.JPG" alt="IMG_0607"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/IMG_0812.JPG" alt="IMG_0812"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06019-20210323000638006-20210326003015585.JPG" alt="DSC06019"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC08319.JPG" alt="DSC08319"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06905.JPG" alt="DSC06905"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC06917.JPG" alt="DSC06917"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03344.JPG" alt="DSC07409"></p><p><img src= "/img/loading.gif" data-lazy-src="https://bloginfo.lebronchao.com/photo/DSC03344.JPG" alt="DSC03344"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 集锦 </tag>
            
            <tag> 风光 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
